#ifndef _MEM_FB_H_
#define _MEM_FB_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define MEM_FB0_CFG_BASE      ( 0x04501000 )
#define MEM_FB1_CFG_BASE      ( 0x04701000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define MEM_FB_SCRATCH_OFFSET ( 0x00000000U )
#define MEM_FB_SOFT_RST_OFFSET ( 0x00000004U )
#define MEM_FB_EN_OFFSET ( 0x00000008U )
#define MEM_FB_LL_CORRUPT_OFFSET ( 0x0000000cU )
#define MEM_FB_PWR_DOWN_CTRL_OFFSET ( 0x00000010U )
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_OFFSET ( 0x00000014U )
#define MEM_FB_DMAC_HOLD_REQ_OFFSET ( 0x00000018U )
#define MEM_FB_DMAC_HOLD_ACK_OFFSET ( 0x0000001cU )
#define MEM_FB_LA_DBG_SEL_OFFSET ( 0x00000020U )
#define MEM_FB_DMAC_DBG_CHAN_SEL_OFFSET ( 0x00000024U )
#define MEM_FB_DMAC_DMA0_DBG_OFFSET ( 0x00000028U )
#define MEM_FB_DMAC_DMA1_DBG_OFFSET ( 0x0000002cU )
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_OFFSET ( 0x00000030U )
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_OFFSET ( 0x00000034U )
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_OFFSET ( 0x00000038U )
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_OFFSET ( 0x0000003cU )
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_OFFSET ( 0x00000040U )
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_OFFSET ( 0x00000044U )
#define MEM_FB_TDD_STALL_OFFSET ( 0x00000048U )
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_OFFSET ( 0x0000004cU )
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_OFFSET ( 0x00000050U )
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_OFFSET ( 0x00000054U )
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_OFFSET ( 0x00000058U )
#define MEM_FB_DMAC_LL_INVALID_OFFSET ( 0x0000005cU )
#define MEM_FB_NSIP_CM0_PKT_LEN_OFFSET ( 0x00000060U )
#define MEM_FB_NSIP_CM1_PKT_LEN_OFFSET ( 0x00000064U )
#define MEM_FB_NSIP_CM_HALT_CFG_OFFSET ( 0x00000068U )
#define MEM_FB_NSIP_CM_HALT_STAT_OFFSET ( 0x0000006cU )
#define MEM_FB_NSIP_CM_STATE_DBG_OFFSET ( 0x00000070U )
#define MEM_FB_INT_HI_AGG_STAT_OFFSET ( 0x00000078U )
#define MEM_FB_INT_LO_AGG_STAT_OFFSET ( 0x0000007cU )
#define MEM_FB_INT_FB_STAT_OFFSET ( 0x00000080U )
#define MEM_FB_INT_FB_HIGH_EN_OFFSET ( 0x00000084U )
#define MEM_FB_INT_FB_LOW_EN_OFFSET ( 0x00000088U )
#define MEM_FB_INT_FB_CLR_OFFSET ( 0x0000008cU )
#define MEM_FB_INT_FB_FORCE_OFFSET ( 0x00000090U )
#define MEM_FB_INT_CRUX_STAT_OFFSET ( 0x000000a0U )
#define MEM_FB_INT_CRUX_HIGH_EN_OFFSET ( 0x000000a4U )
#define MEM_FB_INT_CRUX_LOW_EN_OFFSET ( 0x000000a8U )
#define MEM_FB_INT_CRUX_CLR_OFFSET ( 0x000000acU )
#define MEM_FB_INT_CRUX_FORCE_OFFSET ( 0x000000b0U )
#define MEM_FB_AXI_ECC_ERR_INFO0_OFFSET ( 0x00000100U )
#define MEM_FB_AXI_ECC_CTL0_OFFSET ( 0x00000104U )
#define MEM_FB_AXI_ECC_ERR_STAT0_OFFSET ( 0x00000108U )
#define MEM_FB_AXI_ECC_ERR_INFO1_OFFSET ( 0x00000110U )
#define MEM_FB_AXI_ECC_CTL1_OFFSET ( 0x00000114U )
#define MEM_FB_AXI_ECC_ERR_STAT1_OFFSET ( 0x00000118U )
#define MEM_FB_AXI_ECC_ERR_INFO2_OFFSET ( 0x00000120U )
#define MEM_FB_AXI_ECC_CTL2_OFFSET ( 0x00000124U )
#define MEM_FB_AXI_ECC_ERR_STAT2_OFFSET ( 0x00000128U )
#define MEM_FB_MEM_PTR_PORT0_OFFSET ( 0x00000200U )
#define MEM_FB_MEM_PTR_PORT1_OFFSET ( 0x00000204U )
#define MEM_FB_MEM_PTR_PORT2_OFFSET ( 0x00000208U )
#define MEM_FB_MEM_PTR_PORT3_OFFSET ( 0x0000020cU )
#define MEM_FB_SAMPLE_CNT0_OFFSET ( 0x00000210U )
#define MEM_FB_SAMPLE_CNT1_OFFSET ( 0x00000214U )
#define MEM_FB_SAMPLE_CNT2_OFFSET ( 0x00000218U )
#define MEM_FB_SAMPLE_CNT3_OFFSET ( 0x0000021cU )
#define MEM_FB_ANT_INTF_STAT_OFFSET ( 0x00000228U )
#define MEM_FB_SECTOR_END_PTR0_OFFSET ( 0x00000300U )
#define MEM_FB_SECTOR_NEXT_PTR0_OFFSET ( 0x00000304U )
#define MEM_FB_SECTOR_END_PTR1_OFFSET ( 0x00000308U )
#define MEM_FB_SECTOR_NEXT_PTR1_OFFSET ( 0x0000030cU )
#define MEM_FB_SECTOR_END_PTR2_OFFSET ( 0x00000310U )
#define MEM_FB_SECTOR_NEXT_PTR2_OFFSET ( 0x00000314U )
#define MEM_FB_SECTOR_END_PTR3_OFFSET ( 0x00000318U )
#define MEM_FB_SECTOR_NEXT_PTR3_OFFSET ( 0x0000031cU )
#define MEM_FB_SECTOR_END_PTR4_OFFSET ( 0x00000320U )
#define MEM_FB_SECTOR_NEXT_PTR4_OFFSET ( 0x00000324U )
#define MEM_FB_SECTOR_END_PTR5_OFFSET ( 0x00000328U )
#define MEM_FB_SECTOR_NEXT_PTR5_OFFSET ( 0x0000032cU )
#define MEM_FB_SECTOR_END_PTR6_OFFSET ( 0x00000330U )
#define MEM_FB_SECTOR_NEXT_PTR6_OFFSET ( 0x00000334U )
#define MEM_FB_SECTOR_END_PTR7_OFFSET ( 0x00000338U )
#define MEM_FB_SECTOR_NEXT_PTR7_OFFSET ( 0x0000033cU )
#define MEM_FB_SECTOR_END_PTR8_OFFSET ( 0x00000340U )
#define MEM_FB_SECTOR_NEXT_PTR8_OFFSET ( 0x00000344U )
#define MEM_FB_SECTOR_END_PTR9_OFFSET ( 0x00000348U )
#define MEM_FB_SECTOR_NEXT_PTR9_OFFSET ( 0x0000034cU )
#define MEM_FB_SECTOR_END_PTR10_OFFSET ( 0x00000350U )
#define MEM_FB_SECTOR_NEXT_PTR10_OFFSET ( 0x00000354U )
#define MEM_FB_SECTOR_END_PTR11_OFFSET ( 0x00000358U )
#define MEM_FB_SECTOR_NEXT_PTR11_OFFSET ( 0x0000035cU )
#define MEM_FB_SECTOR_END_PTR12_OFFSET ( 0x00000360U )
#define MEM_FB_SECTOR_NEXT_PTR12_OFFSET ( 0x00000364U )
#define MEM_FB_SECTOR_END_PTR13_OFFSET ( 0x00000368U )
#define MEM_FB_SECTOR_NEXT_PTR13_OFFSET ( 0x0000036cU )
#define MEM_FB_SECTOR_END_PTR14_OFFSET ( 0x00000370U )
#define MEM_FB_SECTOR_NEXT_PTR14_OFFSET ( 0x00000374U )
#define MEM_FB_SECTOR_END_PTR15_OFFSET ( 0x00000378U )
#define MEM_FB_SECTOR_NEXT_PTR15_OFFSET ( 0x0000037cU )
#define MEM_FB_SECTOR_END_PTR16_OFFSET ( 0x00000380U )
#define MEM_FB_SECTOR_NEXT_PTR16_OFFSET ( 0x00000384U )
#define MEM_FB_SECTOR_END_PTR17_OFFSET ( 0x00000388U )
#define MEM_FB_SECTOR_NEXT_PTR17_OFFSET ( 0x0000038cU )
#define MEM_FB_SECTOR_END_PTR18_OFFSET ( 0x00000390U )
#define MEM_FB_SECTOR_NEXT_PTR18_OFFSET ( 0x00000394U )
#define MEM_FB_SECTOR_END_PTR19_OFFSET ( 0x00000398U )
#define MEM_FB_SECTOR_NEXT_PTR19_OFFSET ( 0x0000039cU )
#define MEM_FB_SECTOR_END_PTR20_OFFSET ( 0x000003a0U )
#define MEM_FB_SECTOR_NEXT_PTR20_OFFSET ( 0x000003a4U )
#define MEM_FB_SECTOR_END_PTR21_OFFSET ( 0x000003a8U )
#define MEM_FB_SECTOR_NEXT_PTR21_OFFSET ( 0x000003acU )
#define MEM_FB_SECTOR_END_PTR22_OFFSET ( 0x000003b0U )
#define MEM_FB_SECTOR_NEXT_PTR22_OFFSET ( 0x000003b4U )
#define MEM_FB_SECTOR_END_PTR23_OFFSET ( 0x000003b8U )
#define MEM_FB_SECTOR_NEXT_PTR23_OFFSET ( 0x000003bcU )
#define MEM_FB_SECTOR_END_PTR24_OFFSET ( 0x000003c0U )
#define MEM_FB_SECTOR_NEXT_PTR24_OFFSET ( 0x000003c4U )
#define MEM_FB_SECTOR_END_PTR25_OFFSET ( 0x000003c8U )
#define MEM_FB_SECTOR_NEXT_PTR25_OFFSET ( 0x000003ccU )
#define MEM_FB_SECTOR_END_PTR26_OFFSET ( 0x000003d0U )
#define MEM_FB_SECTOR_NEXT_PTR26_OFFSET ( 0x000003d4U )
#define MEM_FB_SECTOR_END_PTR27_OFFSET ( 0x000003d8U )
#define MEM_FB_SECTOR_NEXT_PTR27_OFFSET ( 0x000003dcU )
#define MEM_FB_SECTOR_END_PTR28_OFFSET ( 0x000003e0U )
#define MEM_FB_SECTOR_NEXT_PTR28_OFFSET ( 0x000003e4U )
#define MEM_FB_SECTOR_END_PTR29_OFFSET ( 0x000003e8U )
#define MEM_FB_SECTOR_NEXT_PTR29_OFFSET ( 0x000003ecU )
#define MEM_FB_SECTOR_END_PTR30_OFFSET ( 0x000003f0U )
#define MEM_FB_SECTOR_NEXT_PTR30_OFFSET ( 0x000003f4U )
#define MEM_FB_SECTOR_END_PTR31_OFFSET ( 0x000003f8U )
#define MEM_FB_SECTOR_NEXT_PTR31_OFFSET ( 0x000003fcU )
#define MEM_FB_BFN_TIMER1_DMA00_OFFSET ( 0x00000400U )
#define MEM_FB_BFN_TIMER2_DMA00_OFFSET ( 0x00000404U )
#define MEM_FB_BFN_TIMER_SEL_DMA00_OFFSET ( 0x00000408U )
#define MEM_FB_BFN_PAUSE_SOFT_DMA00_OFFSET ( 0x0000040cU )
#define MEM_FB_BFN_EXIT_TIMER_DMA00_OFFSET ( 0x00000410U )
#define MEM_FB_SOFT_PAUSE_ST_DMA00_OFFSET ( 0x00000414U )
#define MEM_FB_HARD_PAUSE_ST_DMA00_OFFSET ( 0x00000418U )
#define MEM_FB_BFN_TIMER1_DMA10_OFFSET ( 0x0000041cU )
#define MEM_FB_BFN_TIMER2_DMA10_OFFSET ( 0x00000420U )
#define MEM_FB_BFN_TIMER_SEL_DMA10_OFFSET ( 0x00000424U )
#define MEM_FB_BFN_PAUSE_SOFT_DMA10_OFFSET ( 0x00000428U )
#define MEM_FB_BFN_EXIT_TIMER_DMA10_OFFSET ( 0x0000042cU )
#define MEM_FB_SOFT_PAUSE_ST_DMA10_OFFSET ( 0x00000430U )
#define MEM_FB_HARD_PAUSE_ST_DMA10_OFFSET ( 0x00000434U )
#define MEM_FB_BFN_STATE_DBG0_OFFSET ( 0x00000438U )
#define MEM_FB_BFN_TIMER1_DMA01_OFFSET ( 0x00000480U )
#define MEM_FB_BFN_TIMER2_DMA01_OFFSET ( 0x00000484U )
#define MEM_FB_BFN_TIMER_SEL_DMA01_OFFSET ( 0x00000488U )
#define MEM_FB_BFN_PAUSE_SOFT_DMA01_OFFSET ( 0x0000048cU )
#define MEM_FB_BFN_EXIT_TIMER_DMA01_OFFSET ( 0x00000490U )
#define MEM_FB_SOFT_PAUSE_ST_DMA01_OFFSET ( 0x00000494U )
#define MEM_FB_HARD_PAUSE_ST_DMA01_OFFSET ( 0x00000498U )
#define MEM_FB_BFN_TIMER1_DMA11_OFFSET ( 0x0000049cU )
#define MEM_FB_BFN_TIMER2_DMA11_OFFSET ( 0x000004a0U )
#define MEM_FB_BFN_TIMER_SEL_DMA11_OFFSET ( 0x000004a4U )
#define MEM_FB_BFN_PAUSE_SOFT_DMA11_OFFSET ( 0x000004a8U )
#define MEM_FB_BFN_EXIT_TIMER_DMA11_OFFSET ( 0x000004acU )
#define MEM_FB_SOFT_PAUSE_ST_DMA11_OFFSET ( 0x000004b0U )
#define MEM_FB_HARD_PAUSE_ST_DMA11_OFFSET ( 0x000004b4U )
#define MEM_FB_BFN_STATE_DBG1_OFFSET ( 0x000004b8U )
#define MEM_FB_ISYNC_CTRL_OFFSET ( 0x00000500U )
#define MEM_FB_ISYNC_LCNT_INC_OFFSET ( 0x00000504U )
#define MEM_FB_ISYNC_TEN_MS_CNT_OFFSET ( 0x00000508U )
#define MEM_FB_ISYNC_INC_PRE_OFFSET ( 0x0000050cU )
#define MEM_FB_ISYNC_CNT_ADJ_OFFSET ( 0x00000510U )
#define MEM_FB_ISYNC_BFN_CNT_SYNC_OFFSET ( 0x00000514U )
#define MEM_FB_ISYNC_BFN_CNT_OFFSET ( 0x00000518U )
#define MEM_FB_BFNE_CFG0_OFFSET ( 0x00000530U )
#define MEM_FB_BFNE_CFG1_OFFSET ( 0x00000534U )
#define MEM_FB_BFNE_CFG2_OFFSET ( 0x00000538U )
#define MEM_FB_BFNE_CFG3_OFFSET ( 0x0000053cU )
#define MEM_FB_BFNE_CFG4_OFFSET ( 0x00000540U )
#define MEM_FB_BFNE_CFG5_OFFSET ( 0x00000544U )
#define MEM_FB_BFNE_CFG6_OFFSET ( 0x00000548U )
#define MEM_FB_BFNE_CFG7_OFFSET ( 0x0000054cU )
#define MEM_FB_BFNE_INCR0_OFFSET ( 0x00000550U )
#define MEM_FB_BFNE_INCR1_OFFSET ( 0x00000554U )
#define MEM_FB_BFNE_INCR2_OFFSET ( 0x00000558U )
#define MEM_FB_BFNE_INCR3_OFFSET ( 0x0000055cU )
#define MEM_FB_BFNE_INCR4_OFFSET ( 0x00000560U )
#define MEM_FB_BFNE_INCR5_OFFSET ( 0x00000564U )
#define MEM_FB_BFNE_INCR6_OFFSET ( 0x00000568U )
#define MEM_FB_BFNE_INCR7_OFFSET ( 0x0000056cU )
#define MEM_FB_BFNE_START0_OFFSET ( 0x00000570U )
#define MEM_FB_BFNE_START1_OFFSET ( 0x00000574U )
#define MEM_FB_BFNE_START2_OFFSET ( 0x00000578U )
#define MEM_FB_BFNE_START3_OFFSET ( 0x0000057cU )
#define MEM_FB_BFNE_START4_OFFSET ( 0x00000580U )
#define MEM_FB_BFNE_START5_OFFSET ( 0x00000584U )
#define MEM_FB_BFNE_START6_OFFSET ( 0x00000588U )
#define MEM_FB_BFNE_START7_OFFSET ( 0x0000058cU )
#define MEM_FB_BFNE_STAT0_OFFSET ( 0x00000590U )
#define MEM_FB_BFNE_STAT1_OFFSET ( 0x00000594U )
#define MEM_FB_BFNE_STAT2_OFFSET ( 0x00000598U )
#define MEM_FB_BFNE_STAT3_OFFSET ( 0x0000059cU )
#define MEM_FB_BFNE_STAT4_OFFSET ( 0x000005a0U )
#define MEM_FB_BFNE_STAT5_OFFSET ( 0x000005a4U )
#define MEM_FB_BFNE_STAT6_OFFSET ( 0x000005a8U )
#define MEM_FB_BFNE_STAT7_OFFSET ( 0x000005acU )
#define MEM_FB_DESC_ECC_ERR_INFO0_OFFSET ( 0x00000600U )
#define MEM_FB_DESC_ECC_CTL0_OFFSET ( 0x00000604U )
#define MEM_FB_DESC_ECC_ERR_STAT0_OFFSET ( 0x00000608U )
#define MEM_FB_DESC_ECC_ERR_INFO1_OFFSET ( 0x00000610U )
#define MEM_FB_DESC_ECC_CTL1_OFFSET ( 0x00000614U )
#define MEM_FB_DESC_ECC_ERR_STAT1_OFFSET ( 0x00000618U )
#define MEM_FB_DMA0_ECC_ERR_INFO0_OFFSET ( 0x00000620U )
#define MEM_FB_DMA0_ECC_CTL0_OFFSET ( 0x00000624U )
#define MEM_FB_DMA0_ECC_ERR_STAT0_OFFSET ( 0x00000628U )
#define MEM_FB_DMA0_ECC_ERR_INFO1_OFFSET ( 0x00000630U )
#define MEM_FB_DMA0_ECC_CTL1_OFFSET ( 0x00000634U )
#define MEM_FB_DMA0_ECC_ERR_STAT1_OFFSET ( 0x00000638U )
#define MEM_FB_DMA1_ECC_ERR_INFO0_OFFSET ( 0x00000640U )
#define MEM_FB_DMA1_ECC_CTL0_OFFSET ( 0x00000644U )
#define MEM_FB_DMA1_ECC_ERR_STAT0_OFFSET ( 0x00000648U )
#define MEM_FB_DMA1_ECC_ERR_INFO1_OFFSET ( 0x00000650U )
#define MEM_FB_DMA1_ECC_CTL1_OFFSET ( 0x00000654U )
#define MEM_FB_DMA1_ECC_ERR_STAT1_OFFSET ( 0x00000658U )
#define MEM_FB_DMA_DP_INIT_OFFSET ( 0x00000660U )
#define MEM_FB_DMA_DP_INIT_DONE_OFFSET ( 0x00000664U )
#define MEM_FB_VEX_DMA_SEL_HALT_OFFSET ( 0x00000680U )
#define MEM_FB_VEX_MEM_START_ADDR_OFFSET ( 0x00000684U )
#define MEM_FB_VEX_MEM_END_ADDR_OFFSET ( 0x00000688U )
#define MEM_FB_VEX_DESC_START_ADDR_OFFSET ( 0x0000068cU )
#define MEM_FB_VEX_DESC_END_ADDR_OFFSET ( 0x00000690U )
#define MEM_FB_VEX_START_ADDR_OFFSET ( 0x00000694U )
#define MEM_FB_VEX_END_ADDR_OFFSET ( 0x00000698U )
#define MEM_FB_VEX_ADDR_MASK_OFFSET ( 0x0000069cU )
#define MEM_FB_VEX_CM0_BAD_ADDR_OFFSET ( 0x000006a0U )
#define MEM_FB_VEX_CM1_BAD_ADDR_OFFSET ( 0x000006a4U )
#define MEM_FB_VEX_CM0_DROP_IDX_OFFSET ( 0x000006a8U )
#define MEM_FB_VEX_CM1_DROP_IDX_OFFSET ( 0x000006acU )
#define MEM_FB_VEX_TIMER_OFFSET ( 0x000006b0U )
#define MEM_FB_VEX_DBG_OFFSET ( 0x000006b4U )
#define MEM_FB_VEX_DMA0_CH0_LLP_OFFSET ( 0x000006c0U )
#define MEM_FB_VEX_DMA0_CH1_LLP_OFFSET ( 0x000006c4U )
#define MEM_FB_VEX_DMA1_CH0_LLP_OFFSET ( 0x000006c8U )
#define MEM_FB_VEX_DMA1_CH1_LLP_OFFSET ( 0x000006ccU )
#define MEM_FB_VEX_DMA0_CH01_EN_OFFSET ( 0x000006d0U )
#define MEM_FB_VEX_DMA1_CH01_EN_OFFSET ( 0x000006d4U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define MEM_FB_SCRATCH_ADR(_BASE)   (( ( _BASE ) + ( MEM_FB_SCRATCH_OFFSET ) ))
#define MEM_FB_SOFT_RST_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SOFT_RST_OFFSET ) ))
#define MEM_FB_EN_ADR(_BASE)    (( ( _BASE ) + ( MEM_FB_EN_OFFSET ) ))
#define MEM_FB_LL_CORRUPT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_LL_CORRUPT_OFFSET ) ))
#define MEM_FB_PWR_DOWN_CTRL_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_PWR_DOWN_CTRL_OFFSET ) ))
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_PWR_DOWN_CTRL_CHAIN_OFFSET ) ))
#define MEM_FB_DMAC_HOLD_REQ_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC_HOLD_REQ_OFFSET ) ))
#define MEM_FB_DMAC_HOLD_ACK_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC_HOLD_ACK_OFFSET ) ))
#define MEM_FB_LA_DBG_SEL_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_LA_DBG_SEL_OFFSET ) ))
#define MEM_FB_DMAC_DBG_CHAN_SEL_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC_DBG_CHAN_SEL_OFFSET ) ))
#define MEM_FB_DMAC_DMA0_DBG_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC_DMA0_DBG_OFFSET ) ))
#define MEM_FB_DMAC_DMA1_DBG_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC_DMA1_DBG_OFFSET ) ))
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC0_CH_TFR_DONE_CNT_OFFSET ) ))
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC1_CH_TFR_DONE_CNT_OFFSET ) ))
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC0_DST_TFR_DONE_CNT_OFFSET ) ))
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC1_DST_TFR_DONE_CNT_OFFSET ) ))
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC0_SRC_TFR_DONE_CNT_OFFSET ) ))
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC1_SRC_TFR_DONE_CNT_OFFSET ) ))
#define MEM_FB_TDD_STALL_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_TDD_STALL_OFFSET ) ))
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC0_CH0_PAUSE_CNT_OFFSET ) ))
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC1_CH0_PAUSE_CNT_OFFSET ) ))
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC0_CH1_PAUSE_CNT_OFFSET ) ))
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC1_CH1_PAUSE_CNT_OFFSET ) ))
#define MEM_FB_DMAC_LL_INVALID_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMAC_LL_INVALID_OFFSET ) ))
#define MEM_FB_NSIP_CM0_PKT_LEN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_NSIP_CM0_PKT_LEN_OFFSET ) ))
#define MEM_FB_NSIP_CM1_PKT_LEN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_NSIP_CM1_PKT_LEN_OFFSET ) ))
#define MEM_FB_NSIP_CM_HALT_CFG_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_NSIP_CM_HALT_CFG_OFFSET ) ))
#define MEM_FB_NSIP_CM_HALT_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_NSIP_CM_HALT_STAT_OFFSET ) ))
#define MEM_FB_NSIP_CM_STATE_DBG_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_NSIP_CM_STATE_DBG_OFFSET ) ))
#define MEM_FB_INT_HI_AGG_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_HI_AGG_STAT_OFFSET ) ))
#define MEM_FB_INT_LO_AGG_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_LO_AGG_STAT_OFFSET ) ))
#define MEM_FB_INT_FB_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_FB_STAT_OFFSET ) ))
#define MEM_FB_INT_FB_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_FB_HIGH_EN_OFFSET ) ))
#define MEM_FB_INT_FB_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_FB_LOW_EN_OFFSET ) ))
#define MEM_FB_INT_FB_CLR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_FB_CLR_OFFSET ) ))
#define MEM_FB_INT_FB_FORCE_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_FB_FORCE_OFFSET ) ))
#define MEM_FB_INT_CRUX_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_CRUX_STAT_OFFSET ) ))
#define MEM_FB_INT_CRUX_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_CRUX_HIGH_EN_OFFSET ) ))
#define MEM_FB_INT_CRUX_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_CRUX_LOW_EN_OFFSET ) ))
#define MEM_FB_INT_CRUX_CLR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_CRUX_CLR_OFFSET ) ))
#define MEM_FB_INT_CRUX_FORCE_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_INT_CRUX_FORCE_OFFSET ) ))
#define MEM_FB_AXI_ECC_ERR_INFO0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_ERR_INFO0_OFFSET ) ))
#define MEM_FB_AXI_ECC_CTL0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_CTL0_OFFSET ) ))
#define MEM_FB_AXI_ECC_ERR_STAT0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_ERR_STAT0_OFFSET ) ))
#define MEM_FB_AXI_ECC_ERR_INFO1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_ERR_INFO1_OFFSET ) ))
#define MEM_FB_AXI_ECC_CTL1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_CTL1_OFFSET ) ))
#define MEM_FB_AXI_ECC_ERR_STAT1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_ERR_STAT1_OFFSET ) ))
#define MEM_FB_AXI_ECC_ERR_INFO2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_ERR_INFO2_OFFSET ) ))
#define MEM_FB_AXI_ECC_CTL2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_CTL2_OFFSET ) ))
#define MEM_FB_AXI_ECC_ERR_STAT2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_AXI_ECC_ERR_STAT2_OFFSET ) ))
#define MEM_FB_MEM_PTR_PORT0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_MEM_PTR_PORT0_OFFSET ) ))
#define MEM_FB_MEM_PTR_PORT1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_MEM_PTR_PORT1_OFFSET ) ))
#define MEM_FB_MEM_PTR_PORT2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_MEM_PTR_PORT2_OFFSET ) ))
#define MEM_FB_MEM_PTR_PORT3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_MEM_PTR_PORT3_OFFSET ) ))
#define MEM_FB_SAMPLE_CNT0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SAMPLE_CNT0_OFFSET ) ))
#define MEM_FB_SAMPLE_CNT1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SAMPLE_CNT1_OFFSET ) ))
#define MEM_FB_SAMPLE_CNT2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SAMPLE_CNT2_OFFSET ) ))
#define MEM_FB_SAMPLE_CNT3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SAMPLE_CNT3_OFFSET ) ))
#define MEM_FB_ANT_INTF_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ANT_INTF_STAT_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR0_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR0_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR1_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR1_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR2_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR2_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR3_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR3_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR4_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR4_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR4_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR4_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR5_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR5_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR5_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR5_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR6_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR6_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR6_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR6_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR7_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR7_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR7_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR7_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR8_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR8_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR8_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR8_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR9_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR9_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR9_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR9_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR10_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR10_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR11_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR11_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR12_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR12_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR12_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR12_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR13_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR13_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR13_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR13_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR14_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR14_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR14_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR14_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR15_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR15_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR15_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR15_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR16_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR16_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR16_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR16_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR17_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR17_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR17_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR17_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR18_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR18_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR18_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR18_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR19_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR19_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR19_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR19_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR20_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR20_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR20_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR20_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR21_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR21_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR21_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR21_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR22_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR22_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR22_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR22_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR23_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR23_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR23_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR23_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR24_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR24_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR24_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR24_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR25_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR25_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR25_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR25_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR26_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR26_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR26_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR26_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR27_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR27_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR27_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR27_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR28_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR28_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR28_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR28_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR29_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR29_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR29_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR29_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR30_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR30_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR30_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR30_OFFSET ) ))
#define MEM_FB_SECTOR_END_PTR31_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_END_PTR31_OFFSET ) ))
#define MEM_FB_SECTOR_NEXT_PTR31_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SECTOR_NEXT_PTR31_OFFSET ) ))
#define MEM_FB_BFN_TIMER1_DMA00_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER1_DMA00_OFFSET ) ))
#define MEM_FB_BFN_TIMER2_DMA00_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER2_DMA00_OFFSET ) ))
#define MEM_FB_BFN_TIMER_SEL_DMA00_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER_SEL_DMA00_OFFSET ) ))
#define MEM_FB_BFN_PAUSE_SOFT_DMA00_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_PAUSE_SOFT_DMA00_OFFSET ) ))
#define MEM_FB_BFN_EXIT_TIMER_DMA00_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_EXIT_TIMER_DMA00_OFFSET ) ))
#define MEM_FB_SOFT_PAUSE_ST_DMA00_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SOFT_PAUSE_ST_DMA00_OFFSET ) ))
#define MEM_FB_HARD_PAUSE_ST_DMA00_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_HARD_PAUSE_ST_DMA00_OFFSET ) ))
#define MEM_FB_BFN_TIMER1_DMA10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER1_DMA10_OFFSET ) ))
#define MEM_FB_BFN_TIMER2_DMA10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER2_DMA10_OFFSET ) ))
#define MEM_FB_BFN_TIMER_SEL_DMA10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER_SEL_DMA10_OFFSET ) ))
#define MEM_FB_BFN_PAUSE_SOFT_DMA10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_PAUSE_SOFT_DMA10_OFFSET ) ))
#define MEM_FB_BFN_EXIT_TIMER_DMA10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_EXIT_TIMER_DMA10_OFFSET ) ))
#define MEM_FB_SOFT_PAUSE_ST_DMA10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SOFT_PAUSE_ST_DMA10_OFFSET ) ))
#define MEM_FB_HARD_PAUSE_ST_DMA10_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_HARD_PAUSE_ST_DMA10_OFFSET ) ))
#define MEM_FB_BFN_STATE_DBG0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_STATE_DBG0_OFFSET ) ))
#define MEM_FB_BFN_TIMER1_DMA01_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER1_DMA01_OFFSET ) ))
#define MEM_FB_BFN_TIMER2_DMA01_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER2_DMA01_OFFSET ) ))
#define MEM_FB_BFN_TIMER_SEL_DMA01_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER_SEL_DMA01_OFFSET ) ))
#define MEM_FB_BFN_PAUSE_SOFT_DMA01_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_PAUSE_SOFT_DMA01_OFFSET ) ))
#define MEM_FB_BFN_EXIT_TIMER_DMA01_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_EXIT_TIMER_DMA01_OFFSET ) ))
#define MEM_FB_SOFT_PAUSE_ST_DMA01_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SOFT_PAUSE_ST_DMA01_OFFSET ) ))
#define MEM_FB_HARD_PAUSE_ST_DMA01_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_HARD_PAUSE_ST_DMA01_OFFSET ) ))
#define MEM_FB_BFN_TIMER1_DMA11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER1_DMA11_OFFSET ) ))
#define MEM_FB_BFN_TIMER2_DMA11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER2_DMA11_OFFSET ) ))
#define MEM_FB_BFN_TIMER_SEL_DMA11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_TIMER_SEL_DMA11_OFFSET ) ))
#define MEM_FB_BFN_PAUSE_SOFT_DMA11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_PAUSE_SOFT_DMA11_OFFSET ) ))
#define MEM_FB_BFN_EXIT_TIMER_DMA11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_EXIT_TIMER_DMA11_OFFSET ) ))
#define MEM_FB_SOFT_PAUSE_ST_DMA11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_SOFT_PAUSE_ST_DMA11_OFFSET ) ))
#define MEM_FB_HARD_PAUSE_ST_DMA11_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_HARD_PAUSE_ST_DMA11_OFFSET ) ))
#define MEM_FB_BFN_STATE_DBG1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFN_STATE_DBG1_OFFSET ) ))
#define MEM_FB_ISYNC_CTRL_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ISYNC_CTRL_OFFSET ) ))
#define MEM_FB_ISYNC_LCNT_INC_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ISYNC_LCNT_INC_OFFSET ) ))
#define MEM_FB_ISYNC_TEN_MS_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ISYNC_TEN_MS_CNT_OFFSET ) ))
#define MEM_FB_ISYNC_INC_PRE_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ISYNC_INC_PRE_OFFSET ) ))
#define MEM_FB_ISYNC_CNT_ADJ_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ISYNC_CNT_ADJ_OFFSET ) ))
#define MEM_FB_ISYNC_BFN_CNT_SYNC_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ISYNC_BFN_CNT_SYNC_OFFSET ) ))
#define MEM_FB_ISYNC_BFN_CNT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_ISYNC_BFN_CNT_OFFSET ) ))
#define MEM_FB_BFNE_CFG0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG0_OFFSET ) ))
#define MEM_FB_BFNE_CFG1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG1_OFFSET ) ))
#define MEM_FB_BFNE_CFG2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG2_OFFSET ) ))
#define MEM_FB_BFNE_CFG3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG3_OFFSET ) ))
#define MEM_FB_BFNE_CFG4_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG4_OFFSET ) ))
#define MEM_FB_BFNE_CFG5_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG5_OFFSET ) ))
#define MEM_FB_BFNE_CFG6_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG6_OFFSET ) ))
#define MEM_FB_BFNE_CFG7_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_CFG7_OFFSET ) ))
#define MEM_FB_BFNE_INCR0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR0_OFFSET ) ))
#define MEM_FB_BFNE_INCR1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR1_OFFSET ) ))
#define MEM_FB_BFNE_INCR2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR2_OFFSET ) ))
#define MEM_FB_BFNE_INCR3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR3_OFFSET ) ))
#define MEM_FB_BFNE_INCR4_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR4_OFFSET ) ))
#define MEM_FB_BFNE_INCR5_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR5_OFFSET ) ))
#define MEM_FB_BFNE_INCR6_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR6_OFFSET ) ))
#define MEM_FB_BFNE_INCR7_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_INCR7_OFFSET ) ))
#define MEM_FB_BFNE_START0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START0_OFFSET ) ))
#define MEM_FB_BFNE_START1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START1_OFFSET ) ))
#define MEM_FB_BFNE_START2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START2_OFFSET ) ))
#define MEM_FB_BFNE_START3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START3_OFFSET ) ))
#define MEM_FB_BFNE_START4_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START4_OFFSET ) ))
#define MEM_FB_BFNE_START5_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START5_OFFSET ) ))
#define MEM_FB_BFNE_START6_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START6_OFFSET ) ))
#define MEM_FB_BFNE_START7_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_START7_OFFSET ) ))
#define MEM_FB_BFNE_STAT0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT0_OFFSET ) ))
#define MEM_FB_BFNE_STAT1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT1_OFFSET ) ))
#define MEM_FB_BFNE_STAT2_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT2_OFFSET ) ))
#define MEM_FB_BFNE_STAT3_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT3_OFFSET ) ))
#define MEM_FB_BFNE_STAT4_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT4_OFFSET ) ))
#define MEM_FB_BFNE_STAT5_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT5_OFFSET ) ))
#define MEM_FB_BFNE_STAT6_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT6_OFFSET ) ))
#define MEM_FB_BFNE_STAT7_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_BFNE_STAT7_OFFSET ) ))
#define MEM_FB_DESC_ECC_ERR_INFO0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DESC_ECC_ERR_INFO0_OFFSET ) ))
#define MEM_FB_DESC_ECC_CTL0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DESC_ECC_CTL0_OFFSET ) ))
#define MEM_FB_DESC_ECC_ERR_STAT0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DESC_ECC_ERR_STAT0_OFFSET ) ))
#define MEM_FB_DESC_ECC_ERR_INFO1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DESC_ECC_ERR_INFO1_OFFSET ) ))
#define MEM_FB_DESC_ECC_CTL1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DESC_ECC_CTL1_OFFSET ) ))
#define MEM_FB_DESC_ECC_ERR_STAT1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DESC_ECC_ERR_STAT1_OFFSET ) ))
#define MEM_FB_DMA0_ECC_ERR_INFO0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA0_ECC_ERR_INFO0_OFFSET ) ))
#define MEM_FB_DMA0_ECC_CTL0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA0_ECC_CTL0_OFFSET ) ))
#define MEM_FB_DMA0_ECC_ERR_STAT0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA0_ECC_ERR_STAT0_OFFSET ) ))
#define MEM_FB_DMA0_ECC_ERR_INFO1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA0_ECC_ERR_INFO1_OFFSET ) ))
#define MEM_FB_DMA0_ECC_CTL1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA0_ECC_CTL1_OFFSET ) ))
#define MEM_FB_DMA0_ECC_ERR_STAT1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA0_ECC_ERR_STAT1_OFFSET ) ))
#define MEM_FB_DMA1_ECC_ERR_INFO0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA1_ECC_ERR_INFO0_OFFSET ) ))
#define MEM_FB_DMA1_ECC_CTL0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA1_ECC_CTL0_OFFSET ) ))
#define MEM_FB_DMA1_ECC_ERR_STAT0_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA1_ECC_ERR_STAT0_OFFSET ) ))
#define MEM_FB_DMA1_ECC_ERR_INFO1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA1_ECC_ERR_INFO1_OFFSET ) ))
#define MEM_FB_DMA1_ECC_CTL1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA1_ECC_CTL1_OFFSET ) ))
#define MEM_FB_DMA1_ECC_ERR_STAT1_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA1_ECC_ERR_STAT1_OFFSET ) ))
#define MEM_FB_DMA_DP_INIT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA_DP_INIT_OFFSET ) ))
#define MEM_FB_DMA_DP_INIT_DONE_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_DMA_DP_INIT_DONE_OFFSET ) ))
#define MEM_FB_VEX_DMA_SEL_HALT_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DMA_SEL_HALT_OFFSET ) ))
#define MEM_FB_VEX_MEM_START_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_MEM_START_ADDR_OFFSET ) ))
#define MEM_FB_VEX_MEM_END_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_MEM_END_ADDR_OFFSET ) ))
#define MEM_FB_VEX_DESC_START_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DESC_START_ADDR_OFFSET ) ))
#define MEM_FB_VEX_DESC_END_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DESC_END_ADDR_OFFSET ) ))
#define MEM_FB_VEX_START_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_START_ADDR_OFFSET ) ))
#define MEM_FB_VEX_END_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_END_ADDR_OFFSET ) ))
#define MEM_FB_VEX_ADDR_MASK_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_ADDR_MASK_OFFSET ) ))
#define MEM_FB_VEX_CM0_BAD_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_CM0_BAD_ADDR_OFFSET ) ))
#define MEM_FB_VEX_CM1_BAD_ADDR_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_CM1_BAD_ADDR_OFFSET ) ))
#define MEM_FB_VEX_CM0_DROP_IDX_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_CM0_DROP_IDX_OFFSET ) ))
#define MEM_FB_VEX_CM1_DROP_IDX_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_CM1_DROP_IDX_OFFSET ) ))
#define MEM_FB_VEX_TIMER_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_TIMER_OFFSET ) ))
#define MEM_FB_VEX_DBG_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DBG_OFFSET ) ))
#define MEM_FB_VEX_DMA0_CH0_LLP_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DMA0_CH0_LLP_OFFSET ) ))
#define MEM_FB_VEX_DMA0_CH1_LLP_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DMA0_CH1_LLP_OFFSET ) ))
#define MEM_FB_VEX_DMA1_CH0_LLP_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DMA1_CH0_LLP_OFFSET ) ))
#define MEM_FB_VEX_DMA1_CH1_LLP_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DMA1_CH1_LLP_OFFSET ) ))
#define MEM_FB_VEX_DMA0_CH01_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DMA0_CH01_EN_OFFSET ) ))
#define MEM_FB_VEX_DMA1_CH01_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_FB_VEX_DMA1_CH01_EN_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief MEM_FB_MAP_MEM_REG_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/SCRATCH
  * Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Scratch pad.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_scratch_reg_t;

#define MEM_FB_SCRATCH_DEFAULT (0x00000000U)
#define MEM_FB_SCRATCH_RD_MASK (0xffffffffU)
#define MEM_FB_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch pad.
#define MEM_FB_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define MEM_FB_SCRATCH_SCRATCHPAD_BF_WID (32)
#define MEM_FB_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define MEM_FB_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_SOFT_RESET register description at address offset 0x4
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/SOFT_RESET
  * Soft Reset Register
  */

typedef union {
  struct {
    uint32_t SOFT_RESET_DATAPATH : 1;
    ///< This bit is used to soft reset all the data path inside the feedback
    ///< memory except for the common modules. The steps for reseting the common
    ///< modules are outlined in bits 2 and 3 of this register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t SOFT_RESET_CONFIG : 1;
    ///< This bit is used to soft reset all the configuration inside the feedback
    ///< memory. This bit is not self-clearing and therefore needs to be unset
    ///< to release the soft reset.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SOFT_RESET_CM0 : 1;
    ///< This bit is used to soft reset the common module 0. The common module
    ///< should first be halted by setting the NSIP_CM0_HALT bit in the NSIP_CM_HALT_CFG
    ///< register. Once the NSIP_CM0_HALT_STATUS bit in the NSIP_CM_HALT_STATUS
    ///< register is set, only then can this bit be set.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t SOFT_RESET_CM1 : 1;
    ///< This bit is used to soft reset the common module 1. The common module
    ///< should first be halted by setting the NSIP_CM1_HALT bit in the NSIP_CM_HALT_CFG
    ///< register. Once the NSIP_CM1_HALT_STATUS bit in the NSIP_CM_HALT_STATUS
    ///< register is set, only then can this bit be set.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_soft_rst_reg_t;

#define MEM_FB_SOFT_RST_DEFAULT (0x00000000U)
#define MEM_FB_SOFT_RST_RD_MASK (0x0000000fU)
#define MEM_FB_SOFT_RST_WR_MASK (0x0000000fU)


///< This bit is used to soft reset all the data path inside the feedback
///< memory except for the common modules. The steps for reseting the common
///< modules are outlined in bits 2 and 3 of this register.
#define MEM_FB_SOFT_RST_SOFT_RST_DATAPATH_BF_OFF ( 0)
#define MEM_FB_SOFT_RST_SOFT_RST_DATAPATH_BF_WID ( 1)
#define MEM_FB_SOFT_RST_SOFT_RST_DATAPATH_BF_MSK (0x00000001)
#define MEM_FB_SOFT_RST_SOFT_RST_DATAPATH_BF_DEF (0x00000000)

///< This bit is used to soft reset all the configuration inside the feedback
///< memory. This bit is not self-clearing and therefore needs to be unset
///< to release the soft reset.
#define MEM_FB_SOFT_RST_SOFT_RST_CFG_BF_OFF ( 1)
#define MEM_FB_SOFT_RST_SOFT_RST_CFG_BF_WID ( 1)
#define MEM_FB_SOFT_RST_SOFT_RST_CFG_BF_MSK (0x00000002)
#define MEM_FB_SOFT_RST_SOFT_RST_CFG_BF_DEF (0x00000000)

///< This bit is used to soft reset the common module 0. The common module
///< should first be halted by setting the NSIP_CM0_HALT bit in the NSIP_CM_HALT_CFG
///< register. Once the NSIP_CM0_HALT_STATUS bit in the NSIP_CM_HALT_STATUS
///< register is set, only then can this bit be set.
#define MEM_FB_SOFT_RST_SOFT_RST_CM0_BF_OFF ( 2)
#define MEM_FB_SOFT_RST_SOFT_RST_CM0_BF_WID ( 1)
#define MEM_FB_SOFT_RST_SOFT_RST_CM0_BF_MSK (0x00000004)
#define MEM_FB_SOFT_RST_SOFT_RST_CM0_BF_DEF (0x00000000)

///< This bit is used to soft reset the common module 1. The common module
///< should first be halted by setting the NSIP_CM1_HALT bit in the NSIP_CM_HALT_CFG
///< register. Once the NSIP_CM1_HALT_STATUS bit in the NSIP_CM_HALT_STATUS
///< register is set, only then can this bit be set.
#define MEM_FB_SOFT_RST_SOFT_RST_CM1_BF_OFF ( 3)
#define MEM_FB_SOFT_RST_SOFT_RST_CM1_BF_WID ( 1)
#define MEM_FB_SOFT_RST_SOFT_RST_CM1_BF_MSK (0x00000008)
#define MEM_FB_SOFT_RST_SOFT_RST_CM1_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_ENABLE register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ENABLE
  * Enable Register
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< This bit is used to enable the feedback memory block.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_en_reg_t;

#define MEM_FB_EN_DEFAULT (0x00000000U)
#define MEM_FB_EN_RD_MASK (0x00000001U)
#define MEM_FB_EN_WR_MASK (0x00000001U)


///< This bit is used to enable the feedback memory block.
#define MEM_FB_EN_BF_OFF ( 0)
#define MEM_FB_EN_BF_WID ( 1)
#define MEM_FB_EN_BF_MSK (0x00000001)
#define MEM_FB_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_LL_CORRUPT register description at address offset 0xc
  *
  * Register default value:        0x00000001
  * Register full path in IP: mem_fb_map_MEM/reg/LL_CORRUPT
  * Linked list corruption control Register
  */

typedef union {
  struct {
    uint32_t LL_INVALID : 1;
    ///< If this bit is set, whenever there is a multi-bit error in the descriptor
    ///< memory it invalidates the linked list to prevent DMA operations from
    ///< happening from unintended addresses. Under this scenario, software
    ///< has to re-configure the descriptor memory and not use the bad address
    ///< which was causing the multi-bit ECC error.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_ll_corrupt_reg_t;

#define MEM_FB_LL_CORRUPT_DEFAULT (0x00000001U)
#define MEM_FB_LL_CORRUPT_RD_MASK (0x00000001U)
#define MEM_FB_LL_CORRUPT_WR_MASK (0x00000001U)


///< If this bit is set, whenever there is a multi-bit error in the descriptor
///< memory it invalidates the linked list to prevent DMA operations from
///< happening from unintended addresses. Under this scenario, software
///< has to re-configure the descriptor memory and not use the bad address
///< which was causing the multi-bit ECC error.
#define MEM_FB_LL_CORRUPT_LL_INVALID_BF_OFF ( 0)
#define MEM_FB_LL_CORRUPT_LL_INVALID_BF_WID ( 1)
#define MEM_FB_LL_CORRUPT_LL_INVALID_BF_MSK (0x00000001)
#define MEM_FB_LL_CORRUPT_LL_INVALID_BF_DEF (0x00000001)


/** @brief MEM_FB_MAP_MEM_REG_POWER_DOWN_CONTROL register description at address offset 0x10
  *
  * Register default value:        0xFFFFFFFF
  * Register full path in IP: mem_fb_map_MEM/reg/POWER_DOWN_CONTROL
  * Power down control register for the feedback memory
  */

typedef union {
  struct {
    uint32_t POWER_DOWN : 32;
    ///< The feedback memory block contains a 1MByte memory which is divided
    ///< into 32 sectors. These sectors can be powered down individually using
    ///< these register bits. Here bit 0 corresponds to Sector 0 and bit 31
    ///< corresponds to Sector 31. When the bit is set, the sector corresponding
    ///< to that bit is powered down and is not available for normal operation.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFFFFFFFF"
  } ;
  uint32_t value;
} mem_fb_pwr_down_ctrl_reg_t;

#define MEM_FB_PWR_DOWN_CTRL_DEFAULT (0xffffffffU)
#define MEM_FB_PWR_DOWN_CTRL_RD_MASK (0xffffffffU)
#define MEM_FB_PWR_DOWN_CTRL_WR_MASK (0xffffffffU)


///< The feedback memory block contains a 1MByte memory which is divided
///< into 32 sectors. These sectors can be powered down individually using
///< these register bits. Here bit 0 corresponds to Sector 0 and bit 31
///< corresponds to Sector 31. When the bit is set, the sector corresponding
///< to that bit is powered down and is not available for normal operation.
#define MEM_FB_PWR_DOWN_CTRL_PWR_DOWN_BF_OFF ( 0)
#define MEM_FB_PWR_DOWN_CTRL_PWR_DOWN_BF_WID (32)
#define MEM_FB_PWR_DOWN_CTRL_PWR_DOWN_BF_MSK (0xFFFFFFFF)
#define MEM_FB_PWR_DOWN_CTRL_PWR_DOWN_BF_DEF (0xFFFFFFFF)


/** @brief MEM_FB_MAP_MEM_REG_POWER_DOWN_CONTROL_CHAIN register description at address offset 0x14
  *
  * Register default value:        0x00000001
  * Register full path in IP: mem_fb_map_MEM/reg/POWER_DOWN_CONTROL_CHAIN
  * Power down control register for all memories except the feedback memory
  */

typedef union {
  struct {
    uint32_t POWER_DOWN : 1;
    ///< The descriptor memory and the four DMA FIFO memories are connected
    ///< together to form a chain. When this bit is set, all the memories in
    ///< this chain are powered down.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_pwr_down_ctrl_chain_reg_t;

#define MEM_FB_PWR_DOWN_CTRL_CHAIN_DEFAULT (0x00000001U)
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_RD_MASK (0x00000001U)
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_WR_MASK (0x00000001U)


///< The descriptor memory and the four DMA FIFO memories are connected
///< together to form a chain. When this bit is set, all the memories in
///< this chain are powered down.
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_PWR_DOWN_BF_OFF ( 0)
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_PWR_DOWN_BF_WID ( 1)
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_PWR_DOWN_BF_MSK (0x00000001)
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_PWR_DOWN_BF_DEF (0x00000001)


/** @brief MEM_FB_MAP_MEM_REG_DMAC_HOLD_REQ register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC_HOLD_REQ
  * DMAC debug hold request
  */

typedef union {
  struct {
    uint32_t DMAC0_HOLD_REQ : 1;
    ///< This bit can be set in debug mode to halt the DMAC0 operation. Note
    ///< that it should be de-asserted only after DMAC0_HOLD_ACK bit has been
    ///< set by hardware.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMAC1_HOLD_REQ : 1;
    ///< This bit can be set in debug mode to halt the DMAC1 operation. Note
    ///< that it should be de-asserted only after DMAC1_HOLD_ACK bit has been
    ///< set by hardware.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dmac_hold_req_reg_t;

#define MEM_FB_DMAC_HOLD_REQ_DEFAULT (0x00000000U)
#define MEM_FB_DMAC_HOLD_REQ_RD_MASK (0x00000003U)
#define MEM_FB_DMAC_HOLD_REQ_WR_MASK (0x00000003U)


///< This bit can be set in debug mode to halt the DMAC0 operation. Note
///< that it should be de-asserted only after DMAC0_HOLD_ACK bit has been
///< set by hardware.
#define MEM_FB_DMAC_HOLD_REQ_DMAC0_HOLD_REQ_BF_OFF ( 0)
#define MEM_FB_DMAC_HOLD_REQ_DMAC0_HOLD_REQ_BF_WID ( 1)
#define MEM_FB_DMAC_HOLD_REQ_DMAC0_HOLD_REQ_BF_MSK (0x00000001)
#define MEM_FB_DMAC_HOLD_REQ_DMAC0_HOLD_REQ_BF_DEF (0x00000000)

///< This bit can be set in debug mode to halt the DMAC1 operation. Note
///< that it should be de-asserted only after DMAC1_HOLD_ACK bit has been
///< set by hardware.
#define MEM_FB_DMAC_HOLD_REQ_DMAC1_HOLD_REQ_BF_OFF ( 1)
#define MEM_FB_DMAC_HOLD_REQ_DMAC1_HOLD_REQ_BF_WID ( 1)
#define MEM_FB_DMAC_HOLD_REQ_DMAC1_HOLD_REQ_BF_MSK (0x00000002)
#define MEM_FB_DMAC_HOLD_REQ_DMAC1_HOLD_REQ_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC_HOLD_ACK register description at address offset 0x1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC_HOLD_ACK
  * DMAC debug hold acknowledge
  */

typedef union {
  struct {
    uint32_t DMAC0_HOLD_ACK : 1;
    ///< This bit is set by hardware to acknowledge a software request to halt
    ///< the DMAC0 operation.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DMAC1_HOLD_ACK : 1;
    ///< This bit is set by hardware to acknowledge a software request to halt
    ///< the DMAC1 operation.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dmac_hold_ack_reg_t;

#define MEM_FB_DMAC_HOLD_ACK_DEFAULT (0x00000000U)
#define MEM_FB_DMAC_HOLD_ACK_RD_MASK (0x00000003U)
#define MEM_FB_DMAC_HOLD_ACK_WR_MASK (0x00000000U)


///< This bit is set by hardware to acknowledge a software request to halt
///< the DMAC0 operation.
#define MEM_FB_DMAC_HOLD_ACK_DMAC0_HOLD_ACK_BF_OFF ( 0)
#define MEM_FB_DMAC_HOLD_ACK_DMAC0_HOLD_ACK_BF_WID ( 1)
#define MEM_FB_DMAC_HOLD_ACK_DMAC0_HOLD_ACK_BF_MSK (0x00000001)
#define MEM_FB_DMAC_HOLD_ACK_DMAC0_HOLD_ACK_BF_DEF (0x00000000)

///< This bit is set by hardware to acknowledge a software request to halt
///< the DMAC1 operation.
#define MEM_FB_DMAC_HOLD_ACK_DMAC1_HOLD_ACK_BF_OFF ( 1)
#define MEM_FB_DMAC_HOLD_ACK_DMAC1_HOLD_ACK_BF_WID ( 1)
#define MEM_FB_DMAC_HOLD_ACK_DMAC1_HOLD_ACK_BF_MSK (0x00000002)
#define MEM_FB_DMAC_HOLD_ACK_DMAC1_HOLD_ACK_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_LA_DEBUG_SEL register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/LA_DEBUG_SEL
  * Select debug signals to be observed on the logic analyzer
  */

typedef union {
  struct {
    uint32_t DEBUG_SEL : 4;
    ///< Select AXI signals for debug.       0000 => Select Manager port M1->subordinate
    ///< port S8->APB ready/valid signals       0001 => Select Manager port
    ///< M1->subordinate port S6 ready/valid signals       0010 => Select Manager
    ///< port M1->subordinate port S1 ready/valid signals       0011 => Select
    ///< Manager port M2->subordinate port S1 ready/valid signals       0100
    ///< => Select Manager port M2->subordinate port S2 ready/valid signals
    ///< 0101 => Select Manager port M2->subordinate port S4 ready/valid signals
    ///< 0110 => Select Manager port M2->subordinate port S7 ready/valid signals
    ///< 0111 => Select Manager port M3->subordinate port S1 ready/valid signals
    ///< 1000 => Select Manager port M3->subordinate port S3 ready/valid signals
    ///< 1001 => Select Manager port M3->subordinate port S5 ready/valid signals
    ///< 1010 => Select Manager port M3->subordinate port S7 ready/valid signals
    ///< 1011 => Select Manager port M4->subordinate port S1 ready/valid signals
    ///< 1100 => Select Manager port M4->subordinate port S6 ready/valid signals
    ///< 1101 => Select Manager port M4->subordinate port S8 ready/valid signals
    ///< 1110 => Select Manager port M5->subordinate port S8 ready/valid signals
    ///< 1111 => Select Manager port M6->subordinate port S8 ready/valid signals
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_la_dbg_sel_reg_t;

#define MEM_FB_LA_DBG_SEL_DEFAULT (0x00000000U)
#define MEM_FB_LA_DBG_SEL_RD_MASK (0x0000000fU)
#define MEM_FB_LA_DBG_SEL_WR_MASK (0x0000000fU)


///< Select AXI signals for debug.       0000 => Select Manager port M1->subordinate
///< port S8->APB ready/valid signals       0001 => Select Manager port
///< M1->subordinate port S6 ready/valid signals       0010 => Select Manager
///< port M1->subordinate port S1 ready/valid signals       0011 => Select
///< Manager port M2->subordinate port S1 ready/valid signals       0100
///< => Select Manager port M2->subordinate port S2 ready/valid signals
///< 0101 => Select Manager port M2->subordinate port S4 ready/valid signals
///< 0110 => Select Manager port M2->subordinate port S7 ready/valid signals
///< 0111 => Select Manager port M3->subordinate port S1 ready/valid signals
///< 1000 => Select Manager port M3->subordinate port S3 ready/valid signals
///< 1001 => Select Manager port M3->subordinate port S5 ready/valid signals
///< 1010 => Select Manager port M3->subordinate port S7 ready/valid signals
///< 1011 => Select Manager port M4->subordinate port S1 ready/valid signals
///< 1100 => Select Manager port M4->subordinate port S6 ready/valid signals
///< 1101 => Select Manager port M4->subordinate port S8 ready/valid signals
///< 1110 => Select Manager port M5->subordinate port S8 ready/valid signals
///< 1111 => Select Manager port M6->subordinate port S8 ready/valid signals
#define MEM_FB_LA_DBG_SEL_DBG_SEL_BF_OFF ( 0)
#define MEM_FB_LA_DBG_SEL_DBG_SEL_BF_WID ( 4)
#define MEM_FB_LA_DBG_SEL_DBG_SEL_BF_MSK (0x0000000F)
#define MEM_FB_LA_DBG_SEL_DBG_SEL_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC_DEBUG_CHAN_SEL register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC_DEBUG_CHAN_SEL
  * Select a DMA channel for debug
  */

typedef union {
  struct {
    uint32_t DMAC0_DEBUG_CH_NUM : 1;
    ///< Select channel number in DMA0 to debug.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMAC1_DEBUG_CH_NUM : 1;
    ///< Select channel number in DMA1 to debug.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dmac_dbg_chan_sel_reg_t;

#define MEM_FB_DMAC_DBG_CHAN_SEL_DEFAULT (0x00000000U)
#define MEM_FB_DMAC_DBG_CHAN_SEL_RD_MASK (0x00000003U)
#define MEM_FB_DMAC_DBG_CHAN_SEL_WR_MASK (0x00000003U)


///< Select channel number in DMA0 to debug.
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC0_DBG_CH_NUM_BF_OFF ( 0)
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC0_DBG_CH_NUM_BF_WID ( 1)
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC0_DBG_CH_NUM_BF_MSK (0x00000001)
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC0_DBG_CH_NUM_BF_DEF (0x00000000)

///< Select channel number in DMA1 to debug.
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC1_DBG_CH_NUM_BF_OFF ( 1)
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC1_DBG_CH_NUM_BF_WID ( 1)
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC1_DBG_CH_NUM_BF_MSK (0x00000002)
#define MEM_FB_DMAC_DBG_CHAN_SEL_DMAC1_DBG_CH_NUM_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC_DMA0_DEBUG register description at address offset 0x28
  *
  * Register default value:        0x0FC00000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC_DMA0_DEBUG
  * DMAC debug register for DMA0
  */

typedef union {
  struct {
    uint32_t DEBUG_CH_EN : 2;
    ///< DMA Channel enable debug signal.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DEBUG_CH_SUSPENDED : 1;
    ///< Multiplexed - Channel Suspend status debug signal corresponding to
    ///< the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t DEBUG_CH_ABORTED : 1;
    ///< Multiplexed - Channel Abort status (generated due to Channel Suspend
    ///< request, Channel disable, User Channel abort, or due to reception
    ///< of AXI error response) debug signal corresponding to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t DEBUG_CH_SHADOWREG_OR_LLI_INVALID_ERR : 1;
    ///< Multiplexed - Shadow register or LLI Invalid error debug signal corresponding
    ///< to the channel debug_ch_num_i. For more information, see  Programming
    ///< Flow for Shadow-Register-Based Multi-Block Transfer  and  Programming
    ///< Flow for Linked-List-Based Multi-Bock Transfer  sections of the databook.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_IS_IN_STR : 1;
    ///< Multiplexed - Destination State machine is in Single transaction region
    ///< debug signal corresponding to the channel debug_ch_num_i. For more
    ///< information, see  Single Transaction Region  section of the databook.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_IS_IN_STR : 1;
    ///< Multiplexed - Source State machine is in Single transaction region
    ///< debug signal corresponding to the channel debug_ch_num_i. For more
    ///< information, see  Single Transaction Region  section of the databook.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_TRANS_REQ : 1;
    ///< Multiplexed - internally generated Destination Transaction request
    ///< (generated based on the destination dma_req* and dma_sgl_req*) debug
    ///< signal corresponding to the channel debug_ch_num_i..
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_TRANS_REQ : 1;
    ///< Multiplexed - internally generated Source Transaction request (generated
    ///< based on the Source dma_req* and dma_sgl_req*) debug signal corresponding
    ///< to the channel debug_ch_num_i..
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t DEBUG_CH_DMA_TFR_DONE : 1;
    ///< Multiplexed - DMA Transfer Done debug signal corresponding to the
    ///< channel debug_ch_num_i .
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_TRANS_DONE : 1;
    ///< Multiplexed - Destination Transaction Done debug signal corresponding
    ///< to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_TRANS_DONE : 1;
    ///< Multiplexed - Source Transaction Done debug signal corresponding to
    ///< the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t DEBUG_CH_BLK_TFR_DONE : 1;
    ///< Multiplexed - DMA Block Transfer Done debug signal corresponding to
    ///< the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_BLK_TFR_DONE : 1;
    ///< Multiplexed - Destination Block Transfer Done debug signal corresponding
    ///< to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_BLK_TFR_DONE : 1;
    ///< Multiplexed - Source Block Transfer Done debug signal corresponding
    ///< to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t DEBUG_CH_NUM_I : 1;
    ///< Debug Interface Channel number. This channel number is used to multiplex
    ///< debug signals from all channels to provide one set of debug signals
    ///< corresponding to a Channel number - debug_ch_num_i. The following
    ///< Channel specific debug signals are multiplexed based on the debug_ch_num_i:
    ///< ch_src_blk_tfr_done, ch_dst_blk_tfr_done, ch_blk_tfr_done, ch_src_trans_done,
    ///< ch_dst_trans_done, ch_dma_tfr_done, ch_src_trans_req, ch_dst_trans_req,
    ///< ch_src_is_in_str, ch_dst_is_in_str, ch_aborted, ch_suspended, ch_shadowreg_or_lli_invalid_err.
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint32_t DEBUG_CH_LLI_RD_REQ_M1 : 2;
    ///< Debug port AXI Manager Interface 1 LLI Read Arbiter Request.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t DEBUG_CH_RD_ARB_REQ_M1 : 2;
    ///< Debug port AXI Manager Interface 1 Read Arbiter Request.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t DEBUG_CH_WR_ARB_REQ_M1 : 2;
    ///< Debug port AXI Manager Interface 1 Write Arbiter Request.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t DEBUG_GRANT_INDEX_AW_CH_M1 : 3;
    ///< Debug port AXI Manager Interface 1 Write Address Channel Arbiter grant
    ///< index.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x7"
    uint32_t DEBUG_GRANT_INDEX_AR_CH_M1 : 3;
    ///< Debug port AXI Manager Interface 1 Read Address Channel Arbiter grant
    ///< index.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x7"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dmac_dma0_dbg_reg_t;

#define MEM_FB_DMAC_DMA0_DBG_DEFAULT (0x0fc00000U)
#define MEM_FB_DMAC_DMA0_DBG_RD_MASK (0x0fffffffU)
#define MEM_FB_DMAC_DMA0_DBG_WR_MASK (0x00000000U)


///< DMA Channel enable debug signal.
#define MEM_FB_DMAC_DMA0_DBG_CH_EN_BF_OFF ( 0)
#define MEM_FB_DMAC_DMA0_DBG_CH_EN_BF_WID ( 2)
#define MEM_FB_DMAC_DMA0_DBG_CH_EN_BF_MSK (0x00000003)
#define MEM_FB_DMAC_DMA0_DBG_CH_EN_BF_DEF (0x00000000)

///< Multiplexed - Channel Suspend status debug signal corresponding to
///< the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA0_DBG_CH_SUSPENDED_BF_OFF ( 2)
#define MEM_FB_DMAC_DMA0_DBG_CH_SUSPENDED_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_SUSPENDED_BF_MSK (0x00000004)
#define MEM_FB_DMAC_DMA0_DBG_CH_SUSPENDED_BF_DEF (0x00000000)

///< Multiplexed - Channel Abort status (generated due to Channel Suspend
///< request, Channel disable, User Channel abort, or due to reception
///< of AXI error response) debug signal corresponding to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA0_DBG_CH_ABORTED_BF_OFF ( 3)
#define MEM_FB_DMAC_DMA0_DBG_CH_ABORTED_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_ABORTED_BF_MSK (0x00000008)
#define MEM_FB_DMAC_DMA0_DBG_CH_ABORTED_BF_DEF (0x00000000)

///< Multiplexed - Shadow register or LLI Invalid error debug signal corresponding
///< to the channel debug_ch_num_i. For more information, see  Programming
///< Flow for Shadow-Register-Based Multi-Block Transfer  and  Programming
///< Flow for Linked-List-Based Multi-Bock Transfer  sections of the databook.
#define MEM_FB_DMAC_DMA0_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_OFF ( 4)
#define MEM_FB_DMAC_DMA0_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_MSK (0x00000010)
#define MEM_FB_DMAC_DMA0_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_DEF (0x00000000)

///< Multiplexed - Destination State machine is in Single transaction region
///< debug signal corresponding to the channel debug_ch_num_i. For more
///< information, see  Single Transaction Region  section of the databook.
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_IS_IN_STR_BF_OFF ( 5)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_IS_IN_STR_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_IS_IN_STR_BF_MSK (0x00000020)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_IS_IN_STR_BF_DEF (0x00000000)

///< Multiplexed - Source State machine is in Single transaction region
///< debug signal corresponding to the channel debug_ch_num_i. For more
///< information, see  Single Transaction Region  section of the databook.
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_IS_IN_STR_BF_OFF ( 6)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_IS_IN_STR_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_IS_IN_STR_BF_MSK (0x00000040)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_IS_IN_STR_BF_DEF (0x00000000)

///< Multiplexed - internally generated Destination Transaction request
///< (generated based on the destination dma_req* and dma_sgl_req*) debug
///< signal corresponding to the channel debug_ch_num_i..
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_REQ_BF_OFF ( 7)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_REQ_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_REQ_BF_MSK (0x00000080)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_REQ_BF_DEF (0x00000000)

///< Multiplexed - internally generated Source Transaction request (generated
///< based on the Source dma_req* and dma_sgl_req*) debug signal corresponding
///< to the channel debug_ch_num_i..
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_REQ_BF_OFF ( 8)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_REQ_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_REQ_BF_MSK (0x00000100)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_REQ_BF_DEF (0x00000000)

///< Multiplexed - DMA Transfer Done debug signal corresponding to the
///< channel debug_ch_num_i .
#define MEM_FB_DMAC_DMA0_DBG_CH_DMA_TFR_DONE_BF_OFF ( 9)
#define MEM_FB_DMAC_DMA0_DBG_CH_DMA_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_DMA_TFR_DONE_BF_MSK (0x00000200)
#define MEM_FB_DMAC_DMA0_DBG_CH_DMA_TFR_DONE_BF_DEF (0x00000000)

///< Multiplexed - Destination Transaction Done debug signal corresponding
///< to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_DONE_BF_OFF (10)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_DONE_BF_MSK (0x00000400)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_TRANS_DONE_BF_DEF (0x00000000)

///< Multiplexed - Source Transaction Done debug signal corresponding to
///< the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_DONE_BF_OFF (11)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_DONE_BF_MSK (0x00000800)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_TRANS_DONE_BF_DEF (0x00000000)

///< Multiplexed - DMA Block Transfer Done debug signal corresponding to
///< the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA0_DBG_CH_BLK_TFR_DONE_BF_OFF (12)
#define MEM_FB_DMAC_DMA0_DBG_CH_BLK_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_BLK_TFR_DONE_BF_MSK (0x00001000)
#define MEM_FB_DMAC_DMA0_DBG_CH_BLK_TFR_DONE_BF_DEF (0x00000000)

///< Multiplexed - Destination Block Transfer Done debug signal corresponding
///< to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_BLK_TFR_DONE_BF_OFF (13)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_BLK_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_BLK_TFR_DONE_BF_MSK (0x00002000)
#define MEM_FB_DMAC_DMA0_DBG_CH_DST_BLK_TFR_DONE_BF_DEF (0x00000000)

///< Multiplexed - Source Block Transfer Done debug signal corresponding
///< to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_BLK_TFR_DONE_BF_OFF (14)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_BLK_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_BLK_TFR_DONE_BF_MSK (0x00004000)
#define MEM_FB_DMAC_DMA0_DBG_CH_SRC_BLK_TFR_DONE_BF_DEF (0x00000000)

///< Debug Interface Channel number. This channel number is used to multiplex
///< debug signals from all channels to provide one set of debug signals
///< corresponding to a Channel number - debug_ch_num_i. The following
///< Channel specific debug signals are multiplexed based on the debug_ch_num_i:
///< ch_src_blk_tfr_done, ch_dst_blk_tfr_done, ch_blk_tfr_done, ch_src_trans_done,
///< ch_dst_trans_done, ch_dma_tfr_done, ch_src_trans_req, ch_dst_trans_req,
///< ch_src_is_in_str, ch_dst_is_in_str, ch_aborted, ch_suspended, ch_shadowreg_or_lli_invalid_err.
#define MEM_FB_DMAC_DMA0_DBG_CH_NUM_I_BF_OFF (15)
#define MEM_FB_DMAC_DMA0_DBG_CH_NUM_I_BF_WID ( 1)
#define MEM_FB_DMAC_DMA0_DBG_CH_NUM_I_BF_MSK (0x00008000)
#define MEM_FB_DMAC_DMA0_DBG_CH_NUM_I_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 LLI Read Arbiter Request.
#define MEM_FB_DMAC_DMA0_DBG_CH_LLI_RD_REQ_M1_BF_OFF (16)
#define MEM_FB_DMAC_DMA0_DBG_CH_LLI_RD_REQ_M1_BF_WID ( 2)
#define MEM_FB_DMAC_DMA0_DBG_CH_LLI_RD_REQ_M1_BF_MSK (0x00030000)
#define MEM_FB_DMAC_DMA0_DBG_CH_LLI_RD_REQ_M1_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 Read Arbiter Request.
#define MEM_FB_DMAC_DMA0_DBG_CH_RD_ARB_REQ_M1_BF_OFF (18)
#define MEM_FB_DMAC_DMA0_DBG_CH_RD_ARB_REQ_M1_BF_WID ( 2)
#define MEM_FB_DMAC_DMA0_DBG_CH_RD_ARB_REQ_M1_BF_MSK (0x000C0000)
#define MEM_FB_DMAC_DMA0_DBG_CH_RD_ARB_REQ_M1_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 Write Arbiter Request.
#define MEM_FB_DMAC_DMA0_DBG_CH_WR_ARB_REQ_M1_BF_OFF (20)
#define MEM_FB_DMAC_DMA0_DBG_CH_WR_ARB_REQ_M1_BF_WID ( 2)
#define MEM_FB_DMAC_DMA0_DBG_CH_WR_ARB_REQ_M1_BF_MSK (0x00300000)
#define MEM_FB_DMAC_DMA0_DBG_CH_WR_ARB_REQ_M1_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 Write Address Channel Arbiter grant
///< index.
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AW_CH_M1_BF_OFF (22)
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AW_CH_M1_BF_WID ( 3)
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AW_CH_M1_BF_MSK (0x01C00000)
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AW_CH_M1_BF_DEF (0x01C00000)

///< Debug port AXI Manager Interface 1 Read Address Channel Arbiter grant
///< index.
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AR_CH_M1_BF_OFF (25)
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AR_CH_M1_BF_WID ( 3)
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AR_CH_M1_BF_MSK (0x0E000000)
#define MEM_FB_DMAC_DMA0_DBG_GRANT_INDEX_AR_CH_M1_BF_DEF (0x0E000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC_DMA1_DEBUG register description at address offset 0x2c
  *
  * Register default value:        0x0FC00000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC_DMA1_DEBUG
  * DMAC debug register for DMA1
  */

typedef union {
  struct {
    uint32_t DEBUG_CH_EN : 2;
    ///< DMA Channel enable debug signal.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DEBUG_CH_SUSPENDED : 1;
    ///< Multiplexed - Channel Suspend status debug signal corresponding to
    ///< the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t DEBUG_CH_ABORTED : 1;
    ///< Multiplexed - Channel Abort status (generated due to Channel Suspend
    ///< request, Channel disable, User Channel abort, or due to reception
    ///< of AXI error response) debug signal corresponding to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t DEBUG_CH_SHADOWREG_OR_LLI_INVALID_ERR : 1;
    ///< Multiplexed - Shadow register or LLI Invalid error debug signal corresponding
    ///< to the channel debug_ch_num_i. For more information, see  Programming
    ///< Flow for Shadow-Register-Based Multi-Block Transfer  and  Programming
    ///< Flow for Linked-List-Based Multi-Bock Transfer  sections of the databook.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_IS_IN_STR : 1;
    ///< Multiplexed - Destination State machine is in Single transaction region
    ///< debug signal corresponding to the channel debug_ch_num_i. For more
    ///< information, see  Single Transaction Region  section of the databook.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_IS_IN_STR : 1;
    ///< Multiplexed - Source State machine is in Single transaction region
    ///< debug signal corresponding to the channel debug_ch_num_i. For more
    ///< information, see  Single Transaction Region  section of the databook.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_TRANS_REQ : 1;
    ///< Multiplexed - internally generated Destination Transaction request
    ///< (generated based on the destination dma_req* and dma_sgl_req*) debug
    ///< signal corresponding to the channel debug_ch_num_i..
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_TRANS_REQ : 1;
    ///< Multiplexed - internally generated Source Transaction request (generated
    ///< based on the Source dma_req* and dma_sgl_req*) debug signal corresponding
    ///< to the channel debug_ch_num_i..
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t DEBUG_CH_DMA_TFR_DONE : 1;
    ///< Multiplexed - DMA Transfer Done debug signal corresponding to the
    ///< channel debug_ch_num_i .
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_TRANS_DONE : 1;
    ///< Multiplexed - Destination Transaction Done debug signal corresponding
    ///< to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_TRANS_DONE : 1;
    ///< Multiplexed - Source Transaction Done debug signal corresponding to
    ///< the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t DEBUG_CH_BLK_TFR_DONE : 1;
    ///< Multiplexed - DMA Block Transfer Done debug signal corresponding to
    ///< the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t DEBUG_CH_DST_BLK_TFR_DONE : 1;
    ///< Multiplexed - Destination Block Transfer Done debug signal corresponding
    ///< to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint32_t DEBUG_CH_SRC_BLK_TFR_DONE : 1;
    ///< Multiplexed - Source Block Transfer Done debug signal corresponding
    ///< to the channel debug_ch_num_i.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t DEBUG_CH_NUM_I : 1;
    ///< Debug Interface Channel number. This channel number is used to multiplex
    ///< debug signals from all channels to provide one set of debug signals
    ///< corresponding to a Channel number - debug_ch_num_i. The following
    ///< Channel specific debug signals are multiplexed based on the debug_ch_num_i:
    ///< ch_src_blk_tfr_done, ch_dst_blk_tfr_done, ch_blk_tfr_done, ch_src_trans_done,
    ///< ch_dst_trans_done, ch_dma_tfr_done, ch_src_trans_req, ch_dst_trans_req,
    ///< ch_src_is_in_str, ch_dst_is_in_str, ch_aborted, ch_suspended, ch_shadowreg_or_lli_invalid_err.
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint32_t DEBUG_CH_LLI_RD_REQ_M1 : 2;
    ///< Debug port AXI Manager Interface 1 LLI Read Arbiter Request.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t DEBUG_CH_RD_ARB_REQ_M1 : 2;
    ///< Debug port AXI Manager Interface 1 Read Arbiter Request.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t DEBUG_CH_WR_ARB_REQ_M1 : 2;
    ///< Debug port AXI Manager Interface 1 Write Arbiter Request.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t DEBUG_GRANT_INDEX_AW_CH_M1 : 3;
    ///< Debug port AXI Manager Interface 1 Write Address Channel Arbiter grant
    ///< index.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x7"
    uint32_t DEBUG_GRANT_INDEX_AR_CH_M1 : 3;
    ///< Debug port AXI Manager Interface 1 Read Address Channel Arbiter grant
    ///< index.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x7"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dmac_dma1_dbg_reg_t;

#define MEM_FB_DMAC_DMA1_DBG_DEFAULT (0x0fc00000U)
#define MEM_FB_DMAC_DMA1_DBG_RD_MASK (0x0fffffffU)
#define MEM_FB_DMAC_DMA1_DBG_WR_MASK (0x00000000U)


///< DMA Channel enable debug signal.
#define MEM_FB_DMAC_DMA1_DBG_CH_EN_BF_OFF ( 0)
#define MEM_FB_DMAC_DMA1_DBG_CH_EN_BF_WID ( 2)
#define MEM_FB_DMAC_DMA1_DBG_CH_EN_BF_MSK (0x00000003)
#define MEM_FB_DMAC_DMA1_DBG_CH_EN_BF_DEF (0x00000000)

///< Multiplexed - Channel Suspend status debug signal corresponding to
///< the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA1_DBG_CH_SUSPENDED_BF_OFF ( 2)
#define MEM_FB_DMAC_DMA1_DBG_CH_SUSPENDED_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_SUSPENDED_BF_MSK (0x00000004)
#define MEM_FB_DMAC_DMA1_DBG_CH_SUSPENDED_BF_DEF (0x00000000)

///< Multiplexed - Channel Abort status (generated due to Channel Suspend
///< request, Channel disable, User Channel abort, or due to reception
///< of AXI error response) debug signal corresponding to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA1_DBG_CH_ABORTED_BF_OFF ( 3)
#define MEM_FB_DMAC_DMA1_DBG_CH_ABORTED_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_ABORTED_BF_MSK (0x00000008)
#define MEM_FB_DMAC_DMA1_DBG_CH_ABORTED_BF_DEF (0x00000000)

///< Multiplexed - Shadow register or LLI Invalid error debug signal corresponding
///< to the channel debug_ch_num_i. For more information, see  Programming
///< Flow for Shadow-Register-Based Multi-Block Transfer  and  Programming
///< Flow for Linked-List-Based Multi-Bock Transfer  sections of the databook.
#define MEM_FB_DMAC_DMA1_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_OFF ( 4)
#define MEM_FB_DMAC_DMA1_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_MSK (0x00000010)
#define MEM_FB_DMAC_DMA1_DBG_CH_SHDWREG_OR_LLI_INVALID_ERR_BF_DEF (0x00000000)

///< Multiplexed - Destination State machine is in Single transaction region
///< debug signal corresponding to the channel debug_ch_num_i. For more
///< information, see  Single Transaction Region  section of the databook.
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_IS_IN_STR_BF_OFF ( 5)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_IS_IN_STR_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_IS_IN_STR_BF_MSK (0x00000020)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_IS_IN_STR_BF_DEF (0x00000000)

///< Multiplexed - Source State machine is in Single transaction region
///< debug signal corresponding to the channel debug_ch_num_i. For more
///< information, see  Single Transaction Region  section of the databook.
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_IS_IN_STR_BF_OFF ( 6)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_IS_IN_STR_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_IS_IN_STR_BF_MSK (0x00000040)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_IS_IN_STR_BF_DEF (0x00000000)

///< Multiplexed - internally generated Destination Transaction request
///< (generated based on the destination dma_req* and dma_sgl_req*) debug
///< signal corresponding to the channel debug_ch_num_i..
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_REQ_BF_OFF ( 7)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_REQ_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_REQ_BF_MSK (0x00000080)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_REQ_BF_DEF (0x00000000)

///< Multiplexed - internally generated Source Transaction request (generated
///< based on the Source dma_req* and dma_sgl_req*) debug signal corresponding
///< to the channel debug_ch_num_i..
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_REQ_BF_OFF ( 8)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_REQ_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_REQ_BF_MSK (0x00000100)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_REQ_BF_DEF (0x00000000)

///< Multiplexed - DMA Transfer Done debug signal corresponding to the
///< channel debug_ch_num_i .
#define MEM_FB_DMAC_DMA1_DBG_CH_DMA_TFR_DONE_BF_OFF ( 9)
#define MEM_FB_DMAC_DMA1_DBG_CH_DMA_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_DMA_TFR_DONE_BF_MSK (0x00000200)
#define MEM_FB_DMAC_DMA1_DBG_CH_DMA_TFR_DONE_BF_DEF (0x00000000)

///< Multiplexed - Destination Transaction Done debug signal corresponding
///< to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_DONE_BF_OFF (10)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_DONE_BF_MSK (0x00000400)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_TRANS_DONE_BF_DEF (0x00000000)

///< Multiplexed - Source Transaction Done debug signal corresponding to
///< the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_DONE_BF_OFF (11)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_DONE_BF_MSK (0x00000800)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_TRANS_DONE_BF_DEF (0x00000000)

///< Multiplexed - DMA Block Transfer Done debug signal corresponding to
///< the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA1_DBG_CH_BLK_TFR_DONE_BF_OFF (12)
#define MEM_FB_DMAC_DMA1_DBG_CH_BLK_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_BLK_TFR_DONE_BF_MSK (0x00001000)
#define MEM_FB_DMAC_DMA1_DBG_CH_BLK_TFR_DONE_BF_DEF (0x00000000)

///< Multiplexed - Destination Block Transfer Done debug signal corresponding
///< to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_BLK_TFR_DONE_BF_OFF (13)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_BLK_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_BLK_TFR_DONE_BF_MSK (0x00002000)
#define MEM_FB_DMAC_DMA1_DBG_CH_DST_BLK_TFR_DONE_BF_DEF (0x00000000)

///< Multiplexed - Source Block Transfer Done debug signal corresponding
///< to the channel debug_ch_num_i.
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_BLK_TFR_DONE_BF_OFF (14)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_BLK_TFR_DONE_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_BLK_TFR_DONE_BF_MSK (0x00004000)
#define MEM_FB_DMAC_DMA1_DBG_CH_SRC_BLK_TFR_DONE_BF_DEF (0x00000000)

///< Debug Interface Channel number. This channel number is used to multiplex
///< debug signals from all channels to provide one set of debug signals
///< corresponding to a Channel number - debug_ch_num_i. The following
///< Channel specific debug signals are multiplexed based on the debug_ch_num_i:
///< ch_src_blk_tfr_done, ch_dst_blk_tfr_done, ch_blk_tfr_done, ch_src_trans_done,
///< ch_dst_trans_done, ch_dma_tfr_done, ch_src_trans_req, ch_dst_trans_req,
///< ch_src_is_in_str, ch_dst_is_in_str, ch_aborted, ch_suspended, ch_shadowreg_or_lli_invalid_err.
#define MEM_FB_DMAC_DMA1_DBG_CH_NUM_I_BF_OFF (15)
#define MEM_FB_DMAC_DMA1_DBG_CH_NUM_I_BF_WID ( 1)
#define MEM_FB_DMAC_DMA1_DBG_CH_NUM_I_BF_MSK (0x00008000)
#define MEM_FB_DMAC_DMA1_DBG_CH_NUM_I_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 LLI Read Arbiter Request.
#define MEM_FB_DMAC_DMA1_DBG_CH_LLI_RD_REQ_M1_BF_OFF (16)
#define MEM_FB_DMAC_DMA1_DBG_CH_LLI_RD_REQ_M1_BF_WID ( 2)
#define MEM_FB_DMAC_DMA1_DBG_CH_LLI_RD_REQ_M1_BF_MSK (0x00030000)
#define MEM_FB_DMAC_DMA1_DBG_CH_LLI_RD_REQ_M1_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 Read Arbiter Request.
#define MEM_FB_DMAC_DMA1_DBG_CH_RD_ARB_REQ_M1_BF_OFF (18)
#define MEM_FB_DMAC_DMA1_DBG_CH_RD_ARB_REQ_M1_BF_WID ( 2)
#define MEM_FB_DMAC_DMA1_DBG_CH_RD_ARB_REQ_M1_BF_MSK (0x000C0000)
#define MEM_FB_DMAC_DMA1_DBG_CH_RD_ARB_REQ_M1_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 Write Arbiter Request.
#define MEM_FB_DMAC_DMA1_DBG_CH_WR_ARB_REQ_M1_BF_OFF (20)
#define MEM_FB_DMAC_DMA1_DBG_CH_WR_ARB_REQ_M1_BF_WID ( 2)
#define MEM_FB_DMAC_DMA1_DBG_CH_WR_ARB_REQ_M1_BF_MSK (0x00300000)
#define MEM_FB_DMAC_DMA1_DBG_CH_WR_ARB_REQ_M1_BF_DEF (0x00000000)

///< Debug port AXI Manager Interface 1 Write Address Channel Arbiter grant
///< index.
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AW_CH_M1_BF_OFF (22)
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AW_CH_M1_BF_WID ( 3)
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AW_CH_M1_BF_MSK (0x01C00000)
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AW_CH_M1_BF_DEF (0x01C00000)

///< Debug port AXI Manager Interface 1 Read Address Channel Arbiter grant
///< index.
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AR_CH_M1_BF_OFF (25)
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AR_CH_M1_BF_WID ( 3)
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AR_CH_M1_BF_MSK (0x0E000000)
#define MEM_FB_DMAC_DMA1_DBG_GRANT_INDEX_AR_CH_M1_BF_DEF (0x0E000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC0_CH_TFR_DONE_CNT register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC0_CH_TFR_DONE_CNT
  * DMAC0 channel transfer done count.
  */

typedef union {
  struct {
    uint32_t CH_TFR_DONE_CNT : 32;
    ///< Count of the DMAC0 source block transfers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac0_ch_tfr_done_cnt_reg_t;

#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_WR_MASK (0x00000000U)


///< Count of the DMAC0 source block transfers.
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_WID (32)
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC1_CH_TFR_DONE_CNT register description at address offset 0x34
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC1_CH_TFR_DONE_CNT
  * DMAC1 channel transfer done count.
  */

typedef union {
  struct {
    uint32_t CH_TFR_DONE_CNT : 32;
    ///< Count of the DMAC1 source block transfers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac1_ch_tfr_done_cnt_reg_t;

#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_WR_MASK (0x00000000U)


///< Count of the DMAC1 source block transfers.
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_WID (32)
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_CH_TFR_DONE_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC0_DST_TFR_DONE_CNT register description at address offset 0x38
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC0_DST_TFR_DONE_CNT
  * DMAC0 channel destination transfer done count.
  */

typedef union {
  struct {
    uint32_t DST_TFR_DONE_CNT : 32;
    ///< Count of the DMAC0 channel destination transfers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac0_dst_tfr_done_cnt_reg_t;

#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_WR_MASK (0x00000000U)


///< Count of the DMAC0 channel destination transfers.
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_WID (32)
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC1_DST_TFR_DONE_CNT register description at address offset 0x3c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC1_DST_TFR_DONE_CNT
  * DMAC1 channel destination transfer done count.
  */

typedef union {
  struct {
    uint32_t DST_TFR_DONE_CNT : 32;
    ///< Count of the DMAC1 destination channel transfers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac1_dst_tfr_done_cnt_reg_t;

#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_WR_MASK (0x00000000U)


///< Count of the DMAC1 destination channel transfers.
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_WID (32)
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_DST_TFR_DONE_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC0_SRC_TFR_DONE_CNT register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC0_SRC_TFR_DONE_CNT
  * DMAC0 channel source transfer done count.
  */

typedef union {
  struct {
    uint32_t SRC_TFR_DONE_CNT : 32;
    ///< Count of the DMAC0 channel source transfers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac0_src_tfr_done_cnt_reg_t;

#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_WR_MASK (0x00000000U)


///< Count of the DMAC0 channel source transfers.
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_WID (32)
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC1_SRC_TFR_DONE_CNT register description at address offset 0x44
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC1_SRC_TFR_DONE_CNT
  * DMAC1 channel source transfer done count.
  */

typedef union {
  struct {
    uint32_t SRC_TFR_DONE_CNT : 32;
    ///< Count of the DMAC1 source channel transfers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac1_src_tfr_done_cnt_reg_t;

#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_WR_MASK (0x00000000U)


///< Count of the DMAC1 source channel transfers.
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_WID (32)
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_SRC_TFR_DONE_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_TDD_STALL register description at address offset 0x48
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/TDD_STALL
  * Stall DMA0/1 during TDD operation.
  */

typedef union {
  struct {
    uint32_t TDD_STALL_CH0_DMA0 : 1;
    ///< There are two main modes of operation in a LTE/NR system - Time Division
    ///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
    ///< there are time durations when there is no data transfer in the down
    ///< link direction, channel 0 of DMA0 can be stalled by setting this bit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TDD_STALL_CH0_DMA1 : 1;
    ///< There are two main modes of operation in a LTE/NR system - Time Division
    ///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
    ///< there are time durations when there is no data transfer in the down
    ///< link direction, channel 0 of DMA1 can be stalled by setting this bit.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t TDD_STALL_CH1_DMA0 : 1;
    ///< There are two main modes of operation in a LTE/NR system - Time Division
    ///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
    ///< there are time durations when there is no data transfer in the down
    ///< link direction, channel 1 of DMA0 can be stalled by setting this bit.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t TDD_STALL_CH1_DMA1 : 1;
    ///< There are two main modes of operation in a LTE/NR system - Time Division
    ///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
    ///< there are time durations when there is no data transfer in the down
    ///< link direction, channel 1 of DMA1 can be stalled by setting this bit.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_tdd_stall_reg_t;

#define MEM_FB_TDD_STALL_DEFAULT (0x00000000U)
#define MEM_FB_TDD_STALL_RD_MASK (0x0000000fU)
#define MEM_FB_TDD_STALL_WR_MASK (0x0000000fU)


///< There are two main modes of operation in a LTE/NR system - Time Division
///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
///< there are time durations when there is no data transfer in the down
///< link direction, channel 0 of DMA0 can be stalled by setting this bit.
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA0_BF_OFF ( 0)
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA0_BF_WID ( 1)
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA0_BF_MSK (0x00000001)
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA0_BF_DEF (0x00000000)

///< There are two main modes of operation in a LTE/NR system - Time Division
///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
///< there are time durations when there is no data transfer in the down
///< link direction, channel 0 of DMA1 can be stalled by setting this bit.
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA1_BF_OFF ( 1)
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA1_BF_WID ( 1)
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA1_BF_MSK (0x00000002)
#define MEM_FB_TDD_STALL_TDD_STALL_CH0_DMA1_BF_DEF (0x00000000)

///< There are two main modes of operation in a LTE/NR system - Time Division
///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
///< there are time durations when there is no data transfer in the down
///< link direction, channel 1 of DMA0 can be stalled by setting this bit.
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA0_BF_OFF ( 2)
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA0_BF_WID ( 1)
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA0_BF_MSK (0x00000004)
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA0_BF_DEF (0x00000000)

///< There are two main modes of operation in a LTE/NR system - Time Division
///< Duplex (TDD) and Frequency Division Duplex (FDD). In TDD mode, since
///< there are time durations when there is no data transfer in the down
///< link direction, channel 1 of DMA1 can be stalled by setting this bit.
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA1_BF_OFF ( 3)
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA1_BF_WID ( 1)
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA1_BF_MSK (0x00000008)
#define MEM_FB_TDD_STALL_TDD_STALL_CH1_DMA1_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC0_CH0_PAUSE_CNT register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC0_CH0_PAUSE_CNT
  * Burst count to pause CH0 of DMAC0
  */

typedef union {
  struct {
    uint32_t BURST_CNT : 32;
    ///< The DMA does  block transfers  equal to the value programmed in this
    ///< register and then pauses and waits for a new trigger. If the value
    ///< in this field is zero, the DMA block ignores this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac0_ch0_pause_cnt_reg_t;

#define MEM_FB_DMAC0_CH0_PAUSE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_WR_MASK (0xffffffffU)


///< The DMA does  block transfers  equal to the value programmed in this
///< register and then pauses and waits for a new trigger. If the value
///< in this field is zero, the DMA block ignores this field.
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_BURST_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_BURST_CNT_BF_WID (32)
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_BURST_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_BURST_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC1_CH0_PAUSE_CNT register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC1_CH0_PAUSE_CNT
  * Burst count to pause CH0 of DMAC1
  */

typedef union {
  struct {
    uint32_t BURST_CNT : 32;
    ///< The DMA does  block transfers  equal to the value programmed in this
    ///< register and then pauses and waits for a new trigger. If the value
    ///< in this field is zero, the DMA block ignores this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac1_ch0_pause_cnt_reg_t;

#define MEM_FB_DMAC1_CH0_PAUSE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_WR_MASK (0xffffffffU)


///< The DMA does  block transfers  equal to the value programmed in this
///< register and then pauses and waits for a new trigger. If the value
///< in this field is zero, the DMA block ignores this field.
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_BURST_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_BURST_CNT_BF_WID (32)
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_BURST_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_BURST_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC0_CH1_PAUSE_CNT register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC0_CH1_PAUSE_CNT
  * Burst count to pause CH1 of DMAC0
  */

typedef union {
  struct {
    uint32_t BURST_CNT : 32;
    ///< The DMA does  block transfers  equal to the value programmed in this
    ///< register and then pauses and waits for a new trigger. If the value
    ///< in this field is zero, the DMA block ignores this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac0_ch1_pause_cnt_reg_t;

#define MEM_FB_DMAC0_CH1_PAUSE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_WR_MASK (0xffffffffU)


///< The DMA does  block transfers  equal to the value programmed in this
///< register and then pauses and waits for a new trigger. If the value
///< in this field is zero, the DMA block ignores this field.
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_BURST_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_BURST_CNT_BF_WID (32)
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_BURST_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_BURST_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC1_CH1_PAUSE_CNT register description at address offset 0x58
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC1_CH1_PAUSE_CNT
  * Burst count to pause CH1 of DMAC1
  */

typedef union {
  struct {
    uint32_t BURST_CNT : 32;
    ///< The DMA does  block transfers  equal to the value programmed in this
    ///< register and then pauses and waits for a new trigger. If the value
    ///< in this field is zero, the DMA block ignores this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dmac1_ch1_pause_cnt_reg_t;

#define MEM_FB_DMAC1_CH1_PAUSE_CNT_DEFAULT (0x00000000U)
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_WR_MASK (0xffffffffU)


///< The DMA does  block transfers  equal to the value programmed in this
///< register and then pauses and waits for a new trigger. If the value
///< in this field is zero, the DMA block ignores this field.
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_BURST_CNT_BF_OFF ( 0)
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_BURST_CNT_BF_WID (32)
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_BURST_CNT_BF_MSK (0xFFFFFFFF)
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_BURST_CNT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMAC_LL_INVALID register description at address offset 0x5c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMAC_LL_INVALID
  * DMAC linked list invalid
  */

typedef union {
  struct {
    uint32_t LL_ERR_STATUS : 1;
    ///< This bit is set when a multi-bit ECC error is detected in the descriptor
    ///< memory and the link list is invalidated and all DMA operations are
    ///< stopped. Software should monitor the ShadowReg_Or_LLI_Invalid_ERR
    ///< interrupt in the DMAC interrupt status register. Once the interrupt
    ///< is set, software should check this bit and if set, it should clear
    ///< this bit by writing a 1 to this register and then clear the interrupt
    ///< as well.
    ///< AccessType="RW/1C" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dmac_ll_invalid_reg_t;

#define MEM_FB_DMAC_LL_INVALID_DEFAULT (0x00000000U)
#define MEM_FB_DMAC_LL_INVALID_RD_MASK (0x00000001U)
#define MEM_FB_DMAC_LL_INVALID_WR_MASK (0x00000001U)


///< This bit is set when a multi-bit ECC error is detected in the descriptor
///< memory and the link list is invalidated and all DMA operations are
///< stopped. Software should monitor the ShadowReg_Or_LLI_Invalid_ERR
///< interrupt in the DMAC interrupt status register. Once the interrupt
///< is set, software should check this bit and if set, it should clear
///< this bit by writing a 1 to this register and then clear the interrupt
///< as well.
#define MEM_FB_DMAC_LL_INVALID_LL_ERR_STAT_BF_OFF ( 0)
#define MEM_FB_DMAC_LL_INVALID_LL_ERR_STAT_BF_WID ( 1)
#define MEM_FB_DMAC_LL_INVALID_LL_ERR_STAT_BF_MSK (0x00000001)
#define MEM_FB_DMAC_LL_INVALID_LL_ERR_STAT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_NSIP_CM0_PKT_LEN register description at address offset 0x60
  *
  * Register default value:        0x00000003
  * Register full path in IP: mem_fb_map_MEM/reg/NSIP_CM0_PKT_LEN
  * NSIP CM0 packet length
  */

typedef union {
  struct {
    uint32_t CRUX_INTF_PKT_LEN : 3;
    ///< This field controls the packet length on the Crux interface. Actual
    ///< packet length is (CRUX_INTF_PKT_LEN+1)*64 bytes. Acceptable values
    ///< for this field are 0, 1, 3 and 7.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x3"
    uint32_t DROP : 1;
    ///< If this bit is set, packets will start getting dropped when the Crux
    ///< interface back-pressures the common module and the FIFOs fill up.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_nsip_cm0_pkt_len_reg_t;

#define MEM_FB_NSIP_CM0_PKT_LEN_DEFAULT (0x00000003U)
#define MEM_FB_NSIP_CM0_PKT_LEN_RD_MASK (0x0000000fU)
#define MEM_FB_NSIP_CM0_PKT_LEN_WR_MASK (0x0000000fU)


///< This field controls the packet length on the Crux interface. Actual
///< packet length is (CRUX_INTF_PKT_LEN+1)*64 bytes. Acceptable values
///< for this field are 0, 1, 3 and 7.
#define MEM_FB_NSIP_CM0_PKT_LEN_CRUX_INTF_PKT_LEN_BF_OFF ( 0)
#define MEM_FB_NSIP_CM0_PKT_LEN_CRUX_INTF_PKT_LEN_BF_WID ( 3)
#define MEM_FB_NSIP_CM0_PKT_LEN_CRUX_INTF_PKT_LEN_BF_MSK (0x00000007)
#define MEM_FB_NSIP_CM0_PKT_LEN_CRUX_INTF_PKT_LEN_BF_DEF (0x00000003)

///< If this bit is set, packets will start getting dropped when the Crux
///< interface back-pressures the common module and the FIFOs fill up.
#define MEM_FB_NSIP_CM0_PKT_LEN_DROP_BF_OFF ( 3)
#define MEM_FB_NSIP_CM0_PKT_LEN_DROP_BF_WID ( 1)
#define MEM_FB_NSIP_CM0_PKT_LEN_DROP_BF_MSK (0x00000008)
#define MEM_FB_NSIP_CM0_PKT_LEN_DROP_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_NSIP_CM1_PKT_LEN register description at address offset 0x64
  *
  * Register default value:        0x00000003
  * Register full path in IP: mem_fb_map_MEM/reg/NSIP_CM1_PKT_LEN
  * NSIP CM1 packet length
  */

typedef union {
  struct {
    uint32_t CRUX_INTF_PKT_LEN : 3;
    ///< This field controls the packet length on the Crux interface. Actual
    ///< packet length is (CRUX_INTF_PKT_LEN+1)*64 bytes. Acceptable values
    ///< for this field are 0, 1, 3 and 7.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x3"
    uint32_t DROP : 1;
    ///< If this bit is set, packets will start getting dropped when the Crux
    ///< interface back-pressures the common module and the FIFOs fill up.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_nsip_cm1_pkt_len_reg_t;

#define MEM_FB_NSIP_CM1_PKT_LEN_DEFAULT (0x00000003U)
#define MEM_FB_NSIP_CM1_PKT_LEN_RD_MASK (0x0000000fU)
#define MEM_FB_NSIP_CM1_PKT_LEN_WR_MASK (0x0000000fU)


///< This field controls the packet length on the Crux interface. Actual
///< packet length is (CRUX_INTF_PKT_LEN+1)*64 bytes. Acceptable values
///< for this field are 0, 1, 3 and 7.
#define MEM_FB_NSIP_CM1_PKT_LEN_CRUX_INTF_PKT_LEN_BF_OFF ( 0)
#define MEM_FB_NSIP_CM1_PKT_LEN_CRUX_INTF_PKT_LEN_BF_WID ( 3)
#define MEM_FB_NSIP_CM1_PKT_LEN_CRUX_INTF_PKT_LEN_BF_MSK (0x00000007)
#define MEM_FB_NSIP_CM1_PKT_LEN_CRUX_INTF_PKT_LEN_BF_DEF (0x00000003)

///< If this bit is set, packets will start getting dropped when the Crux
///< interface back-pressures the common module and the FIFOs fill up.
#define MEM_FB_NSIP_CM1_PKT_LEN_DROP_BF_OFF ( 3)
#define MEM_FB_NSIP_CM1_PKT_LEN_DROP_BF_WID ( 1)
#define MEM_FB_NSIP_CM1_PKT_LEN_DROP_BF_MSK (0x00000008)
#define MEM_FB_NSIP_CM1_PKT_LEN_DROP_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_NSIP_CM_HALT_CFG register description at address offset 0x68
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/NSIP_CM_HALT_CFG
  * NSIP CM halt config
  */

typedef union {
  struct {
    uint32_t NSIP_CM0_HALT : 1;
    ///< This bit is used to halt the operation of common module 0.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NSIP_CM1_HALT : 1;
    ///< This bit is used to halt the operation of common module 1.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_nsip_cm_halt_cfg_reg_t;

#define MEM_FB_NSIP_CM_HALT_CFG_DEFAULT (0x00000000U)
#define MEM_FB_NSIP_CM_HALT_CFG_RD_MASK (0x00000003U)
#define MEM_FB_NSIP_CM_HALT_CFG_WR_MASK (0x00000003U)


///< This bit is used to halt the operation of common module 0.
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM0_HALT_BF_OFF ( 0)
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM0_HALT_BF_WID ( 1)
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM0_HALT_BF_MSK (0x00000001)
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM0_HALT_BF_DEF (0x00000000)

///< This bit is used to halt the operation of common module 1.
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM1_HALT_BF_OFF ( 1)
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM1_HALT_BF_WID ( 1)
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM1_HALT_BF_MSK (0x00000002)
#define MEM_FB_NSIP_CM_HALT_CFG_NSIP_CM1_HALT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_NSIP_CM_HALT_STATUS register description at address offset 0x6c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/NSIP_CM_HALT_STATUS
  * NSIP CM halt status
  */

typedef union {
  struct {
    uint32_t NSIP_CM0_HALT_STATUS : 1;
    ///< This bit is used to check the halt status of common module 0.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NSIP_CM1_HALT_STATUS : 1;
    ///< This bit is used to check the halt status of common module 1.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_nsip_cm_halt_stat_reg_t;

#define MEM_FB_NSIP_CM_HALT_STAT_DEFAULT (0x00000000U)
#define MEM_FB_NSIP_CM_HALT_STAT_RD_MASK (0x00000003U)
#define MEM_FB_NSIP_CM_HALT_STAT_WR_MASK (0x00000000U)


///< This bit is used to check the halt status of common module 0.
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM0_HALT_STAT_BF_OFF ( 0)
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM0_HALT_STAT_BF_WID ( 1)
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM0_HALT_STAT_BF_MSK (0x00000001)
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM0_HALT_STAT_BF_DEF (0x00000000)

///< This bit is used to check the halt status of common module 1.
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM1_HALT_STAT_BF_OFF ( 1)
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM1_HALT_STAT_BF_WID ( 1)
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM1_HALT_STAT_BF_MSK (0x00000002)
#define MEM_FB_NSIP_CM_HALT_STAT_NSIP_CM1_HALT_STAT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_NSIP_CM_STATE_DEBUG register description at address offset 0x70
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/NSIP_CM_STATE_DEBUG
  * NSIP CM state machine states
  */

typedef union {
  struct {
    uint32_t NSIP_CM0_H2B_STATE : 2;
    ///< Common module state machine state.       Monitor for debug. The following
    ///< states are defined for each common module:      2'b00: SOP_STATE
    ///< -> This state is entered when the chip reset is asserted.      2'b01:
    ///< EOP_STATE    -> This state is entered when the NSIP packet length
    ///< is equal to the NSIP packet count.      2'b10: ERROR_STATE  -> This
    ///< state is entered on encountering an error condition like the FIFO
    ///< becoming full.      2'b11: HOLD_STATE   -> This state is entered from
    ///< the ERROR_STATE when the end of packet condition is detected.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NSIP_CM1_H2B_STATE : 2;
    ///< Common module state machine state.       Monitor for debug. The following
    ///< states are defined for each common module:      2'b00: SOP_STATE
    ///< -> This state is entered when the chip reset is asserted.      2'b01:
    ///< EOP_STATE    -> This state is entered when the NSIP packet length
    ///< is equal to the NSIP packet count.      2'b10: ERROR_STATE  -> This
    ///< state is entered on encountering an error condition like the FIFO
    ///< becoming full.      2'b11: HOLD_STATE   -> This state is entered from
    ///< the ERROR_STATE when the end of packet condition is detected.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t NSIP_CM0_B2H_STATE : 4;
    ///< Common module state machine state.       Monitor for debug. The following
    ///< states are defined for each common module:      4'b0000: RESET_STATE
    ///< -> This state is entered when the chip reset is asserted.      4'b0001:
    ///< GOOD_STATE       -> This state is entered when a SOP is received from
    ///< the Crux interface.      4'b0011: PKT_ERROR_STATE  -> This state is
    ///< entered when error conditions like missing sop, missing eop, incorrect
    ///< type field, incorrect length field etc. conditions are encountered.
    ///< 4'b0010: RESP_STATE       -> This state is entered in vex debug mode
    ///< where the state machine waits for a bvalid response before issuing
    ///< the next transaction.                                         4'b0111:
    ///< HERROR_STATE     -> This state ie entered when VEX requests a DMA
    ///< operation from mem_fb without halting IQ traffic.
    ///< 4'b0101: CHECK_HALT_STATE -> In this state, the state machine checks
    ///< if VEX is halted before starting the DMA operation.
    ///< 4'b0100: FIFO_DEPTH_STATE -> In this state, the state machine checks
    ///< if the FIFO is full.                                         4'b1100:
    ///< FERROR_STATE     -> This state is entered if the FIFO is full and
    ///< another DMA operation is attempted from the VEX.
    ///< 4'b1101: WRITE_FIFO_STATE -> In this state the data from the VEX is
    ///< written into the FIFO.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t NSIP_CM1_B2H_STATE : 4;
    ///< Common module state machine state.       Monitor for debug. The following
    ///< states are defined for each common module:      4'b0000: RESET_STATE
    ///< -> This state is entered when the chip reset is asserted.      4'b0001:
    ///< GOOD_STATE       -> This state is entered when a SOP is received from
    ///< the Crux interface.      4'b0011: PKT_ERROR_STATE  -> This state is
    ///< entered when error conditions like missing sop, missing eop, incorrect
    ///< type field, incorrect length field etc. conditions are encountered.
    ///< 4'b0010: RESP_STATE       -> This state is entered in vex debug mode
    ///< where the state machine waits for a bvalid response before issuing
    ///< the next transaction.                                         4'b0111:
    ///< HERROR_STATE     -> This state ie entered when VEX requests a DMA
    ///< operation from mem_fb without halting IQ traffic.
    ///< 4'b0101: CHECK_HALT_STATE -> In this state, the state machine checks
    ///< if VEX is halted before starting the DMA operation.
    ///< 4'b0100: FIFO_DEPTH_STATE -> In this state, the state machine checks
    ///< if the FIFO is full.                                         4'b1100:
    ///< FERROR_STATE     -> This state is entered if the FIFO is full and
    ///< another DMA operation is attempted from the VEX.
    ///< 4'b1101: WRITE_FIFO_STATE -> In this state the data from the VEX is
    ///< written into the FIFO.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_nsip_cm_state_dbg_reg_t;

#define MEM_FB_NSIP_CM_STATE_DBG_DEFAULT (0x00000000U)
#define MEM_FB_NSIP_CM_STATE_DBG_RD_MASK (0x00000fffU)
#define MEM_FB_NSIP_CM_STATE_DBG_WR_MASK (0x00000000U)


///< Common module state machine state.       Monitor for debug. The following
///< states are defined for each common module:      2'b00: SOP_STATE
///< -> This state is entered when the chip reset is asserted.      2'b01:
///< EOP_STATE    -> This state is entered when the NSIP packet length
///< is equal to the NSIP packet count.      2'b10: ERROR_STATE  -> This
///< state is entered on encountering an error condition like the FIFO
///< becoming full.      2'b11: HOLD_STATE   -> This state is entered from
///< the ERROR_STATE when the end of packet condition is detected.
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_H2B_STATE_BF_OFF ( 0)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_H2B_STATE_BF_WID ( 2)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_H2B_STATE_BF_MSK (0x00000003)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_H2B_STATE_BF_DEF (0x00000000)

///< Common module state machine state.       Monitor for debug. The following
///< states are defined for each common module:      2'b00: SOP_STATE
///< -> This state is entered when the chip reset is asserted.      2'b01:
///< EOP_STATE    -> This state is entered when the NSIP packet length
///< is equal to the NSIP packet count.      2'b10: ERROR_STATE  -> This
///< state is entered on encountering an error condition like the FIFO
///< becoming full.      2'b11: HOLD_STATE   -> This state is entered from
///< the ERROR_STATE when the end of packet condition is detected.
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_H2B_STATE_BF_OFF ( 2)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_H2B_STATE_BF_WID ( 2)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_H2B_STATE_BF_MSK (0x0000000C)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_H2B_STATE_BF_DEF (0x00000000)

///< Common module state machine state.       Monitor for debug. The following
///< states are defined for each common module:      4'b0000: RESET_STATE
///< -> This state is entered when the chip reset is asserted.      4'b0001:
///< GOOD_STATE       -> This state is entered when a SOP is received from
///< the Crux interface.      4'b0011: PKT_ERROR_STATE  -> This state is
///< entered when error conditions like missing sop, missing eop, incorrect
///< type field, incorrect length field etc. conditions are encountered.
///< 4'b0010: RESP_STATE       -> This state is entered in vex debug mode
///< where the state machine waits for a bvalid response before issuing
///< the next transaction.                                         4'b0111:
///< HERROR_STATE     -> This state ie entered when VEX requests a DMA
///< operation from mem_fb without halting IQ traffic.
///< 4'b0101: CHECK_HALT_STATE -> In this state, the state machine checks
///< if VEX is halted before starting the DMA operation.
///< 4'b0100: FIFO_DEPTH_STATE -> In this state, the state machine checks
///< if the FIFO is full.                                         4'b1100:
///< FERROR_STATE     -> This state is entered if the FIFO is full and
///< another DMA operation is attempted from the VEX.
///< 4'b1101: WRITE_FIFO_STATE -> In this state the data from the VEX is
///< written into the FIFO.
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_B2H_STATE_BF_OFF ( 4)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_B2H_STATE_BF_WID ( 4)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_B2H_STATE_BF_MSK (0x000000F0)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM0_B2H_STATE_BF_DEF (0x00000000)

///< Common module state machine state.       Monitor for debug. The following
///< states are defined for each common module:      4'b0000: RESET_STATE
///< -> This state is entered when the chip reset is asserted.      4'b0001:
///< GOOD_STATE       -> This state is entered when a SOP is received from
///< the Crux interface.      4'b0011: PKT_ERROR_STATE  -> This state is
///< entered when error conditions like missing sop, missing eop, incorrect
///< type field, incorrect length field etc. conditions are encountered.
///< 4'b0010: RESP_STATE       -> This state is entered in vex debug mode
///< where the state machine waits for a bvalid response before issuing
///< the next transaction.                                         4'b0111:
///< HERROR_STATE     -> This state ie entered when VEX requests a DMA
///< operation from mem_fb without halting IQ traffic.
///< 4'b0101: CHECK_HALT_STATE -> In this state, the state machine checks
///< if VEX is halted before starting the DMA operation.
///< 4'b0100: FIFO_DEPTH_STATE -> In this state, the state machine checks
///< if the FIFO is full.                                         4'b1100:
///< FERROR_STATE     -> This state is entered if the FIFO is full and
///< another DMA operation is attempted from the VEX.
///< 4'b1101: WRITE_FIFO_STATE -> In this state the data from the VEX is
///< written into the FIFO.
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_B2H_STATE_BF_OFF ( 8)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_B2H_STATE_BF_WID ( 4)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_B2H_STATE_BF_MSK (0x00000F00)
#define MEM_FB_NSIP_CM_STATE_DBG_NSIP_CM1_B2H_STATE_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_HI_AGG_STATUS register description at address offset 0x78
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_HI_AGG_STATUS
  * Aggregate high priority interrupt status
  */

typedef union {
  struct {
    uint32_t FB_STATUS : 1;
    ///< This bit is set by interrupts arising from the feedback memory logic.
    ///< Please read the INT_FB_STATUS register to find out what event caused
    ///< the interrupt.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DMAC0_STATUS : 1;
    ///< This bit is set by interrupts arising from DMA0. Please first read
    ///< the DMAC_INTSTATUSREG in DMA0 to find out which one of 1) common registers
    ///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
    ///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
    ///< CH2_INTSTATUS register to find out what event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t DMAC1_STATUS : 1;
    ///< This bit is set by interrupts arising from DMA1. Please first read
    ///< the DMAC_INTSTATUSREG in DMA1 to find out which one of 1) common registers
    ///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
    ///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
    ///< CH2_INTSTATUS register to find out what event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t NSIP0_STATUS : 1;
    ///< This bit is set by interrupts arising from NSIP0. Please read the
    ///< INT_STATUS register in NSIP0 to find out which event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t NSIP1_STATUS : 1;
    ///< This bit is set by interrupts arising from NSIP0. Please read the
    ///< INT_STATUS register in NSIP1 to find out which event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t CRUX_STATUS : 1;
    ///< This bit is set by interrupts arising from the Crux interface 0 and
    ///< 1. Please read the INT_CRUX_STATUS register to find out which event
    ///< caused the interrupt.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_int_hi_agg_stat_reg_t;

#define MEM_FB_INT_HI_AGG_STAT_DEFAULT (0x00000000U)
#define MEM_FB_INT_HI_AGG_STAT_RD_MASK (0x0000003fU)
#define MEM_FB_INT_HI_AGG_STAT_WR_MASK (0x00000000U)


///< This bit is set by interrupts arising from the feedback memory logic.
///< Please read the INT_FB_STATUS register to find out what event caused
///< the interrupt.
#define MEM_FB_INT_HI_AGG_STAT_FB_STAT_BF_OFF ( 0)
#define MEM_FB_INT_HI_AGG_STAT_FB_STAT_BF_WID ( 1)
#define MEM_FB_INT_HI_AGG_STAT_FB_STAT_BF_MSK (0x00000001)
#define MEM_FB_INT_HI_AGG_STAT_FB_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from DMA0. Please first read
///< the DMAC_INTSTATUSREG in DMA0 to find out which one of 1) common registers
///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
///< CH2_INTSTATUS register to find out what event caused the interrupt.
#define MEM_FB_INT_HI_AGG_STAT_DMAC0_STAT_BF_OFF ( 1)
#define MEM_FB_INT_HI_AGG_STAT_DMAC0_STAT_BF_WID ( 1)
#define MEM_FB_INT_HI_AGG_STAT_DMAC0_STAT_BF_MSK (0x00000002)
#define MEM_FB_INT_HI_AGG_STAT_DMAC0_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from DMA1. Please first read
///< the DMAC_INTSTATUSREG in DMA1 to find out which one of 1) common registers
///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
///< CH2_INTSTATUS register to find out what event caused the interrupt.
#define MEM_FB_INT_HI_AGG_STAT_DMAC1_STAT_BF_OFF ( 2)
#define MEM_FB_INT_HI_AGG_STAT_DMAC1_STAT_BF_WID ( 1)
#define MEM_FB_INT_HI_AGG_STAT_DMAC1_STAT_BF_MSK (0x00000004)
#define MEM_FB_INT_HI_AGG_STAT_DMAC1_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from NSIP0. Please read the
///< INT_STATUS register in NSIP0 to find out which event caused the interrupt.
#define MEM_FB_INT_HI_AGG_STAT_NSIP0_STAT_BF_OFF ( 3)
#define MEM_FB_INT_HI_AGG_STAT_NSIP0_STAT_BF_WID ( 1)
#define MEM_FB_INT_HI_AGG_STAT_NSIP0_STAT_BF_MSK (0x00000008)
#define MEM_FB_INT_HI_AGG_STAT_NSIP0_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from NSIP0. Please read the
///< INT_STATUS register in NSIP1 to find out which event caused the interrupt.
#define MEM_FB_INT_HI_AGG_STAT_NSIP1_STAT_BF_OFF ( 4)
#define MEM_FB_INT_HI_AGG_STAT_NSIP1_STAT_BF_WID ( 1)
#define MEM_FB_INT_HI_AGG_STAT_NSIP1_STAT_BF_MSK (0x00000010)
#define MEM_FB_INT_HI_AGG_STAT_NSIP1_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from the Crux interface 0 and
///< 1. Please read the INT_CRUX_STATUS register to find out which event
///< caused the interrupt.
#define MEM_FB_INT_HI_AGG_STAT_CRUX_STAT_BF_OFF ( 5)
#define MEM_FB_INT_HI_AGG_STAT_CRUX_STAT_BF_WID ( 1)
#define MEM_FB_INT_HI_AGG_STAT_CRUX_STAT_BF_MSK (0x00000020)
#define MEM_FB_INT_HI_AGG_STAT_CRUX_STAT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_LO_AGG_STATUS register description at address offset 0x7c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_LO_AGG_STATUS
  * Aggregate low priority interrupt status
  */

typedef union {
  struct {
    uint32_t FB_STATUS : 1;
    ///< This bit is set by interrupts arising from the feedback memory logic.
    ///< Please read the INT_FB_STATUS register to find out what event caused
    ///< the interrupt.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DMAC0_STATUS : 1;
    ///< This bit is set by interrupts arising from DMA0. Please first read
    ///< the DMAC_INTSTATUSREG in DMA0 to find out which one of 1) common registers
    ///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
    ///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
    ///< CH2_INTSTATUS register to find out what event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t DMAC1_STATUS : 1;
    ///< This bit is set by interrupts arising from DMA1. Please first read
    ///< the DMAC_INTSTATUSREG in DMA1 to find out which one of 1) common registers
    ///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
    ///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
    ///< CH2_INTSTATUS register to find out what event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t NSIP0_STATUS : 1;
    ///< This bit is set by interrupts arising from NSIP0. Please read the
    ///< INT_STATUS register in NSIP0 to find out which event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t NSIP1_STATUS : 1;
    ///< This bit is set by interrupts arising from NSIP0. Please read the
    ///< INT_STATUS register in NSIP1 to find out which event caused the interrupt.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_int_lo_agg_stat_reg_t;

#define MEM_FB_INT_LO_AGG_STAT_DEFAULT (0x00000000U)
#define MEM_FB_INT_LO_AGG_STAT_RD_MASK (0x0000001fU)
#define MEM_FB_INT_LO_AGG_STAT_WR_MASK (0x00000000U)


///< This bit is set by interrupts arising from the feedback memory logic.
///< Please read the INT_FB_STATUS register to find out what event caused
///< the interrupt.
#define MEM_FB_INT_LO_AGG_STAT_FB_STAT_BF_OFF ( 0)
#define MEM_FB_INT_LO_AGG_STAT_FB_STAT_BF_WID ( 1)
#define MEM_FB_INT_LO_AGG_STAT_FB_STAT_BF_MSK (0x00000001)
#define MEM_FB_INT_LO_AGG_STAT_FB_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from DMA0. Please first read
///< the DMAC_INTSTATUSREG in DMA0 to find out which one of 1) common registers
///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
///< CH2_INTSTATUS register to find out what event caused the interrupt.
#define MEM_FB_INT_LO_AGG_STAT_DMAC0_STAT_BF_OFF ( 1)
#define MEM_FB_INT_LO_AGG_STAT_DMAC0_STAT_BF_WID ( 1)
#define MEM_FB_INT_LO_AGG_STAT_DMAC0_STAT_BF_MSK (0x00000002)
#define MEM_FB_INT_LO_AGG_STAT_DMAC0_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from DMA1. Please first read
///< the DMAC_INTSTATUSREG in DMA1 to find out which one of 1) common registers
///< 2) channel 0 3) channel 1 caused the interrupt. Then based on the
///< bit(s) set, please read DMAC_COMMONREG_INTSTATUSREG, CH1_INTSTATUS,
///< CH2_INTSTATUS register to find out what event caused the interrupt.
#define MEM_FB_INT_LO_AGG_STAT_DMAC1_STAT_BF_OFF ( 2)
#define MEM_FB_INT_LO_AGG_STAT_DMAC1_STAT_BF_WID ( 1)
#define MEM_FB_INT_LO_AGG_STAT_DMAC1_STAT_BF_MSK (0x00000004)
#define MEM_FB_INT_LO_AGG_STAT_DMAC1_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from NSIP0. Please read the
///< INT_STATUS register in NSIP0 to find out which event caused the interrupt.
#define MEM_FB_INT_LO_AGG_STAT_NSIP0_STAT_BF_OFF ( 3)
#define MEM_FB_INT_LO_AGG_STAT_NSIP0_STAT_BF_WID ( 1)
#define MEM_FB_INT_LO_AGG_STAT_NSIP0_STAT_BF_MSK (0x00000008)
#define MEM_FB_INT_LO_AGG_STAT_NSIP0_STAT_BF_DEF (0x00000000)

///< This bit is set by interrupts arising from NSIP0. Please read the
///< INT_STATUS register in NSIP1 to find out which event caused the interrupt.
#define MEM_FB_INT_LO_AGG_STAT_NSIP1_STAT_BF_OFF ( 4)
#define MEM_FB_INT_LO_AGG_STAT_NSIP1_STAT_BF_WID ( 1)
#define MEM_FB_INT_LO_AGG_STAT_NSIP1_STAT_BF_MSK (0x00000010)
#define MEM_FB_INT_LO_AGG_STAT_NSIP1_STAT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_FB_STATUS register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_FB_STATUS
  * Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t DMA0_SM_TIMER_EXP_NO_ACK_ST : 1;
    ///< DMA0 state machine timer expiry with no ack. This bit indicates that
    ///< DMAC0 timer expired before receiving any acknowledge from the DMAC
    ///< hardware.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_ACK_ST : 1;
    ///< DMA1 state machine timer expiry with no ack. This bit indicates that
    ///< DMAC1 timer expired before receiving any acknowledge from the DMAC
    ///< hardware.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t DMA0_ACK_NOT_REC_ST : 1;
    ///< DMA0 ack not received when req driven low. This bit indicates that
    ///< when the hardware drives request low, the DMAC never acknowledges
    ///< by driving the acknowledge signal low.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t DMA1_ACK_NOT_REC_ST : 1;
    ///< DMA1 ack not received when req driven low. This bit indicates that
    ///< when the hardware drives request low, the DMAC never acknowledges
    ///< by driving the acknowledge signal low.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t DMA0_SM_TIMER_EXP_NO_FIN_ST : 1;
    ///< DMA0 state machine timer expiry with no finish. This bit indicates
    ///< that DMAC0 timer expired before the finish signal being asserted from
    ///< the DMAC hardware.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_FIN_ST : 1;
    ///< DMA1 state machine timer expiry with no ack. This bit indicates that
    ///< DMAC1 timer expired before the finish signal being asserted from the
    ///< DMAC hardware.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DMA0_DST_NO_FIN : 1;
    ///< DMA0 destination interface did not issue a finish.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t DMA1_DST_NO_FIN : 1;
    ///< DMA1 destination interface did not issue a finish.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t BFN0_SM_DMA_NOT_IN_ENB_ST : 1;
    ///< BFN0 state machine cannot move to the triggered state. This bit indicates
    ///< that the BFN state machine cannot move to the triggered state as the
    ///< DMA state machine has not finished its operation.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t BFN1_SM_DMA_NOT_IN_ENB_ST : 1;
    ///< BFN1 state machine cannot move to the triggered state. This bit indicates
    ///< that the BFN state machine cannot move to the triggered state as the
    ///< DMA state machine has not finished its operation.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t CM0_FIFO_FULL : 1;
    ///< This bit is asserted when the FIFO associated with the host to bridge
    ///< direction in Common module0 became full.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t CM1_FIFO_FULL : 1;
    ///< This bit is asserted when the FIFO associated with the host to bridge
    ///< direction in Common module1 became full.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t ARB_INT_MULT_READS : 1;
    ///< This bit is asserted when reads happen simultaneously from different
    ///< ports to the same sector.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t ARB_INT_MULT_WRITES : 1;
    ///< This bit is asserted when writes happen simultaneously from different
    ///< ports to the same sector.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint32_t ARB_INT_READ_AND_WRITE : 1;
    ///< This bit is asserted when reads and writes happen simultaneously from
    ///< the same port to the same sector.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t PHM_DB_OFLOW : 1;
    ///< This bit is asserted when any one of the FIFOs inside the alarm module
    ///< overflows.
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint32_t ANT_INTF_ERROR : 1;
    ///< This bit is asserted when there is an error on the received sample
    ///< count on any one of the antenna interface ports. Please read the register
    ///< ANT_INTF_STATUS to identify which antenna port and the antenna ID
    ///< which caused the error. Note that the register has to be read first
    ///< before clearing this interrupt bit.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA0 : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected for accesses from DMA0. Please read
    ///< the register AXI_ECC_ERR_STAT[0] to identify what event caused the
    ///< error.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA1 : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected for accesses from DMA1. Please read
    ///< the register AXI_ECC_ERR_STAT[1] to identify what event caused the
    ///< error.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_ORION : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected on accesses from the Orion. Please
    ///< read the register AXI_ECC_ERR_STAT[2] to identify what event caused
    ///< the error.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM0 : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected on accesses to MEM0 of the descriptor
    ///< memory. Please read the register DESC_ECC_ERR_STAT[0] to identify
    ///< what event caused the error.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM1 : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected on accesses to MEM1 of the descriptor
    ///< memory. Please read the register DESC_ECC_ERR_STAT[1] to identify
    ///< what event caused the error.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint32_t DMA0_CH0_ECC_ERROR : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected on CH0 of the FIFO memory inside DMA0.
    ///< Please read the register DMA0_ECC_ERR_STAT[0] to identify what event
    ///< caused the error.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint32_t DMA0_CH1_ECC_ERROR : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected on CH1 of the FIFO memory inside DMA0.
    ///< Please read the register DMA0_ECC_ERR_STAT[1] to identify what event
    ///< caused the error.
    ///< AccessType="RO/V" BitOffset="23" ResetValue="0x0"
    uint32_t DMA1_CH0_ECC_ERROR : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected on CH0 of the FIFO memory inside DMA1.
    ///< Please read the register DMA1_ECC_ERR_STAT[0] to identify what event
    ///< caused the error.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t DMA1_CH1_ECC_ERROR : 1;
    ///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
    ///< ERR error overflow is detected on CH1 of the FIFO memory inside DMA1.
    ///< Please read the register DMA1_ECC_ERR_STAT[1] to identify what event
    ///< caused the error.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_int_fb_stat_reg_t;

#define MEM_FB_INT_FB_STAT_DEFAULT (0x00000000U)
#define MEM_FB_INT_FB_STAT_RD_MASK (0x03ffffffU)
#define MEM_FB_INT_FB_STAT_WR_MASK (0x00000000U)


///< DMA0 state machine timer expiry with no ack. This bit indicates that
///< DMAC0 timer expired before receiving any acknowledge from the DMAC
///< hardware.
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_ACK_ST_BF_OFF ( 0)
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_ACK_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_ACK_ST_BF_MSK (0x00000001)
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_ACK_ST_BF_DEF (0x00000000)

///< DMA1 state machine timer expiry with no ack. This bit indicates that
///< DMAC1 timer expired before receiving any acknowledge from the DMAC
///< hardware.
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_ACK_ST_BF_OFF ( 1)
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_ACK_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_ACK_ST_BF_MSK (0x00000002)
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_ACK_ST_BF_DEF (0x00000000)

///< DMA0 ack not received when req driven low. This bit indicates that
///< when the hardware drives request low, the DMAC never acknowledges
///< by driving the acknowledge signal low.
#define MEM_FB_INT_FB_STAT_DMA0_ACK_NOT_REC_ST_BF_OFF ( 2)
#define MEM_FB_INT_FB_STAT_DMA0_ACK_NOT_REC_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA0_ACK_NOT_REC_ST_BF_MSK (0x00000004)
#define MEM_FB_INT_FB_STAT_DMA0_ACK_NOT_REC_ST_BF_DEF (0x00000000)

///< DMA1 ack not received when req driven low. This bit indicates that
///< when the hardware drives request low, the DMAC never acknowledges
///< by driving the acknowledge signal low.
#define MEM_FB_INT_FB_STAT_DMA1_ACK_NOT_REC_ST_BF_OFF ( 3)
#define MEM_FB_INT_FB_STAT_DMA1_ACK_NOT_REC_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA1_ACK_NOT_REC_ST_BF_MSK (0x00000008)
#define MEM_FB_INT_FB_STAT_DMA1_ACK_NOT_REC_ST_BF_DEF (0x00000000)

///< DMA0 state machine timer expiry with no finish. This bit indicates
///< that DMAC0 timer expired before the finish signal being asserted from
///< the DMAC hardware.
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_FIN_ST_BF_OFF ( 4)
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_FIN_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_FIN_ST_BF_MSK (0x00000010)
#define MEM_FB_INT_FB_STAT_DMA0_SM_TIMER_EXP_NO_FIN_ST_BF_DEF (0x00000000)

///< DMA1 state machine timer expiry with no ack. This bit indicates that
///< DMAC1 timer expired before the finish signal being asserted from the
///< DMAC hardware.
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_FIN_ST_BF_OFF ( 5)
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_FIN_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_FIN_ST_BF_MSK (0x00000020)
#define MEM_FB_INT_FB_STAT_DMA1_SM_TIMER_EXP_NO_FIN_ST_BF_DEF (0x00000000)

///< DMA0 destination interface did not issue a finish.
#define MEM_FB_INT_FB_STAT_DMA0_DST_NO_FIN_BF_OFF ( 6)
#define MEM_FB_INT_FB_STAT_DMA0_DST_NO_FIN_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA0_DST_NO_FIN_BF_MSK (0x00000040)
#define MEM_FB_INT_FB_STAT_DMA0_DST_NO_FIN_BF_DEF (0x00000000)

///< DMA1 destination interface did not issue a finish.
#define MEM_FB_INT_FB_STAT_DMA1_DST_NO_FIN_BF_OFF ( 7)
#define MEM_FB_INT_FB_STAT_DMA1_DST_NO_FIN_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA1_DST_NO_FIN_BF_MSK (0x00000080)
#define MEM_FB_INT_FB_STAT_DMA1_DST_NO_FIN_BF_DEF (0x00000000)

///< BFN0 state machine cannot move to the triggered state. This bit indicates
///< that the BFN state machine cannot move to the triggered state as the
///< DMA state machine has not finished its operation.
#define MEM_FB_INT_FB_STAT_BFN0_SM_DMA_NOT_IN_ENB_ST_BF_OFF ( 8)
#define MEM_FB_INT_FB_STAT_BFN0_SM_DMA_NOT_IN_ENB_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_BFN0_SM_DMA_NOT_IN_ENB_ST_BF_MSK (0x00000100)
#define MEM_FB_INT_FB_STAT_BFN0_SM_DMA_NOT_IN_ENB_ST_BF_DEF (0x00000000)

///< BFN1 state machine cannot move to the triggered state. This bit indicates
///< that the BFN state machine cannot move to the triggered state as the
///< DMA state machine has not finished its operation.
#define MEM_FB_INT_FB_STAT_BFN1_SM_DMA_NOT_IN_ENB_ST_BF_OFF ( 9)
#define MEM_FB_INT_FB_STAT_BFN1_SM_DMA_NOT_IN_ENB_ST_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_BFN1_SM_DMA_NOT_IN_ENB_ST_BF_MSK (0x00000200)
#define MEM_FB_INT_FB_STAT_BFN1_SM_DMA_NOT_IN_ENB_ST_BF_DEF (0x00000000)

///< This bit is asserted when the FIFO associated with the host to bridge
///< direction in Common module0 became full.
#define MEM_FB_INT_FB_STAT_CM0_FIFO_FULL_BF_OFF (10)
#define MEM_FB_INT_FB_STAT_CM0_FIFO_FULL_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_CM0_FIFO_FULL_BF_MSK (0x00000400)
#define MEM_FB_INT_FB_STAT_CM0_FIFO_FULL_BF_DEF (0x00000000)

///< This bit is asserted when the FIFO associated with the host to bridge
///< direction in Common module1 became full.
#define MEM_FB_INT_FB_STAT_CM1_FIFO_FULL_BF_OFF (11)
#define MEM_FB_INT_FB_STAT_CM1_FIFO_FULL_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_CM1_FIFO_FULL_BF_MSK (0x00000800)
#define MEM_FB_INT_FB_STAT_CM1_FIFO_FULL_BF_DEF (0x00000000)

///< This bit is asserted when reads happen simultaneously from different
///< ports to the same sector.
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_READS_BF_OFF (12)
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_READS_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_READS_BF_MSK (0x00001000)
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_READS_BF_DEF (0x00000000)

///< This bit is asserted when writes happen simultaneously from different
///< ports to the same sector.
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_WRITES_BF_OFF (13)
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_WRITES_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_WRITES_BF_MSK (0x00002000)
#define MEM_FB_INT_FB_STAT_ARB_INT_MULT_WRITES_BF_DEF (0x00000000)

///< This bit is asserted when reads and writes happen simultaneously from
///< the same port to the same sector.
#define MEM_FB_INT_FB_STAT_ARB_INT_READ_AND_WRITE_BF_OFF (14)
#define MEM_FB_INT_FB_STAT_ARB_INT_READ_AND_WRITE_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_ARB_INT_READ_AND_WRITE_BF_MSK (0x00004000)
#define MEM_FB_INT_FB_STAT_ARB_INT_READ_AND_WRITE_BF_DEF (0x00000000)

///< This bit is asserted when any one of the FIFOs inside the alarm module
///< overflows.
#define MEM_FB_INT_FB_STAT_PHM_DB_OFLOW_BF_OFF (15)
#define MEM_FB_INT_FB_STAT_PHM_DB_OFLOW_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_PHM_DB_OFLOW_BF_MSK (0x00008000)
#define MEM_FB_INT_FB_STAT_PHM_DB_OFLOW_BF_DEF (0x00000000)

///< This bit is asserted when there is an error on the received sample
///< count on any one of the antenna interface ports. Please read the register
///< ANT_INTF_STATUS to identify which antenna port and the antenna ID
///< which caused the error. Note that the register has to be read first
///< before clearing this interrupt bit.
#define MEM_FB_INT_FB_STAT_ANT_INTF_ERR_BF_OFF (16)
#define MEM_FB_INT_FB_STAT_ANT_INTF_ERR_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_ANT_INTF_ERR_BF_MSK (0x00010000)
#define MEM_FB_INT_FB_STAT_ANT_INTF_ERR_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected for accesses from DMA0. Please read
///< the register AXI_ECC_ERR_STAT[0] to identify what event caused the
///< error.
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA0_BF_OFF (17)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA0_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA0_BF_MSK (0x00020000)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA0_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected for accesses from DMA1. Please read
///< the register AXI_ECC_ERR_STAT[1] to identify what event caused the
///< error.
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA1_BF_OFF (18)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA1_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA1_BF_MSK (0x00040000)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_DMA1_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected on accesses from the Orion. Please
///< read the register AXI_ECC_ERR_STAT[2] to identify what event caused
///< the error.
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_ORION_BF_OFF (19)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_ORION_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_ORION_BF_MSK (0x00080000)
#define MEM_FB_INT_FB_STAT_AXI2ED_ECC_ERR_ORION_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected on accesses to MEM0 of the descriptor
///< memory. Please read the register DESC_ECC_ERR_STAT[0] to identify
///< what event caused the error.
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM0_BF_OFF (20)
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM0_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM0_BF_MSK (0x00100000)
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM0_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected on accesses to MEM1 of the descriptor
///< memory. Please read the register DESC_ECC_ERR_STAT[1] to identify
///< what event caused the error.
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM1_BF_OFF (21)
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM1_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM1_BF_MSK (0x00200000)
#define MEM_FB_INT_FB_STAT_DESC_ECC_ERR_MEM1_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected on CH0 of the FIFO memory inside DMA0.
///< Please read the register DMA0_ECC_ERR_STAT[0] to identify what event
///< caused the error.
#define MEM_FB_INT_FB_STAT_DMA0_CH0_ECC_ERR_BF_OFF (22)
#define MEM_FB_INT_FB_STAT_DMA0_CH0_ECC_ERR_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA0_CH0_ECC_ERR_BF_MSK (0x00400000)
#define MEM_FB_INT_FB_STAT_DMA0_CH0_ECC_ERR_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected on CH1 of the FIFO memory inside DMA0.
///< Please read the register DMA0_ECC_ERR_STAT[1] to identify what event
///< caused the error.
#define MEM_FB_INT_FB_STAT_DMA0_CH1_ECC_ERR_BF_OFF (23)
#define MEM_FB_INT_FB_STAT_DMA0_CH1_ECC_ERR_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA0_CH1_ECC_ERR_BF_MSK (0x00800000)
#define MEM_FB_INT_FB_STAT_DMA0_CH1_ECC_ERR_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected on CH0 of the FIFO memory inside DMA1.
///< Please read the register DMA1_ECC_ERR_STAT[0] to identify what event
///< caused the error.
#define MEM_FB_INT_FB_STAT_DMA1_CH0_ECC_ERR_BF_OFF (24)
#define MEM_FB_INT_FB_STAT_DMA1_CH0_ECC_ERR_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA1_CH0_ECC_ERR_BF_MSK (0x01000000)
#define MEM_FB_INT_FB_STAT_DMA1_CH0_ECC_ERR_BF_DEF (0x00000000)

///< This bit is asserted when a ECC error (single/multi-bit) or a single-bit
///< ERR error overflow is detected on CH1 of the FIFO memory inside DMA1.
///< Please read the register DMA1_ECC_ERR_STAT[1] to identify what event
///< caused the error.
#define MEM_FB_INT_FB_STAT_DMA1_CH1_ECC_ERR_BF_OFF (25)
#define MEM_FB_INT_FB_STAT_DMA1_CH1_ECC_ERR_BF_WID ( 1)
#define MEM_FB_INT_FB_STAT_DMA1_CH1_ECC_ERR_BF_MSK (0x02000000)
#define MEM_FB_INT_FB_STAT_DMA1_CH1_ECC_ERR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_FB_HIGH_EN register description at address offset 0x84
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_FB_HIGH_EN
  * High Priority Interrupt Enable Register
  */

typedef union {
  struct {
    uint32_t DMA0_SM_TIMER_EXP_NO_ACK_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA0_SM_TIMER_EXP_NO_ACK. This
    ///< bit enables a high priority interrupt for the DMA0_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_ACK_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA1_SM_TIMER_EXP_NO_ACK. This
    ///< bit enables a high priority interrupt for the DMA1_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DMA0_ACK_NOT_REC_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA0_ACK_NOT_REC. This bit enables
    ///< a high priority interrupt for the DMA0_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DMA1_ACK_NOT_REC_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA1_ACK_NOT_REC. This bit enables
    ///< a high priority interrupt for the DMA1_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DMA0_SM_TIMER_EXP_NO_FIN_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA0_SM_TIMER_EXP_NO_FIN. This
    ///< bit enables a high priority interrupt for the DMA0_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_FIN_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA1_SM_TIMER_EXP_NO_FIN. This
    ///< bit enables a high priority interrupt for the DMA1_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DMA0_DST_NO_FIN_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA0 destination interface did
    ///< not issue a finish.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t DMA1_DST_NO_FIN_HIGH_EN : 1;
    ///< High priority interrupt enable for DMA1 destination interface did
    ///< not issue a finish.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BFN0_SM_DMA_NOT_IN_ENB_HIGH_EN : 1;
    ///< High priority interrupt enable for BFN0_SM_DMA_NOT_IN_ENB. This bit
    ///< enables a high priority interrupt for the BFN0_SM_DMA_NOT_IN_ENB field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t BFN1_SM_DMA_NOT_IN_ENB_HIGH_EN : 1;
    ///< High priority interrupt enable for BFN1_SM_DMA_NOT_IN_ENB. This bit
    ///< enables a high priority interrupt for the BFN1_SM_DMA_NOT_IN_ENB field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CM0_FIFO_FULL_HIGH_EN : 1;
    ///< High priority interrupt enable for CM0 FIFO becoming full.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CM1_FIFO_FULL_HIGH_EN : 1;
    ///< High priority interrupt enable for CM1 FIFO becoming full.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t ARB_INT_MULT_READS_HIGH_EN : 1;
    ///< High priority interrupt enable for reads happening to the same sector
    ///< from multiple ports.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t ARB_INT_MULT_WRITES_HIGH_EN : 1;
    ///< High priority interrupt enable for writes happening to the same sector
    ///< from multiple ports.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t ARB_INT_READ_AND_WRITE_HIGH_EN : 1;
    ///< High priority interrupt enable for read and write happening to the
    ///< same sector from the same port.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t PHM_DB_OFLOW_HIGH_EN : 1;
    ///< High priority interrupt enable for the alarm FIFO overflow.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ANT_INTF_ERROR_HIGH_EN : 1;
    ///< High priority interrupt enable for the antenna interface error.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA0_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA1_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_ORION_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM0_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM1_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t DMA0_CH0_ECC_ERROR_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DMA0_CH1_ECC_ERROR_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t DMA1_CH0_ECC_ERROR_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t DMA1_CH1_ECC_ERROR_HIGH_EN : 1;
    ///< High priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_int_fb_high_en_reg_t;

#define MEM_FB_INT_FB_HIGH_EN_DEFAULT (0x00000000U)
#define MEM_FB_INT_FB_HIGH_EN_RD_MASK (0x03ffffffU)
#define MEM_FB_INT_FB_HIGH_EN_WR_MASK (0x03ffffffU)


///< High priority interrupt enable for DMA0_SM_TIMER_EXP_NO_ACK. This
///< bit enables a high priority interrupt for the DMA0_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_OFF ( 0)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_MSK (0x00000001)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for DMA1_SM_TIMER_EXP_NO_ACK. This
///< bit enables a high priority interrupt for the DMA1_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_OFF ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_MSK (0x00000002)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_ACK_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for DMA0_ACK_NOT_REC. This bit enables
///< a high priority interrupt for the DMA0_ACK_NOT_REC field.
#define MEM_FB_INT_FB_HIGH_EN_DMA0_ACK_NOT_REC_HIGH_EN_BF_OFF ( 2)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_ACK_NOT_REC_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_ACK_NOT_REC_HIGH_EN_BF_MSK (0x00000004)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_ACK_NOT_REC_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for DMA1_ACK_NOT_REC. This bit enables
///< a high priority interrupt for the DMA1_ACK_NOT_REC field.
#define MEM_FB_INT_FB_HIGH_EN_DMA1_ACK_NOT_REC_HIGH_EN_BF_OFF ( 3)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_ACK_NOT_REC_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_ACK_NOT_REC_HIGH_EN_BF_MSK (0x00000008)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_ACK_NOT_REC_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for DMA0_SM_TIMER_EXP_NO_FIN. This
///< bit enables a high priority interrupt for the DMA0_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_OFF ( 4)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_MSK (0x00000010)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for DMA1_SM_TIMER_EXP_NO_FIN. This
///< bit enables a high priority interrupt for the DMA1_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_OFF ( 5)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_MSK (0x00000020)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_SM_TIMER_EXP_NO_FIN_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for DMA0 destination interface did
///< not issue a finish.
#define MEM_FB_INT_FB_HIGH_EN_DMA0_DST_NO_FIN_HIGH_EN_BF_OFF ( 6)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_DST_NO_FIN_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_DST_NO_FIN_HIGH_EN_BF_MSK (0x00000040)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_DST_NO_FIN_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for DMA1 destination interface did
///< not issue a finish.
#define MEM_FB_INT_FB_HIGH_EN_DMA1_DST_NO_FIN_HIGH_EN_BF_OFF ( 7)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_DST_NO_FIN_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_DST_NO_FIN_HIGH_EN_BF_MSK (0x00000080)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_DST_NO_FIN_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for BFN0_SM_DMA_NOT_IN_ENB. This bit
///< enables a high priority interrupt for the BFN0_SM_DMA_NOT_IN_ENB field.
#define MEM_FB_INT_FB_HIGH_EN_BFN0_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_OFF ( 8)
#define MEM_FB_INT_FB_HIGH_EN_BFN0_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_BFN0_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_MSK (0x00000100)
#define MEM_FB_INT_FB_HIGH_EN_BFN0_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for BFN1_SM_DMA_NOT_IN_ENB. This bit
///< enables a high priority interrupt for the BFN1_SM_DMA_NOT_IN_ENB field.
#define MEM_FB_INT_FB_HIGH_EN_BFN1_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_OFF ( 9)
#define MEM_FB_INT_FB_HIGH_EN_BFN1_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_BFN1_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_MSK (0x00000200)
#define MEM_FB_INT_FB_HIGH_EN_BFN1_SM_DMA_NOT_IN_ENB_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for CM0 FIFO becoming full.
#define MEM_FB_INT_FB_HIGH_EN_CM0_FIFO_FULL_HIGH_EN_BF_OFF (10)
#define MEM_FB_INT_FB_HIGH_EN_CM0_FIFO_FULL_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_CM0_FIFO_FULL_HIGH_EN_BF_MSK (0x00000400)
#define MEM_FB_INT_FB_HIGH_EN_CM0_FIFO_FULL_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for CM1 FIFO becoming full.
#define MEM_FB_INT_FB_HIGH_EN_CM1_FIFO_FULL_HIGH_EN_BF_OFF (11)
#define MEM_FB_INT_FB_HIGH_EN_CM1_FIFO_FULL_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_CM1_FIFO_FULL_HIGH_EN_BF_MSK (0x00000800)
#define MEM_FB_INT_FB_HIGH_EN_CM1_FIFO_FULL_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for reads happening to the same sector
///< from multiple ports.
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_READS_HIGH_EN_BF_OFF (12)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_READS_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_READS_HIGH_EN_BF_MSK (0x00001000)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_READS_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for writes happening to the same sector
///< from multiple ports.
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_WRITES_HIGH_EN_BF_OFF (13)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_WRITES_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_WRITES_HIGH_EN_BF_MSK (0x00002000)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_MULT_WRITES_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for read and write happening to the
///< same sector from the same port.
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_READ_AND_WRITE_HIGH_EN_BF_OFF (14)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_READ_AND_WRITE_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_READ_AND_WRITE_HIGH_EN_BF_MSK (0x00004000)
#define MEM_FB_INT_FB_HIGH_EN_ARB_INT_READ_AND_WRITE_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for the alarm FIFO overflow.
#define MEM_FB_INT_FB_HIGH_EN_PHM_DB_OFLOW_HIGH_EN_BF_OFF (15)
#define MEM_FB_INT_FB_HIGH_EN_PHM_DB_OFLOW_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_PHM_DB_OFLOW_HIGH_EN_BF_MSK (0x00008000)
#define MEM_FB_INT_FB_HIGH_EN_PHM_DB_OFLOW_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for the antenna interface error.
#define MEM_FB_INT_FB_HIGH_EN_ANT_INTF_ERR_HIGH_EN_BF_OFF (16)
#define MEM_FB_INT_FB_HIGH_EN_ANT_INTF_ERR_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_ANT_INTF_ERR_HIGH_EN_BF_MSK (0x00010000)
#define MEM_FB_INT_FB_HIGH_EN_ANT_INTF_ERR_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA0_HIGH_EN_BF_OFF (17)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA0_HIGH_EN_BF_MSK (0x00020000)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA0_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA1_HIGH_EN_BF_OFF (18)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA1_HIGH_EN_BF_MSK (0x00040000)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_DMA1_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_ORION_HIGH_EN_BF_OFF (19)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_ORION_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_ORION_HIGH_EN_BF_MSK (0x00080000)
#define MEM_FB_INT_FB_HIGH_EN_AXI2ED_ECC_ERR_ORION_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM0_HIGH_EN_BF_OFF (20)
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM0_HIGH_EN_BF_MSK (0x00100000)
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM0_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM1_HIGH_EN_BF_OFF (21)
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM1_HIGH_EN_BF_MSK (0x00200000)
#define MEM_FB_INT_FB_HIGH_EN_DESC_ECC_ERR_MEM1_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH0_ECC_ERR_HIGH_EN_BF_OFF (22)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH0_ECC_ERR_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH0_ECC_ERR_HIGH_EN_BF_MSK (0x00400000)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH0_ECC_ERR_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH1_ECC_ERR_HIGH_EN_BF_OFF (23)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH1_ECC_ERR_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH1_ECC_ERR_HIGH_EN_BF_MSK (0x00800000)
#define MEM_FB_INT_FB_HIGH_EN_DMA0_CH1_ECC_ERR_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH0_ECC_ERR_HIGH_EN_BF_OFF (24)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH0_ECC_ERR_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH0_ECC_ERR_HIGH_EN_BF_MSK (0x01000000)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH0_ECC_ERR_HIGH_EN_BF_DEF (0x00000000)

///< High priority interrupt enable for this field.
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH1_ECC_ERR_HIGH_EN_BF_OFF (25)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH1_ECC_ERR_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH1_ECC_ERR_HIGH_EN_BF_MSK (0x02000000)
#define MEM_FB_INT_FB_HIGH_EN_DMA1_CH1_ECC_ERR_HIGH_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_FB_LOW_EN register description at address offset 0x88
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_FB_LOW_EN
  * Low Priority Interrupt Enable Register
  */

typedef union {
  struct {
    uint32_t DMA0_SM_TIMER_EXP_NO_ACK_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA0_SM_TIMER_EXP_NO_ACK. This bit
    ///< enables a low priority interrupt for the DMA0_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_ACK_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA1_SM_TIMER_EXP_NO_ACK. This bit
    ///< enables a low priority interrupt for the DMA1_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DMA0_ACK_NOT_REC_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA0_ACK_NOT_REC. This bit enables
    ///< a low priority interrupt for the DMA0_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DMA1_ACK_NOT_REC_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA1_ACK_NOT_REC. This bit enables
    ///< a low priority interrupt for the DMA1_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DMA0_SM_TIMER_EXP_NO_FIN_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA0_SM_TIMER_EXP_NO_FIN. This bit
    ///< enables a low priority interrupt for the DMA0_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_FIN_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA1_SM_TIMER_EXP_NO_FIN. This bit
    ///< enables a low priority interrupt for the DMA1_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DMA0_DST_NO_FIN_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA0 destination interface did not
    ///< issue a finish.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t DMA1_DST_NO_FIN_LOW_EN : 1;
    ///< Low priority interrupt enable for DMA1 destination interface did not
    ///< issue a finish.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BFN0_SM_DMA_NOT_IN_ENB_LOW_EN : 1;
    ///< Low priority interrupt enable for BFN0_SM_DMA_NOT_IN_ENB. This bit
    ///< enables a low priority interrupt for the BFN0_SM_DMA_NOT_IN_ENB field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t BFN1_SM_DMA_NOT_IN_ENB_LOW_EN : 1;
    ///< Low priority interrupt enable for BFN1_SM_DMA_NOT_IN_ENB. This bit
    ///< enables a low priority interrupt for the BFN1_SM_DMA_NOT_IN_ENB field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CM0_FIFO_FULL_LOW_EN : 1;
    ///< Low priority interrupt enable for CM0 FIFO becoming full.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CM1_FIFO_FULL_LOW_EN : 1;
    ///< Low priority interrupt enable for CM1 FIFO becoming full.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t ARB_INT_MULT_READS_LOW_EN : 1;
    ///< Low priority interrupt enable for reads happening to the same sector
    ///< from multiple ports.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t ARB_INT_MULT_WRITES_LOW_EN : 1;
    ///< Low priority interrupt enable for writes happening to the same sector
    ///< from multiple ports.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t ARB_INT_READ_AND_WRITE_LOW_EN : 1;
    ///< Low priority interrupt enable for read and write happening to the
    ///< same sector from the same port.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t PHM_DB_OFLOW_LOW_EN : 1;
    ///< Low priority interrupt enable for the alarm FIFO overflow.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ANT_INTF_ERROR_LOW_EN : 1;
    ///< Low priority interrupt enable for the antenna interface error.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA0_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA1_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_ORION_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM0_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM1_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t DMA0_CH0_ECC_ERROR_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DMA0_CH1_ECC_ERROR_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t DMA1_CH0_ECC_ERROR_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t DMA1_CH1_ECC_ERROR_LOW_EN : 1;
    ///< Low priority interrupt enable for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_int_fb_low_en_reg_t;

#define MEM_FB_INT_FB_LOW_EN_DEFAULT (0x00000000U)
#define MEM_FB_INT_FB_LOW_EN_RD_MASK (0x03ffffffU)
#define MEM_FB_INT_FB_LOW_EN_WR_MASK (0x03ffffffU)


///< Low priority interrupt enable for DMA0_SM_TIMER_EXP_NO_ACK. This bit
///< enables a low priority interrupt for the DMA0_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_OFF ( 0)
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_MSK (0x00000001)
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for DMA1_SM_TIMER_EXP_NO_ACK. This bit
///< enables a low priority interrupt for the DMA1_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_OFF ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_MSK (0x00000002)
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_ACK_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for DMA0_ACK_NOT_REC. This bit enables
///< a low priority interrupt for the DMA0_ACK_NOT_REC field.
#define MEM_FB_INT_FB_LOW_EN_DMA0_ACK_NOT_REC_LOW_EN_BF_OFF ( 2)
#define MEM_FB_INT_FB_LOW_EN_DMA0_ACK_NOT_REC_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA0_ACK_NOT_REC_LOW_EN_BF_MSK (0x00000004)
#define MEM_FB_INT_FB_LOW_EN_DMA0_ACK_NOT_REC_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for DMA1_ACK_NOT_REC. This bit enables
///< a low priority interrupt for the DMA1_ACK_NOT_REC field.
#define MEM_FB_INT_FB_LOW_EN_DMA1_ACK_NOT_REC_LOW_EN_BF_OFF ( 3)
#define MEM_FB_INT_FB_LOW_EN_DMA1_ACK_NOT_REC_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA1_ACK_NOT_REC_LOW_EN_BF_MSK (0x00000008)
#define MEM_FB_INT_FB_LOW_EN_DMA1_ACK_NOT_REC_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for DMA0_SM_TIMER_EXP_NO_FIN. This bit
///< enables a low priority interrupt for the DMA0_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_OFF ( 4)
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_MSK (0x00000010)
#define MEM_FB_INT_FB_LOW_EN_DMA0_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for DMA1_SM_TIMER_EXP_NO_FIN. This bit
///< enables a low priority interrupt for the DMA1_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_OFF ( 5)
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_MSK (0x00000020)
#define MEM_FB_INT_FB_LOW_EN_DMA1_SM_TIMER_EXP_NO_FIN_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for DMA0 destination interface did not
///< issue a finish.
#define MEM_FB_INT_FB_LOW_EN_DMA0_DST_NO_FIN_LOW_EN_BF_OFF ( 6)
#define MEM_FB_INT_FB_LOW_EN_DMA0_DST_NO_FIN_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA0_DST_NO_FIN_LOW_EN_BF_MSK (0x00000040)
#define MEM_FB_INT_FB_LOW_EN_DMA0_DST_NO_FIN_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for DMA1 destination interface did not
///< issue a finish.
#define MEM_FB_INT_FB_LOW_EN_DMA1_DST_NO_FIN_LOW_EN_BF_OFF ( 7)
#define MEM_FB_INT_FB_LOW_EN_DMA1_DST_NO_FIN_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA1_DST_NO_FIN_LOW_EN_BF_MSK (0x00000080)
#define MEM_FB_INT_FB_LOW_EN_DMA1_DST_NO_FIN_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for BFN0_SM_DMA_NOT_IN_ENB. This bit
///< enables a low priority interrupt for the BFN0_SM_DMA_NOT_IN_ENB field.
#define MEM_FB_INT_FB_LOW_EN_BFN0_SM_DMA_NOT_IN_ENB_LOW_EN_BF_OFF ( 8)
#define MEM_FB_INT_FB_LOW_EN_BFN0_SM_DMA_NOT_IN_ENB_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_BFN0_SM_DMA_NOT_IN_ENB_LOW_EN_BF_MSK (0x00000100)
#define MEM_FB_INT_FB_LOW_EN_BFN0_SM_DMA_NOT_IN_ENB_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for BFN1_SM_DMA_NOT_IN_ENB. This bit
///< enables a low priority interrupt for the BFN1_SM_DMA_NOT_IN_ENB field.
#define MEM_FB_INT_FB_LOW_EN_BFN1_SM_DMA_NOT_IN_ENB_LOW_EN_BF_OFF ( 9)
#define MEM_FB_INT_FB_LOW_EN_BFN1_SM_DMA_NOT_IN_ENB_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_BFN1_SM_DMA_NOT_IN_ENB_LOW_EN_BF_MSK (0x00000200)
#define MEM_FB_INT_FB_LOW_EN_BFN1_SM_DMA_NOT_IN_ENB_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for CM0 FIFO becoming full.
#define MEM_FB_INT_FB_LOW_EN_CM0_FIFO_FULL_LOW_EN_BF_OFF (10)
#define MEM_FB_INT_FB_LOW_EN_CM0_FIFO_FULL_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_CM0_FIFO_FULL_LOW_EN_BF_MSK (0x00000400)
#define MEM_FB_INT_FB_LOW_EN_CM0_FIFO_FULL_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for CM1 FIFO becoming full.
#define MEM_FB_INT_FB_LOW_EN_CM1_FIFO_FULL_LOW_EN_BF_OFF (11)
#define MEM_FB_INT_FB_LOW_EN_CM1_FIFO_FULL_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_CM1_FIFO_FULL_LOW_EN_BF_MSK (0x00000800)
#define MEM_FB_INT_FB_LOW_EN_CM1_FIFO_FULL_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for reads happening to the same sector
///< from multiple ports.
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_READS_LOW_EN_BF_OFF (12)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_READS_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_READS_LOW_EN_BF_MSK (0x00001000)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_READS_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for writes happening to the same sector
///< from multiple ports.
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_WRITES_LOW_EN_BF_OFF (13)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_WRITES_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_WRITES_LOW_EN_BF_MSK (0x00002000)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_MULT_WRITES_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for read and write happening to the
///< same sector from the same port.
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_READ_AND_WRITE_LOW_EN_BF_OFF (14)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_READ_AND_WRITE_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_READ_AND_WRITE_LOW_EN_BF_MSK (0x00004000)
#define MEM_FB_INT_FB_LOW_EN_ARB_INT_READ_AND_WRITE_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for the alarm FIFO overflow.
#define MEM_FB_INT_FB_LOW_EN_PHM_DB_OFLOW_LOW_EN_BF_OFF (15)
#define MEM_FB_INT_FB_LOW_EN_PHM_DB_OFLOW_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_PHM_DB_OFLOW_LOW_EN_BF_MSK (0x00008000)
#define MEM_FB_INT_FB_LOW_EN_PHM_DB_OFLOW_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for the antenna interface error.
#define MEM_FB_INT_FB_LOW_EN_ANT_INTF_ERR_LOW_EN_BF_OFF (16)
#define MEM_FB_INT_FB_LOW_EN_ANT_INTF_ERR_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_ANT_INTF_ERR_LOW_EN_BF_MSK (0x00010000)
#define MEM_FB_INT_FB_LOW_EN_ANT_INTF_ERR_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA0_LOW_EN_BF_OFF (17)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA0_LOW_EN_BF_MSK (0x00020000)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA0_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA1_LOW_EN_BF_OFF (18)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA1_LOW_EN_BF_MSK (0x00040000)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_DMA1_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_ORION_LOW_EN_BF_OFF (19)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_ORION_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_ORION_LOW_EN_BF_MSK (0x00080000)
#define MEM_FB_INT_FB_LOW_EN_AXI2ED_ECC_ERR_ORION_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM0_LOW_EN_BF_OFF (20)
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM0_LOW_EN_BF_MSK (0x00100000)
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM0_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM1_LOW_EN_BF_OFF (21)
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM1_LOW_EN_BF_MSK (0x00200000)
#define MEM_FB_INT_FB_LOW_EN_DESC_ECC_ERR_MEM1_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH0_ECC_ERR_LOW_EN_BF_OFF (22)
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH0_ECC_ERR_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH0_ECC_ERR_LOW_EN_BF_MSK (0x00400000)
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH0_ECC_ERR_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH1_ECC_ERR_LOW_EN_BF_OFF (23)
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH1_ECC_ERR_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH1_ECC_ERR_LOW_EN_BF_MSK (0x00800000)
#define MEM_FB_INT_FB_LOW_EN_DMA0_CH1_ECC_ERR_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH0_ECC_ERR_LOW_EN_BF_OFF (24)
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH0_ECC_ERR_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH0_ECC_ERR_LOW_EN_BF_MSK (0x01000000)
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH0_ECC_ERR_LOW_EN_BF_DEF (0x00000000)

///< Low priority interrupt enable for this field.
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH1_ECC_ERR_LOW_EN_BF_OFF (25)
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH1_ECC_ERR_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH1_ECC_ERR_LOW_EN_BF_MSK (0x02000000)
#define MEM_FB_INT_FB_LOW_EN_DMA1_CH1_ECC_ERR_LOW_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_FB_CLEAR register description at address offset 0x8c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_FB_CLEAR
  * Interrupt Clear Regsiter.
  */

typedef union {
  struct {
    uint32_t DMA0_SM_TIMER_EXP_NO_ACK_CLEAR : 1;
    ///< Clear interrupt for DMA0_SM_TIMER_EXP_NO_ACK. Setting this bit to
    ///< a 1 will clear the interrupt associated with the DMA0_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_ACK_CLEAR : 1;
    ///< Clear interrupt for DMA1_SM_TIMER_EXP_NO_ACK. Setting this bit to
    ///< a 1 will clear the interrupt associated with the DMA1_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DMA0_ACK_NOT_REC_CLEAR : 1;
    ///< Clear interrupt for DMA0_ACK_NOT_REC. Setting this bit to a 1 will
    ///< clear the interrupt associated with the DMA0_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DMA1_ACK_NOT_REC_CLEAR : 1;
    ///< Clear interrupt for DMA1_ACK_NOT_REC. Setting this bit to a 1 will
    ///< clear the interrupt associated with the DMA1_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DMA0_SM_TIMER_EXP_NO_FIN_CLEAR : 1;
    ///< Clear interrupt for DMA0_SM_TIMER_EXP_NO_FIN. Setting this bit to
    ///< a 1 will clear the interrupt associated with the DMA0_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_FIN_CLEAR : 1;
    ///< Clear interrupt for DMA1_SM_TIMER_EXP_NO_FIN. Setting this bit to
    ///< a 1 will clear the interrupt associated with the DMA1_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DMA0_DST_NO_FIN_CLEAR : 1;
    ///< Clear interrupt for DMA0 destination interface did not issue a finish.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t DMA1_DST_NO_FIN_CLEAR : 1;
    ///< Clear interrupt for DMA1 destination interface did not issue a finish.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BFN0_SM_DMA_NOT_IN_ENB_CLEAR : 1;
    ///< Clear interrupt for BFN0_SM_DMA_NOT_IN_ENB. Setting this bit to a
    ///< 1 will clear the interrupt associated with the BFN0_SM_DMA_NOT_IN_ENB
    ///< field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t BFN1_SM_DMA_NOT_IN_ENB_CLEAR : 1;
    ///< Clear interrupt for BFN1_SM_DMA_NOT_IN_ENB. Setting this bit to a
    ///< 1 will clear the interrupt associated with the BFN1_SM_DMA_NOT_IN_ENB
    ///< field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CM0_FIFO_FULL_CLEAR : 1;
    ///< Clear interrupt for CM0 FIFO becoming full.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CM1_FIFO_FULL_CLEAR : 1;
    ///< Clear interrupt for CM1 FIFO becoming full.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t ARB_INT_MULT_READS_CLEAR : 1;
    ///< Clear interrupt for reads happening to the same sector from multiple
    ///< ports.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t ARB_INT_MULT_WRITES_CLEAR : 1;
    ///< Clear interrupt for writes happening to the same sector from multiple
    ///< ports.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t ARB_INT_READ_AND_WRITE_CLEAR : 1;
    ///< Clear interrupt for read and write happening to the same sector from
    ///< the same port.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t PHM_DB_OFLOW_CLEAR : 1;
    ///< Clear interrupt for the alarm FIFO overflow.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ANT_INTF_ERROR_CLEAR : 1;
    ///< Clear interrupt for the antenna interface error.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_ORION_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t DMA0_CH0_ECC_ERROR_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DMA0_CH1_ECC_ERROR_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t DMA1_CH0_ECC_ERROR_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t DMA1_CH1_ECC_ERROR_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_int_fb_clr_reg_t;

#define MEM_FB_INT_FB_CLR_DEFAULT (0x00000000U)
#define MEM_FB_INT_FB_CLR_RD_MASK (0x03ffffffU)
#define MEM_FB_INT_FB_CLR_WR_MASK (0x03ffffffU)


///< Clear interrupt for DMA0_SM_TIMER_EXP_NO_ACK. Setting this bit to
///< a 1 will clear the interrupt associated with the DMA0_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_ACK_CLR_BF_OFF ( 0)
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_ACK_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_ACK_CLR_BF_MSK (0x00000001)
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_ACK_CLR_BF_DEF (0x00000000)

///< Clear interrupt for DMA1_SM_TIMER_EXP_NO_ACK. Setting this bit to
///< a 1 will clear the interrupt associated with the DMA1_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_ACK_CLR_BF_OFF ( 1)
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_ACK_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_ACK_CLR_BF_MSK (0x00000002)
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_ACK_CLR_BF_DEF (0x00000000)

///< Clear interrupt for DMA0_ACK_NOT_REC. Setting this bit to a 1 will
///< clear the interrupt associated with the DMA0_ACK_NOT_REC field.
#define MEM_FB_INT_FB_CLR_DMA0_ACK_NOT_REC_CLR_BF_OFF ( 2)
#define MEM_FB_INT_FB_CLR_DMA0_ACK_NOT_REC_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA0_ACK_NOT_REC_CLR_BF_MSK (0x00000004)
#define MEM_FB_INT_FB_CLR_DMA0_ACK_NOT_REC_CLR_BF_DEF (0x00000000)

///< Clear interrupt for DMA1_ACK_NOT_REC. Setting this bit to a 1 will
///< clear the interrupt associated with the DMA1_ACK_NOT_REC field.
#define MEM_FB_INT_FB_CLR_DMA1_ACK_NOT_REC_CLR_BF_OFF ( 3)
#define MEM_FB_INT_FB_CLR_DMA1_ACK_NOT_REC_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA1_ACK_NOT_REC_CLR_BF_MSK (0x00000008)
#define MEM_FB_INT_FB_CLR_DMA1_ACK_NOT_REC_CLR_BF_DEF (0x00000000)

///< Clear interrupt for DMA0_SM_TIMER_EXP_NO_FIN. Setting this bit to
///< a 1 will clear the interrupt associated with the DMA0_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_FIN_CLR_BF_OFF ( 4)
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_FIN_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_FIN_CLR_BF_MSK (0x00000010)
#define MEM_FB_INT_FB_CLR_DMA0_SM_TIMER_EXP_NO_FIN_CLR_BF_DEF (0x00000000)

///< Clear interrupt for DMA1_SM_TIMER_EXP_NO_FIN. Setting this bit to
///< a 1 will clear the interrupt associated with the DMA1_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_FIN_CLR_BF_OFF ( 5)
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_FIN_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_FIN_CLR_BF_MSK (0x00000020)
#define MEM_FB_INT_FB_CLR_DMA1_SM_TIMER_EXP_NO_FIN_CLR_BF_DEF (0x00000000)

///< Clear interrupt for DMA0 destination interface did not issue a finish.
#define MEM_FB_INT_FB_CLR_DMA0_DST_NO_FIN_CLR_BF_OFF ( 6)
#define MEM_FB_INT_FB_CLR_DMA0_DST_NO_FIN_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA0_DST_NO_FIN_CLR_BF_MSK (0x00000040)
#define MEM_FB_INT_FB_CLR_DMA0_DST_NO_FIN_CLR_BF_DEF (0x00000000)

///< Clear interrupt for DMA1 destination interface did not issue a finish.
#define MEM_FB_INT_FB_CLR_DMA1_DST_NO_FIN_CLR_BF_OFF ( 7)
#define MEM_FB_INT_FB_CLR_DMA1_DST_NO_FIN_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA1_DST_NO_FIN_CLR_BF_MSK (0x00000080)
#define MEM_FB_INT_FB_CLR_DMA1_DST_NO_FIN_CLR_BF_DEF (0x00000000)

///< Clear interrupt for BFN0_SM_DMA_NOT_IN_ENB. Setting this bit to a
///< 1 will clear the interrupt associated with the BFN0_SM_DMA_NOT_IN_ENB
///< field.
#define MEM_FB_INT_FB_CLR_BFN0_SM_DMA_NOT_IN_ENB_CLR_BF_OFF ( 8)
#define MEM_FB_INT_FB_CLR_BFN0_SM_DMA_NOT_IN_ENB_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_BFN0_SM_DMA_NOT_IN_ENB_CLR_BF_MSK (0x00000100)
#define MEM_FB_INT_FB_CLR_BFN0_SM_DMA_NOT_IN_ENB_CLR_BF_DEF (0x00000000)

///< Clear interrupt for BFN1_SM_DMA_NOT_IN_ENB. Setting this bit to a
///< 1 will clear the interrupt associated with the BFN1_SM_DMA_NOT_IN_ENB
///< field.
#define MEM_FB_INT_FB_CLR_BFN1_SM_DMA_NOT_IN_ENB_CLR_BF_OFF ( 9)
#define MEM_FB_INT_FB_CLR_BFN1_SM_DMA_NOT_IN_ENB_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_BFN1_SM_DMA_NOT_IN_ENB_CLR_BF_MSK (0x00000200)
#define MEM_FB_INT_FB_CLR_BFN1_SM_DMA_NOT_IN_ENB_CLR_BF_DEF (0x00000000)

///< Clear interrupt for CM0 FIFO becoming full.
#define MEM_FB_INT_FB_CLR_CM0_FIFO_FULL_CLR_BF_OFF (10)
#define MEM_FB_INT_FB_CLR_CM0_FIFO_FULL_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_CM0_FIFO_FULL_CLR_BF_MSK (0x00000400)
#define MEM_FB_INT_FB_CLR_CM0_FIFO_FULL_CLR_BF_DEF (0x00000000)

///< Clear interrupt for CM1 FIFO becoming full.
#define MEM_FB_INT_FB_CLR_CM1_FIFO_FULL_CLR_BF_OFF (11)
#define MEM_FB_INT_FB_CLR_CM1_FIFO_FULL_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_CM1_FIFO_FULL_CLR_BF_MSK (0x00000800)
#define MEM_FB_INT_FB_CLR_CM1_FIFO_FULL_CLR_BF_DEF (0x00000000)

///< Clear interrupt for reads happening to the same sector from multiple
///< ports.
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_READS_CLR_BF_OFF (12)
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_READS_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_READS_CLR_BF_MSK (0x00001000)
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_READS_CLR_BF_DEF (0x00000000)

///< Clear interrupt for writes happening to the same sector from multiple
///< ports.
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_WRITES_CLR_BF_OFF (13)
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_WRITES_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_WRITES_CLR_BF_MSK (0x00002000)
#define MEM_FB_INT_FB_CLR_ARB_INT_MULT_WRITES_CLR_BF_DEF (0x00000000)

///< Clear interrupt for read and write happening to the same sector from
///< the same port.
#define MEM_FB_INT_FB_CLR_ARB_INT_READ_AND_WRITE_CLR_BF_OFF (14)
#define MEM_FB_INT_FB_CLR_ARB_INT_READ_AND_WRITE_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_ARB_INT_READ_AND_WRITE_CLR_BF_MSK (0x00004000)
#define MEM_FB_INT_FB_CLR_ARB_INT_READ_AND_WRITE_CLR_BF_DEF (0x00000000)

///< Clear interrupt for the alarm FIFO overflow.
#define MEM_FB_INT_FB_CLR_PHM_DB_OFLOW_CLR_BF_OFF (15)
#define MEM_FB_INT_FB_CLR_PHM_DB_OFLOW_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_PHM_DB_OFLOW_CLR_BF_MSK (0x00008000)
#define MEM_FB_INT_FB_CLR_PHM_DB_OFLOW_CLR_BF_DEF (0x00000000)

///< Clear interrupt for the antenna interface error.
#define MEM_FB_INT_FB_CLR_ANT_INTF_ERR_CLR_BF_OFF (16)
#define MEM_FB_INT_FB_CLR_ANT_INTF_ERR_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_ANT_INTF_ERR_CLR_BF_MSK (0x00010000)
#define MEM_FB_INT_FB_CLR_ANT_INTF_ERR_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA0_CLR_BF_OFF (17)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA0_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA0_CLR_BF_MSK (0x00020000)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA1_CLR_BF_OFF (18)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA1_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA1_CLR_BF_MSK (0x00040000)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_DMA1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_ORION_CLR_BF_OFF (19)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_ORION_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_ORION_CLR_BF_MSK (0x00080000)
#define MEM_FB_INT_FB_CLR_AXI2ED_ECC_ERR_ORION_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM0_CLR_BF_OFF (20)
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM0_CLR_BF_MSK (0x00100000)
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM1_CLR_BF_OFF (21)
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM1_CLR_BF_MSK (0x00200000)
#define MEM_FB_INT_FB_CLR_DESC_ECC_ERR_MEM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_DMA0_CH0_ECC_ERR_CLR_BF_OFF (22)
#define MEM_FB_INT_FB_CLR_DMA0_CH0_ECC_ERR_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA0_CH0_ECC_ERR_CLR_BF_MSK (0x00400000)
#define MEM_FB_INT_FB_CLR_DMA0_CH0_ECC_ERR_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_DMA0_CH1_ECC_ERR_CLR_BF_OFF (23)
#define MEM_FB_INT_FB_CLR_DMA0_CH1_ECC_ERR_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA0_CH1_ECC_ERR_CLR_BF_MSK (0x00800000)
#define MEM_FB_INT_FB_CLR_DMA0_CH1_ECC_ERR_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_DMA1_CH0_ECC_ERR_CLR_BF_OFF (24)
#define MEM_FB_INT_FB_CLR_DMA1_CH0_ECC_ERR_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA1_CH0_ECC_ERR_CLR_BF_MSK (0x01000000)
#define MEM_FB_INT_FB_CLR_DMA1_CH0_ECC_ERR_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_FB_CLR_DMA1_CH1_ECC_ERR_CLR_BF_OFF (25)
#define MEM_FB_INT_FB_CLR_DMA1_CH1_ECC_ERR_CLR_BF_WID ( 1)
#define MEM_FB_INT_FB_CLR_DMA1_CH1_ECC_ERR_CLR_BF_MSK (0x02000000)
#define MEM_FB_INT_FB_CLR_DMA1_CH1_ECC_ERR_CLR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_FB_FORCE register description at address offset 0x90
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_FB_FORCE
  * Interrupt Force Regsiter.
  */

typedef union {
  struct {
    uint32_t DMA0_SM_TIMER_EXP_NO_ACK_FORCE : 1;
    ///< Force interrupt for DMA0_SM_TIMER_EXP_NO_ACK. Setting this bit to
    ///< a 1 will force the interrupt associated with the DMA0_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_ACK_FORCE : 1;
    ///< Force interrupt for DMA1_SM_TIMER_EXP_NO_ACK. Setting this bit to
    ///< a 1 will force the interrupt associated with the DMA1_SM_TIMER_EXP_NO_ACK
    ///< field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DMA0_ACK_NOT_REC_FORCE : 1;
    ///< Force interrupt for DMA0_ACK_NOT_REC. Setting this bit to a 1 will
    ///< force the interrupt associated with the DMA0_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DMA1_ACK_NOT_REC_FORCE : 1;
    ///< Force interrupt for DMA1_ACK_NOT_REC. Setting this bit to a 1 will
    ///< force the interrupt associated with the DMA1_ACK_NOT_REC field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DMA0_SM_TIMER_EXP_NO_FIN_FORCE : 1;
    ///< Force interrupt for DMA0_SM_TIMER_EXP_NO_FIN. Setting this bit to
    ///< a 1 will force the interrupt associated with the DMA0_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t DMA1_SM_TIMER_EXP_NO_FIN_FORCE : 1;
    ///< Force interrupt for DMA1_SM_TIMER_EXP_NO_FIN. Setting this bit to
    ///< a 1 will force the interrupt associated with the DMA1_SM_TIMER_EXP_NO_FIN
    ///< field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DMA0_DST_NO_FIN_FORCE : 1;
    ///< Force interrupt for DMA0 destination interface did not issue a finish.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t DMA1_DST_NO_FIN_FORCE : 1;
    ///< Force interrupt for DMA1 destination interface did not issue a finish.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BFN0_SM_DMA_NOT_IN_ENB_FORCE : 1;
    ///< Force interrupt for BFN0_SM_DMA_NOT_IN_ENB. Setting this bit to a
    ///< 1 will force the interrupt associated with the BFN0_SM_DMA_NOT_IN_ENB
    ///< field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t BFN1_SM_DMA_NOT_IN_ENB_FORCE : 1;
    ///< Force interrupt for BFN1_SM_DMA_NOT_IN_ENB. Setting this bit to a
    ///< 1 will force the interrupt associated with the BFN1_SM_DMA_NOT_IN_ENB
    ///< field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CM0_FIFO_FULL_FORCE : 1;
    ///< Force interrupt for CM0 FIFO becoming full.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CM1_FIFO_FULL_FORCE : 1;
    ///< Force interrupt for CM1 FIFO becoming full.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t ARB_INT_MULT_READS_FORCE : 1;
    ///< Force interrupt enable for reads happening to the same sector from
    ///< multiple ports.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t ARB_INT_MULT_WRITES_FORCE : 1;
    ///< Force interrupt enable for writes happening to the same sector from
    ///< multiple ports.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t ARB_INT_READ_AND_WRITE_FORCE : 1;
    ///< Force interrupt enable for read and write happening to the same sector
    ///< from the same port.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t PHM_DB_OFLOW_FORCE : 1;
    ///< Force interrupt for the alarm FIFO overflow.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ANT_INTF_ERROR_FORCE : 1;
    ///< Force interrupt for the antenna interface error.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_DMA1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t AXI2ED_ECC_ERROR_ORION_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t DESC_ECC_ERROR_MEM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t DMA0_CH0_ECC_ERROR_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DMA0_CH1_ECC_ERROR_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t DMA1_CH0_ECC_ERROR_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t DMA1_CH1_ECC_ERROR_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_int_fb_force_reg_t;

#define MEM_FB_INT_FB_FORCE_DEFAULT (0x00000000U)
#define MEM_FB_INT_FB_FORCE_RD_MASK (0x03ffffffU)
#define MEM_FB_INT_FB_FORCE_WR_MASK (0x03ffffffU)


///< Force interrupt for DMA0_SM_TIMER_EXP_NO_ACK. Setting this bit to
///< a 1 will force the interrupt associated with the DMA0_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_ACK_FORCE_BF_OFF ( 0)
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_ACK_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_ACK_FORCE_BF_MSK (0x00000001)
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_ACK_FORCE_BF_DEF (0x00000000)

///< Force interrupt for DMA1_SM_TIMER_EXP_NO_ACK. Setting this bit to
///< a 1 will force the interrupt associated with the DMA1_SM_TIMER_EXP_NO_ACK
///< field.
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_ACK_FORCE_BF_OFF ( 1)
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_ACK_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_ACK_FORCE_BF_MSK (0x00000002)
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_ACK_FORCE_BF_DEF (0x00000000)

///< Force interrupt for DMA0_ACK_NOT_REC. Setting this bit to a 1 will
///< force the interrupt associated with the DMA0_ACK_NOT_REC field.
#define MEM_FB_INT_FB_FORCE_DMA0_ACK_NOT_REC_FORCE_BF_OFF ( 2)
#define MEM_FB_INT_FB_FORCE_DMA0_ACK_NOT_REC_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA0_ACK_NOT_REC_FORCE_BF_MSK (0x00000004)
#define MEM_FB_INT_FB_FORCE_DMA0_ACK_NOT_REC_FORCE_BF_DEF (0x00000000)

///< Force interrupt for DMA1_ACK_NOT_REC. Setting this bit to a 1 will
///< force the interrupt associated with the DMA1_ACK_NOT_REC field.
#define MEM_FB_INT_FB_FORCE_DMA1_ACK_NOT_REC_FORCE_BF_OFF ( 3)
#define MEM_FB_INT_FB_FORCE_DMA1_ACK_NOT_REC_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA1_ACK_NOT_REC_FORCE_BF_MSK (0x00000008)
#define MEM_FB_INT_FB_FORCE_DMA1_ACK_NOT_REC_FORCE_BF_DEF (0x00000000)

///< Force interrupt for DMA0_SM_TIMER_EXP_NO_FIN. Setting this bit to
///< a 1 will force the interrupt associated with the DMA0_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_FIN_FORCE_BF_OFF ( 4)
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_FIN_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_FIN_FORCE_BF_MSK (0x00000010)
#define MEM_FB_INT_FB_FORCE_DMA0_SM_TIMER_EXP_NO_FIN_FORCE_BF_DEF (0x00000000)

///< Force interrupt for DMA1_SM_TIMER_EXP_NO_FIN. Setting this bit to
///< a 1 will force the interrupt associated with the DMA1_SM_TIMER_EXP_NO_FIN
///< field.
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_FIN_FORCE_BF_OFF ( 5)
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_FIN_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_FIN_FORCE_BF_MSK (0x00000020)
#define MEM_FB_INT_FB_FORCE_DMA1_SM_TIMER_EXP_NO_FIN_FORCE_BF_DEF (0x00000000)

///< Force interrupt for DMA0 destination interface did not issue a finish.
#define MEM_FB_INT_FB_FORCE_DMA0_DST_NO_FIN_FORCE_BF_OFF ( 6)
#define MEM_FB_INT_FB_FORCE_DMA0_DST_NO_FIN_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA0_DST_NO_FIN_FORCE_BF_MSK (0x00000040)
#define MEM_FB_INT_FB_FORCE_DMA0_DST_NO_FIN_FORCE_BF_DEF (0x00000000)

///< Force interrupt for DMA1 destination interface did not issue a finish.
#define MEM_FB_INT_FB_FORCE_DMA1_DST_NO_FIN_FORCE_BF_OFF ( 7)
#define MEM_FB_INT_FB_FORCE_DMA1_DST_NO_FIN_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA1_DST_NO_FIN_FORCE_BF_MSK (0x00000080)
#define MEM_FB_INT_FB_FORCE_DMA1_DST_NO_FIN_FORCE_BF_DEF (0x00000000)

///< Force interrupt for BFN0_SM_DMA_NOT_IN_ENB. Setting this bit to a
///< 1 will force the interrupt associated with the BFN0_SM_DMA_NOT_IN_ENB
///< field.
#define MEM_FB_INT_FB_FORCE_BFN0_SM_DMA_NOT_IN_ENB_FORCE_BF_OFF ( 8)
#define MEM_FB_INT_FB_FORCE_BFN0_SM_DMA_NOT_IN_ENB_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_BFN0_SM_DMA_NOT_IN_ENB_FORCE_BF_MSK (0x00000100)
#define MEM_FB_INT_FB_FORCE_BFN0_SM_DMA_NOT_IN_ENB_FORCE_BF_DEF (0x00000000)

///< Force interrupt for BFN1_SM_DMA_NOT_IN_ENB. Setting this bit to a
///< 1 will force the interrupt associated with the BFN1_SM_DMA_NOT_IN_ENB
///< field.
#define MEM_FB_INT_FB_FORCE_BFN1_SM_DMA_NOT_IN_ENB_FORCE_BF_OFF ( 9)
#define MEM_FB_INT_FB_FORCE_BFN1_SM_DMA_NOT_IN_ENB_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_BFN1_SM_DMA_NOT_IN_ENB_FORCE_BF_MSK (0x00000200)
#define MEM_FB_INT_FB_FORCE_BFN1_SM_DMA_NOT_IN_ENB_FORCE_BF_DEF (0x00000000)

///< Force interrupt for CM0 FIFO becoming full.
#define MEM_FB_INT_FB_FORCE_CM0_FIFO_FULL_FORCE_BF_OFF (10)
#define MEM_FB_INT_FB_FORCE_CM0_FIFO_FULL_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_CM0_FIFO_FULL_FORCE_BF_MSK (0x00000400)
#define MEM_FB_INT_FB_FORCE_CM0_FIFO_FULL_FORCE_BF_DEF (0x00000000)

///< Force interrupt for CM1 FIFO becoming full.
#define MEM_FB_INT_FB_FORCE_CM1_FIFO_FULL_FORCE_BF_OFF (11)
#define MEM_FB_INT_FB_FORCE_CM1_FIFO_FULL_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_CM1_FIFO_FULL_FORCE_BF_MSK (0x00000800)
#define MEM_FB_INT_FB_FORCE_CM1_FIFO_FULL_FORCE_BF_DEF (0x00000000)

///< Force interrupt enable for reads happening to the same sector from
///< multiple ports.
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_READS_FORCE_BF_OFF (12)
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_READS_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_READS_FORCE_BF_MSK (0x00001000)
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_READS_FORCE_BF_DEF (0x00000000)

///< Force interrupt enable for writes happening to the same sector from
///< multiple ports.
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_WRITES_FORCE_BF_OFF (13)
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_WRITES_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_WRITES_FORCE_BF_MSK (0x00002000)
#define MEM_FB_INT_FB_FORCE_ARB_INT_MULT_WRITES_FORCE_BF_DEF (0x00000000)

///< Force interrupt enable for read and write happening to the same sector
///< from the same port.
#define MEM_FB_INT_FB_FORCE_ARB_INT_READ_AND_WRITE_FORCE_BF_OFF (14)
#define MEM_FB_INT_FB_FORCE_ARB_INT_READ_AND_WRITE_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_ARB_INT_READ_AND_WRITE_FORCE_BF_MSK (0x00004000)
#define MEM_FB_INT_FB_FORCE_ARB_INT_READ_AND_WRITE_FORCE_BF_DEF (0x00000000)

///< Force interrupt for the alarm FIFO overflow.
#define MEM_FB_INT_FB_FORCE_PHM_DB_OFLOW_FORCE_BF_OFF (15)
#define MEM_FB_INT_FB_FORCE_PHM_DB_OFLOW_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_PHM_DB_OFLOW_FORCE_BF_MSK (0x00008000)
#define MEM_FB_INT_FB_FORCE_PHM_DB_OFLOW_FORCE_BF_DEF (0x00000000)

///< Force interrupt for the antenna interface error.
#define MEM_FB_INT_FB_FORCE_ANT_INTF_ERR_FORCE_BF_OFF (16)
#define MEM_FB_INT_FB_FORCE_ANT_INTF_ERR_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_ANT_INTF_ERR_FORCE_BF_MSK (0x00010000)
#define MEM_FB_INT_FB_FORCE_ANT_INTF_ERR_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA0_FORCE_BF_OFF (17)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA0_FORCE_BF_MSK (0x00020000)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA1_FORCE_BF_OFF (18)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA1_FORCE_BF_MSK (0x00040000)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_DMA1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_ORION_FORCE_BF_OFF (19)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_ORION_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_ORION_FORCE_BF_MSK (0x00080000)
#define MEM_FB_INT_FB_FORCE_AXI2ED_ECC_ERR_ORION_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM0_FORCE_BF_OFF (20)
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM0_FORCE_BF_MSK (0x00100000)
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM1_FORCE_BF_OFF (21)
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM1_FORCE_BF_MSK (0x00200000)
#define MEM_FB_INT_FB_FORCE_DESC_ECC_ERR_MEM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_DMA0_CH0_ECC_ERR_FORCE_BF_OFF (22)
#define MEM_FB_INT_FB_FORCE_DMA0_CH0_ECC_ERR_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA0_CH0_ECC_ERR_FORCE_BF_MSK (0x00400000)
#define MEM_FB_INT_FB_FORCE_DMA0_CH0_ECC_ERR_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_DMA0_CH1_ECC_ERR_FORCE_BF_OFF (23)
#define MEM_FB_INT_FB_FORCE_DMA0_CH1_ECC_ERR_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA0_CH1_ECC_ERR_FORCE_BF_MSK (0x00800000)
#define MEM_FB_INT_FB_FORCE_DMA0_CH1_ECC_ERR_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_DMA1_CH0_ECC_ERR_FORCE_BF_OFF (24)
#define MEM_FB_INT_FB_FORCE_DMA1_CH0_ECC_ERR_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA1_CH0_ECC_ERR_FORCE_BF_MSK (0x01000000)
#define MEM_FB_INT_FB_FORCE_DMA1_CH0_ECC_ERR_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_FB_FORCE_DMA1_CH1_ECC_ERR_FORCE_BF_OFF (25)
#define MEM_FB_INT_FB_FORCE_DMA1_CH1_ECC_ERR_FORCE_BF_WID ( 1)
#define MEM_FB_INT_FB_FORCE_DMA1_CH1_ECC_ERR_FORCE_BF_MSK (0x02000000)
#define MEM_FB_INT_FB_FORCE_DMA1_CH1_ECC_ERR_FORCE_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_CRUX_STATUS register description at address offset 0xa0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_CRUX_STATUS
  * Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t INVALID_LEN_CM0 : 1;
    ///< SOP and EOP were active on the same cycle for data from Crux interface
    ///< 0 but the length field was not zero.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM0 : 1;
    ///< Crux interface 0 is trying to access a register outside the allowable
    ///< range programmed in mem_fb. Please read the register VEX_BAD_ADDR
    ///< to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t MISSING_SOP_CM0 : 1;
    ///< Crux interface 0 is missing an SOP on the first word.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t MISSING_EOP_CM0 : 1;
    ///< Crux interface 0 is missing an EOP on the last word.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t SHORT_EOP_CM0 : 1;
    ///< If the value on the length field was x, x+1 words are expected on
    ///< Crux interface 0. However, an EOP was detected before x+1 words are
    ///< sent on the interface.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM0 : 1;
    ///< If bvalid was never received for a write transaction initiated by
    ///< the VEX, this bit is set. Please read the register VEX_BAD_ADDR to
    ///< check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t BAD_RESP_CM0 : 1;
    ///< If a bad reponse code was received for a write transaction initiated
    ///< by the VEX in CM0, this bit is set. Please read the register VEX_BAD_ADDR
    ///< to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM0 : 1;
    ///< This bit is set if the FIFO inside CM0 which stores DMA requests from
    ///< the VEX becomes full.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t BAD_TYPE_CM0 : 1;
    ///< This bit is set if a bad type field is received on the CM0 Crux interface.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM0 : 1;
    ///< If a bad reponse code was received for a write transaction initiated
    ///< form the VEX FIFO, this bit is set. Please read the register VEX_BAD_ADDR
    ///< to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM0 : 1;
    ///< If bvalid was never received for a DMA transaction initiated by the
    ///< VEX in CM0, this bit is set. Please read the register VEX_BAD_ADDR
    ///< to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM0 : 1;
    ///< If a bad channel number was received on CM0 for a write transaction
    ///< initiated form the VEX FIFO, this bit is set.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM0 : 1;
    ///< When the VEX FIFO issues asserts request to the DMA on CM0 but never
    ///< receives and acknowledge back, this bit is set.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM0 : 1;
    ///< When the VEX FIFO issues de-asserts request to the DMA on CM0 but
    ///< the acknowledge from the DMA never de-asserts, this bit ise set.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint32_t RSVD1 : 2;
    ///< Reserved field.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t INVALID_LEN_CM1 : 1;
    ///< SOP and EOP were active on the same cycle for data from Crux interface
    ///< 1 but the length field was not zero.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM1 : 1;
    ///< Crux interface 1 is trying to access a register outside the allowable
    ///< range programmed in mem_fb. Please read the register VEX_BAD_ADDR
    ///< to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t MISSING_SOP_CM1 : 1;
    ///< Crux interface 1 is missing an SOP on the first word.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t MISSING_EOP_CM1 : 1;
    ///< Crux interface 1 is missing an EOP on the last word.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t SHORT_EOP_CM1 : 1;
    ///< If the value on the length field was x, x+1 words are expected on
    ///< Crux interface 1. However, an EOP was detected before x+1 words are
    ///< sent on the interface.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM1 : 1;
    ///< If bvalid was never received for a write transaction initiated by
    ///< the VEX, this bit is set. Please read the register VEX_BAD_ADDR to
    ///< check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint32_t BAD_RESP_CM1 : 1;
    ///< If a bad reponse code was received for a write transaction initiated
    ///< by the VEX, this bit is set. Please read the register VEX_BAD_ADDR
    ///< to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM1 : 1;
    ///< This bit is set if the FIFO inside CM1 which stores DMA requests from
    ///< the VEX becomes full.
    ///< AccessType="RO/V" BitOffset="23" ResetValue="0x0"
    uint32_t BAD_TYPE_CM1 : 1;
    ///< This bit is set if a bad type field is received on the CM1 Crux interface.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM1 : 1;
    ///< If a bad reponse code was received for a write transaction initiated
    ///< form the VEX FIFO in CM1, this bit is set. Please read the register
    ///< VEX_BAD_ADDR to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM1 : 1;
    ///< If bvalid was never received for a DMA transaction initiated by the
    ///< VEX in CM1, this bit is set. Please read the register VEX_BAD_ADDR
    ///< to check which address caused this issue.
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM1 : 1;
    ///< If a bad channel number was received on CM1 for a write transaction
    ///< initiated form the VEX FIFO, this bit is set.
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM1 : 1;
    ///< When the VEX FIFO issues asserts request to the DMA on CM0 but never
    ///< receives and acknowledge back, this bit is set.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM1 : 1;
    ///< When the VEX FIFO issues de-asserts request to the DMA on CM0 but
    ///< the acknowledge from the DMA never de-asserts, this bit ise set.
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint32_t RSVD2 : 2;
    ///< Reserved field.
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_int_crux_stat_reg_t;

#define MEM_FB_INT_CRUX_STAT_DEFAULT (0x00000000U)
#define MEM_FB_INT_CRUX_STAT_RD_MASK (0xffffffffU)
#define MEM_FB_INT_CRUX_STAT_WR_MASK (0x00000000U)


///< SOP and EOP were active on the same cycle for data from Crux interface
///< 0 but the length field was not zero.
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM0_BF_OFF ( 0)
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM0_BF_MSK (0x00000001)
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM0_BF_DEF (0x00000000)

///< Crux interface 0 is trying to access a register outside the allowable
///< range programmed in mem_fb. Please read the register VEX_BAD_ADDR
///< to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM0_BF_OFF ( 1)
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM0_BF_MSK (0x00000002)
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM0_BF_DEF (0x00000000)

///< Crux interface 0 is missing an SOP on the first word.
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM0_BF_OFF ( 2)
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM0_BF_MSK (0x00000004)
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM0_BF_DEF (0x00000000)

///< Crux interface 0 is missing an EOP on the last word.
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM0_BF_OFF ( 3)
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM0_BF_MSK (0x00000008)
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM0_BF_DEF (0x00000000)

///< If the value on the length field was x, x+1 words are expected on
///< Crux interface 0. However, an EOP was detected before x+1 words are
///< sent on the interface.
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM0_BF_OFF ( 4)
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM0_BF_MSK (0x00000010)
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM0_BF_DEF (0x00000000)

///< If bvalid was never received for a write transaction initiated by
///< the VEX, this bit is set. Please read the register VEX_BAD_ADDR to
///< check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM0_BF_OFF ( 5)
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM0_BF_MSK (0x00000020)
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM0_BF_DEF (0x00000000)

///< If a bad reponse code was received for a write transaction initiated
///< by the VEX in CM0, this bit is set. Please read the register VEX_BAD_ADDR
///< to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM0_BF_OFF ( 6)
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM0_BF_MSK (0x00000040)
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM0_BF_DEF (0x00000000)

///< This bit is set if the FIFO inside CM0 which stores DMA requests from
///< the VEX becomes full.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM0_BF_OFF ( 7)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM0_BF_MSK (0x00000080)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM0_BF_DEF (0x00000000)

///< This bit is set if a bad type field is received on the CM0 Crux interface.
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM0_BF_OFF ( 8)
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM0_BF_MSK (0x00000100)
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM0_BF_DEF (0x00000000)

///< If a bad reponse code was received for a write transaction initiated
///< form the VEX FIFO, this bit is set. Please read the register VEX_BAD_ADDR
///< to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM0_BF_OFF ( 9)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM0_BF_MSK (0x00000200)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM0_BF_DEF (0x00000000)

///< If bvalid was never received for a DMA transaction initiated by the
///< VEX in CM0, this bit is set. Please read the register VEX_BAD_ADDR
///< to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM0_BF_OFF (10)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM0_BF_MSK (0x00000400)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM0_BF_DEF (0x00000000)

///< If a bad channel number was received on CM0 for a write transaction
///< initiated form the VEX FIFO, this bit is set.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM0_BF_OFF (11)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM0_BF_MSK (0x00000800)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM0_BF_DEF (0x00000000)

///< When the VEX FIFO issues asserts request to the DMA on CM0 but never
///< receives and acknowledge back, this bit is set.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM0_BF_OFF (12)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM0_BF_MSK (0x00001000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM0_BF_DEF (0x00000000)

///< When the VEX FIFO issues de-asserts request to the DMA on CM0 but
///< the acknowledge from the DMA never de-asserts, this bit ise set.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM0_BF_OFF (13)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM0_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM0_BF_MSK (0x00002000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM0_BF_DEF (0x00000000)

///< Reserved field.
#define MEM_FB_INT_CRUX_STAT_RSVD1_BF_OFF (14)
#define MEM_FB_INT_CRUX_STAT_RSVD1_BF_WID ( 2)
#define MEM_FB_INT_CRUX_STAT_RSVD1_BF_MSK (0x0000C000)
#define MEM_FB_INT_CRUX_STAT_RSVD1_BF_DEF (0x00000000)

///< SOP and EOP were active on the same cycle for data from Crux interface
///< 1 but the length field was not zero.
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM1_BF_OFF (16)
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM1_BF_MSK (0x00010000)
#define MEM_FB_INT_CRUX_STAT_INVALID_LEN_CM1_BF_DEF (0x00000000)

///< Crux interface 1 is trying to access a register outside the allowable
///< range programmed in mem_fb. Please read the register VEX_BAD_ADDR
///< to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM1_BF_OFF (17)
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM1_BF_MSK (0x00020000)
#define MEM_FB_INT_CRUX_STAT_INVALID_ADDR_CM1_BF_DEF (0x00000000)

///< Crux interface 1 is missing an SOP on the first word.
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM1_BF_OFF (18)
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM1_BF_MSK (0x00040000)
#define MEM_FB_INT_CRUX_STAT_MISSING_SOP_CM1_BF_DEF (0x00000000)

///< Crux interface 1 is missing an EOP on the last word.
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM1_BF_OFF (19)
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM1_BF_MSK (0x00080000)
#define MEM_FB_INT_CRUX_STAT_MISSING_EOP_CM1_BF_DEF (0x00000000)

///< If the value on the length field was x, x+1 words are expected on
///< Crux interface 1. However, an EOP was detected before x+1 words are
///< sent on the interface.
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM1_BF_OFF (20)
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM1_BF_MSK (0x00100000)
#define MEM_FB_INT_CRUX_STAT_SHORT_EOP_CM1_BF_DEF (0x00000000)

///< If bvalid was never received for a write transaction initiated by
///< the VEX, this bit is set. Please read the register VEX_BAD_ADDR to
///< check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM1_BF_OFF (21)
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM1_BF_MSK (0x00200000)
#define MEM_FB_INT_CRUX_STAT_MISSING_BVALID_CM1_BF_DEF (0x00000000)

///< If a bad reponse code was received for a write transaction initiated
///< by the VEX, this bit is set. Please read the register VEX_BAD_ADDR
///< to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM1_BF_OFF (22)
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM1_BF_MSK (0x00400000)
#define MEM_FB_INT_CRUX_STAT_BAD_RESP_CM1_BF_DEF (0x00000000)

///< This bit is set if the FIFO inside CM1 which stores DMA requests from
///< the VEX becomes full.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM1_BF_OFF (23)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM1_BF_MSK (0x00800000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_FULL_CM1_BF_DEF (0x00000000)

///< This bit is set if a bad type field is received on the CM1 Crux interface.
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM1_BF_OFF (24)
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM1_BF_MSK (0x01000000)
#define MEM_FB_INT_CRUX_STAT_BAD_TYPE_CM1_BF_DEF (0x00000000)

///< If a bad reponse code was received for a write transaction initiated
///< form the VEX FIFO in CM1, this bit is set. Please read the register
///< VEX_BAD_ADDR to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM1_BF_OFF (25)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM1_BF_MSK (0x02000000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_RESP_CM1_BF_DEF (0x00000000)

///< If bvalid was never received for a DMA transaction initiated by the
///< VEX in CM1, this bit is set. Please read the register VEX_BAD_ADDR
///< to check which address caused this issue.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM1_BF_OFF (26)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM1_BF_MSK (0x04000000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_BVALID_CM1_BF_DEF (0x00000000)

///< If a bad channel number was received on CM1 for a write transaction
///< initiated form the VEX FIFO, this bit is set.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM1_BF_OFF (27)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM1_BF_MSK (0x08000000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_BAD_CHAN_CM1_BF_DEF (0x00000000)

///< When the VEX FIFO issues asserts request to the DMA on CM0 but never
///< receives and acknowledge back, this bit is set.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM1_BF_OFF (28)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM1_BF_MSK (0x10000000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKH_CM1_BF_DEF (0x00000000)

///< When the VEX FIFO issues de-asserts request to the DMA on CM0 but
///< the acknowledge from the DMA never de-asserts, this bit ise set.
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM1_BF_OFF (29)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM1_BF_WID ( 1)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM1_BF_MSK (0x20000000)
#define MEM_FB_INT_CRUX_STAT_VEX_FIFO_MISSING_ACKL_CM1_BF_DEF (0x00000000)

///< Reserved field.
#define MEM_FB_INT_CRUX_STAT_RSVD2_BF_OFF (30)
#define MEM_FB_INT_CRUX_STAT_RSVD2_BF_WID ( 2)
#define MEM_FB_INT_CRUX_STAT_RSVD2_BF_MSK (0xC0000000)
#define MEM_FB_INT_CRUX_STAT_RSVD2_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_CRUX_HIGH_EN register description at address offset 0xa4
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_CRUX_HIGH_EN
  * Interrupt Status high enable
  */

typedef union {
  struct {
    uint32_t INVALID_LEN_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MISSING_SOP_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t MISSING_EOP_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t SHORT_EOP_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t BAD_RESP_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BAD_TYPE_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM0_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t RSVD1_HIGH_EN : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t INVALID_LEN_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t MISSING_SOP_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t MISSING_EOP_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SHORT_EOP_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t BAD_RESP_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t BAD_TYPE_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM1_HIGH_EN : 1;
    ///< Enable high priority interrupt for this field.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t RSVD2_HIGH_EN : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_int_crux_high_en_reg_t;

#define MEM_FB_INT_CRUX_HIGH_EN_DEFAULT (0x00000000U)
#define MEM_FB_INT_CRUX_HIGH_EN_RD_MASK (0xffffffffU)
#define MEM_FB_INT_CRUX_HIGH_EN_WR_MASK (0xffffffffU)


///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM0_HIGH_EN_BF_OFF ( 0)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM0_HIGH_EN_BF_MSK (0x00000001)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM0_HIGH_EN_BF_OFF ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM0_HIGH_EN_BF_MSK (0x00000002)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM0_HIGH_EN_BF_OFF ( 2)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM0_HIGH_EN_BF_MSK (0x00000004)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM0_HIGH_EN_BF_OFF ( 3)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM0_HIGH_EN_BF_MSK (0x00000008)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM0_HIGH_EN_BF_OFF ( 4)
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM0_HIGH_EN_BF_MSK (0x00000010)
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM0_HIGH_EN_BF_OFF ( 5)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM0_HIGH_EN_BF_MSK (0x00000020)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM0_HIGH_EN_BF_OFF ( 6)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM0_HIGH_EN_BF_MSK (0x00000040)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM0_HIGH_EN_BF_OFF ( 7)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM0_HIGH_EN_BF_MSK (0x00000080)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM0_HIGH_EN_BF_OFF ( 8)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM0_HIGH_EN_BF_MSK (0x00000100)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM0_HIGH_EN_BF_OFF ( 9)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM0_HIGH_EN_BF_MSK (0x00000200)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM0_HIGH_EN_BF_OFF (10)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM0_HIGH_EN_BF_MSK (0x00000400)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM0_HIGH_EN_BF_OFF (11)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM0_HIGH_EN_BF_MSK (0x00000800)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM0_HIGH_EN_BF_OFF (12)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM0_HIGH_EN_BF_MSK (0x00001000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM0_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM0_HIGH_EN_BF_OFF (13)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM0_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM0_HIGH_EN_BF_MSK (0x00002000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM0_HIGH_EN_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD1_HIGH_EN_BF_OFF (14)
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD1_HIGH_EN_BF_WID ( 2)
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD1_HIGH_EN_BF_MSK (0x0000C000)
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM1_HIGH_EN_BF_OFF (16)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM1_HIGH_EN_BF_MSK (0x00010000)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_LEN_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM1_HIGH_EN_BF_OFF (17)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM1_HIGH_EN_BF_MSK (0x00020000)
#define MEM_FB_INT_CRUX_HIGH_EN_INVALID_ADDR_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM1_HIGH_EN_BF_OFF (18)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM1_HIGH_EN_BF_MSK (0x00040000)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_SOP_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM1_HIGH_EN_BF_OFF (19)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM1_HIGH_EN_BF_MSK (0x00080000)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_EOP_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM1_HIGH_EN_BF_OFF (20)
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM1_HIGH_EN_BF_MSK (0x00100000)
#define MEM_FB_INT_CRUX_HIGH_EN_SHORT_EOP_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM1_HIGH_EN_BF_OFF (21)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM1_HIGH_EN_BF_MSK (0x00200000)
#define MEM_FB_INT_CRUX_HIGH_EN_MISSING_BVALID_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM1_HIGH_EN_BF_OFF (22)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM1_HIGH_EN_BF_MSK (0x00400000)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_RESP_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM1_HIGH_EN_BF_OFF (23)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM1_HIGH_EN_BF_MSK (0x00800000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_FULL_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM1_HIGH_EN_BF_OFF (24)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM1_HIGH_EN_BF_MSK (0x01000000)
#define MEM_FB_INT_CRUX_HIGH_EN_BAD_TYPE_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM1_HIGH_EN_BF_OFF (25)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM1_HIGH_EN_BF_MSK (0x02000000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_RESP_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM1_HIGH_EN_BF_OFF (26)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM1_HIGH_EN_BF_MSK (0x04000000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_BVALID_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM1_HIGH_EN_BF_OFF (27)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM1_HIGH_EN_BF_MSK (0x08000000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_BAD_CHAN_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM1_HIGH_EN_BF_OFF (28)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM1_HIGH_EN_BF_MSK (0x10000000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKH_CM1_HIGH_EN_BF_DEF (0x00000000)

///< Enable high priority interrupt for this field.
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM1_HIGH_EN_BF_OFF (29)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM1_HIGH_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM1_HIGH_EN_BF_MSK (0x20000000)
#define MEM_FB_INT_CRUX_HIGH_EN_VEX_FIFO_MISSING_ACKL_CM1_HIGH_EN_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD2_HIGH_EN_BF_OFF (30)
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD2_HIGH_EN_BF_WID ( 2)
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD2_HIGH_EN_BF_MSK (0xC0000000)
#define MEM_FB_INT_CRUX_HIGH_EN_RSVD2_HIGH_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_CRUX_LOW_EN register description at address offset 0xa8
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_CRUX_LOW_EN
  * Interrupt Status low enable
  */

typedef union {
  struct {
    uint32_t INVALID_LEN_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MISSING_SOP_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t MISSING_EOP_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t SHORT_EOP_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t BAD_RESP_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BAD_TYPE_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM0_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t RSVD1_LOW_EN : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t INVALID_LEN_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t MISSING_SOP_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t MISSING_EOP_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SHORT_EOP_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t BAD_RESP_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t BAD_TYPE_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM1_LOW_EN : 1;
    ///< Enable low priority interrupt for this field.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t RSVD2_LOW_EN : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_int_crux_low_en_reg_t;

#define MEM_FB_INT_CRUX_LOW_EN_DEFAULT (0x00000000U)
#define MEM_FB_INT_CRUX_LOW_EN_RD_MASK (0xffffffffU)
#define MEM_FB_INT_CRUX_LOW_EN_WR_MASK (0xffffffffU)


///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM0_LOW_EN_BF_OFF ( 0)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM0_LOW_EN_BF_MSK (0x00000001)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM0_LOW_EN_BF_OFF ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM0_LOW_EN_BF_MSK (0x00000002)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM0_LOW_EN_BF_OFF ( 2)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM0_LOW_EN_BF_MSK (0x00000004)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM0_LOW_EN_BF_OFF ( 3)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM0_LOW_EN_BF_MSK (0x00000008)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM0_LOW_EN_BF_OFF ( 4)
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM0_LOW_EN_BF_MSK (0x00000010)
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM0_LOW_EN_BF_OFF ( 5)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM0_LOW_EN_BF_MSK (0x00000020)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM0_LOW_EN_BF_OFF ( 6)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM0_LOW_EN_BF_MSK (0x00000040)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM0_LOW_EN_BF_OFF ( 7)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM0_LOW_EN_BF_MSK (0x00000080)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM0_LOW_EN_BF_OFF ( 8)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM0_LOW_EN_BF_MSK (0x00000100)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM0_LOW_EN_BF_OFF ( 9)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM0_LOW_EN_BF_MSK (0x00000200)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM0_LOW_EN_BF_OFF (10)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM0_LOW_EN_BF_MSK (0x00000400)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM0_LOW_EN_BF_OFF (11)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM0_LOW_EN_BF_MSK (0x00000800)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM0_LOW_EN_BF_OFF (12)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM0_LOW_EN_BF_MSK (0x00001000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM0_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM0_LOW_EN_BF_OFF (13)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM0_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM0_LOW_EN_BF_MSK (0x00002000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM0_LOW_EN_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_LOW_EN_RSVD1_LOW_EN_BF_OFF (14)
#define MEM_FB_INT_CRUX_LOW_EN_RSVD1_LOW_EN_BF_WID ( 2)
#define MEM_FB_INT_CRUX_LOW_EN_RSVD1_LOW_EN_BF_MSK (0x0000C000)
#define MEM_FB_INT_CRUX_LOW_EN_RSVD1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM1_LOW_EN_BF_OFF (16)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM1_LOW_EN_BF_MSK (0x00010000)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_LEN_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM1_LOW_EN_BF_OFF (17)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM1_LOW_EN_BF_MSK (0x00020000)
#define MEM_FB_INT_CRUX_LOW_EN_INVALID_ADDR_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM1_LOW_EN_BF_OFF (18)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM1_LOW_EN_BF_MSK (0x00040000)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_SOP_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM1_LOW_EN_BF_OFF (19)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM1_LOW_EN_BF_MSK (0x00080000)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_EOP_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM1_LOW_EN_BF_OFF (20)
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM1_LOW_EN_BF_MSK (0x00100000)
#define MEM_FB_INT_CRUX_LOW_EN_SHORT_EOP_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM1_LOW_EN_BF_OFF (21)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM1_LOW_EN_BF_MSK (0x00200000)
#define MEM_FB_INT_CRUX_LOW_EN_MISSING_BVALID_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM1_LOW_EN_BF_OFF (22)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM1_LOW_EN_BF_MSK (0x00400000)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_RESP_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM1_LOW_EN_BF_OFF (23)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM1_LOW_EN_BF_MSK (0x00800000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_FULL_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM1_LOW_EN_BF_OFF (24)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM1_LOW_EN_BF_MSK (0x01000000)
#define MEM_FB_INT_CRUX_LOW_EN_BAD_TYPE_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM1_LOW_EN_BF_OFF (25)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM1_LOW_EN_BF_MSK (0x02000000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_RESP_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM1_LOW_EN_BF_OFF (26)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM1_LOW_EN_BF_MSK (0x04000000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_BVALID_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM1_LOW_EN_BF_OFF (27)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM1_LOW_EN_BF_MSK (0x08000000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_BAD_CHAN_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM1_LOW_EN_BF_OFF (28)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM1_LOW_EN_BF_MSK (0x10000000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKH_CM1_LOW_EN_BF_DEF (0x00000000)

///< Enable low priority interrupt for this field.
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM1_LOW_EN_BF_OFF (29)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM1_LOW_EN_BF_WID ( 1)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM1_LOW_EN_BF_MSK (0x20000000)
#define MEM_FB_INT_CRUX_LOW_EN_VEX_FIFO_MISSING_ACKL_CM1_LOW_EN_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_LOW_EN_RSVD2_LOW_EN_BF_OFF (30)
#define MEM_FB_INT_CRUX_LOW_EN_RSVD2_LOW_EN_BF_WID ( 2)
#define MEM_FB_INT_CRUX_LOW_EN_RSVD2_LOW_EN_BF_MSK (0xC0000000)
#define MEM_FB_INT_CRUX_LOW_EN_RSVD2_LOW_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_CRUX_CLEAR register description at address offset 0xac
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_CRUX_CLEAR
  * Interrupt Status low enable
  */

typedef union {
  struct {
    uint32_t INVALID_LEN_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MISSING_SOP_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t MISSING_EOP_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t SHORT_EOP_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t BAD_RESP_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BAD_TYPE_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM0_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t RSVD1_CLEAR : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t INVALID_LEN_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t MISSING_SOP_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t MISSING_EOP_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SHORT_EOP_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t BAD_RESP_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t BAD_TYPE_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM1_CLEAR : 1;
    ///< Clear interrupt for this field.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t RSVD2_CLEAR : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_int_crux_clr_reg_t;

#define MEM_FB_INT_CRUX_CLR_DEFAULT (0x00000000U)
#define MEM_FB_INT_CRUX_CLR_RD_MASK (0xffffffffU)
#define MEM_FB_INT_CRUX_CLR_WR_MASK (0xffffffffU)


///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM0_CLR_BF_OFF ( 0)
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM0_CLR_BF_MSK (0x00000001)
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM0_CLR_BF_OFF ( 1)
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM0_CLR_BF_MSK (0x00000002)
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM0_CLR_BF_OFF ( 2)
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM0_CLR_BF_MSK (0x00000004)
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM0_CLR_BF_OFF ( 3)
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM0_CLR_BF_MSK (0x00000008)
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM0_CLR_BF_OFF ( 4)
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM0_CLR_BF_MSK (0x00000010)
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM0_CLR_BF_OFF ( 5)
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM0_CLR_BF_MSK (0x00000020)
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM0_CLR_BF_OFF ( 6)
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM0_CLR_BF_MSK (0x00000040)
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM0_CLR_BF_OFF ( 7)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM0_CLR_BF_MSK (0x00000080)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM0_CLR_BF_OFF ( 8)
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM0_CLR_BF_MSK (0x00000100)
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM0_CLR_BF_OFF ( 9)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM0_CLR_BF_MSK (0x00000200)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM0_CLR_BF_OFF (10)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM0_CLR_BF_MSK (0x00000400)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM0_CLR_BF_OFF (11)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM0_CLR_BF_MSK (0x00000800)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM0_CLR_BF_OFF (12)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM0_CLR_BF_MSK (0x00001000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM0_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM0_CLR_BF_OFF (13)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM0_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM0_CLR_BF_MSK (0x00002000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM0_CLR_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_CLR_RSVD1_CLR_BF_OFF (14)
#define MEM_FB_INT_CRUX_CLR_RSVD1_CLR_BF_WID ( 2)
#define MEM_FB_INT_CRUX_CLR_RSVD1_CLR_BF_MSK (0x0000C000)
#define MEM_FB_INT_CRUX_CLR_RSVD1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM1_CLR_BF_OFF (16)
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM1_CLR_BF_MSK (0x00010000)
#define MEM_FB_INT_CRUX_CLR_INVALID_LEN_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM1_CLR_BF_OFF (17)
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM1_CLR_BF_MSK (0x00020000)
#define MEM_FB_INT_CRUX_CLR_INVALID_ADDR_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM1_CLR_BF_OFF (18)
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM1_CLR_BF_MSK (0x00040000)
#define MEM_FB_INT_CRUX_CLR_MISSING_SOP_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM1_CLR_BF_OFF (19)
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM1_CLR_BF_MSK (0x00080000)
#define MEM_FB_INT_CRUX_CLR_MISSING_EOP_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM1_CLR_BF_OFF (20)
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM1_CLR_BF_MSK (0x00100000)
#define MEM_FB_INT_CRUX_CLR_SHORT_EOP_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM1_CLR_BF_OFF (21)
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM1_CLR_BF_MSK (0x00200000)
#define MEM_FB_INT_CRUX_CLR_MISSING_BVALID_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM1_CLR_BF_OFF (22)
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM1_CLR_BF_MSK (0x00400000)
#define MEM_FB_INT_CRUX_CLR_BAD_RESP_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM1_CLR_BF_OFF (23)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM1_CLR_BF_MSK (0x00800000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_FULL_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM1_CLR_BF_OFF (24)
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM1_CLR_BF_MSK (0x01000000)
#define MEM_FB_INT_CRUX_CLR_BAD_TYPE_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM1_CLR_BF_OFF (25)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM1_CLR_BF_MSK (0x02000000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_RESP_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM1_CLR_BF_OFF (26)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM1_CLR_BF_MSK (0x04000000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_BVALID_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM1_CLR_BF_OFF (27)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM1_CLR_BF_MSK (0x08000000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_BAD_CHAN_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM1_CLR_BF_OFF (28)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM1_CLR_BF_MSK (0x10000000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKH_CM1_CLR_BF_DEF (0x00000000)

///< Clear interrupt for this field.
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM1_CLR_BF_OFF (29)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM1_CLR_BF_WID ( 1)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM1_CLR_BF_MSK (0x20000000)
#define MEM_FB_INT_CRUX_CLR_VEX_FIFO_MISSING_ACKL_CM1_CLR_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_CLR_RSVD2_CLR_BF_OFF (30)
#define MEM_FB_INT_CRUX_CLR_RSVD2_CLR_BF_WID ( 2)
#define MEM_FB_INT_CRUX_CLR_RSVD2_CLR_BF_MSK (0xC0000000)
#define MEM_FB_INT_CRUX_CLR_RSVD2_CLR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_INT_CRUX_FORCE register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/INT_CRUX_FORCE
  * Interrupt Status low enable
  */

typedef union {
  struct {
    uint32_t INVALID_LEN_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MISSING_SOP_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t MISSING_EOP_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t SHORT_EOP_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t BAD_RESP_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t BAD_TYPE_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM0_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t RSVD1_FORCE : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t INVALID_LEN_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INVALID_ADDR_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t MISSING_SOP_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t MISSING_EOP_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SHORT_EOP_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t MISSING_BVALID_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t BAD_RESP_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t VEX_FIFO_FULL_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t BAD_TYPE_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_RESP_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_BVALID_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t VEX_FIFO_BAD_CHAN_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKH_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t VEX_FIFO_MISSING_ACKL_CM1_FORCE : 1;
    ///< Force interrupt for this field.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t RSVD2_FORCE : 2;
    ///< This field is reserved.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_int_crux_force_reg_t;

#define MEM_FB_INT_CRUX_FORCE_DEFAULT (0x00000000U)
#define MEM_FB_INT_CRUX_FORCE_RD_MASK (0xffffffffU)
#define MEM_FB_INT_CRUX_FORCE_WR_MASK (0xffffffffU)


///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM0_FORCE_BF_OFF ( 0)
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM0_FORCE_BF_MSK (0x00000001)
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM0_FORCE_BF_OFF ( 1)
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM0_FORCE_BF_MSK (0x00000002)
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM0_FORCE_BF_OFF ( 2)
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM0_FORCE_BF_MSK (0x00000004)
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM0_FORCE_BF_OFF ( 3)
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM0_FORCE_BF_MSK (0x00000008)
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM0_FORCE_BF_OFF ( 4)
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM0_FORCE_BF_MSK (0x00000010)
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM0_FORCE_BF_OFF ( 5)
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM0_FORCE_BF_MSK (0x00000020)
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM0_FORCE_BF_OFF ( 6)
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM0_FORCE_BF_MSK (0x00000040)
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM0_FORCE_BF_OFF ( 7)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM0_FORCE_BF_MSK (0x00000080)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM0_FORCE_BF_OFF ( 8)
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM0_FORCE_BF_MSK (0x00000100)
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM0_FORCE_BF_OFF ( 9)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM0_FORCE_BF_MSK (0x00000200)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM0_FORCE_BF_OFF (10)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM0_FORCE_BF_MSK (0x00000400)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM0_FORCE_BF_OFF (11)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM0_FORCE_BF_MSK (0x00000800)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM0_FORCE_BF_OFF (12)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM0_FORCE_BF_MSK (0x00001000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM0_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM0_FORCE_BF_OFF (13)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM0_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM0_FORCE_BF_MSK (0x00002000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM0_FORCE_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_FORCE_RSVD1_FORCE_BF_OFF (14)
#define MEM_FB_INT_CRUX_FORCE_RSVD1_FORCE_BF_WID ( 2)
#define MEM_FB_INT_CRUX_FORCE_RSVD1_FORCE_BF_MSK (0x0000C000)
#define MEM_FB_INT_CRUX_FORCE_RSVD1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM1_FORCE_BF_OFF (16)
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM1_FORCE_BF_MSK (0x00010000)
#define MEM_FB_INT_CRUX_FORCE_INVALID_LEN_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM1_FORCE_BF_OFF (17)
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM1_FORCE_BF_MSK (0x00020000)
#define MEM_FB_INT_CRUX_FORCE_INVALID_ADDR_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM1_FORCE_BF_OFF (18)
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM1_FORCE_BF_MSK (0x00040000)
#define MEM_FB_INT_CRUX_FORCE_MISSING_SOP_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM1_FORCE_BF_OFF (19)
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM1_FORCE_BF_MSK (0x00080000)
#define MEM_FB_INT_CRUX_FORCE_MISSING_EOP_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM1_FORCE_BF_OFF (20)
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM1_FORCE_BF_MSK (0x00100000)
#define MEM_FB_INT_CRUX_FORCE_SHORT_EOP_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM1_FORCE_BF_OFF (21)
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM1_FORCE_BF_MSK (0x00200000)
#define MEM_FB_INT_CRUX_FORCE_MISSING_BVALID_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM1_FORCE_BF_OFF (22)
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM1_FORCE_BF_MSK (0x00400000)
#define MEM_FB_INT_CRUX_FORCE_BAD_RESP_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM1_FORCE_BF_OFF (23)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM1_FORCE_BF_MSK (0x00800000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_FULL_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM1_FORCE_BF_OFF (24)
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM1_FORCE_BF_MSK (0x01000000)
#define MEM_FB_INT_CRUX_FORCE_BAD_TYPE_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM1_FORCE_BF_OFF (25)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM1_FORCE_BF_MSK (0x02000000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_RESP_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM1_FORCE_BF_OFF (26)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM1_FORCE_BF_MSK (0x04000000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_BVALID_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM1_FORCE_BF_OFF (27)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM1_FORCE_BF_MSK (0x08000000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_BAD_CHAN_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM1_FORCE_BF_OFF (28)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM1_FORCE_BF_MSK (0x10000000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKH_CM1_FORCE_BF_DEF (0x00000000)

///< Force interrupt for this field.
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM1_FORCE_BF_OFF (29)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM1_FORCE_BF_WID ( 1)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM1_FORCE_BF_MSK (0x20000000)
#define MEM_FB_INT_CRUX_FORCE_VEX_FIFO_MISSING_ACKL_CM1_FORCE_BF_DEF (0x00000000)

///< This field is reserved.
#define MEM_FB_INT_CRUX_FORCE_RSVD2_FORCE_BF_OFF (30)
#define MEM_FB_INT_CRUX_FORCE_RSVD2_FORCE_BF_WID ( 2)
#define MEM_FB_INT_CRUX_FORCE_RSVD2_FORCE_BF_MSK (0xC0000000)
#define MEM_FB_INT_CRUX_FORCE_RSVD2_FORCE_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_AXI_ECC_ERR_INFO[3] register description at address offset 0x100
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/AXI_ECC_ERR_INFO
  * ECC error info associated with the feedback memory
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 14;
    ///< Error Address. This is the captured memory address of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t ERR_SYNDROME : 11;
    ///< Error Syndrome. This is the captured ECC syndrome of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
    uint32_t SBE_COUNT : 4;
    ///< SBE Count. This is the value of the SBE counter, which doesn't roll
    ///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_axi_ecc_err_info_reg_t;

#define MEM_FB_AXI_ECC_ERR_INFO_DEFAULT (0x00000000U)
#define MEM_FB_AXI_ECC_ERR_INFO_RD_MASK (0xf7ff3fffU)
#define MEM_FB_AXI_ECC_ERR_INFO_WR_MASK (0x00000000U)


///< Error Address. This is the captured memory address of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_ADDR_BF_OFF ( 0)
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_ADDR_BF_WID (14)
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_ADDR_BF_MSK (0x00003FFF)
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< Error Syndrome. This is the captured ECC syndrome of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_SYNDROME_BF_OFF (16)
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_SYNDROME_BF_WID (11)
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_SYNDROME_BF_MSK (0x07FF0000)
#define MEM_FB_AXI_ECC_ERR_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< SBE Count. This is the value of the SBE counter, which doesn't roll
///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_AXI_ECC_ERR_INFO_SBE_CNT_BF_OFF (28)
#define MEM_FB_AXI_ECC_ERR_INFO_SBE_CNT_BF_WID ( 4)
#define MEM_FB_AXI_ECC_ERR_INFO_SBE_CNT_BF_MSK (0xF0000000)
#define MEM_FB_AXI_ECC_ERR_INFO_SBE_CNT_BF_DEF (0x00000000)
#define MEM_FB_AXI_ECC_ERR_INFO_ARR_SZ0 (3)
#define MEM_FB_AXI_ECC_ERR_INFO_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_AXI_ECC_CTL[3] register description at address offset 0x104
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/AXI_ECC_CTL
  * ECC controls associated with the feedback memory
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< ECC Force Error Type. This bit indicates the type of ECC errors forced
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< ECC Force Error. When set to 1, this bit enables to insert one ECC
    ///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
    ///< the expected ECC error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
    ///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
    ///< of the corresponding memory slice. This bit retains the last written
    ///< value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< ECC Check and Correction Disable. When set, this bit disables ECC
    ///< checking and correction for the corresponding memory slice. It's used
    ///< for debug and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< ECC Generation Disable. When set, this bit disables ECC generation
    ///< for the corresponding memory slice. It's used for debug and testing
    ///< purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_axi_ecc_ctl_reg_t;

#define MEM_FB_AXI_ECC_CTL_DEFAULT (0x00000000U)
#define MEM_FB_AXI_ECC_CTL_RD_MASK (0x0000003fU)
#define MEM_FB_AXI_ECC_CTL_WR_MASK (0x0000003fU)


///< ECC Force Error Type. This bit indicates the type of ECC errors forced
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define MEM_FB_AXI_ECC_CTL_FORCE_TYPE_BF_OFF ( 0)
#define MEM_FB_AXI_ECC_CTL_FORCE_TYPE_BF_WID ( 1)
#define MEM_FB_AXI_ECC_CTL_FORCE_TYPE_BF_MSK (0x00000001)
#define MEM_FB_AXI_ECC_CTL_FORCE_TYPE_BF_DEF (0x00000000)

///< ECC Force Error. When set to 1, this bit enables to insert one ECC
///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
///< the expected ECC error is seen by hardware.
#define MEM_FB_AXI_ECC_CTL_FORCE_ERR_BF_OFF ( 1)
#define MEM_FB_AXI_ECC_CTL_FORCE_ERR_BF_WID ( 1)
#define MEM_FB_AXI_ECC_CTL_FORCE_ERR_BF_MSK (0x00000002)
#define MEM_FB_AXI_ECC_CTL_FORCE_ERR_BF_DEF (0x00000000)

///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
///< the last written value.
#define MEM_FB_AXI_ECC_CTL_ERR_CLR_BF_OFF ( 2)
#define MEM_FB_AXI_ECC_CTL_ERR_CLR_BF_WID ( 1)
#define MEM_FB_AXI_ECC_CTL_ERR_CLR_BF_MSK (0x00000004)
#define MEM_FB_AXI_ECC_CTL_ERR_CLR_BF_DEF (0x00000000)

///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
///< of the corresponding memory slice. This bit retains the last written
///< value.
#define MEM_FB_AXI_ECC_CTL_CNT_CLR_BF_OFF ( 3)
#define MEM_FB_AXI_ECC_CTL_CNT_CLR_BF_WID ( 1)
#define MEM_FB_AXI_ECC_CTL_CNT_CLR_BF_MSK (0x00000008)
#define MEM_FB_AXI_ECC_CTL_CNT_CLR_BF_DEF (0x00000000)

///< ECC Check and Correction Disable. When set, this bit disables ECC
///< checking and correction for the corresponding memory slice. It's used
///< for debug and testing purpose.
#define MEM_FB_AXI_ECC_CTL_CHK_DIS_BF_OFF ( 4)
#define MEM_FB_AXI_ECC_CTL_CHK_DIS_BF_WID ( 1)
#define MEM_FB_AXI_ECC_CTL_CHK_DIS_BF_MSK (0x00000010)
#define MEM_FB_AXI_ECC_CTL_CHK_DIS_BF_DEF (0x00000000)

///< ECC Generation Disable. When set, this bit disables ECC generation
///< for the corresponding memory slice. It's used for debug and testing
///< purpose.
#define MEM_FB_AXI_ECC_CTL_GEN_DIS_BF_OFF ( 5)
#define MEM_FB_AXI_ECC_CTL_GEN_DIS_BF_WID ( 1)
#define MEM_FB_AXI_ECC_CTL_GEN_DIS_BF_MSK (0x00000020)
#define MEM_FB_AXI_ECC_CTL_GEN_DIS_BF_DEF (0x00000000)
#define MEM_FB_AXI_ECC_CTL_ARR_SZ0 (3)
#define MEM_FB_AXI_ECC_CTL_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_AXI_ECC_ERR_STAT[3] register description at address offset 0x108
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/AXI_ECC_ERR_STAT
  * ECC stats associated with the feedback memory
  */

typedef union {
  struct {
    uint32_t SBE : 1;
    ///< ECC Single Bit Error. When set, indicates an ECC single bit error
    ///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 1;
    ///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
    ///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 1;
    ///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
    ///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_axi_ecc_err_stat_reg_t;

#define MEM_FB_AXI_ECC_ERR_STAT_DEFAULT (0x00000000U)
#define MEM_FB_AXI_ECC_ERR_STAT_RD_MASK (0x00000007U)
#define MEM_FB_AXI_ECC_ERR_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. When set, indicates an ECC single bit error
///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_BF_OFF ( 0)
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_BF_WID ( 1)
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_BF_MSK (0x00000001)
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_AXI_ECC_ERR_STAT_DBE_BF_OFF ( 1)
#define MEM_FB_AXI_ECC_ERR_STAT_DBE_BF_WID ( 1)
#define MEM_FB_AXI_ECC_ERR_STAT_DBE_BF_MSK (0x00000002)
#define MEM_FB_AXI_ECC_ERR_STAT_DBE_BF_DEF (0x00000000)

///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_CNT_OVFL_BF_OFF ( 2)
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_CNT_OVFL_BF_WID ( 1)
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_CNT_OVFL_BF_MSK (0x00000004)
#define MEM_FB_AXI_ECC_ERR_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)
#define MEM_FB_AXI_ECC_ERR_STAT_ARR_SZ0 (3)
#define MEM_FB_AXI_ECC_ERR_STAT_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_FB_MEM_PTR_PORT0 register description at address offset 0x200
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/FB_MEM_PTR_PORT0
  * Initial pointer associated with the feedback memory for antenna port 0
  */

typedef union {
  struct {
    uint32_t INIT_PTR : 14;
    ///< When data is written from antenna port 0 into the memory, the very
    ///< first address where it gets written is stored in this register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_mem_ptr_port0_reg_t;

#define MEM_FB_MEM_PTR_PORT0_DEFAULT (0x00000000U)
#define MEM_FB_MEM_PTR_PORT0_RD_MASK (0x00003fffU)
#define MEM_FB_MEM_PTR_PORT0_WR_MASK (0x00003fffU)


///< When data is written from antenna port 0 into the memory, the very
///< first address where it gets written is stored in this register.
#define MEM_FB_MEM_PTR_PORT0_INIT_PTR_BF_OFF ( 0)
#define MEM_FB_MEM_PTR_PORT0_INIT_PTR_BF_WID (14)
#define MEM_FB_MEM_PTR_PORT0_INIT_PTR_BF_MSK (0x00003FFF)
#define MEM_FB_MEM_PTR_PORT0_INIT_PTR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_FB_MEM_PTR_PORT1 register description at address offset 0x204
  *
  * Register default value:        0x00000800
  * Register full path in IP: mem_fb_map_MEM/reg/FB_MEM_PTR_PORT1
  * Initial pointer associated with the feedback memory for antenna port 1.
  */

typedef union {
  struct {
    uint32_t INIT_PTR : 14;
    ///< When data is written from antenna port 1 into the memory, the very
    ///< first address where it gets written is stored in this register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x800"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_mem_ptr_port1_reg_t;

#define MEM_FB_MEM_PTR_PORT1_DEFAULT (0x00000800U)
#define MEM_FB_MEM_PTR_PORT1_RD_MASK (0x00003fffU)
#define MEM_FB_MEM_PTR_PORT1_WR_MASK (0x00003fffU)


///< When data is written from antenna port 1 into the memory, the very
///< first address where it gets written is stored in this register.
#define MEM_FB_MEM_PTR_PORT1_INIT_PTR_BF_OFF ( 0)
#define MEM_FB_MEM_PTR_PORT1_INIT_PTR_BF_WID (14)
#define MEM_FB_MEM_PTR_PORT1_INIT_PTR_BF_MSK (0x00003FFF)
#define MEM_FB_MEM_PTR_PORT1_INIT_PTR_BF_DEF (0x00000800)


/** @brief MEM_FB_MAP_MEM_REG_FB_MEM_PTR_PORT2 register description at address offset 0x208
  *
  * Register default value:        0x00001000
  * Register full path in IP: mem_fb_map_MEM/reg/FB_MEM_PTR_PORT2
  * Initial pointer associated with the feedback memory for antenna port 2.
  */

typedef union {
  struct {
    uint32_t INIT_PTR : 14;
    ///< When data is written from antenna port 2 into the memory, the very
    ///< first address where it gets written is stored in this register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_mem_ptr_port2_reg_t;

#define MEM_FB_MEM_PTR_PORT2_DEFAULT (0x00001000U)
#define MEM_FB_MEM_PTR_PORT2_RD_MASK (0x00003fffU)
#define MEM_FB_MEM_PTR_PORT2_WR_MASK (0x00003fffU)


///< When data is written from antenna port 2 into the memory, the very
///< first address where it gets written is stored in this register.
#define MEM_FB_MEM_PTR_PORT2_INIT_PTR_BF_OFF ( 0)
#define MEM_FB_MEM_PTR_PORT2_INIT_PTR_BF_WID (14)
#define MEM_FB_MEM_PTR_PORT2_INIT_PTR_BF_MSK (0x00003FFF)
#define MEM_FB_MEM_PTR_PORT2_INIT_PTR_BF_DEF (0x00001000)


/** @brief MEM_FB_MAP_MEM_REG_FB_MEM_PTR_PORT3 register description at address offset 0x20c
  *
  * Register default value:        0x00001800
  * Register full path in IP: mem_fb_map_MEM/reg/FB_MEM_PTR_PORT3
  * Initial pointer associated with the feedback memory for antenna port 3.
  */

typedef union {
  struct {
    uint32_t INIT_PTR : 14;
    ///< When data is written from antenna port 3 into the memory, the very
    ///< first address where it gets written is stored in this register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1800"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_mem_ptr_port3_reg_t;

#define MEM_FB_MEM_PTR_PORT3_DEFAULT (0x00001800U)
#define MEM_FB_MEM_PTR_PORT3_RD_MASK (0x00003fffU)
#define MEM_FB_MEM_PTR_PORT3_WR_MASK (0x00003fffU)


///< When data is written from antenna port 3 into the memory, the very
///< first address where it gets written is stored in this register.
#define MEM_FB_MEM_PTR_PORT3_INIT_PTR_BF_OFF ( 0)
#define MEM_FB_MEM_PTR_PORT3_INIT_PTR_BF_WID (14)
#define MEM_FB_MEM_PTR_PORT3_INIT_PTR_BF_MSK (0x00003FFF)
#define MEM_FB_MEM_PTR_PORT3_INIT_PTR_BF_DEF (0x00001800)


/** @brief MEM_FB_MAP_MEM_REG_SAMPLE_CNT[4] register description at address offset 0x210
  *
  * Register default value:        0x00002000
  * Register full path in IP: mem_fb_map_MEM/reg/SAMPLE_CNT
  * Count of antenna data samples from a particular antenna.
  */

typedef union {
  struct {
    uint32_t CNT_VALUE : 20;
    ///< The hardware uses this value to match the number of samples received
    ///< from a particular antenna before it switches to samples being received
    ///< from a different antenna. If the samples don't match this programmed
    ///< value, an interrupt is asserted. Note that a value of 0x2000 in this
    ///< field corresponds to 64k samples as 8 samples can be sent in each
    ///< clock cycle.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x2000"
    uint32_t ENABLE_CNT_CHECK : 1;
    ///< If this bit is set, the CNT_VALUE field in this register is checked
    ///< against the received samples.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t STABLE : 1;
    ///< The values in this register are used in a different clock domain than
    ///< the domain where they are being written. Therefore, this bit should
    ///< only be set once all the fields of this register have been set and
    ///< are stable. Once this bit is set, the remaining values in this register
    ///< should not be changed. If the values need to be changed, this bit
    ///< has to be set to 0, the values changed and then this bit has to be
    ///< set to a 1.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_sample_cnt_reg_t;

#define MEM_FB_SAMPLE_CNT_DEFAULT (0x00002000U)
#define MEM_FB_SAMPLE_CNT_RD_MASK (0x003fffffU)
#define MEM_FB_SAMPLE_CNT_WR_MASK (0x003fffffU)


///< The hardware uses this value to match the number of samples received
///< from a particular antenna before it switches to samples being received
///< from a different antenna. If the samples don't match this programmed
///< value, an interrupt is asserted. Note that a value of 0x2000 in this
///< field corresponds to 64k samples as 8 samples can be sent in each
///< clock cycle.
#define MEM_FB_SAMPLE_CNT_VAL_BF_OFF ( 0)
#define MEM_FB_SAMPLE_CNT_VAL_BF_WID (20)
#define MEM_FB_SAMPLE_CNT_VAL_BF_MSK (0x000FFFFF)
#define MEM_FB_SAMPLE_CNT_VAL_BF_DEF (0x00002000)

///< If this bit is set, the CNT_VALUE field in this register is checked
///< against the received samples.
#define MEM_FB_SAMPLE_CNT_EN_CNT_CHECK_BF_OFF (20)
#define MEM_FB_SAMPLE_CNT_EN_CNT_CHECK_BF_WID ( 1)
#define MEM_FB_SAMPLE_CNT_EN_CNT_CHECK_BF_MSK (0x00100000)
#define MEM_FB_SAMPLE_CNT_EN_CNT_CHECK_BF_DEF (0x00000000)

///< The values in this register are used in a different clock domain than
///< the domain where they are being written. Therefore, this bit should
///< only be set once all the fields of this register have been set and
///< are stable. Once this bit is set, the remaining values in this register
///< should not be changed. If the values need to be changed, this bit
///< has to be set to 0, the values changed and then this bit has to be
///< set to a 1.
#define MEM_FB_SAMPLE_CNT_STBL_BF_OFF (21)
#define MEM_FB_SAMPLE_CNT_STBL_BF_WID ( 1)
#define MEM_FB_SAMPLE_CNT_STBL_BF_MSK (0x00200000)
#define MEM_FB_SAMPLE_CNT_STBL_BF_DEF (0x00000000)
#define MEM_FB_SAMPLE_CNT_ARR_SZ0 (4)
#define MEM_FB_SAMPLE_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_FB_MAP_MEM_REG_ANT_INTF_STATUS register description at address offset 0x228
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ANT_INTF_STATUS
  * Antenna interface error status register
  */

typedef union {
  struct {
    uint32_t ANT_PORT_NO : 2;
    ///< This field contains the antenna port number on which the error occured.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ANT_ID_NO : 2;
    ///< This field contains the antenna ID number on the port identified by
    ///< ANT_PORT_NO where the occured. Note that each antenna port can support
    ///< upto four antennas.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_ant_intf_stat_reg_t;

#define MEM_FB_ANT_INTF_STAT_DEFAULT (0x00000000U)
#define MEM_FB_ANT_INTF_STAT_RD_MASK (0x0000000fU)
#define MEM_FB_ANT_INTF_STAT_WR_MASK (0x00000000U)


///< This field contains the antenna port number on which the error occured.
#define MEM_FB_ANT_INTF_STAT_ANT_PORT_NO_BF_OFF ( 0)
#define MEM_FB_ANT_INTF_STAT_ANT_PORT_NO_BF_WID ( 2)
#define MEM_FB_ANT_INTF_STAT_ANT_PORT_NO_BF_MSK (0x00000003)
#define MEM_FB_ANT_INTF_STAT_ANT_PORT_NO_BF_DEF (0x00000000)

///< This field contains the antenna ID number on the port identified by
///< ANT_PORT_NO where the occured. Note that each antenna port can support
///< upto four antennas.
#define MEM_FB_ANT_INTF_STAT_ANT_ID_NO_BF_OFF ( 2)
#define MEM_FB_ANT_INTF_STAT_ANT_ID_NO_BF_WID ( 2)
#define MEM_FB_ANT_INTF_STAT_ANT_ID_NO_BF_MSK (0x0000000C)
#define MEM_FB_ANT_INTF_STAT_ANT_ID_NO_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_SECTOR_END_PTR[32] register description at address offset 0x300
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/SECTOR_END_PTR
  * End pointer for each sector in the feedback memory.
  */

typedef union {
  struct {
    uint32_t END_PTR : 14;
    ///< . The feedback memory is partitioned into 32 sectors. This field specifies
    ///< the end pointer for the associated sector.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_sector_end_ptr_reg_t;

#define MEM_FB_SECTOR_END_PTR_DEFAULT (0x00000000U)
#define MEM_FB_SECTOR_END_PTR_RD_MASK (0x00003fffU)
#define MEM_FB_SECTOR_END_PTR_WR_MASK (0x00003fffU)


///< . The feedback memory is partitioned into 32 sectors. This field specifies
///< the end pointer for the associated sector.
#define MEM_FB_SECTOR_END_PTR_END_PTR_BF_OFF ( 0)
#define MEM_FB_SECTOR_END_PTR_END_PTR_BF_WID (14)
#define MEM_FB_SECTOR_END_PTR_END_PTR_BF_MSK (0x00003FFF)
#define MEM_FB_SECTOR_END_PTR_END_PTR_BF_DEF (0x00000000)
#define MEM_FB_SECTOR_END_PTR_ARR_SZ0 (32)
#define MEM_FB_SECTOR_END_PTR_ARRAY_STRIDE0 (0x0008)


/** @brief MEM_FB_MAP_MEM_REG_SECTOR_NEXT_PTR[32] register description at address offset 0x304
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/SECTOR_NEXT_PTR
  * Next pointer for each sector in the feedback memory.
  */

typedef union {
  struct {
    uint32_t NEXT_PTR : 14;
    ///< The feedback memory is partitioned into 32 sectors. This field specifies
    ///< the end pointer for the associated sector.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_sector_next_ptr_reg_t;

#define MEM_FB_SECTOR_NEXT_PTR_DEFAULT (0x00000000U)
#define MEM_FB_SECTOR_NEXT_PTR_RD_MASK (0x00003fffU)
#define MEM_FB_SECTOR_NEXT_PTR_WR_MASK (0x00003fffU)


///< The feedback memory is partitioned into 32 sectors. This field specifies
///< the end pointer for the associated sector.
#define MEM_FB_SECTOR_NEXT_PTR_NEXT_PTR_BF_OFF ( 0)
#define MEM_FB_SECTOR_NEXT_PTR_NEXT_PTR_BF_WID (14)
#define MEM_FB_SECTOR_NEXT_PTR_NEXT_PTR_BF_MSK (0x00003FFF)
#define MEM_FB_SECTOR_NEXT_PTR_NEXT_PTR_BF_DEF (0x00000000)
#define MEM_FB_SECTOR_NEXT_PTR_ARR_SZ0 (32)
#define MEM_FB_SECTOR_NEXT_PTR_ARRAY_STRIDE0 (0x0008)


/** @brief MEM_FB_MAP_MEM_REG_BFN_TIMER1_DMA0[2] register description at address offset 0x400
  *
  * Register default value:        0x00001000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_TIMER1_DMA0
  * Timer1 for DMA0 operation
  */

typedef union {
  struct {
    uint32_t TIMER1_VALUE : 32;
    ///< DMA0 operation requires a request pulse to be generated to initiate
    ///< the DMA operation. This needs to be generated periodically and the
    ///< peridocity is controlled by the TIMER1 value. The value is with respect
    ///< to a clock frequency of 983.04MHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
  } ;
  uint32_t value;
} mem_fb_bfn_timer1_dma0_reg_t;

#define MEM_FB_BFN_TIMER1_DMA0_DEFAULT (0x00001000U)
#define MEM_FB_BFN_TIMER1_DMA0_RD_MASK (0xffffffffU)
#define MEM_FB_BFN_TIMER1_DMA0_WR_MASK (0xffffffffU)


///< DMA0 operation requires a request pulse to be generated to initiate
///< the DMA operation. This needs to be generated periodically and the
///< peridocity is controlled by the TIMER1 value. The value is with respect
///< to a clock frequency of 983.04MHz.
#define MEM_FB_BFN_TIMER1_DMA0_TIMER1_VAL_BF_OFF ( 0)
#define MEM_FB_BFN_TIMER1_DMA0_TIMER1_VAL_BF_WID (32)
#define MEM_FB_BFN_TIMER1_DMA0_TIMER1_VAL_BF_MSK (0xFFFFFFFF)
#define MEM_FB_BFN_TIMER1_DMA0_TIMER1_VAL_BF_DEF (0x00001000)
#define MEM_FB_BFN_TIMER1_DMA0_ARR_SZ0 (2)
#define MEM_FB_BFN_TIMER1_DMA0_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_TIMER2_DMA0[2] register description at address offset 0x404
  *
  * Register default value:        0x00001000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_TIMER2_DMA0
  * Timer2 for DMA0 operation
  */

typedef union {
  struct {
    uint32_t TIMER2_VALUE : 32;
    ///< DMA0 operation requires a request pulse to be generated to initiate
    ///< the DMA operation. This needs to be generated periodically and the
    ///< peridocity is controlled by the TIMER2 value. The value is with respect
    ///< to a clock frequency of 983.04MHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
  } ;
  uint32_t value;
} mem_fb_bfn_timer2_dma0_reg_t;

#define MEM_FB_BFN_TIMER2_DMA0_DEFAULT (0x00001000U)
#define MEM_FB_BFN_TIMER2_DMA0_RD_MASK (0xffffffffU)
#define MEM_FB_BFN_TIMER2_DMA0_WR_MASK (0xffffffffU)


///< DMA0 operation requires a request pulse to be generated to initiate
///< the DMA operation. This needs to be generated periodically and the
///< peridocity is controlled by the TIMER2 value. The value is with respect
///< to a clock frequency of 983.04MHz.
#define MEM_FB_BFN_TIMER2_DMA0_TIMER2_VAL_BF_OFF ( 0)
#define MEM_FB_BFN_TIMER2_DMA0_TIMER2_VAL_BF_WID (32)
#define MEM_FB_BFN_TIMER2_DMA0_TIMER2_VAL_BF_MSK (0xFFFFFFFF)
#define MEM_FB_BFN_TIMER2_DMA0_TIMER2_VAL_BF_DEF (0x00001000)
#define MEM_FB_BFN_TIMER2_DMA0_ARR_SZ0 (2)
#define MEM_FB_BFN_TIMER2_DMA0_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_TIMER_SEL_DMA0[2] register description at address offset 0x408
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_TIMER_SEL_DMA0
  * Select which timer to use for DMA0 operation
  */

typedef union {
  struct {
    uint32_t TIMER_SEL : 1;
    ///< DMA0 operation requires a request pulse to be generated to initiate
    ///< the DMA operation. This register bit is used to select either TIMER1
    ///< or TIMER2 to generate these periodic DMA0 requests. 0=>TIMER1, 1=>TIMER2.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_bfn_timer_sel_dma0_reg_t;

#define MEM_FB_BFN_TIMER_SEL_DMA0_DEFAULT (0x00000000U)
#define MEM_FB_BFN_TIMER_SEL_DMA0_RD_MASK (0x00000001U)
#define MEM_FB_BFN_TIMER_SEL_DMA0_WR_MASK (0x00000001U)


///< DMA0 operation requires a request pulse to be generated to initiate
///< the DMA operation. This register bit is used to select either TIMER1
///< or TIMER2 to generate these periodic DMA0 requests. 0=>TIMER1, 1=>TIMER2.
#define MEM_FB_BFN_TIMER_SEL_DMA0_TIMER_SEL_BF_OFF ( 0)
#define MEM_FB_BFN_TIMER_SEL_DMA0_TIMER_SEL_BF_WID ( 1)
#define MEM_FB_BFN_TIMER_SEL_DMA0_TIMER_SEL_BF_MSK (0x00000001)
#define MEM_FB_BFN_TIMER_SEL_DMA0_TIMER_SEL_BF_DEF (0x00000000)
#define MEM_FB_BFN_TIMER_SEL_DMA0_ARR_SZ0 (2)
#define MEM_FB_BFN_TIMER_SEL_DMA0_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_PAUSE_SOFT_DMA0[2] register description at address offset 0x40c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_PAUSE_SOFT_DMA0
  * This is used to pause DMA0 operation.
  */

typedef union {
  struct {
    uint32_t SOFT_PAUSE : 1;
    ///< DMA0 operation requires periodic request pulses to be generated to
    ///< initiate the DMA operation. This register bit can be set to pause
    ///< the generation of these requests.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_bfn_pause_soft_dma0_reg_t;

#define MEM_FB_BFN_PAUSE_SOFT_DMA0_DEFAULT (0x00000000U)
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_RD_MASK (0x00000001U)
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_WR_MASK (0x00000001U)


///< DMA0 operation requires periodic request pulses to be generated to
///< initiate the DMA operation. This register bit can be set to pause
///< the generation of these requests.
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_SOFT_PAUSE_BF_OFF ( 0)
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_SOFT_PAUSE_BF_WID ( 1)
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_SOFT_PAUSE_BF_MSK (0x00000001)
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_SOFT_PAUSE_BF_DEF (0x00000000)
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_ARR_SZ0 (2)
#define MEM_FB_BFN_PAUSE_SOFT_DMA0_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_EXIT_TIMER_DMA0[2] register description at address offset 0x410
  *
  * Register default value:        0xFFFFFFFF
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_EXIT_TIMER_DMA0
  * This is used to check if the DMA0 operation occurs in the specified time.
  */

typedef union {
  struct {
    uint32_t DMA_EXIT_TIMER : 32;
    ///< The design requires that the DMA0 operation complete in a specified
    ///< unit of time. This timer monitors this operation. If the timer expires
    ///< and the DMA0 operation has not completed, it indicates an error in
    ///< the system and an interrupt is generated. The timer is with respect
    ///< to a clock frequency of 983.04MHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFFFFFFFF"
  } ;
  uint32_t value;
} mem_fb_bfn_exit_timer_dma0_reg_t;

#define MEM_FB_BFN_EXIT_TIMER_DMA0_DEFAULT (0xffffffffU)
#define MEM_FB_BFN_EXIT_TIMER_DMA0_RD_MASK (0xffffffffU)
#define MEM_FB_BFN_EXIT_TIMER_DMA0_WR_MASK (0xffffffffU)


///< The design requires that the DMA0 operation complete in a specified
///< unit of time. This timer monitors this operation. If the timer expires
///< and the DMA0 operation has not completed, it indicates an error in
///< the system and an interrupt is generated. The timer is with respect
///< to a clock frequency of 983.04MHz.
#define MEM_FB_BFN_EXIT_TIMER_DMA0_DMA_EXIT_TIMER_BF_OFF ( 0)
#define MEM_FB_BFN_EXIT_TIMER_DMA0_DMA_EXIT_TIMER_BF_WID (32)
#define MEM_FB_BFN_EXIT_TIMER_DMA0_DMA_EXIT_TIMER_BF_MSK (0xFFFFFFFF)
#define MEM_FB_BFN_EXIT_TIMER_DMA0_DMA_EXIT_TIMER_BF_DEF (0xFFFFFFFF)
#define MEM_FB_BFN_EXIT_TIMER_DMA0_ARR_SZ0 (2)
#define MEM_FB_BFN_EXIT_TIMER_DMA0_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_SOFT_PAUSE_ST_DMA0[2] register description at address offset 0x414
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/SOFT_PAUSE_ST_DMA0
  * DMA0 soft reset pause status
  */

typedef union {
  struct {
    uint32_t PAUSE_SOFT_STATUS : 1;
    ///< DMA0 operation can be pause by setting the soft_pause bit. Once hardware
    ///< pauses the DMA operation, it sets this bit which indicates to software
    ///< that the hardware is paused.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_soft_pause_st_dma0_reg_t;

#define MEM_FB_SOFT_PAUSE_ST_DMA0_DEFAULT (0x00000000U)
#define MEM_FB_SOFT_PAUSE_ST_DMA0_RD_MASK (0x00000001U)
#define MEM_FB_SOFT_PAUSE_ST_DMA0_WR_MASK (0x00000000U)


///< DMA0 operation can be pause by setting the soft_pause bit. Once hardware
///< pauses the DMA operation, it sets this bit which indicates to software
///< that the hardware is paused.
#define MEM_FB_SOFT_PAUSE_ST_DMA0_PAUSE_SOFT_STAT_BF_OFF ( 0)
#define MEM_FB_SOFT_PAUSE_ST_DMA0_PAUSE_SOFT_STAT_BF_WID ( 1)
#define MEM_FB_SOFT_PAUSE_ST_DMA0_PAUSE_SOFT_STAT_BF_MSK (0x00000001)
#define MEM_FB_SOFT_PAUSE_ST_DMA0_PAUSE_SOFT_STAT_BF_DEF (0x00000000)
#define MEM_FB_SOFT_PAUSE_ST_DMA0_ARR_SZ0 (2)
#define MEM_FB_SOFT_PAUSE_ST_DMA0_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_HARD_PAUSE_ST_DMA0[2] register description at address offset 0x418
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/HARD_PAUSE_ST_DMA0
  * DMA0 hard reset pause status
  */

typedef union {
  struct {
    uint32_t PAUSE_HARD_STATUS : 1;
    ///< DMA0 operation can be pause by setting the hard_pause bit. Once hardware
    ///< pauses the DMA operation, it sets this bit which indicates to software
    ///< that the hardware is paused.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_hard_pause_st_dma0_reg_t;

#define MEM_FB_HARD_PAUSE_ST_DMA0_DEFAULT (0x00000000U)
#define MEM_FB_HARD_PAUSE_ST_DMA0_RD_MASK (0x00000001U)
#define MEM_FB_HARD_PAUSE_ST_DMA0_WR_MASK (0x00000000U)


///< DMA0 operation can be pause by setting the hard_pause bit. Once hardware
///< pauses the DMA operation, it sets this bit which indicates to software
///< that the hardware is paused.
#define MEM_FB_HARD_PAUSE_ST_DMA0_PAUSE_HARD_STAT_BF_OFF ( 0)
#define MEM_FB_HARD_PAUSE_ST_DMA0_PAUSE_HARD_STAT_BF_WID ( 1)
#define MEM_FB_HARD_PAUSE_ST_DMA0_PAUSE_HARD_STAT_BF_MSK (0x00000001)
#define MEM_FB_HARD_PAUSE_ST_DMA0_PAUSE_HARD_STAT_BF_DEF (0x00000000)
#define MEM_FB_HARD_PAUSE_ST_DMA0_ARR_SZ0 (2)
#define MEM_FB_HARD_PAUSE_ST_DMA0_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_TIMER1_DMA1[2] register description at address offset 0x41c
  *
  * Register default value:        0x00001000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_TIMER1_DMA1
  * Timer1 for DMA1 operation
  */

typedef union {
  struct {
    uint32_t TIMER1_VALUE : 32;
    ///< DMA1 operation requires a request pulse to be generated to initiate
    ///< the DMA operation. This needs to be generated periodically and the
    ///< peridocity is controlled by the TIMER1 value. The value is with respect
    ///< to a clock frequency of 983.04MHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
  } ;
  uint32_t value;
} mem_fb_bfn_timer1_dma1_reg_t;

#define MEM_FB_BFN_TIMER1_DMA1_DEFAULT (0x00001000U)
#define MEM_FB_BFN_TIMER1_DMA1_RD_MASK (0xffffffffU)
#define MEM_FB_BFN_TIMER1_DMA1_WR_MASK (0xffffffffU)


///< DMA1 operation requires a request pulse to be generated to initiate
///< the DMA operation. This needs to be generated periodically and the
///< peridocity is controlled by the TIMER1 value. The value is with respect
///< to a clock frequency of 983.04MHz.
#define MEM_FB_BFN_TIMER1_DMA1_TIMER1_VAL_BF_OFF ( 0)
#define MEM_FB_BFN_TIMER1_DMA1_TIMER1_VAL_BF_WID (32)
#define MEM_FB_BFN_TIMER1_DMA1_TIMER1_VAL_BF_MSK (0xFFFFFFFF)
#define MEM_FB_BFN_TIMER1_DMA1_TIMER1_VAL_BF_DEF (0x00001000)
#define MEM_FB_BFN_TIMER1_DMA1_ARR_SZ0 (2)
#define MEM_FB_BFN_TIMER1_DMA1_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_TIMER2_DMA1[2] register description at address offset 0x420
  *
  * Register default value:        0x00001000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_TIMER2_DMA1
  * Timer2 for DMA1 operation
  */

typedef union {
  struct {
    uint32_t TIMER2_VALUE : 32;
    ///< DMA1 operation requires a request pulse to be generated to initiate
    ///< the DMA operation. This needs to be generated periodically and the
    ///< peridocity is controlled by the TIMER2 value. The value is with respect
    ///< to a clock frequency of 983.04MHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
  } ;
  uint32_t value;
} mem_fb_bfn_timer2_dma1_reg_t;

#define MEM_FB_BFN_TIMER2_DMA1_DEFAULT (0x00001000U)
#define MEM_FB_BFN_TIMER2_DMA1_RD_MASK (0xffffffffU)
#define MEM_FB_BFN_TIMER2_DMA1_WR_MASK (0xffffffffU)


///< DMA1 operation requires a request pulse to be generated to initiate
///< the DMA operation. This needs to be generated periodically and the
///< peridocity is controlled by the TIMER2 value. The value is with respect
///< to a clock frequency of 983.04MHz.
#define MEM_FB_BFN_TIMER2_DMA1_TIMER2_VAL_BF_OFF ( 0)
#define MEM_FB_BFN_TIMER2_DMA1_TIMER2_VAL_BF_WID (32)
#define MEM_FB_BFN_TIMER2_DMA1_TIMER2_VAL_BF_MSK (0xFFFFFFFF)
#define MEM_FB_BFN_TIMER2_DMA1_TIMER2_VAL_BF_DEF (0x00001000)
#define MEM_FB_BFN_TIMER2_DMA1_ARR_SZ0 (2)
#define MEM_FB_BFN_TIMER2_DMA1_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_TIMER_SEL_DMA1[2] register description at address offset 0x424
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_TIMER_SEL_DMA1
  * Select which timer to use for DMA1 operation
  */

typedef union {
  struct {
    uint32_t TIMER_SEL : 1;
    ///< DMA1 operation requires a request pulse to be generated to initiate
    ///< the DMA operation. This register bit is used to select either TIMER1
    ///< or TIMER2 to generate these periodic DMA1 requests.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_bfn_timer_sel_dma1_reg_t;

#define MEM_FB_BFN_TIMER_SEL_DMA1_DEFAULT (0x00000000U)
#define MEM_FB_BFN_TIMER_SEL_DMA1_RD_MASK (0x00000001U)
#define MEM_FB_BFN_TIMER_SEL_DMA1_WR_MASK (0x00000001U)


///< DMA1 operation requires a request pulse to be generated to initiate
///< the DMA operation. This register bit is used to select either TIMER1
///< or TIMER2 to generate these periodic DMA1 requests.
#define MEM_FB_BFN_TIMER_SEL_DMA1_TIMER_SEL_BF_OFF ( 0)
#define MEM_FB_BFN_TIMER_SEL_DMA1_TIMER_SEL_BF_WID ( 1)
#define MEM_FB_BFN_TIMER_SEL_DMA1_TIMER_SEL_BF_MSK (0x00000001)
#define MEM_FB_BFN_TIMER_SEL_DMA1_TIMER_SEL_BF_DEF (0x00000000)
#define MEM_FB_BFN_TIMER_SEL_DMA1_ARR_SZ0 (2)
#define MEM_FB_BFN_TIMER_SEL_DMA1_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_PAUSE_SOFT_DMA1[2] register description at address offset 0x428
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_PAUSE_SOFT_DMA1
  * This is used to pause DMA1 operation.
  */

typedef union {
  struct {
    uint32_t SOFT_PAUSE : 1;
    ///< DMA1 operation requires periodic request pulses to be generated to
    ///< initiate the DMA operation. This register bit can be set to pause
    ///< the generation of these requests.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_bfn_pause_soft_dma1_reg_t;

#define MEM_FB_BFN_PAUSE_SOFT_DMA1_DEFAULT (0x00000000U)
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_RD_MASK (0x00000001U)
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_WR_MASK (0x00000001U)


///< DMA1 operation requires periodic request pulses to be generated to
///< initiate the DMA operation. This register bit can be set to pause
///< the generation of these requests.
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_SOFT_PAUSE_BF_OFF ( 0)
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_SOFT_PAUSE_BF_WID ( 1)
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_SOFT_PAUSE_BF_MSK (0x00000001)
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_SOFT_PAUSE_BF_DEF (0x00000000)
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_ARR_SZ0 (2)
#define MEM_FB_BFN_PAUSE_SOFT_DMA1_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_EXIT_TIMER_DMA1[2] register description at address offset 0x42c
  *
  * Register default value:        0xFFFFFFFF
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_EXIT_TIMER_DMA1
  * This is used to check if the DMA1 operation occurs in the specified time.
  */

typedef union {
  struct {
    uint32_t DMA_EXIT_TIMER : 32;
    ///< The design requires that the DMA1 operation complete in a specified
    ///< unit of time. This timer monitors this operation. If the timer expires
    ///< and the DMA1 operation has not completed, it indicates an error in
    ///< the system and an interrupt is generated. The timer is with respect
    ///< to a clock frequency of 983.04MHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFFFFFFFF"
  } ;
  uint32_t value;
} mem_fb_bfn_exit_timer_dma1_reg_t;

#define MEM_FB_BFN_EXIT_TIMER_DMA1_DEFAULT (0xffffffffU)
#define MEM_FB_BFN_EXIT_TIMER_DMA1_RD_MASK (0xffffffffU)
#define MEM_FB_BFN_EXIT_TIMER_DMA1_WR_MASK (0xffffffffU)


///< The design requires that the DMA1 operation complete in a specified
///< unit of time. This timer monitors this operation. If the timer expires
///< and the DMA1 operation has not completed, it indicates an error in
///< the system and an interrupt is generated. The timer is with respect
///< to a clock frequency of 983.04MHz.
#define MEM_FB_BFN_EXIT_TIMER_DMA1_DMA_EXIT_TIMER_BF_OFF ( 0)
#define MEM_FB_BFN_EXIT_TIMER_DMA1_DMA_EXIT_TIMER_BF_WID (32)
#define MEM_FB_BFN_EXIT_TIMER_DMA1_DMA_EXIT_TIMER_BF_MSK (0xFFFFFFFF)
#define MEM_FB_BFN_EXIT_TIMER_DMA1_DMA_EXIT_TIMER_BF_DEF (0xFFFFFFFF)
#define MEM_FB_BFN_EXIT_TIMER_DMA1_ARR_SZ0 (2)
#define MEM_FB_BFN_EXIT_TIMER_DMA1_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_SOFT_PAUSE_ST_DMA1[2] register description at address offset 0x430
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/SOFT_PAUSE_ST_DMA1
  * DMA1 soft reset pause status
  */

typedef union {
  struct {
    uint32_t PAUSE_SOFT_STATUS : 1;
    ///< DMA1 operation can be pause by setting the soft_pause bit. Once hardware
    ///< pauses the DMA operation, it sets this bit which indicates to software
    ///< that the hardware is paused.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_soft_pause_st_dma1_reg_t;

#define MEM_FB_SOFT_PAUSE_ST_DMA1_DEFAULT (0x00000000U)
#define MEM_FB_SOFT_PAUSE_ST_DMA1_RD_MASK (0x00000001U)
#define MEM_FB_SOFT_PAUSE_ST_DMA1_WR_MASK (0x00000000U)


///< DMA1 operation can be pause by setting the soft_pause bit. Once hardware
///< pauses the DMA operation, it sets this bit which indicates to software
///< that the hardware is paused.
#define MEM_FB_SOFT_PAUSE_ST_DMA1_PAUSE_SOFT_STAT_BF_OFF ( 0)
#define MEM_FB_SOFT_PAUSE_ST_DMA1_PAUSE_SOFT_STAT_BF_WID ( 1)
#define MEM_FB_SOFT_PAUSE_ST_DMA1_PAUSE_SOFT_STAT_BF_MSK (0x00000001)
#define MEM_FB_SOFT_PAUSE_ST_DMA1_PAUSE_SOFT_STAT_BF_DEF (0x00000000)
#define MEM_FB_SOFT_PAUSE_ST_DMA1_ARR_SZ0 (2)
#define MEM_FB_SOFT_PAUSE_ST_DMA1_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_HARD_PAUSE_ST_DMA1[2] register description at address offset 0x434
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/HARD_PAUSE_ST_DMA1
  * DMA1 hard reset pause status
  */

typedef union {
  struct {
    uint32_t PAUSE_HARD_STATUS : 1;
    ///< DMA1 operation can be pause by setting the hard_pause bit. Once hardware
    ///< pauses the DMA operation, it sets this bit which indicates to software
    ///< that the hardware is paused.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_hard_pause_st_dma1_reg_t;

#define MEM_FB_HARD_PAUSE_ST_DMA1_DEFAULT (0x00000000U)
#define MEM_FB_HARD_PAUSE_ST_DMA1_RD_MASK (0x00000001U)
#define MEM_FB_HARD_PAUSE_ST_DMA1_WR_MASK (0x00000000U)


///< DMA1 operation can be pause by setting the hard_pause bit. Once hardware
///< pauses the DMA operation, it sets this bit which indicates to software
///< that the hardware is paused.
#define MEM_FB_HARD_PAUSE_ST_DMA1_PAUSE_HARD_STAT_BF_OFF ( 0)
#define MEM_FB_HARD_PAUSE_ST_DMA1_PAUSE_HARD_STAT_BF_WID ( 1)
#define MEM_FB_HARD_PAUSE_ST_DMA1_PAUSE_HARD_STAT_BF_MSK (0x00000001)
#define MEM_FB_HARD_PAUSE_ST_DMA1_PAUSE_HARD_STAT_BF_DEF (0x00000000)
#define MEM_FB_HARD_PAUSE_ST_DMA1_ARR_SZ0 (2)
#define MEM_FB_HARD_PAUSE_ST_DMA1_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_BFN_STATE_DEBUG[2] register description at address offset 0x438
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/BFN_STATE_DEBUG
  * This register stores the BFN and DMA state machine states for debug.
  */

typedef union {
  struct {
    uint32_t BFN_STATE : 6;
    ///< BFN state machine state. Bits [2:0] are for defined for DMA0 and bits[5:3]
    ///< are defined for DMA1.              Monitor for debug. The following
    ///< states are defined for each DMA:       3'b000: RESET_STATE
    ///< -> This state is entered when the chip reset is asserted.       3'b001:
    ///< ENABLED_STATE      -> This state is entered when the memory feedback
    ///< block is enabled.       3'b011: TRIGGERED_STATE    -> This state is
    ///< entered when a trigger event is detected.       3'b111: WAIT_STATE
    ///< -> This state is entered from the TRIGGERED_STATE and the timer countdown
    ///< starts.       3'b110: INIT_TIMER_STATE   -> This state is entered
    ///< when the timer has counted down to zero.       3'b100: SOFT_PAUSE_STATE
    ///< -> This state is entered when a soft pause event is detected.
    ///< 3'b101: HARD_PAUSE_STATE   -> This state is entered when a hard pause
    ///< event is detected.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DMA_STATE : 6;
    ///< DMA state machine state. Bits [2:0] are for defined for DMA0 and bits[5:3]
    ///< are defined for DMA1.      Monitor for debug. The following states
    ///< are defined for each DMA:      3'b000: RESET_STATE    -> This state
    ///< is entered when the chip reset is asserted.      3'b001: ENABLED_STATE
    ///< -> This state is entered when the memory feedback block is enabled.
    ///< 3'b011: REQ_STATE    -> This state is entered when a trigger event
    ///< is detected from the BFN state machine.      3'b111: FINISH_STATE
    ///< -> This state is entered when the finish and ack signals are asserted
    ///< from the DMA hardware.      3'b110: CONT_STATE   -> This state is
    ///< entered when only the ack signal is assrted from the DMA hardware.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_bfn_state_dbg_reg_t;

#define MEM_FB_BFN_STATE_DBG_DEFAULT (0x00000000U)
#define MEM_FB_BFN_STATE_DBG_RD_MASK (0x00000fffU)
#define MEM_FB_BFN_STATE_DBG_WR_MASK (0x00000000U)


///< BFN state machine state. Bits [2:0] are for defined for DMA0 and bits[5:3]
///< are defined for DMA1.              Monitor for debug. The following
///< states are defined for each DMA:       3'b000: RESET_STATE
///< -> This state is entered when the chip reset is asserted.       3'b001:
///< ENABLED_STATE      -> This state is entered when the memory feedback
///< block is enabled.       3'b011: TRIGGERED_STATE    -> This state is
///< entered when a trigger event is detected.       3'b111: WAIT_STATE
///< -> This state is entered from the TRIGGERED_STATE and the timer countdown
///< starts.       3'b110: INIT_TIMER_STATE   -> This state is entered
///< when the timer has counted down to zero.       3'b100: SOFT_PAUSE_STATE
///< -> This state is entered when a soft pause event is detected.
///< 3'b101: HARD_PAUSE_STATE   -> This state is entered when a hard pause
///< event is detected.
#define MEM_FB_BFN_STATE_DBG_BFN_STATE_BF_OFF ( 0)
#define MEM_FB_BFN_STATE_DBG_BFN_STATE_BF_WID ( 6)
#define MEM_FB_BFN_STATE_DBG_BFN_STATE_BF_MSK (0x0000003F)
#define MEM_FB_BFN_STATE_DBG_BFN_STATE_BF_DEF (0x00000000)

///< DMA state machine state. Bits [2:0] are for defined for DMA0 and bits[5:3]
///< are defined for DMA1.      Monitor for debug. The following states
///< are defined for each DMA:      3'b000: RESET_STATE    -> This state
///< is entered when the chip reset is asserted.      3'b001: ENABLED_STATE
///< -> This state is entered when the memory feedback block is enabled.
///< 3'b011: REQ_STATE    -> This state is entered when a trigger event
///< is detected from the BFN state machine.      3'b111: FINISH_STATE
///< -> This state is entered when the finish and ack signals are asserted
///< from the DMA hardware.      3'b110: CONT_STATE   -> This state is
///< entered when only the ack signal is assrted from the DMA hardware.
#define MEM_FB_BFN_STATE_DBG_DMA_STATE_BF_OFF ( 6)
#define MEM_FB_BFN_STATE_DBG_DMA_STATE_BF_WID ( 6)
#define MEM_FB_BFN_STATE_DBG_DMA_STATE_BF_MSK (0x00000FC0)
#define MEM_FB_BFN_STATE_DBG_DMA_STATE_BF_DEF (0x00000000)
#define MEM_FB_BFN_STATE_DBG_ARR_SZ0 (2)
#define MEM_FB_BFN_STATE_DBG_ARRAY_STRIDE0 (0x0080)


/** @brief MEM_FB_MAP_MEM_REG_ISYNC_MAP_ISYNC_CTRL register description at address offset 0x500
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ISYNC_MAP/ISYNC_CTRL
  * ISYNC Control Register
  */

typedef union {
  struct {
    uint32_t TIMER_CMD : 3;
    ///< When i_isync value is 11, the command programmed in this register
    ///< is executed.  3'b000, 3'b100, 3'b110 -> bfn_lower_cnt is incremented
    ///< with the value in BFN_LOWER_CNT_INC. If the  lower count value equals
    ///< the TEN_MS_CNT value the bfn_upper_cnt value is incremented by 1.
    ///< 3'b001 -> bfn_lower_cnt and bfn_upper_cnt are preset to the value
    ///< in the TIMER_INC_PRE register.  3'b010 -> The internal registers corresponding
    ///< to BFN_LOWER_CNT_INC., TIMER_INC_PRE, TIMER_INC_ADJ  TEN_MS_CNT are
    ///< all initialized to their corresponding input values.  If the current
    ///< bfn_lower_cnt value is equal to the TEN_MS_CNT value, the bfn_upper_cnt
    ///< is incremented by 1. If not, bfn_lower_cnt is incremented by the value
    ///< in BFN_LOWER_CNT_INC.  register.  3'b011 -> Increment the bfn_lower_cnt
    ///< value with the value in the TIMER_INC_PRE register.  3'b101 -> If
    ///< bfn_lower_cnt value equals the TEN_MS_CNT value, reset the bfn_lower_cnt
    ///< to zero and  increment the bfn_upper_cnt by 1. If not, increment bfn_lower_cnt
    ///< by a value  in the BFN_LOWER_CNT_INC. register. A sync_adj_pulse is
    ///< also generated so that when the  bfn_lower_cnt value is equal to the
    ///< TEN_MS_CNT and the bfn_upper_cnt equals timer_cnt_adj  the bfn_lower_cnt
    ///< is preset to the value in TIMER_INC_PRE and the bfn_upper_cnt is
    ///< incremented by the value in TIMER_INC_PRE register.  3'b111 -> The
    ///< current value in the bfn_lower_cnt and bfn_upper_cnt is captured and
    ///< made available  in a register for the application to read.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
    uint32_t LOAD_READ : 1;
    ///< When 1, load BFN count into the manager counter at the first timesync
    ///< pulse, when 0, read BFN count from the Manager BFN counter at every
    ///< timesync pulse.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t BFN_CNT_SAMPLE : 1;
    ///< Write to 1 (regardless of the current value) causes the circuit to
    ///< sample the BFN_CNT and synchronize it into the register clock domain.
    ///< After waiting 3-4 BFN clock cycles plus 3-4 register clock cycles,
    ///< the sample is available to read in the ISYNC_BFN_CNT register
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t SOFT_RESET : 1;
    ///< Soft Reset for the entire AW_isync. Active high.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_isync_ctrl_reg_t;

#define MEM_FB_ISYNC_CTRL_DEFAULT (0x00000000U)
#define MEM_FB_ISYNC_CTRL_RD_MASK (0x00008037U)
#define MEM_FB_ISYNC_CTRL_WR_MASK (0x00008037U)


///< When i_isync value is 11, the command programmed in this register
///< is executed.  3'b000, 3'b100, 3'b110 -> bfn_lower_cnt is incremented
///< with the value in BFN_LOWER_CNT_INC. If the  lower count value equals
///< the TEN_MS_CNT value the bfn_upper_cnt value is incremented by 1.
///< 3'b001 -> bfn_lower_cnt and bfn_upper_cnt are preset to the value
///< in the TIMER_INC_PRE register.  3'b010 -> The internal registers corresponding
///< to BFN_LOWER_CNT_INC., TIMER_INC_PRE, TIMER_INC_ADJ  TEN_MS_CNT are
///< all initialized to their corresponding input values.  If the current
///< bfn_lower_cnt value is equal to the TEN_MS_CNT value, the bfn_upper_cnt
///< is incremented by 1. If not, bfn_lower_cnt is incremented by the value
///< in BFN_LOWER_CNT_INC.  register.  3'b011 -> Increment the bfn_lower_cnt
///< value with the value in the TIMER_INC_PRE register.  3'b101 -> If
///< bfn_lower_cnt value equals the TEN_MS_CNT value, reset the bfn_lower_cnt
///< to zero and  increment the bfn_upper_cnt by 1. If not, increment bfn_lower_cnt
///< by a value  in the BFN_LOWER_CNT_INC. register. A sync_adj_pulse is
///< also generated so that when the  bfn_lower_cnt value is equal to the
///< TEN_MS_CNT and the bfn_upper_cnt equals timer_cnt_adj  the bfn_lower_cnt
///< is preset to the value in TIMER_INC_PRE and the bfn_upper_cnt is
///< incremented by the value in TIMER_INC_PRE register.  3'b111 -> The
///< current value in the bfn_lower_cnt and bfn_upper_cnt is captured and
///< made available  in a register for the application to read.
#define MEM_FB_ISYNC_CTRL_TIMER_CMD_BF_OFF ( 0)
#define MEM_FB_ISYNC_CTRL_TIMER_CMD_BF_WID ( 3)
#define MEM_FB_ISYNC_CTRL_TIMER_CMD_BF_MSK (0x00000007)
#define MEM_FB_ISYNC_CTRL_TIMER_CMD_BF_DEF (0x00000000)

///< When 1, load BFN count into the manager counter at the first timesync
///< pulse, when 0, read BFN count from the Manager BFN counter at every
///< timesync pulse.
#define MEM_FB_ISYNC_CTRL_LOAD_READ_BF_OFF ( 4)
#define MEM_FB_ISYNC_CTRL_LOAD_READ_BF_WID ( 1)
#define MEM_FB_ISYNC_CTRL_LOAD_READ_BF_MSK (0x00000010)
#define MEM_FB_ISYNC_CTRL_LOAD_READ_BF_DEF (0x00000000)

///< Write to 1 (regardless of the current value) causes the circuit to
///< sample the BFN_CNT and synchronize it into the register clock domain.
///< After waiting 3-4 BFN clock cycles plus 3-4 register clock cycles,
///< the sample is available to read in the ISYNC_BFN_CNT register
#define MEM_FB_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_OFF ( 5)
#define MEM_FB_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_WID ( 1)
#define MEM_FB_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_MSK (0x00000020)
#define MEM_FB_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_DEF (0x00000000)

///< Soft Reset for the entire AW_isync. Active high.
#define MEM_FB_ISYNC_CTRL_SOFT_RST_BF_OFF (15)
#define MEM_FB_ISYNC_CTRL_SOFT_RST_BF_WID ( 1)
#define MEM_FB_ISYNC_CTRL_SOFT_RST_BF_MSK (0x00008000)
#define MEM_FB_ISYNC_CTRL_SOFT_RST_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_ISYNC_MAP_ISYNC_LCNT_INC register description at address offset 0x504
  *
  * Register default value:        0x00000001
  * Register full path in IP: mem_fb_map_MEM/reg/ISYNC_MAP/ISYNC_LCNT_INC
  * Isync Lower Count Increment Register
  */

typedef union {
  struct {
    uint32_t BFN_LOWER_CNT_INC : 24;
    ///< Increment for the Offset Counter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_isync_lcnt_inc_reg_t;

#define MEM_FB_ISYNC_LCNT_INC_DEFAULT (0x00000001U)
#define MEM_FB_ISYNC_LCNT_INC_RD_MASK (0x00ffffffU)
#define MEM_FB_ISYNC_LCNT_INC_WR_MASK (0x00ffffffU)


///< Increment for the Offset Counter.
#define MEM_FB_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_OFF ( 0)
#define MEM_FB_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_WID (24)
#define MEM_FB_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_MSK (0x00FFFFFF)
#define MEM_FB_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_DEF (0x00000001)


/** @brief MEM_FB_MAP_MEM_REG_ISYNC_MAP_ISYNC_TEN_MS_CNT register description at address offset 0x508
  *
  * Register default value:        0x0095FFFF
  * Register full path in IP: mem_fb_map_MEM/reg/ISYNC_MAP/ISYNC_TEN_MS_CNT
  * Isync 10ms Counter Register
  */

typedef union {
  struct {
    uint32_t TEN_MS_CNT : 24;
    ///< Number of clock cycles in 10ms (minus 1).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x95FFFF"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_isync_ten_ms_cnt_reg_t;

#define MEM_FB_ISYNC_TEN_MS_CNT_DEFAULT (0x0095ffffU)
#define MEM_FB_ISYNC_TEN_MS_CNT_RD_MASK (0x00ffffffU)
#define MEM_FB_ISYNC_TEN_MS_CNT_WR_MASK (0x00ffffffU)


///< Number of clock cycles in 10ms (minus 1).
#define MEM_FB_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_OFF ( 0)
#define MEM_FB_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_WID (24)
#define MEM_FB_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_MSK (0x00FFFFFF)
#define MEM_FB_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_DEF (0x0095FFFF)


/** @brief MEM_FB_MAP_MEM_REG_ISYNC_MAP_ISYNC_INC_PRE register description at address offset 0x50c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ISYNC_MAP/ISYNC_INC_PRE
  * Isync Timer Increment/Preset Register
  */

typedef union {
  struct {
    uint32_t OFFSET_INCR : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME_INCR : 8;
    ///< Bits [7:0] of the 10ms frame counter.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_isync_inc_pre_reg_t;

#define MEM_FB_ISYNC_INC_PRE_DEFAULT (0x00000000U)
#define MEM_FB_ISYNC_INC_PRE_RD_MASK (0xffffffffU)
#define MEM_FB_ISYNC_INC_PRE_WR_MASK (0xffffffffU)


///< Offset from nearest 10ms frame, in clock cycles.
#define MEM_FB_ISYNC_INC_PRE_OFFSET_INCR_BF_OFF ( 0)
#define MEM_FB_ISYNC_INC_PRE_OFFSET_INCR_BF_WID (24)
#define MEM_FB_ISYNC_INC_PRE_OFFSET_INCR_BF_MSK (0x00FFFFFF)
#define MEM_FB_ISYNC_INC_PRE_OFFSET_INCR_BF_DEF (0x00000000)

///< Bits [7:0] of the 10ms frame counter.
#define MEM_FB_ISYNC_INC_PRE_FRAME_INCR_BF_OFF (24)
#define MEM_FB_ISYNC_INC_PRE_FRAME_INCR_BF_WID ( 8)
#define MEM_FB_ISYNC_INC_PRE_FRAME_INCR_BF_MSK (0xFF000000)
#define MEM_FB_ISYNC_INC_PRE_FRAME_INCR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_ISYNC_MAP_ISYNC_CNT_ADJ register description at address offset 0x510
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ISYNC_MAP/ISYNC_CNT_ADJ
  * Isync Timer Count Adjustment Register
  */

typedef union {
  struct {
    uint32_t FRAME_ADJ : 8;
    ///< Bits [7:0] of the 10ms frame counter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_isync_cnt_adj_reg_t;

#define MEM_FB_ISYNC_CNT_ADJ_DEFAULT (0x00000000U)
#define MEM_FB_ISYNC_CNT_ADJ_RD_MASK (0x000000ffU)
#define MEM_FB_ISYNC_CNT_ADJ_WR_MASK (0x000000ffU)


///< Bits [7:0] of the 10ms frame counter.
#define MEM_FB_ISYNC_CNT_ADJ_FRAME_ADJ_BF_OFF ( 0)
#define MEM_FB_ISYNC_CNT_ADJ_FRAME_ADJ_BF_WID ( 8)
#define MEM_FB_ISYNC_CNT_ADJ_FRAME_ADJ_BF_MSK (0x000000FF)
#define MEM_FB_ISYNC_CNT_ADJ_FRAME_ADJ_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_ISYNC_MAP_ISYNC_BFN_CNT_SYNC register description at address offset 0x514
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ISYNC_MAP/ISYNC_BFN_CNT_SYNC
  * BFN Count Sync
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< Bits [7:0] fo the count of 10ms frames.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_isync_bfn_cnt_sync_reg_t;

#define MEM_FB_ISYNC_BFN_CNT_SYNC_DEFAULT (0x00000000U)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_RD_MASK (0xffffffffU)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_WR_MASK (0x00000000U)


///< Offset from nearest 10ms frame, in clock cycles.
#define MEM_FB_ISYNC_BFN_CNT_SYNC_OFFSET_BF_OFF ( 0)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_OFFSET_BF_WID (24)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_OFFSET_BF_MSK (0x00FFFFFF)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_OFFSET_BF_DEF (0x00000000)

///< Bits [7:0] fo the count of 10ms frames.
#define MEM_FB_ISYNC_BFN_CNT_SYNC_FRAME_BF_OFF (24)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_FRAME_BF_WID ( 8)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_FRAME_BF_MSK (0xFF000000)
#define MEM_FB_ISYNC_BFN_CNT_SYNC_FRAME_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_ISYNC_MAP_ISYNC_BFN_CNT register description at address offset 0x518
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ISYNC_MAP/ISYNC_BFN_CNT
  * BFN Count
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< LSB's of Count of 10ms frames.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_isync_bfn_cnt_reg_t;

#define MEM_FB_ISYNC_BFN_CNT_DEFAULT (0x00000000U)
#define MEM_FB_ISYNC_BFN_CNT_RD_MASK (0xffffffffU)
#define MEM_FB_ISYNC_BFN_CNT_WR_MASK (0x00000000U)


///< Offset from nearest 10ms frame, in clock cycles.
#define MEM_FB_ISYNC_BFN_CNT_OFFSET_BF_OFF ( 0)
#define MEM_FB_ISYNC_BFN_CNT_OFFSET_BF_WID (24)
#define MEM_FB_ISYNC_BFN_CNT_OFFSET_BF_MSK (0x00FFFFFF)
#define MEM_FB_ISYNC_BFN_CNT_OFFSET_BF_DEF (0x00000000)

///< LSB's of Count of 10ms frames.
#define MEM_FB_ISYNC_BFN_CNT_FRAME_BF_OFF (24)
#define MEM_FB_ISYNC_BFN_CNT_FRAME_BF_WID ( 8)
#define MEM_FB_ISYNC_BFN_CNT_FRAME_BF_MSK (0xFF000000)
#define MEM_FB_ISYNC_BFN_CNT_FRAME_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_ABC_BFN_EVENTS_BFNE_CONFIG[8] register description at address offset 0x530
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ABC_BFN_EVENTS/BFNE_CONFIG
  * BFN Event Config Register
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< Set to 1 to enable the operation of the bfn_event module. When running
    ///< in repeat mode, set this back to zero to immediately halt the operation.
    ///< NOte that this must be set to 1 for the force mechanism (See BFN_START
    ///< register) to work.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MODE : 2;
    ///< Selects the mode of operation. Note that the force mechanism can be
    ///< triggered (see BFNE_START) regardless of which mode is selected here.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t OUTPUT_MODE : 1;
    ///< Selects whether the BFN_EVENT output toggles at each event, or produces
    ///< a single cycle pulse.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DEBUG_MODE : 2;
    ///< Controls what appears in BFN_EVENT_STAT DEBUG field, which is 28 bits.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_bfne_cfg_reg_t;

#define MEM_FB_BFNE_CFG_DEFAULT (0x00000000U)
#define MEM_FB_BFNE_CFG_RD_MASK (0x0000003fU)
#define MEM_FB_BFNE_CFG_WR_MASK (0x0000003fU)


///< Set to 1 to enable the operation of the bfn_event module. When running
///< in repeat mode, set this back to zero to immediately halt the operation.
///< NOte that this must be set to 1 for the force mechanism (See BFN_START
///< register) to work.
#define MEM_FB_BFNE_CFG_EN_BF_OFF ( 0)
#define MEM_FB_BFNE_CFG_EN_BF_WID ( 1)
#define MEM_FB_BFNE_CFG_EN_BF_MSK (0x00000001)
#define MEM_FB_BFNE_CFG_EN_BF_DEF (0x00000000)

///< Selects the mode of operation. Note that the force mechanism can be
///< triggered (see BFNE_START) regardless of which mode is selected here.
#define MEM_FB_BFNE_CFG_MODE_BF_OFF ( 1)
#define MEM_FB_BFNE_CFG_MODE_BF_WID ( 2)
#define MEM_FB_BFNE_CFG_MODE_BF_MSK (0x00000006)
#define MEM_FB_BFNE_CFG_MODE_BF_DEF (0x00000000)

///< Selects whether the BFN_EVENT output toggles at each event, or produces
///< a single cycle pulse.
#define MEM_FB_BFNE_CFG_OUTPUT_MODE_BF_OFF ( 3)
#define MEM_FB_BFNE_CFG_OUTPUT_MODE_BF_WID ( 1)
#define MEM_FB_BFNE_CFG_OUTPUT_MODE_BF_MSK (0x00000008)
#define MEM_FB_BFNE_CFG_OUTPUT_MODE_BF_DEF (0x00000000)

///< Controls what appears in BFN_EVENT_STAT DEBUG field, which is 28 bits.
#define MEM_FB_BFNE_CFG_DBG_MODE_BF_OFF ( 4)
#define MEM_FB_BFNE_CFG_DBG_MODE_BF_WID ( 2)
#define MEM_FB_BFNE_CFG_DBG_MODE_BF_MSK (0x00000030)
#define MEM_FB_BFNE_CFG_DBG_MODE_BF_DEF (0x00000000)
#define MEM_FB_BFNE_CFG_ARR_SZ0 (8)
#define MEM_FB_BFNE_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_FB_MAP_MEM_REG_ABC_BFN_EVENTS_BFNE_INCR[8] register description at address offset 0x550
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ABC_BFN_EVENTS/BFNE_INCR
  * BFN Event Increment
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< Count of 10ms frames.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_bfne_incr_reg_t;

#define MEM_FB_BFNE_INCR_DEFAULT (0x00000000U)
#define MEM_FB_BFNE_INCR_RD_MASK (0xffffffffU)
#define MEM_FB_BFNE_INCR_WR_MASK (0xffffffffU)


///< Offset from nearest 10ms frame, in clock cycles.
#define MEM_FB_BFNE_INCR_OFFSET_BF_OFF ( 0)
#define MEM_FB_BFNE_INCR_OFFSET_BF_WID (24)
#define MEM_FB_BFNE_INCR_OFFSET_BF_MSK (0x00FFFFFF)
#define MEM_FB_BFNE_INCR_OFFSET_BF_DEF (0x00000000)

///< Count of 10ms frames.
#define MEM_FB_BFNE_INCR_FRAME_BF_OFF (24)
#define MEM_FB_BFNE_INCR_FRAME_BF_WID ( 8)
#define MEM_FB_BFNE_INCR_FRAME_BF_MSK (0xFF000000)
#define MEM_FB_BFNE_INCR_FRAME_BF_DEF (0x00000000)
#define MEM_FB_BFNE_INCR_ARR_SZ0 (8)
#define MEM_FB_BFNE_INCR_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_FB_MAP_MEM_REG_ABC_BFN_EVENTS_BFNE_START[8] register description at address offset 0x570
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ABC_BFN_EVENTS/BFNE_START
  * BFN Event Start
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< Count of 10ms frames.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_bfne_start_reg_t;

#define MEM_FB_BFNE_START_DEFAULT (0x00000000U)
#define MEM_FB_BFNE_START_RD_MASK (0xffffffffU)
#define MEM_FB_BFNE_START_WR_MASK (0xffffffffU)


///< Offset from nearest 10ms frame, in clock cycles.
#define MEM_FB_BFNE_START_OFFSET_BF_OFF ( 0)
#define MEM_FB_BFNE_START_OFFSET_BF_WID (24)
#define MEM_FB_BFNE_START_OFFSET_BF_MSK (0x00FFFFFF)
#define MEM_FB_BFNE_START_OFFSET_BF_DEF (0x00000000)

///< Count of 10ms frames.
#define MEM_FB_BFNE_START_FRAME_BF_OFF (24)
#define MEM_FB_BFNE_START_FRAME_BF_WID ( 8)
#define MEM_FB_BFNE_START_FRAME_BF_MSK (0xFF000000)
#define MEM_FB_BFNE_START_FRAME_BF_DEF (0x00000000)
#define MEM_FB_BFNE_START_ARR_SZ0 (8)
#define MEM_FB_BFNE_START_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_FB_MAP_MEM_REG_ABC_BFN_EVENTS_BFNE_STAT[8] register description at address offset 0x590
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/ABC_BFN_EVENTS/BFNE_STAT
  * BFN Event Status Register
  */

typedef union {
  struct {
    uint32_t CURRENT_VALUE : 1;
    ///< This bit shows the current output value of the bfn_event module
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t WAITING : 1;
    ///< This bit indicates when the bfn_event module is waiting for the programmed
    ///< bfn_start time. In Repeat mode, this will only toggle low during the
    ///< single cycle of each event, so is not useful.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t DONE : 1;
    ///< This bit indicates that the bfn_module has reached its programmed
    ///< bfn time. In Repeate mode, this will only toggle high during the single
    ///< cycle of each event, so is not usefule.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t DEBUG : 29;
    ///< This field is different based on the DEBUG_MODE setting in the BFNE_CONFIG
    ///< register.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_bfne_stat_reg_t;

#define MEM_FB_BFNE_STAT_DEFAULT (0x00000000U)
#define MEM_FB_BFNE_STAT_RD_MASK (0xffffffffU)
#define MEM_FB_BFNE_STAT_WR_MASK (0x00000000U)


///< This bit shows the current output value of the bfn_event module
#define MEM_FB_BFNE_STAT_CURRENT_VAL_BF_OFF ( 0)
#define MEM_FB_BFNE_STAT_CURRENT_VAL_BF_WID ( 1)
#define MEM_FB_BFNE_STAT_CURRENT_VAL_BF_MSK (0x00000001)
#define MEM_FB_BFNE_STAT_CURRENT_VAL_BF_DEF (0x00000000)

///< This bit indicates when the bfn_event module is waiting for the programmed
///< bfn_start time. In Repeat mode, this will only toggle low during the
///< single cycle of each event, so is not useful.
#define MEM_FB_BFNE_STAT_WAITING_BF_OFF ( 1)
#define MEM_FB_BFNE_STAT_WAITING_BF_WID ( 1)
#define MEM_FB_BFNE_STAT_WAITING_BF_MSK (0x00000002)
#define MEM_FB_BFNE_STAT_WAITING_BF_DEF (0x00000000)

///< This bit indicates that the bfn_module has reached its programmed
///< bfn time. In Repeate mode, this will only toggle high during the single
///< cycle of each event, so is not usefule.
#define MEM_FB_BFNE_STAT_DONE_BF_OFF ( 2)
#define MEM_FB_BFNE_STAT_DONE_BF_WID ( 1)
#define MEM_FB_BFNE_STAT_DONE_BF_MSK (0x00000004)
#define MEM_FB_BFNE_STAT_DONE_BF_DEF (0x00000000)

///< This field is different based on the DEBUG_MODE setting in the BFNE_CONFIG
///< register.
#define MEM_FB_BFNE_STAT_DBG_BF_OFF ( 3)
#define MEM_FB_BFNE_STAT_DBG_BF_WID (29)
#define MEM_FB_BFNE_STAT_DBG_BF_MSK (0xFFFFFFF8)
#define MEM_FB_BFNE_STAT_DBG_BF_DEF (0x00000000)
#define MEM_FB_BFNE_STAT_ARR_SZ0 (8)
#define MEM_FB_BFNE_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_FB_MAP_MEM_REG_DESC_ECC_ERR_INFO[2] register description at address offset 0x600
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DESC_ECC_ERR_INFO
  * ECC error info associated with the descriptor memory
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 12;
    ///< Error Address. This is the captured memory address of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t ERR_SYNDROME : 8;
    ///< Error Syndrome. This is the captured ECC syndrome of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t SBE_COUNT : 4;
    ///< SBE Count. This is the value of the SBE counter, which doesn't roll
    ///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_desc_ecc_err_info_reg_t;

#define MEM_FB_DESC_ECC_ERR_INFO_DEFAULT (0x00000000U)
#define MEM_FB_DESC_ECC_ERR_INFO_RD_MASK (0xf0ff0fffU)
#define MEM_FB_DESC_ECC_ERR_INFO_WR_MASK (0x00000000U)


///< Error Address. This is the captured memory address of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_ADDR_BF_OFF ( 0)
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_ADDR_BF_WID (12)
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_ADDR_BF_MSK (0x00000FFF)
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< Error Syndrome. This is the captured ECC syndrome of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_SYNDROME_BF_OFF (16)
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_SYNDROME_BF_WID ( 8)
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_SYNDROME_BF_MSK (0x00FF0000)
#define MEM_FB_DESC_ECC_ERR_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< SBE Count. This is the value of the SBE counter, which doesn't roll
///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DESC_ECC_ERR_INFO_SBE_CNT_BF_OFF (28)
#define MEM_FB_DESC_ECC_ERR_INFO_SBE_CNT_BF_WID ( 4)
#define MEM_FB_DESC_ECC_ERR_INFO_SBE_CNT_BF_MSK (0xF0000000)
#define MEM_FB_DESC_ECC_ERR_INFO_SBE_CNT_BF_DEF (0x00000000)
#define MEM_FB_DESC_ECC_ERR_INFO_ARR_SZ0 (2)
#define MEM_FB_DESC_ECC_ERR_INFO_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DESC_ECC_CTL[2] register description at address offset 0x604
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DESC_ECC_CTL
  * ECC controls associated with the descriptor memory
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< ECC Force Error Type. This bit indicates the type of ECC errors forced
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< ECC Force Error. When set to 1, this bit enables to insert one ECC
    ///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
    ///< the expected ECC error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
    ///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
    ///< of the corresponding memory slice. This bit retains the last written
    ///< value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< ECC Check and Correction Disable. When set, this bit disables ECC
    ///< checking and correction for the corresponding memory slice. It's used
    ///< for debug and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< ECC Generation Disable. When set, this bit disables ECC generation
    ///< for the corresponding memory slice. It's used for debug and testing
    ///< purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_desc_ecc_ctl_reg_t;

#define MEM_FB_DESC_ECC_CTL_DEFAULT (0x00000000U)
#define MEM_FB_DESC_ECC_CTL_RD_MASK (0x0000003fU)
#define MEM_FB_DESC_ECC_CTL_WR_MASK (0x0000003fU)


///< ECC Force Error Type. This bit indicates the type of ECC errors forced
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define MEM_FB_DESC_ECC_CTL_FORCE_TYPE_BF_OFF ( 0)
#define MEM_FB_DESC_ECC_CTL_FORCE_TYPE_BF_WID ( 1)
#define MEM_FB_DESC_ECC_CTL_FORCE_TYPE_BF_MSK (0x00000001)
#define MEM_FB_DESC_ECC_CTL_FORCE_TYPE_BF_DEF (0x00000000)

///< ECC Force Error. When set to 1, this bit enables to insert one ECC
///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
///< the expected ECC error is seen by hardware.
#define MEM_FB_DESC_ECC_CTL_FORCE_ERR_BF_OFF ( 1)
#define MEM_FB_DESC_ECC_CTL_FORCE_ERR_BF_WID ( 1)
#define MEM_FB_DESC_ECC_CTL_FORCE_ERR_BF_MSK (0x00000002)
#define MEM_FB_DESC_ECC_CTL_FORCE_ERR_BF_DEF (0x00000000)

///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
///< the last written value.
#define MEM_FB_DESC_ECC_CTL_ERR_CLR_BF_OFF ( 2)
#define MEM_FB_DESC_ECC_CTL_ERR_CLR_BF_WID ( 1)
#define MEM_FB_DESC_ECC_CTL_ERR_CLR_BF_MSK (0x00000004)
#define MEM_FB_DESC_ECC_CTL_ERR_CLR_BF_DEF (0x00000000)

///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
///< of the corresponding memory slice. This bit retains the last written
///< value.
#define MEM_FB_DESC_ECC_CTL_CNT_CLR_BF_OFF ( 3)
#define MEM_FB_DESC_ECC_CTL_CNT_CLR_BF_WID ( 1)
#define MEM_FB_DESC_ECC_CTL_CNT_CLR_BF_MSK (0x00000008)
#define MEM_FB_DESC_ECC_CTL_CNT_CLR_BF_DEF (0x00000000)

///< ECC Check and Correction Disable. When set, this bit disables ECC
///< checking and correction for the corresponding memory slice. It's used
///< for debug and testing purpose.
#define MEM_FB_DESC_ECC_CTL_CHK_DIS_BF_OFF ( 4)
#define MEM_FB_DESC_ECC_CTL_CHK_DIS_BF_WID ( 1)
#define MEM_FB_DESC_ECC_CTL_CHK_DIS_BF_MSK (0x00000010)
#define MEM_FB_DESC_ECC_CTL_CHK_DIS_BF_DEF (0x00000000)

///< ECC Generation Disable. When set, this bit disables ECC generation
///< for the corresponding memory slice. It's used for debug and testing
///< purpose.
#define MEM_FB_DESC_ECC_CTL_GEN_DIS_BF_OFF ( 5)
#define MEM_FB_DESC_ECC_CTL_GEN_DIS_BF_WID ( 1)
#define MEM_FB_DESC_ECC_CTL_GEN_DIS_BF_MSK (0x00000020)
#define MEM_FB_DESC_ECC_CTL_GEN_DIS_BF_DEF (0x00000000)
#define MEM_FB_DESC_ECC_CTL_ARR_SZ0 (2)
#define MEM_FB_DESC_ECC_CTL_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DESC_ECC_ERR_STAT[2] register description at address offset 0x608
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DESC_ECC_ERR_STAT
  * ECC stats associated with the descriptor memory
  */

typedef union {
  struct {
    uint32_t SBE : 1;
    ///< ECC Single Bit Error. When set, indicates an ECC single bit error
    ///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 1;
    ///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
    ///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 1;
    ///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
    ///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_desc_ecc_err_stat_reg_t;

#define MEM_FB_DESC_ECC_ERR_STAT_DEFAULT (0x00000000U)
#define MEM_FB_DESC_ECC_ERR_STAT_RD_MASK (0x00000007U)
#define MEM_FB_DESC_ECC_ERR_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. When set, indicates an ECC single bit error
///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_BF_OFF ( 0)
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_BF_WID ( 1)
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_BF_MSK (0x00000001)
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DESC_ECC_ERR_STAT_DBE_BF_OFF ( 1)
#define MEM_FB_DESC_ECC_ERR_STAT_DBE_BF_WID ( 1)
#define MEM_FB_DESC_ECC_ERR_STAT_DBE_BF_MSK (0x00000002)
#define MEM_FB_DESC_ECC_ERR_STAT_DBE_BF_DEF (0x00000000)

///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_CNT_OVFL_BF_OFF ( 2)
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_CNT_OVFL_BF_WID ( 1)
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_CNT_OVFL_BF_MSK (0x00000004)
#define MEM_FB_DESC_ECC_ERR_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)
#define MEM_FB_DESC_ECC_ERR_STAT_ARR_SZ0 (2)
#define MEM_FB_DESC_ECC_ERR_STAT_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DMA0_ECC_ERR_INFO[2] register description at address offset 0x620
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA0_ECC_ERR_INFO
  * ECC error info associated with the DMA0 FIFO memory
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 5;
    ///< Error Address. This is the captured memory address of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
    uint32_t ERR_SYNDROME : 11;
    ///< Error Syndrome. This is the captured ECC syndrome of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
    uint32_t SBE_COUNT : 4;
    ///< SBE Count. This is the value of the SBE counter, which doesn't roll
    ///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dma0_ecc_err_info_reg_t;

#define MEM_FB_DMA0_ECC_ERR_INFO_DEFAULT (0x00000000U)
#define MEM_FB_DMA0_ECC_ERR_INFO_RD_MASK (0xf7ff001fU)
#define MEM_FB_DMA0_ECC_ERR_INFO_WR_MASK (0x00000000U)


///< Error Address. This is the captured memory address of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_ADDR_BF_OFF ( 0)
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_ADDR_BF_WID ( 5)
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_ADDR_BF_MSK (0x0000001F)
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< Error Syndrome. This is the captured ECC syndrome of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_SYNDROME_BF_OFF (16)
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_SYNDROME_BF_WID (11)
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_SYNDROME_BF_MSK (0x07FF0000)
#define MEM_FB_DMA0_ECC_ERR_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< SBE Count. This is the value of the SBE counter, which doesn't roll
///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DMA0_ECC_ERR_INFO_SBE_CNT_BF_OFF (28)
#define MEM_FB_DMA0_ECC_ERR_INFO_SBE_CNT_BF_WID ( 4)
#define MEM_FB_DMA0_ECC_ERR_INFO_SBE_CNT_BF_MSK (0xF0000000)
#define MEM_FB_DMA0_ECC_ERR_INFO_SBE_CNT_BF_DEF (0x00000000)
#define MEM_FB_DMA0_ECC_ERR_INFO_ARR_SZ0 (2)
#define MEM_FB_DMA0_ECC_ERR_INFO_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DMA0_ECC_CTL[2] register description at address offset 0x624
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA0_ECC_CTL
  * ECC controls associated with the DMA0 FIFO memory
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< ECC Force Error Type. This bit indicates the type of ECC errors forced
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< ECC Force Error. When set to 1, this bit enables to insert one ECC
    ///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
    ///< the expected ECC error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
    ///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
    ///< of the corresponding memory slice. This bit retains the last written
    ///< value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< ECC Check and Correction Disable. When set, this bit disables ECC
    ///< checking and correction for the corresponding memory slice. It's used
    ///< for debug and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< ECC Generation Disable. When set, this bit disables ECC generation
    ///< for the corresponding memory slice. It's used for debug and testing
    ///< purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dma0_ecc_ctl_reg_t;

#define MEM_FB_DMA0_ECC_CTL_DEFAULT (0x00000000U)
#define MEM_FB_DMA0_ECC_CTL_RD_MASK (0x0000003fU)
#define MEM_FB_DMA0_ECC_CTL_WR_MASK (0x0000003fU)


///< ECC Force Error Type. This bit indicates the type of ECC errors forced
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define MEM_FB_DMA0_ECC_CTL_FORCE_TYPE_BF_OFF ( 0)
#define MEM_FB_DMA0_ECC_CTL_FORCE_TYPE_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_CTL_FORCE_TYPE_BF_MSK (0x00000001)
#define MEM_FB_DMA0_ECC_CTL_FORCE_TYPE_BF_DEF (0x00000000)

///< ECC Force Error. When set to 1, this bit enables to insert one ECC
///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
///< the expected ECC error is seen by hardware.
#define MEM_FB_DMA0_ECC_CTL_FORCE_ERR_BF_OFF ( 1)
#define MEM_FB_DMA0_ECC_CTL_FORCE_ERR_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_CTL_FORCE_ERR_BF_MSK (0x00000002)
#define MEM_FB_DMA0_ECC_CTL_FORCE_ERR_BF_DEF (0x00000000)

///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
///< the last written value.
#define MEM_FB_DMA0_ECC_CTL_ERR_CLR_BF_OFF ( 2)
#define MEM_FB_DMA0_ECC_CTL_ERR_CLR_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_CTL_ERR_CLR_BF_MSK (0x00000004)
#define MEM_FB_DMA0_ECC_CTL_ERR_CLR_BF_DEF (0x00000000)

///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
///< of the corresponding memory slice. This bit retains the last written
///< value.
#define MEM_FB_DMA0_ECC_CTL_CNT_CLR_BF_OFF ( 3)
#define MEM_FB_DMA0_ECC_CTL_CNT_CLR_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_CTL_CNT_CLR_BF_MSK (0x00000008)
#define MEM_FB_DMA0_ECC_CTL_CNT_CLR_BF_DEF (0x00000000)

///< ECC Check and Correction Disable. When set, this bit disables ECC
///< checking and correction for the corresponding memory slice. It's used
///< for debug and testing purpose.
#define MEM_FB_DMA0_ECC_CTL_CHK_DIS_BF_OFF ( 4)
#define MEM_FB_DMA0_ECC_CTL_CHK_DIS_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_CTL_CHK_DIS_BF_MSK (0x00000010)
#define MEM_FB_DMA0_ECC_CTL_CHK_DIS_BF_DEF (0x00000000)

///< ECC Generation Disable. When set, this bit disables ECC generation
///< for the corresponding memory slice. It's used for debug and testing
///< purpose.
#define MEM_FB_DMA0_ECC_CTL_GEN_DIS_BF_OFF ( 5)
#define MEM_FB_DMA0_ECC_CTL_GEN_DIS_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_CTL_GEN_DIS_BF_MSK (0x00000020)
#define MEM_FB_DMA0_ECC_CTL_GEN_DIS_BF_DEF (0x00000000)
#define MEM_FB_DMA0_ECC_CTL_ARR_SZ0 (2)
#define MEM_FB_DMA0_ECC_CTL_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DMA0_ECC_ERR_STAT[2] register description at address offset 0x628
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA0_ECC_ERR_STAT
  * ECC stats associated with the DMA0 FIFO memory
  */

typedef union {
  struct {
    uint32_t SBE : 1;
    ///< ECC Single Bit Error. When set, indicates an ECC single bit error
    ///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 1;
    ///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
    ///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 1;
    ///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
    ///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dma0_ecc_err_stat_reg_t;

#define MEM_FB_DMA0_ECC_ERR_STAT_DEFAULT (0x00000000U)
#define MEM_FB_DMA0_ECC_ERR_STAT_RD_MASK (0x00000007U)
#define MEM_FB_DMA0_ECC_ERR_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. When set, indicates an ECC single bit error
///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_BF_OFF ( 0)
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_BF_MSK (0x00000001)
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DMA0_ECC_ERR_STAT_DBE_BF_OFF ( 1)
#define MEM_FB_DMA0_ECC_ERR_STAT_DBE_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_ERR_STAT_DBE_BF_MSK (0x00000002)
#define MEM_FB_DMA0_ECC_ERR_STAT_DBE_BF_DEF (0x00000000)

///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_CNT_OVFL_BF_OFF ( 2)
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_CNT_OVFL_BF_WID ( 1)
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_CNT_OVFL_BF_MSK (0x00000004)
#define MEM_FB_DMA0_ECC_ERR_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)
#define MEM_FB_DMA0_ECC_ERR_STAT_ARR_SZ0 (2)
#define MEM_FB_DMA0_ECC_ERR_STAT_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DMA1_ECC_ERR_INFO[2] register description at address offset 0x640
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA1_ECC_ERR_INFO
  * ECC error info associated with the DMA1 FIFO memory
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 5;
    ///< Error Address. This is the captured memory address of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
    uint32_t ERR_SYNDROME : 11;
    ///< Error Syndrome. This is the captured ECC syndrome of the first DBE
    ///< or SBE, but DBE has higher priority and can overwrite captured SBE
    ///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
    uint32_t SBE_COUNT : 4;
    ///< SBE Count. This is the value of the SBE counter, which doesn't roll
    ///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_dma1_ecc_err_info_reg_t;

#define MEM_FB_DMA1_ECC_ERR_INFO_DEFAULT (0x00000000U)
#define MEM_FB_DMA1_ECC_ERR_INFO_RD_MASK (0xf7ff001fU)
#define MEM_FB_DMA1_ECC_ERR_INFO_WR_MASK (0x00000000U)


///< Error Address. This is the captured memory address of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< address. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_ADDR_BF_OFF ( 0)
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_ADDR_BF_WID ( 5)
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_ADDR_BF_MSK (0x0000001F)
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< Error Syndrome. This is the captured ECC syndrome of the first DBE
///< or SBE, but DBE has higher priority and can overwrite captured SBE
///< syndrome. It can be cleared by ERR_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_SYNDROME_BF_OFF (16)
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_SYNDROME_BF_WID (11)
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_SYNDROME_BF_MSK (0x07FF0000)
#define MEM_FB_DMA1_ECC_ERR_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< SBE Count. This is the value of the SBE counter, which doesn't roll
///< over and can be cleared by CNT_CLR bit in the corresponding ECC_CTRL
///< register.
#define MEM_FB_DMA1_ECC_ERR_INFO_SBE_CNT_BF_OFF (28)
#define MEM_FB_DMA1_ECC_ERR_INFO_SBE_CNT_BF_WID ( 4)
#define MEM_FB_DMA1_ECC_ERR_INFO_SBE_CNT_BF_MSK (0xF0000000)
#define MEM_FB_DMA1_ECC_ERR_INFO_SBE_CNT_BF_DEF (0x00000000)
#define MEM_FB_DMA1_ECC_ERR_INFO_ARR_SZ0 (2)
#define MEM_FB_DMA1_ECC_ERR_INFO_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DMA1_ECC_CTL[2] register description at address offset 0x644
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA1_ECC_CTL
  * ECC controls associated with the DMA1 FIFO memory
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< ECC Force Error Type. This bit indicates the type of ECC errors forced
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< ECC Force Error. When set to 1, this bit enables to insert one ECC
    ///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
    ///< the expected ECC error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
    ///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
    ///< of the corresponding memory slice. This bit retains the last written
    ///< value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< ECC Check and Correction Disable. When set, this bit disables ECC
    ///< checking and correction for the corresponding memory slice. It's used
    ///< for debug and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< ECC Generation Disable. When set, this bit disables ECC generation
    ///< for the corresponding memory slice. It's used for debug and testing
    ///< purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dma1_ecc_ctl_reg_t;

#define MEM_FB_DMA1_ECC_CTL_DEFAULT (0x00000000U)
#define MEM_FB_DMA1_ECC_CTL_RD_MASK (0x0000003fU)
#define MEM_FB_DMA1_ECC_CTL_WR_MASK (0x0000003fU)


///< ECC Force Error Type. This bit indicates the type of ECC errors forced
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define MEM_FB_DMA1_ECC_CTL_FORCE_TYPE_BF_OFF ( 0)
#define MEM_FB_DMA1_ECC_CTL_FORCE_TYPE_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_CTL_FORCE_TYPE_BF_MSK (0x00000001)
#define MEM_FB_DMA1_ECC_CTL_FORCE_TYPE_BF_DEF (0x00000000)

///< ECC Force Error. When set to 1, this bit enables to insert one ECC
///< error determined by ECC_FORCE_TYPE. It's automatically cleared when
///< the expected ECC error is seen by hardware.
#define MEM_FB_DMA1_ECC_CTL_FORCE_ERR_BF_OFF ( 1)
#define MEM_FB_DMA1_ECC_CTL_FORCE_ERR_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_CTL_FORCE_ERR_BF_MSK (0x00000002)
#define MEM_FB_DMA1_ECC_CTL_FORCE_ERR_BF_DEF (0x00000000)

///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
///< and ECC_ERR_SYNDROME of the correponding memory slice. This bit retains
///< the last written value.
#define MEM_FB_DMA1_ECC_CTL_ERR_CLR_BF_OFF ( 2)
#define MEM_FB_DMA1_ECC_CTL_ERR_CLR_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_CTL_ERR_CLR_BF_MSK (0x00000004)
#define MEM_FB_DMA1_ECC_CTL_ERR_CLR_BF_DEF (0x00000000)

///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
///< of the corresponding memory slice. This bit retains the last written
///< value.
#define MEM_FB_DMA1_ECC_CTL_CNT_CLR_BF_OFF ( 3)
#define MEM_FB_DMA1_ECC_CTL_CNT_CLR_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_CTL_CNT_CLR_BF_MSK (0x00000008)
#define MEM_FB_DMA1_ECC_CTL_CNT_CLR_BF_DEF (0x00000000)

///< ECC Check and Correction Disable. When set, this bit disables ECC
///< checking and correction for the corresponding memory slice. It's used
///< for debug and testing purpose.
#define MEM_FB_DMA1_ECC_CTL_CHK_DIS_BF_OFF ( 4)
#define MEM_FB_DMA1_ECC_CTL_CHK_DIS_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_CTL_CHK_DIS_BF_MSK (0x00000010)
#define MEM_FB_DMA1_ECC_CTL_CHK_DIS_BF_DEF (0x00000000)

///< ECC Generation Disable. When set, this bit disables ECC generation
///< for the corresponding memory slice. It's used for debug and testing
///< purpose.
#define MEM_FB_DMA1_ECC_CTL_GEN_DIS_BF_OFF ( 5)
#define MEM_FB_DMA1_ECC_CTL_GEN_DIS_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_CTL_GEN_DIS_BF_MSK (0x00000020)
#define MEM_FB_DMA1_ECC_CTL_GEN_DIS_BF_DEF (0x00000000)
#define MEM_FB_DMA1_ECC_CTL_ARR_SZ0 (2)
#define MEM_FB_DMA1_ECC_CTL_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DMA1_ECC_ERR_STAT[2] register description at address offset 0x648
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA1_ECC_ERR_STAT
  * ECC stats associated with the DMA1 FIFO memory
  */

typedef union {
  struct {
    uint32_t SBE : 1;
    ///< ECC Single Bit Error. When set, indicates an ECC single bit error
    ///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 1;
    ///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
    ///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 1;
    ///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
    ///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dma1_ecc_err_stat_reg_t;

#define MEM_FB_DMA1_ECC_ERR_STAT_DEFAULT (0x00000000U)
#define MEM_FB_DMA1_ECC_ERR_STAT_RD_MASK (0x00000007U)
#define MEM_FB_DMA1_ECC_ERR_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. When set, indicates an ECC single bit error
///< was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_BF_OFF ( 0)
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_BF_MSK (0x00000001)
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. When set, indicates an ECC double/multi
///< bit error was detected, and can be cleared by ECC_ERR_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DMA1_ECC_ERR_STAT_DBE_BF_OFF ( 1)
#define MEM_FB_DMA1_ECC_ERR_STAT_DBE_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_ERR_STAT_DBE_BF_MSK (0x00000002)
#define MEM_FB_DMA1_ECC_ERR_STAT_DBE_BF_DEF (0x00000000)

///< ECC SBE Count Overflow. When set, indicates the ECC_SBE_COUNT[3:0]
///< is overflowed. It can be cleared by ECC_CNT_CLR bit in corresponding
///< ECC_CTRL register.
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_CNT_OVFL_BF_OFF ( 2)
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_CNT_OVFL_BF_WID ( 1)
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_CNT_OVFL_BF_MSK (0x00000004)
#define MEM_FB_DMA1_ECC_ERR_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)
#define MEM_FB_DMA1_ECC_ERR_STAT_ARR_SZ0 (2)
#define MEM_FB_DMA1_ECC_ERR_STAT_ARRAY_STRIDE0 (0x0010)


/** @brief MEM_FB_MAP_MEM_REG_DMA_DP_INIT register description at address offset 0x660
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA_DP_INIT
  * DP init request
  */

typedef union {
  struct {
    uint32_t DMA0_INIT_REQ : 1;
    ///< When set, all triggers associated with DMA0 will stop. This bit should
    ///< only be set as part of the Antenna bring-up/down event.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMA1_INIT_REQ : 1;
    ///< When set, all triggers associated with DMA1 will stop. This bit should
    ///< only be set as part of the Antenna bring-up/down event.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dma_dp_init_reg_t;

#define MEM_FB_DMA_DP_INIT_DEFAULT (0x00000000U)
#define MEM_FB_DMA_DP_INIT_RD_MASK (0x00000003U)
#define MEM_FB_DMA_DP_INIT_WR_MASK (0x00000003U)


///< When set, all triggers associated with DMA0 will stop. This bit should
///< only be set as part of the Antenna bring-up/down event.
#define MEM_FB_DMA_DP_INIT_DMA0_INIT_REQ_BF_OFF ( 0)
#define MEM_FB_DMA_DP_INIT_DMA0_INIT_REQ_BF_WID ( 1)
#define MEM_FB_DMA_DP_INIT_DMA0_INIT_REQ_BF_MSK (0x00000001)
#define MEM_FB_DMA_DP_INIT_DMA0_INIT_REQ_BF_DEF (0x00000000)

///< When set, all triggers associated with DMA1 will stop. This bit should
///< only be set as part of the Antenna bring-up/down event.
#define MEM_FB_DMA_DP_INIT_DMA1_INIT_REQ_BF_OFF ( 1)
#define MEM_FB_DMA_DP_INIT_DMA1_INIT_REQ_BF_WID ( 1)
#define MEM_FB_DMA_DP_INIT_DMA1_INIT_REQ_BF_MSK (0x00000002)
#define MEM_FB_DMA_DP_INIT_DMA1_INIT_REQ_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_DMA_DP_INIT_DONE register description at address offset 0x664
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/DMA_DP_INIT_DONE
  * DP init acknowledge
  */

typedef union {
  struct {
    uint32_t DMA0_INIT_ACK : 1;
    ///< This bit is set by the DMA0 hardware when all DMA transfers have ceased
    ///< in response to the DMA0_INIT_REQ bit set in the DMA_DP_INIT register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DMA1_INIT_ACK : 1;
    ///< This bit is set by the DMA1 hardware when all DMA transfers have ceased
    ///< in response to the DMA1_INIT_REQ bit set in the DMA_DP_INIT register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_dma_dp_init_done_reg_t;

#define MEM_FB_DMA_DP_INIT_DONE_DEFAULT (0x00000000U)
#define MEM_FB_DMA_DP_INIT_DONE_RD_MASK (0x00000003U)
#define MEM_FB_DMA_DP_INIT_DONE_WR_MASK (0x00000000U)


///< This bit is set by the DMA0 hardware when all DMA transfers have ceased
///< in response to the DMA0_INIT_REQ bit set in the DMA_DP_INIT register.
#define MEM_FB_DMA_DP_INIT_DONE_DMA0_INIT_ACK_BF_OFF ( 0)
#define MEM_FB_DMA_DP_INIT_DONE_DMA0_INIT_ACK_BF_WID ( 1)
#define MEM_FB_DMA_DP_INIT_DONE_DMA0_INIT_ACK_BF_MSK (0x00000001)
#define MEM_FB_DMA_DP_INIT_DONE_DMA0_INIT_ACK_BF_DEF (0x00000000)

///< This bit is set by the DMA1 hardware when all DMA transfers have ceased
///< in response to the DMA1_INIT_REQ bit set in the DMA_DP_INIT register.
#define MEM_FB_DMA_DP_INIT_DONE_DMA1_INIT_ACK_BF_OFF ( 1)
#define MEM_FB_DMA_DP_INIT_DONE_DMA1_INIT_ACK_BF_WID ( 1)
#define MEM_FB_DMA_DP_INIT_DONE_DMA1_INIT_ACK_BF_MSK (0x00000002)
#define MEM_FB_DMA_DP_INIT_DONE_DMA1_INIT_ACK_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DMA_SEL_HALT register description at address offset 0x680
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DMA_SEL_HALT
  * VEX DMA select/halt
  */

typedef union {
  struct {
    uint32_t DMA0_CH0 : 1;
    ///< This bit should be set when DMA requests from VEX need to be selected
    ///< on DMA0 channel0 as opposed to IQ transfer requests. The bit needs
    ///< to be unset once the DMA accesses are completed.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMA0_CH1 : 1;
    ///< This bit should be set when DMA requests from VEX need to be selected
    ///< on DMA0 channel1 as opposed to IQ transfer requests. The bit needs
    ///< to be unset once the DMA accesses are completed.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DMA1_CH0 : 1;
    ///< This bit should be set when DMA requests from VEX need to be selected
    ///< on DMA1 channel0 as opposed to IQ transfer requests. The bit needs
    ///< to be unset once the DMA accesses are completed.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DMA1_CH1 : 1;
    ///< This bit should be set when DMA requests from VEX need to be selected
    ///< on DMA1 channel1 as opposed to IQ transfer requests. The bit needs
    ///< to be unset once the DMA accesses are completed.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DMA0_HALT : 1;
    ///< This bit in conjunction with the bits in the VEX_CM0_DROP_IDX register
    ///< are used to halt traffic towards the VEX.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t DMA1_HALT : 1;
    ///< This bit in conjunction with the bits in the VEX_CM1_DROP_IDX register
    ///< are used to halt traffic towards the VEX.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_dma_sel_halt_reg_t;

#define MEM_FB_VEX_DMA_SEL_HALT_DEFAULT (0x00000000U)
#define MEM_FB_VEX_DMA_SEL_HALT_RD_MASK (0x0000003fU)
#define MEM_FB_VEX_DMA_SEL_HALT_WR_MASK (0x0000003fU)


///< This bit should be set when DMA requests from VEX need to be selected
///< on DMA0 channel0 as opposed to IQ transfer requests. The bit needs
///< to be unset once the DMA accesses are completed.
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH0_BF_OFF ( 0)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH0_BF_WID ( 1)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH0_BF_MSK (0x00000001)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH0_BF_DEF (0x00000000)

///< This bit should be set when DMA requests from VEX need to be selected
///< on DMA0 channel1 as opposed to IQ transfer requests. The bit needs
///< to be unset once the DMA accesses are completed.
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH1_BF_OFF ( 1)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH1_BF_WID ( 1)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH1_BF_MSK (0x00000002)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_CH1_BF_DEF (0x00000000)

///< This bit should be set when DMA requests from VEX need to be selected
///< on DMA1 channel0 as opposed to IQ transfer requests. The bit needs
///< to be unset once the DMA accesses are completed.
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH0_BF_OFF ( 2)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH0_BF_WID ( 1)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH0_BF_MSK (0x00000004)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH0_BF_DEF (0x00000000)

///< This bit should be set when DMA requests from VEX need to be selected
///< on DMA1 channel1 as opposed to IQ transfer requests. The bit needs
///< to be unset once the DMA accesses are completed.
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH1_BF_OFF ( 3)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH1_BF_WID ( 1)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH1_BF_MSK (0x00000008)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_CH1_BF_DEF (0x00000000)

///< This bit in conjunction with the bits in the VEX_CM0_DROP_IDX register
///< are used to halt traffic towards the VEX.
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_HALT_BF_OFF ( 4)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_HALT_BF_WID ( 1)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_HALT_BF_MSK (0x00000010)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA0_HALT_BF_DEF (0x00000000)

///< This bit in conjunction with the bits in the VEX_CM1_DROP_IDX register
///< are used to halt traffic towards the VEX.
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_HALT_BF_OFF ( 5)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_HALT_BF_WID ( 1)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_HALT_BF_MSK (0x00000020)
#define MEM_FB_VEX_DMA_SEL_HALT_DMA1_HALT_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_MEM_START_ADDR register description at address offset 0x684
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_MEM_START_ADDR
  * VEX memory start address
  */

typedef union {
  struct {
    uint32_t START_ADDR : 22;
    ///< This field specifies the start address of the feed back memory which
    ///< the VEX cores can access.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_mem_start_addr_reg_t;

#define MEM_FB_VEX_MEM_START_ADDR_DEFAULT (0x00000000U)
#define MEM_FB_VEX_MEM_START_ADDR_RD_MASK (0x003fffffU)
#define MEM_FB_VEX_MEM_START_ADDR_WR_MASK (0x003fffffU)


///< This field specifies the start address of the feed back memory which
///< the VEX cores can access.
#define MEM_FB_VEX_MEM_START_ADDR_START_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_MEM_START_ADDR_START_ADDR_BF_WID (22)
#define MEM_FB_VEX_MEM_START_ADDR_START_ADDR_BF_MSK (0x003FFFFF)
#define MEM_FB_VEX_MEM_START_ADDR_START_ADDR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_MEM_END_ADDR register description at address offset 0x688
  *
  * Register default value:        0x000FFFFF
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_MEM_END_ADDR
  * VEX memory end address
  */

typedef union {
  struct {
    uint32_t END_ADDR : 22;
    ///< This field specifies the end address of the feed back memory which
    ///< the VEX cores can access.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFFFFF"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_mem_end_addr_reg_t;

#define MEM_FB_VEX_MEM_END_ADDR_DEFAULT (0x000fffffU)
#define MEM_FB_VEX_MEM_END_ADDR_RD_MASK (0x003fffffU)
#define MEM_FB_VEX_MEM_END_ADDR_WR_MASK (0x003fffffU)


///< This field specifies the end address of the feed back memory which
///< the VEX cores can access.
#define MEM_FB_VEX_MEM_END_ADDR_END_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_MEM_END_ADDR_END_ADDR_BF_WID (22)
#define MEM_FB_VEX_MEM_END_ADDR_END_ADDR_BF_MSK (0x003FFFFF)
#define MEM_FB_VEX_MEM_END_ADDR_END_ADDR_BF_DEF (0x000FFFFF)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DESC_START_ADDR register description at address offset 0x68c
  *
  * Register default value:        0x00110000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DESC_START_ADDR
  * VEX descriptor start address
  */

typedef union {
  struct {
    uint32_t START_ADDR : 22;
    ///< This field specifies the start address of the feed back descriptor
    ///< which the VEX cores can access.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x110000"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_desc_start_addr_reg_t;

#define MEM_FB_VEX_DESC_START_ADDR_DEFAULT (0x00110000U)
#define MEM_FB_VEX_DESC_START_ADDR_RD_MASK (0x003fffffU)
#define MEM_FB_VEX_DESC_START_ADDR_WR_MASK (0x003fffffU)


///< This field specifies the start address of the feed back descriptor
///< which the VEX cores can access.
#define MEM_FB_VEX_DESC_START_ADDR_START_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DESC_START_ADDR_START_ADDR_BF_WID (22)
#define MEM_FB_VEX_DESC_START_ADDR_START_ADDR_BF_MSK (0x003FFFFF)
#define MEM_FB_VEX_DESC_START_ADDR_START_ADDR_BF_DEF (0x00110000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DESC_END_ADDR register description at address offset 0x690
  *
  * Register default value:        0x0011FFFF
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DESC_END_ADDR
  * VEX descriptor end address
  */

typedef union {
  struct {
    uint32_t END_ADDR : 22;
    ///< This field specifies the end address of the feed back descriptor which
    ///< the VEX cores can access.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x11FFFF"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_desc_end_addr_reg_t;

#define MEM_FB_VEX_DESC_END_ADDR_DEFAULT (0x0011ffffU)
#define MEM_FB_VEX_DESC_END_ADDR_RD_MASK (0x003fffffU)
#define MEM_FB_VEX_DESC_END_ADDR_WR_MASK (0x003fffffU)


///< This field specifies the end address of the feed back descriptor which
///< the VEX cores can access.
#define MEM_FB_VEX_DESC_END_ADDR_END_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DESC_END_ADDR_END_ADDR_BF_WID (22)
#define MEM_FB_VEX_DESC_END_ADDR_END_ADDR_BF_MSK (0x003FFFFF)
#define MEM_FB_VEX_DESC_END_ADDR_END_ADDR_BF_DEF (0x0011FFFF)


/** @brief MEM_FB_MAP_MEM_REG_VEX_REG_START_ADDR register description at address offset 0x694
  *
  * Register default value:        0x00101000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_REG_START_ADDR
  * VEX register start address
  */

typedef union {
  struct {
    uint32_t START_ADDR : 22;
    ///< This field specifies the start address of the register space which
    ///< the VEX cores can access.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x101000"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_start_addr_reg_t;

#define MEM_FB_VEX_START_ADDR_DEFAULT (0x00101000U)
#define MEM_FB_VEX_START_ADDR_RD_MASK (0x003fffffU)
#define MEM_FB_VEX_START_ADDR_WR_MASK (0x003fffffU)


///< This field specifies the start address of the register space which
///< the VEX cores can access.
#define MEM_FB_VEX_START_ADDR_START_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_START_ADDR_START_ADDR_BF_WID (22)
#define MEM_FB_VEX_START_ADDR_START_ADDR_BF_MSK (0x003FFFFF)
#define MEM_FB_VEX_START_ADDR_START_ADDR_BF_DEF (0x00101000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_REG_END_ADDR register description at address offset 0x698
  *
  * Register default value:        0x00103FFF
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_REG_END_ADDR
  * VEX register end address
  */

typedef union {
  struct {
    uint32_t END_ADDR : 22;
    ///< This field specifies the end address of the register space which the
    ///< VEX cores can access.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x103FFF"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_end_addr_reg_t;

#define MEM_FB_VEX_END_ADDR_DEFAULT (0x00103fffU)
#define MEM_FB_VEX_END_ADDR_RD_MASK (0x003fffffU)
#define MEM_FB_VEX_END_ADDR_WR_MASK (0x003fffffU)


///< This field specifies the end address of the register space which the
///< VEX cores can access.
#define MEM_FB_VEX_END_ADDR_END_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_END_ADDR_END_ADDR_BF_WID (22)
#define MEM_FB_VEX_END_ADDR_END_ADDR_BF_MSK (0x003FFFFF)
#define MEM_FB_VEX_END_ADDR_END_ADDR_BF_DEF (0x00103FFF)


/** @brief MEM_FB_MAP_MEM_REG_VEX_ADDR_MASK register description at address offset 0x69c
  *
  * Register default value:        0x000FFFFF
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_ADDR_MASK
  * VEX address mask
  */

typedef union {
  struct {
    uint32_t MASK : 26;
    ///< The address received from the VEX is ANDed with the value in this
    ///< field to generate the actual address for the mem_fb block.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFFFFF"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_addr_mask_reg_t;

#define MEM_FB_VEX_ADDR_MASK_DEFAULT (0x000fffffU)
#define MEM_FB_VEX_ADDR_MASK_RD_MASK (0x03ffffffU)
#define MEM_FB_VEX_ADDR_MASK_WR_MASK (0x03ffffffU)


///< The address received from the VEX is ANDed with the value in this
///< field to generate the actual address for the mem_fb block.
#define MEM_FB_VEX_ADDR_MASK_BF_OFF ( 0)
#define MEM_FB_VEX_ADDR_MASK_BF_WID (26)
#define MEM_FB_VEX_ADDR_MASK_BF_MSK (0x03FFFFFF)
#define MEM_FB_VEX_ADDR_MASK_BF_DEF (0x000FFFFF)


/** @brief MEM_FB_MAP_MEM_REG_VEX_CM0_BAD_ADDR register description at address offset 0x6a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_CM0_BAD_ADDR
  * VEX CM0 bad address
  */

typedef union {
  struct {
    uint32_t ADDR : 32;
    ///< If there is a write transaction from the VEX to CM0 which results
    ///< in a bad response code or a missing response the bad address is stored
    ///< in this field.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_vex_cm0_bad_addr_reg_t;

#define MEM_FB_VEX_CM0_BAD_ADDR_DEFAULT (0x00000000U)
#define MEM_FB_VEX_CM0_BAD_ADDR_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_CM0_BAD_ADDR_WR_MASK (0x00000000U)


///< If there is a write transaction from the VEX to CM0 which results
///< in a bad response code or a missing response the bad address is stored
///< in this field.
#define MEM_FB_VEX_CM0_BAD_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_CM0_BAD_ADDR_BF_WID (32)
#define MEM_FB_VEX_CM0_BAD_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_CM0_BAD_ADDR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_CM1_BAD_ADDR register description at address offset 0x6a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_CM1_BAD_ADDR
  * VEX CM1 bad address
  */

typedef union {
  struct {
    uint32_t ADDR : 32;
    ///< If there is a write transaction from the VEX to CM1 which results
    ///< in a bad response code or a missing response the bad address is stored
    ///< in this field.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_vex_cm1_bad_addr_reg_t;

#define MEM_FB_VEX_CM1_BAD_ADDR_DEFAULT (0x00000000U)
#define MEM_FB_VEX_CM1_BAD_ADDR_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_CM1_BAD_ADDR_WR_MASK (0x00000000U)


///< If there is a write transaction from the VEX to CM1 which results
///< in a bad response code or a missing response the bad address is stored
///< in this field.
#define MEM_FB_VEX_CM1_BAD_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_CM1_BAD_ADDR_BF_WID (32)
#define MEM_FB_VEX_CM1_BAD_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_CM1_BAD_ADDR_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_CM0_DROP_IDX register description at address offset 0x6a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_CM0_DROP_IDX
  * VEX CM0 drop index
  */

typedef union {
  struct {
    uint32_t DROP_ENABLE : 32;
    ///< Data from the DMA maps to 32 streams or indices in the common module.
    ///< The indices are determined based on the destination address programmed
    ///< in the descriptor. This register has a drop enable bit per index.
    ///< If a bit corresponding to a particular index is set, DMA data destined
    ///< for that index will be dropped and not sent to the common module.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_vex_cm0_drop_idx_reg_t;

#define MEM_FB_VEX_CM0_DROP_IDX_DEFAULT (0x00000000U)
#define MEM_FB_VEX_CM0_DROP_IDX_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_CM0_DROP_IDX_WR_MASK (0xffffffffU)


///< Data from the DMA maps to 32 streams or indices in the common module.
///< The indices are determined based on the destination address programmed
///< in the descriptor. This register has a drop enable bit per index.
///< If a bit corresponding to a particular index is set, DMA data destined
///< for that index will be dropped and not sent to the common module.
#define MEM_FB_VEX_CM0_DROP_IDX_DROP_EN_BF_OFF ( 0)
#define MEM_FB_VEX_CM0_DROP_IDX_DROP_EN_BF_WID (32)
#define MEM_FB_VEX_CM0_DROP_IDX_DROP_EN_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_CM0_DROP_IDX_DROP_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_CM1_DROP_IDX register description at address offset 0x6ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_CM1_DROP_IDX
  * VEX CM1 drop index
  */

typedef union {
  struct {
    uint32_t DROP_ENABLE : 32;
    ///< Data from the DMA maps to 32 streams or indices in the common module.
    ///< The indices are determined based on the destination address programmed
    ///< in the descriptor. This register has a drop enable bit per index.
    ///< If a bit corresponding to a particular index is set, DMA data destined
    ///< for that index will be dropped and not sent to the common module.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_fb_vex_cm1_drop_idx_reg_t;

#define MEM_FB_VEX_CM1_DROP_IDX_DEFAULT (0x00000000U)
#define MEM_FB_VEX_CM1_DROP_IDX_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_CM1_DROP_IDX_WR_MASK (0xffffffffU)


///< Data from the DMA maps to 32 streams or indices in the common module.
///< The indices are determined based on the destination address programmed
///< in the descriptor. This register has a drop enable bit per index.
///< If a bit corresponding to a particular index is set, DMA data destined
///< for that index will be dropped and not sent to the common module.
#define MEM_FB_VEX_CM1_DROP_IDX_DROP_EN_BF_OFF ( 0)
#define MEM_FB_VEX_CM1_DROP_IDX_DROP_EN_BF_WID (32)
#define MEM_FB_VEX_CM1_DROP_IDX_DROP_EN_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_CM1_DROP_IDX_DROP_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_TIMER register description at address offset 0x6b0
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_TIMER
  * VEX timer value
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VAL : 32;
    ///< Timeout value for the B2H state machine to exit a particular state
    ///< when an expected event does not occur.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFFFF"
  } ;
  uint32_t value;
} mem_fb_vex_timer_reg_t;

#define MEM_FB_VEX_TIMER_DEFAULT (0x0000ffffU)
#define MEM_FB_VEX_TIMER_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_TIMER_WR_MASK (0xffffffffU)


///< Timeout value for the B2H state machine to exit a particular state
///< when an expected event does not occur.
#define MEM_FB_VEX_TIMER_TIMEOUT_VAL_BF_OFF ( 0)
#define MEM_FB_VEX_TIMER_TIMEOUT_VAL_BF_WID (32)
#define MEM_FB_VEX_TIMER_TIMEOUT_VAL_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_TIMER_TIMEOUT_VAL_BF_DEF (0x0000FFFF)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DEBUG register description at address offset 0x6b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DEBUG
  * VEX debug
  */

typedef union {
  struct {
    uint32_t DEBUG_EN : 1;
    ///< When set, this bit helps debug of errors associated with writes from
    ///< the VEX.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_fb_vex_dbg_reg_t;

#define MEM_FB_VEX_DBG_DEFAULT (0x00000000U)
#define MEM_FB_VEX_DBG_RD_MASK (0x00000001U)
#define MEM_FB_VEX_DBG_WR_MASK (0x00000001U)


///< When set, this bit helps debug of errors associated with writes from
///< the VEX.
#define MEM_FB_VEX_DBG_EN_BF_OFF ( 0)
#define MEM_FB_VEX_DBG_EN_BF_WID ( 1)
#define MEM_FB_VEX_DBG_EN_BF_MSK (0x00000001)
#define MEM_FB_VEX_DBG_EN_BF_DEF (0x00000000)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DMA0_CH0_LLP register description at address offset 0x6c0
  *
  * Register default value:        0x00102128
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DMA0_CH0_LLP
  * VEX DMA0_CH0 LLP address
  */

typedef union {
  struct {
    uint32_t LLP_ADDR : 32;
    ///< The VEX cores need to use this address when they need to request a
    ///< DMA operation from mem_fb.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x102128"
  } ;
  uint32_t value;
} mem_fb_vex_dma0_ch0_llp_reg_t;

#define MEM_FB_VEX_DMA0_CH0_LLP_DEFAULT (0x00102128U)
#define MEM_FB_VEX_DMA0_CH0_LLP_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_DMA0_CH0_LLP_WR_MASK (0xffffffffU)


///< The VEX cores need to use this address when they need to request a
///< DMA operation from mem_fb.
#define MEM_FB_VEX_DMA0_CH0_LLP_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DMA0_CH0_LLP_ADDR_BF_WID (32)
#define MEM_FB_VEX_DMA0_CH0_LLP_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_DMA0_CH0_LLP_ADDR_BF_DEF (0x00102128)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DMA0_CH1_LLP register description at address offset 0x6c4
  *
  * Register default value:        0x00102228
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DMA0_CH1_LLP
  * VEX DMA0_CH1 LLP address
  */

typedef union {
  struct {
    uint32_t LLP_ADDR : 32;
    ///< The VEX cores need to use this address when they need to request a
    ///< DMA operation from mem_fb.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x102228"
  } ;
  uint32_t value;
} mem_fb_vex_dma0_ch1_llp_reg_t;

#define MEM_FB_VEX_DMA0_CH1_LLP_DEFAULT (0x00102228U)
#define MEM_FB_VEX_DMA0_CH1_LLP_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_DMA0_CH1_LLP_WR_MASK (0xffffffffU)


///< The VEX cores need to use this address when they need to request a
///< DMA operation from mem_fb.
#define MEM_FB_VEX_DMA0_CH1_LLP_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DMA0_CH1_LLP_ADDR_BF_WID (32)
#define MEM_FB_VEX_DMA0_CH1_LLP_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_DMA0_CH1_LLP_ADDR_BF_DEF (0x00102228)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DMA1_CH0_LLP register description at address offset 0x6c8
  *
  * Register default value:        0x00103128
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DMA1_CH0_LLP
  * VEX DMA1_CH0 LLP address
  */

typedef union {
  struct {
    uint32_t LLP_ADDR : 32;
    ///< The VEX cores need to use this address when they need to request a
    ///< DMA operation from mem_fb.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x103128"
  } ;
  uint32_t value;
} mem_fb_vex_dma1_ch0_llp_reg_t;

#define MEM_FB_VEX_DMA1_CH0_LLP_DEFAULT (0x00103128U)
#define MEM_FB_VEX_DMA1_CH0_LLP_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_DMA1_CH0_LLP_WR_MASK (0xffffffffU)


///< The VEX cores need to use this address when they need to request a
///< DMA operation from mem_fb.
#define MEM_FB_VEX_DMA1_CH0_LLP_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DMA1_CH0_LLP_ADDR_BF_WID (32)
#define MEM_FB_VEX_DMA1_CH0_LLP_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_DMA1_CH0_LLP_ADDR_BF_DEF (0x00103128)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DMA1_CH1_LLP register description at address offset 0x6cc
  *
  * Register default value:        0x00103228
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DMA1_CH1_LLP
  * VEX DMA1_CH1 LLP address
  */

typedef union {
  struct {
    uint32_t LLP_ADDR : 32;
    ///< The VEX cores need to use this address when they need to request a
    ///< DMA operation from mem_fb.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x103228"
  } ;
  uint32_t value;
} mem_fb_vex_dma1_ch1_llp_reg_t;

#define MEM_FB_VEX_DMA1_CH1_LLP_DEFAULT (0x00103228U)
#define MEM_FB_VEX_DMA1_CH1_LLP_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_DMA1_CH1_LLP_WR_MASK (0xffffffffU)


///< The VEX cores need to use this address when they need to request a
///< DMA operation from mem_fb.
#define MEM_FB_VEX_DMA1_CH1_LLP_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DMA1_CH1_LLP_ADDR_BF_WID (32)
#define MEM_FB_VEX_DMA1_CH1_LLP_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_DMA1_CH1_LLP_ADDR_BF_DEF (0x00103228)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DMA0_CH01_EN register description at address offset 0x6d0
  *
  * Register default value:        0x00102018
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DMA0_CH01_EN
  * VEX DMA0 CH01 enable
  */

typedef union {
  struct {
    uint32_t CH01_ADDR : 32;
    ///< mem_fb block uses the value in the field to enable/disable channels
    ///< in DMA0 before writing the CHx_LLP register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x102018"
  } ;
  uint32_t value;
} mem_fb_vex_dma0_ch01_en_reg_t;

#define MEM_FB_VEX_DMA0_CH01_EN_DEFAULT (0x00102018U)
#define MEM_FB_VEX_DMA0_CH01_EN_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_DMA0_CH01_EN_WR_MASK (0xffffffffU)


///< mem_fb block uses the value in the field to enable/disable channels
///< in DMA0 before writing the CHx_LLP register.
#define MEM_FB_VEX_DMA0_CH01_EN_CH01_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DMA0_CH01_EN_CH01_ADDR_BF_WID (32)
#define MEM_FB_VEX_DMA0_CH01_EN_CH01_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_DMA0_CH01_EN_CH01_ADDR_BF_DEF (0x00102018)


/** @brief MEM_FB_MAP_MEM_REG_VEX_DMA1_CH01_EN register description at address offset 0x6d4
  *
  * Register default value:        0x00103018
  * Register full path in IP: mem_fb_map_MEM/reg/VEX_DMA1_CH01_EN
  * VEX DMA1 CH01 enable
  */

typedef union {
  struct {
    uint32_t CH01_ADDR : 32;
    ///< mem_fb block uses the value in the field to enable/disable channels
    ///< in DMA1 before writing the CHx_LLP register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x103018"
  } ;
  uint32_t value;
} mem_fb_vex_dma1_ch01_en_reg_t;

#define MEM_FB_VEX_DMA1_CH01_EN_DEFAULT (0x00103018U)
#define MEM_FB_VEX_DMA1_CH01_EN_RD_MASK (0xffffffffU)
#define MEM_FB_VEX_DMA1_CH01_EN_WR_MASK (0xffffffffU)


///< mem_fb block uses the value in the field to enable/disable channels
///< in DMA1 before writing the CHx_LLP register.
#define MEM_FB_VEX_DMA1_CH01_EN_CH01_ADDR_BF_OFF ( 0)
#define MEM_FB_VEX_DMA1_CH01_EN_CH01_ADDR_BF_WID (32)
#define MEM_FB_VEX_DMA1_CH01_EN_CH01_ADDR_BF_MSK (0xFFFFFFFF)
#define MEM_FB_VEX_DMA1_CH01_EN_CH01_ADDR_BF_DEF (0x00103018)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define MEM_FB_SCRATCH_REG(_BASE) ((mem_fb_scratch_reg_t*) MEM_FB_SCRATCH_ADR(_BASE))
#define MEM_FB_SOFT_RST_REG(_BASE) ((mem_fb_soft_rst_reg_t*) MEM_FB_SOFT_RST_ADR(_BASE))
#define MEM_FB_EN_REG(_BASE) ((mem_fb_en_reg_t*) MEM_FB_EN_ADR(_BASE))
#define MEM_FB_LL_CORRUPT_REG(_BASE) ((mem_fb_ll_corrupt_reg_t*) MEM_FB_LL_CORRUPT_ADR(_BASE))
#define MEM_FB_PWR_DOWN_CTRL_REG(_BASE) ((mem_fb_pwr_down_ctrl_reg_t*) MEM_FB_PWR_DOWN_CTRL_ADR(_BASE))
#define MEM_FB_PWR_DOWN_CTRL_CHAIN_REG(_BASE) ((mem_fb_pwr_down_ctrl_chain_reg_t*) MEM_FB_PWR_DOWN_CTRL_CHAIN_ADR(_BASE))
#define MEM_FB_DMAC_HOLD_REQ_REG(_BASE) ((mem_fb_dmac_hold_req_reg_t*) MEM_FB_DMAC_HOLD_REQ_ADR(_BASE))
#define MEM_FB_DMAC_HOLD_ACK_REG(_BASE) ((mem_fb_dmac_hold_ack_reg_t*) MEM_FB_DMAC_HOLD_ACK_ADR(_BASE))
#define MEM_FB_LA_DBG_SEL_REG(_BASE) ((mem_fb_la_dbg_sel_reg_t*) MEM_FB_LA_DBG_SEL_ADR(_BASE))
#define MEM_FB_DMAC_DBG_CHAN_SEL_REG(_BASE) ((mem_fb_dmac_dbg_chan_sel_reg_t*) MEM_FB_DMAC_DBG_CHAN_SEL_ADR(_BASE))
#define MEM_FB_DMAC_DMA0_DBG_REG(_BASE) ((mem_fb_dmac_dma0_dbg_reg_t*) MEM_FB_DMAC_DMA0_DBG_ADR(_BASE))
#define MEM_FB_DMAC_DMA1_DBG_REG(_BASE) ((mem_fb_dmac_dma1_dbg_reg_t*) MEM_FB_DMAC_DMA1_DBG_ADR(_BASE))
#define MEM_FB_DMAC0_CH_TFR_DONE_CNT_REG(_BASE) ((mem_fb_dmac0_ch_tfr_done_cnt_reg_t*) MEM_FB_DMAC0_CH_TFR_DONE_CNT_ADR(_BASE))
#define MEM_FB_DMAC1_CH_TFR_DONE_CNT_REG(_BASE) ((mem_fb_dmac1_ch_tfr_done_cnt_reg_t*) MEM_FB_DMAC1_CH_TFR_DONE_CNT_ADR(_BASE))
#define MEM_FB_DMAC0_DST_TFR_DONE_CNT_REG(_BASE) ((mem_fb_dmac0_dst_tfr_done_cnt_reg_t*) MEM_FB_DMAC0_DST_TFR_DONE_CNT_ADR(_BASE))
#define MEM_FB_DMAC1_DST_TFR_DONE_CNT_REG(_BASE) ((mem_fb_dmac1_dst_tfr_done_cnt_reg_t*) MEM_FB_DMAC1_DST_TFR_DONE_CNT_ADR(_BASE))
#define MEM_FB_DMAC0_SRC_TFR_DONE_CNT_REG(_BASE) ((mem_fb_dmac0_src_tfr_done_cnt_reg_t*) MEM_FB_DMAC0_SRC_TFR_DONE_CNT_ADR(_BASE))
#define MEM_FB_DMAC1_SRC_TFR_DONE_CNT_REG(_BASE) ((mem_fb_dmac1_src_tfr_done_cnt_reg_t*) MEM_FB_DMAC1_SRC_TFR_DONE_CNT_ADR(_BASE))
#define MEM_FB_TDD_STALL_REG(_BASE) ((mem_fb_tdd_stall_reg_t*) MEM_FB_TDD_STALL_ADR(_BASE))
#define MEM_FB_DMAC0_CH0_PAUSE_CNT_REG(_BASE) ((mem_fb_dmac0_ch0_pause_cnt_reg_t*) MEM_FB_DMAC0_CH0_PAUSE_CNT_ADR(_BASE))
#define MEM_FB_DMAC1_CH0_PAUSE_CNT_REG(_BASE) ((mem_fb_dmac1_ch0_pause_cnt_reg_t*) MEM_FB_DMAC1_CH0_PAUSE_CNT_ADR(_BASE))
#define MEM_FB_DMAC0_CH1_PAUSE_CNT_REG(_BASE) ((mem_fb_dmac0_ch1_pause_cnt_reg_t*) MEM_FB_DMAC0_CH1_PAUSE_CNT_ADR(_BASE))
#define MEM_FB_DMAC1_CH1_PAUSE_CNT_REG(_BASE) ((mem_fb_dmac1_ch1_pause_cnt_reg_t*) MEM_FB_DMAC1_CH1_PAUSE_CNT_ADR(_BASE))
#define MEM_FB_DMAC_LL_INVALID_REG(_BASE) ((mem_fb_dmac_ll_invalid_reg_t*) MEM_FB_DMAC_LL_INVALID_ADR(_BASE))
#define MEM_FB_NSIP_CM0_PKT_LEN_REG(_BASE) ((mem_fb_nsip_cm0_pkt_len_reg_t*) MEM_FB_NSIP_CM0_PKT_LEN_ADR(_BASE))
#define MEM_FB_NSIP_CM1_PKT_LEN_REG(_BASE) ((mem_fb_nsip_cm1_pkt_len_reg_t*) MEM_FB_NSIP_CM1_PKT_LEN_ADR(_BASE))
#define MEM_FB_NSIP_CM_HALT_CFG_REG(_BASE) ((mem_fb_nsip_cm_halt_cfg_reg_t*) MEM_FB_NSIP_CM_HALT_CFG_ADR(_BASE))
#define MEM_FB_NSIP_CM_HALT_STAT_REG(_BASE) ((mem_fb_nsip_cm_halt_stat_reg_t*) MEM_FB_NSIP_CM_HALT_STAT_ADR(_BASE))
#define MEM_FB_NSIP_CM_STATE_DBG_REG(_BASE) ((mem_fb_nsip_cm_state_dbg_reg_t*) MEM_FB_NSIP_CM_STATE_DBG_ADR(_BASE))
#define MEM_FB_INT_HI_AGG_STAT_REG(_BASE) ((mem_fb_int_hi_agg_stat_reg_t*) MEM_FB_INT_HI_AGG_STAT_ADR(_BASE))
#define MEM_FB_INT_LO_AGG_STAT_REG(_BASE) ((mem_fb_int_lo_agg_stat_reg_t*) MEM_FB_INT_LO_AGG_STAT_ADR(_BASE))
#define MEM_FB_INT_FB_STAT_REG(_BASE) ((mem_fb_int_fb_stat_reg_t*) MEM_FB_INT_FB_STAT_ADR(_BASE))
#define MEM_FB_INT_FB_HIGH_EN_REG(_BASE) ((mem_fb_int_fb_high_en_reg_t*) MEM_FB_INT_FB_HIGH_EN_ADR(_BASE))
#define MEM_FB_INT_FB_LOW_EN_REG(_BASE) ((mem_fb_int_fb_low_en_reg_t*) MEM_FB_INT_FB_LOW_EN_ADR(_BASE))
#define MEM_FB_INT_FB_CLR_REG(_BASE) ((mem_fb_int_fb_clr_reg_t*) MEM_FB_INT_FB_CLR_ADR(_BASE))
#define MEM_FB_INT_FB_FORCE_REG(_BASE) ((mem_fb_int_fb_force_reg_t*) MEM_FB_INT_FB_FORCE_ADR(_BASE))
#define MEM_FB_INT_CRUX_STAT_REG(_BASE) ((mem_fb_int_crux_stat_reg_t*) MEM_FB_INT_CRUX_STAT_ADR(_BASE))
#define MEM_FB_INT_CRUX_HIGH_EN_REG(_BASE) ((mem_fb_int_crux_high_en_reg_t*) MEM_FB_INT_CRUX_HIGH_EN_ADR(_BASE))
#define MEM_FB_INT_CRUX_LOW_EN_REG(_BASE) ((mem_fb_int_crux_low_en_reg_t*) MEM_FB_INT_CRUX_LOW_EN_ADR(_BASE))
#define MEM_FB_INT_CRUX_CLR_REG(_BASE) ((mem_fb_int_crux_clr_reg_t*) MEM_FB_INT_CRUX_CLR_ADR(_BASE))
#define MEM_FB_INT_CRUX_FORCE_REG(_BASE) ((mem_fb_int_crux_force_reg_t*) MEM_FB_INT_CRUX_FORCE_ADR(_BASE))
#define MEM_FB_AXI_ECC_ERR_INFO0_REG(_BASE) ((mem_fb_axi_ecc_err_info_reg_t*) MEM_FB_AXI_ECC_ERR_INFO0_ADR(_BASE))
#define MEM_FB_AXI_ECC_CTL0_REG(_BASE) ((mem_fb_axi_ecc_ctl_reg_t*) MEM_FB_AXI_ECC_CTL0_ADR(_BASE))
#define MEM_FB_AXI_ECC_ERR_STAT0_REG(_BASE) ((mem_fb_axi_ecc_err_stat_reg_t*) MEM_FB_AXI_ECC_ERR_STAT0_ADR(_BASE))
#define MEM_FB_AXI_ECC_ERR_INFO1_REG(_BASE) ((mem_fb_axi_ecc_err_info_reg_t*) MEM_FB_AXI_ECC_ERR_INFO1_ADR(_BASE))
#define MEM_FB_AXI_ECC_CTL1_REG(_BASE) ((mem_fb_axi_ecc_ctl_reg_t*) MEM_FB_AXI_ECC_CTL1_ADR(_BASE))
#define MEM_FB_AXI_ECC_ERR_STAT1_REG(_BASE) ((mem_fb_axi_ecc_err_stat_reg_t*) MEM_FB_AXI_ECC_ERR_STAT1_ADR(_BASE))
#define MEM_FB_AXI_ECC_ERR_INFO2_REG(_BASE) ((mem_fb_axi_ecc_err_info_reg_t*) MEM_FB_AXI_ECC_ERR_INFO2_ADR(_BASE))
#define MEM_FB_AXI_ECC_CTL2_REG(_BASE) ((mem_fb_axi_ecc_ctl_reg_t*) MEM_FB_AXI_ECC_CTL2_ADR(_BASE))
#define MEM_FB_AXI_ECC_ERR_STAT2_REG(_BASE) ((mem_fb_axi_ecc_err_stat_reg_t*) MEM_FB_AXI_ECC_ERR_STAT2_ADR(_BASE))
#define MEM_FB_MEM_PTR_PORT0_REG(_BASE) ((mem_fb_mem_ptr_port0_reg_t*) MEM_FB_MEM_PTR_PORT0_ADR(_BASE))
#define MEM_FB_MEM_PTR_PORT1_REG(_BASE) ((mem_fb_mem_ptr_port1_reg_t*) MEM_FB_MEM_PTR_PORT1_ADR(_BASE))
#define MEM_FB_MEM_PTR_PORT2_REG(_BASE) ((mem_fb_mem_ptr_port2_reg_t*) MEM_FB_MEM_PTR_PORT2_ADR(_BASE))
#define MEM_FB_MEM_PTR_PORT3_REG(_BASE) ((mem_fb_mem_ptr_port3_reg_t*) MEM_FB_MEM_PTR_PORT3_ADR(_BASE))
#define MEM_FB_SAMPLE_CNT0_REG(_BASE) ((mem_fb_sample_cnt_reg_t*) MEM_FB_SAMPLE_CNT0_ADR(_BASE))
#define MEM_FB_SAMPLE_CNT1_REG(_BASE) ((mem_fb_sample_cnt_reg_t*) MEM_FB_SAMPLE_CNT1_ADR(_BASE))
#define MEM_FB_SAMPLE_CNT2_REG(_BASE) ((mem_fb_sample_cnt_reg_t*) MEM_FB_SAMPLE_CNT2_ADR(_BASE))
#define MEM_FB_SAMPLE_CNT3_REG(_BASE) ((mem_fb_sample_cnt_reg_t*) MEM_FB_SAMPLE_CNT3_ADR(_BASE))
#define MEM_FB_ANT_INTF_STAT_REG(_BASE) ((mem_fb_ant_intf_stat_reg_t*) MEM_FB_ANT_INTF_STAT_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR0_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR0_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR0_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR0_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR1_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR1_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR1_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR1_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR2_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR2_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR2_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR2_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR3_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR3_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR3_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR3_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR4_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR4_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR4_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR4_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR5_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR5_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR5_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR5_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR6_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR6_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR6_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR6_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR7_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR7_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR7_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR7_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR8_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR8_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR8_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR8_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR9_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR9_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR9_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR9_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR10_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR10_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR10_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR10_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR11_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR11_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR11_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR11_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR12_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR12_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR12_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR12_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR13_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR13_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR13_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR13_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR14_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR14_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR14_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR14_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR15_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR15_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR15_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR15_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR16_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR16_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR16_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR16_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR17_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR17_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR17_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR17_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR18_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR18_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR18_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR18_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR19_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR19_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR19_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR19_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR20_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR20_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR20_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR20_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR21_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR21_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR21_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR21_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR22_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR22_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR22_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR22_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR23_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR23_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR23_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR23_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR24_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR24_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR24_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR24_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR25_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR25_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR25_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR25_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR26_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR26_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR26_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR26_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR27_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR27_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR27_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR27_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR28_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR28_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR28_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR28_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR29_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR29_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR29_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR29_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR30_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR30_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR30_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR30_ADR(_BASE))
#define MEM_FB_SECTOR_END_PTR31_REG(_BASE) ((mem_fb_sector_end_ptr_reg_t*) MEM_FB_SECTOR_END_PTR31_ADR(_BASE))
#define MEM_FB_SECTOR_NEXT_PTR31_REG(_BASE) ((mem_fb_sector_next_ptr_reg_t*) MEM_FB_SECTOR_NEXT_PTR31_ADR(_BASE))
#define MEM_FB_BFN_TIMER1_DMA00_REG(_BASE) ((mem_fb_bfn_timer1_dma0_reg_t*) MEM_FB_BFN_TIMER1_DMA00_ADR(_BASE))
#define MEM_FB_BFN_TIMER2_DMA00_REG(_BASE) ((mem_fb_bfn_timer2_dma0_reg_t*) MEM_FB_BFN_TIMER2_DMA00_ADR(_BASE))
#define MEM_FB_BFN_TIMER_SEL_DMA00_REG(_BASE) ((mem_fb_bfn_timer_sel_dma0_reg_t*) MEM_FB_BFN_TIMER_SEL_DMA00_ADR(_BASE))
#define MEM_FB_BFN_PAUSE_SOFT_DMA00_REG(_BASE) ((mem_fb_bfn_pause_soft_dma0_reg_t*) MEM_FB_BFN_PAUSE_SOFT_DMA00_ADR(_BASE))
#define MEM_FB_BFN_EXIT_TIMER_DMA00_REG(_BASE) ((mem_fb_bfn_exit_timer_dma0_reg_t*) MEM_FB_BFN_EXIT_TIMER_DMA00_ADR(_BASE))
#define MEM_FB_SOFT_PAUSE_ST_DMA00_REG(_BASE) ((mem_fb_soft_pause_st_dma0_reg_t*) MEM_FB_SOFT_PAUSE_ST_DMA00_ADR(_BASE))
#define MEM_FB_HARD_PAUSE_ST_DMA00_REG(_BASE) ((mem_fb_hard_pause_st_dma0_reg_t*) MEM_FB_HARD_PAUSE_ST_DMA00_ADR(_BASE))
#define MEM_FB_BFN_TIMER1_DMA10_REG(_BASE) ((mem_fb_bfn_timer1_dma1_reg_t*) MEM_FB_BFN_TIMER1_DMA10_ADR(_BASE))
#define MEM_FB_BFN_TIMER2_DMA10_REG(_BASE) ((mem_fb_bfn_timer2_dma1_reg_t*) MEM_FB_BFN_TIMER2_DMA10_ADR(_BASE))
#define MEM_FB_BFN_TIMER_SEL_DMA10_REG(_BASE) ((mem_fb_bfn_timer_sel_dma1_reg_t*) MEM_FB_BFN_TIMER_SEL_DMA10_ADR(_BASE))
#define MEM_FB_BFN_PAUSE_SOFT_DMA10_REG(_BASE) ((mem_fb_bfn_pause_soft_dma1_reg_t*) MEM_FB_BFN_PAUSE_SOFT_DMA10_ADR(_BASE))
#define MEM_FB_BFN_EXIT_TIMER_DMA10_REG(_BASE) ((mem_fb_bfn_exit_timer_dma1_reg_t*) MEM_FB_BFN_EXIT_TIMER_DMA10_ADR(_BASE))
#define MEM_FB_SOFT_PAUSE_ST_DMA10_REG(_BASE) ((mem_fb_soft_pause_st_dma1_reg_t*) MEM_FB_SOFT_PAUSE_ST_DMA10_ADR(_BASE))
#define MEM_FB_HARD_PAUSE_ST_DMA10_REG(_BASE) ((mem_fb_hard_pause_st_dma1_reg_t*) MEM_FB_HARD_PAUSE_ST_DMA10_ADR(_BASE))
#define MEM_FB_BFN_STATE_DBG0_REG(_BASE) ((mem_fb_bfn_state_dbg_reg_t*) MEM_FB_BFN_STATE_DBG0_ADR(_BASE))
#define MEM_FB_BFN_TIMER1_DMA01_REG(_BASE) ((mem_fb_bfn_timer1_dma0_reg_t*) MEM_FB_BFN_TIMER1_DMA01_ADR(_BASE))
#define MEM_FB_BFN_TIMER2_DMA01_REG(_BASE) ((mem_fb_bfn_timer2_dma0_reg_t*) MEM_FB_BFN_TIMER2_DMA01_ADR(_BASE))
#define MEM_FB_BFN_TIMER_SEL_DMA01_REG(_BASE) ((mem_fb_bfn_timer_sel_dma0_reg_t*) MEM_FB_BFN_TIMER_SEL_DMA01_ADR(_BASE))
#define MEM_FB_BFN_PAUSE_SOFT_DMA01_REG(_BASE) ((mem_fb_bfn_pause_soft_dma0_reg_t*) MEM_FB_BFN_PAUSE_SOFT_DMA01_ADR(_BASE))
#define MEM_FB_BFN_EXIT_TIMER_DMA01_REG(_BASE) ((mem_fb_bfn_exit_timer_dma0_reg_t*) MEM_FB_BFN_EXIT_TIMER_DMA01_ADR(_BASE))
#define MEM_FB_SOFT_PAUSE_ST_DMA01_REG(_BASE) ((mem_fb_soft_pause_st_dma0_reg_t*) MEM_FB_SOFT_PAUSE_ST_DMA01_ADR(_BASE))
#define MEM_FB_HARD_PAUSE_ST_DMA01_REG(_BASE) ((mem_fb_hard_pause_st_dma0_reg_t*) MEM_FB_HARD_PAUSE_ST_DMA01_ADR(_BASE))
#define MEM_FB_BFN_TIMER1_DMA11_REG(_BASE) ((mem_fb_bfn_timer1_dma1_reg_t*) MEM_FB_BFN_TIMER1_DMA11_ADR(_BASE))
#define MEM_FB_BFN_TIMER2_DMA11_REG(_BASE) ((mem_fb_bfn_timer2_dma1_reg_t*) MEM_FB_BFN_TIMER2_DMA11_ADR(_BASE))
#define MEM_FB_BFN_TIMER_SEL_DMA11_REG(_BASE) ((mem_fb_bfn_timer_sel_dma1_reg_t*) MEM_FB_BFN_TIMER_SEL_DMA11_ADR(_BASE))
#define MEM_FB_BFN_PAUSE_SOFT_DMA11_REG(_BASE) ((mem_fb_bfn_pause_soft_dma1_reg_t*) MEM_FB_BFN_PAUSE_SOFT_DMA11_ADR(_BASE))
#define MEM_FB_BFN_EXIT_TIMER_DMA11_REG(_BASE) ((mem_fb_bfn_exit_timer_dma1_reg_t*) MEM_FB_BFN_EXIT_TIMER_DMA11_ADR(_BASE))
#define MEM_FB_SOFT_PAUSE_ST_DMA11_REG(_BASE) ((mem_fb_soft_pause_st_dma1_reg_t*) MEM_FB_SOFT_PAUSE_ST_DMA11_ADR(_BASE))
#define MEM_FB_HARD_PAUSE_ST_DMA11_REG(_BASE) ((mem_fb_hard_pause_st_dma1_reg_t*) MEM_FB_HARD_PAUSE_ST_DMA11_ADR(_BASE))
#define MEM_FB_BFN_STATE_DBG1_REG(_BASE) ((mem_fb_bfn_state_dbg_reg_t*) MEM_FB_BFN_STATE_DBG1_ADR(_BASE))
#define MEM_FB_ISYNC_CTRL_REG(_BASE) ((mem_fb_isync_ctrl_reg_t*) MEM_FB_ISYNC_CTRL_ADR(_BASE))
#define MEM_FB_ISYNC_LCNT_INC_REG(_BASE) ((mem_fb_isync_lcnt_inc_reg_t*) MEM_FB_ISYNC_LCNT_INC_ADR(_BASE))
#define MEM_FB_ISYNC_TEN_MS_CNT_REG(_BASE) ((mem_fb_isync_ten_ms_cnt_reg_t*) MEM_FB_ISYNC_TEN_MS_CNT_ADR(_BASE))
#define MEM_FB_ISYNC_INC_PRE_REG(_BASE) ((mem_fb_isync_inc_pre_reg_t*) MEM_FB_ISYNC_INC_PRE_ADR(_BASE))
#define MEM_FB_ISYNC_CNT_ADJ_REG(_BASE) ((mem_fb_isync_cnt_adj_reg_t*) MEM_FB_ISYNC_CNT_ADJ_ADR(_BASE))
#define MEM_FB_ISYNC_BFN_CNT_SYNC_REG(_BASE) ((mem_fb_isync_bfn_cnt_sync_reg_t*) MEM_FB_ISYNC_BFN_CNT_SYNC_ADR(_BASE))
#define MEM_FB_ISYNC_BFN_CNT_REG(_BASE) ((mem_fb_isync_bfn_cnt_reg_t*) MEM_FB_ISYNC_BFN_CNT_ADR(_BASE))
#define MEM_FB_BFNE_CFG0_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG0_ADR(_BASE))
#define MEM_FB_BFNE_CFG1_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG1_ADR(_BASE))
#define MEM_FB_BFNE_CFG2_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG2_ADR(_BASE))
#define MEM_FB_BFNE_CFG3_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG3_ADR(_BASE))
#define MEM_FB_BFNE_CFG4_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG4_ADR(_BASE))
#define MEM_FB_BFNE_CFG5_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG5_ADR(_BASE))
#define MEM_FB_BFNE_CFG6_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG6_ADR(_BASE))
#define MEM_FB_BFNE_CFG7_REG(_BASE) ((mem_fb_bfne_cfg_reg_t*) MEM_FB_BFNE_CFG7_ADR(_BASE))
#define MEM_FB_BFNE_INCR0_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR0_ADR(_BASE))
#define MEM_FB_BFNE_INCR1_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR1_ADR(_BASE))
#define MEM_FB_BFNE_INCR2_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR2_ADR(_BASE))
#define MEM_FB_BFNE_INCR3_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR3_ADR(_BASE))
#define MEM_FB_BFNE_INCR4_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR4_ADR(_BASE))
#define MEM_FB_BFNE_INCR5_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR5_ADR(_BASE))
#define MEM_FB_BFNE_INCR6_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR6_ADR(_BASE))
#define MEM_FB_BFNE_INCR7_REG(_BASE) ((mem_fb_bfne_incr_reg_t*) MEM_FB_BFNE_INCR7_ADR(_BASE))
#define MEM_FB_BFNE_START0_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START0_ADR(_BASE))
#define MEM_FB_BFNE_START1_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START1_ADR(_BASE))
#define MEM_FB_BFNE_START2_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START2_ADR(_BASE))
#define MEM_FB_BFNE_START3_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START3_ADR(_BASE))
#define MEM_FB_BFNE_START4_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START4_ADR(_BASE))
#define MEM_FB_BFNE_START5_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START5_ADR(_BASE))
#define MEM_FB_BFNE_START6_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START6_ADR(_BASE))
#define MEM_FB_BFNE_START7_REG(_BASE) ((mem_fb_bfne_start_reg_t*) MEM_FB_BFNE_START7_ADR(_BASE))
#define MEM_FB_BFNE_STAT0_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT0_ADR(_BASE))
#define MEM_FB_BFNE_STAT1_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT1_ADR(_BASE))
#define MEM_FB_BFNE_STAT2_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT2_ADR(_BASE))
#define MEM_FB_BFNE_STAT3_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT3_ADR(_BASE))
#define MEM_FB_BFNE_STAT4_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT4_ADR(_BASE))
#define MEM_FB_BFNE_STAT5_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT5_ADR(_BASE))
#define MEM_FB_BFNE_STAT6_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT6_ADR(_BASE))
#define MEM_FB_BFNE_STAT7_REG(_BASE) ((mem_fb_bfne_stat_reg_t*) MEM_FB_BFNE_STAT7_ADR(_BASE))
#define MEM_FB_DESC_ECC_ERR_INFO0_REG(_BASE) ((mem_fb_desc_ecc_err_info_reg_t*) MEM_FB_DESC_ECC_ERR_INFO0_ADR(_BASE))
#define MEM_FB_DESC_ECC_CTL0_REG(_BASE) ((mem_fb_desc_ecc_ctl_reg_t*) MEM_FB_DESC_ECC_CTL0_ADR(_BASE))
#define MEM_FB_DESC_ECC_ERR_STAT0_REG(_BASE) ((mem_fb_desc_ecc_err_stat_reg_t*) MEM_FB_DESC_ECC_ERR_STAT0_ADR(_BASE))
#define MEM_FB_DESC_ECC_ERR_INFO1_REG(_BASE) ((mem_fb_desc_ecc_err_info_reg_t*) MEM_FB_DESC_ECC_ERR_INFO1_ADR(_BASE))
#define MEM_FB_DESC_ECC_CTL1_REG(_BASE) ((mem_fb_desc_ecc_ctl_reg_t*) MEM_FB_DESC_ECC_CTL1_ADR(_BASE))
#define MEM_FB_DESC_ECC_ERR_STAT1_REG(_BASE) ((mem_fb_desc_ecc_err_stat_reg_t*) MEM_FB_DESC_ECC_ERR_STAT1_ADR(_BASE))
#define MEM_FB_DMA0_ECC_ERR_INFO0_REG(_BASE) ((mem_fb_dma0_ecc_err_info_reg_t*) MEM_FB_DMA0_ECC_ERR_INFO0_ADR(_BASE))
#define MEM_FB_DMA0_ECC_CTL0_REG(_BASE) ((mem_fb_dma0_ecc_ctl_reg_t*) MEM_FB_DMA0_ECC_CTL0_ADR(_BASE))
#define MEM_FB_DMA0_ECC_ERR_STAT0_REG(_BASE) ((mem_fb_dma0_ecc_err_stat_reg_t*) MEM_FB_DMA0_ECC_ERR_STAT0_ADR(_BASE))
#define MEM_FB_DMA0_ECC_ERR_INFO1_REG(_BASE) ((mem_fb_dma0_ecc_err_info_reg_t*) MEM_FB_DMA0_ECC_ERR_INFO1_ADR(_BASE))
#define MEM_FB_DMA0_ECC_CTL1_REG(_BASE) ((mem_fb_dma0_ecc_ctl_reg_t*) MEM_FB_DMA0_ECC_CTL1_ADR(_BASE))
#define MEM_FB_DMA0_ECC_ERR_STAT1_REG(_BASE) ((mem_fb_dma0_ecc_err_stat_reg_t*) MEM_FB_DMA0_ECC_ERR_STAT1_ADR(_BASE))
#define MEM_FB_DMA1_ECC_ERR_INFO0_REG(_BASE) ((mem_fb_dma1_ecc_err_info_reg_t*) MEM_FB_DMA1_ECC_ERR_INFO0_ADR(_BASE))
#define MEM_FB_DMA1_ECC_CTL0_REG(_BASE) ((mem_fb_dma1_ecc_ctl_reg_t*) MEM_FB_DMA1_ECC_CTL0_ADR(_BASE))
#define MEM_FB_DMA1_ECC_ERR_STAT0_REG(_BASE) ((mem_fb_dma1_ecc_err_stat_reg_t*) MEM_FB_DMA1_ECC_ERR_STAT0_ADR(_BASE))
#define MEM_FB_DMA1_ECC_ERR_INFO1_REG(_BASE) ((mem_fb_dma1_ecc_err_info_reg_t*) MEM_FB_DMA1_ECC_ERR_INFO1_ADR(_BASE))
#define MEM_FB_DMA1_ECC_CTL1_REG(_BASE) ((mem_fb_dma1_ecc_ctl_reg_t*) MEM_FB_DMA1_ECC_CTL1_ADR(_BASE))
#define MEM_FB_DMA1_ECC_ERR_STAT1_REG(_BASE) ((mem_fb_dma1_ecc_err_stat_reg_t*) MEM_FB_DMA1_ECC_ERR_STAT1_ADR(_BASE))
#define MEM_FB_DMA_DP_INIT_REG(_BASE) ((mem_fb_dma_dp_init_reg_t*) MEM_FB_DMA_DP_INIT_ADR(_BASE))
#define MEM_FB_DMA_DP_INIT_DONE_REG(_BASE) ((mem_fb_dma_dp_init_done_reg_t*) MEM_FB_DMA_DP_INIT_DONE_ADR(_BASE))
#define MEM_FB_VEX_DMA_SEL_HALT_REG(_BASE) ((mem_fb_vex_dma_sel_halt_reg_t*) MEM_FB_VEX_DMA_SEL_HALT_ADR(_BASE))
#define MEM_FB_VEX_MEM_START_ADDR_REG(_BASE) ((mem_fb_vex_mem_start_addr_reg_t*) MEM_FB_VEX_MEM_START_ADDR_ADR(_BASE))
#define MEM_FB_VEX_MEM_END_ADDR_REG(_BASE) ((mem_fb_vex_mem_end_addr_reg_t*) MEM_FB_VEX_MEM_END_ADDR_ADR(_BASE))
#define MEM_FB_VEX_DESC_START_ADDR_REG(_BASE) ((mem_fb_vex_desc_start_addr_reg_t*) MEM_FB_VEX_DESC_START_ADDR_ADR(_BASE))
#define MEM_FB_VEX_DESC_END_ADDR_REG(_BASE) ((mem_fb_vex_desc_end_addr_reg_t*) MEM_FB_VEX_DESC_END_ADDR_ADR(_BASE))
#define MEM_FB_VEX_START_ADDR_REG(_BASE) ((mem_fb_vex_start_addr_reg_t*) MEM_FB_VEX_START_ADDR_ADR(_BASE))
#define MEM_FB_VEX_END_ADDR_REG(_BASE) ((mem_fb_vex_end_addr_reg_t*) MEM_FB_VEX_END_ADDR_ADR(_BASE))
#define MEM_FB_VEX_ADDR_MASK_REG(_BASE) ((mem_fb_vex_addr_mask_reg_t*) MEM_FB_VEX_ADDR_MASK_ADR(_BASE))
#define MEM_FB_VEX_CM0_BAD_ADDR_REG(_BASE) ((mem_fb_vex_cm0_bad_addr_reg_t*) MEM_FB_VEX_CM0_BAD_ADDR_ADR(_BASE))
#define MEM_FB_VEX_CM1_BAD_ADDR_REG(_BASE) ((mem_fb_vex_cm1_bad_addr_reg_t*) MEM_FB_VEX_CM1_BAD_ADDR_ADR(_BASE))
#define MEM_FB_VEX_CM0_DROP_IDX_REG(_BASE) ((mem_fb_vex_cm0_drop_idx_reg_t*) MEM_FB_VEX_CM0_DROP_IDX_ADR(_BASE))
#define MEM_FB_VEX_CM1_DROP_IDX_REG(_BASE) ((mem_fb_vex_cm1_drop_idx_reg_t*) MEM_FB_VEX_CM1_DROP_IDX_ADR(_BASE))
#define MEM_FB_VEX_TIMER_REG(_BASE) ((mem_fb_vex_timer_reg_t*) MEM_FB_VEX_TIMER_ADR(_BASE))
#define MEM_FB_VEX_DBG_REG(_BASE) ((mem_fb_vex_dbg_reg_t*) MEM_FB_VEX_DBG_ADR(_BASE))
#define MEM_FB_VEX_DMA0_CH0_LLP_REG(_BASE) ((mem_fb_vex_dma0_ch0_llp_reg_t*) MEM_FB_VEX_DMA0_CH0_LLP_ADR(_BASE))
#define MEM_FB_VEX_DMA0_CH1_LLP_REG(_BASE) ((mem_fb_vex_dma0_ch1_llp_reg_t*) MEM_FB_VEX_DMA0_CH1_LLP_ADR(_BASE))
#define MEM_FB_VEX_DMA1_CH0_LLP_REG(_BASE) ((mem_fb_vex_dma1_ch0_llp_reg_t*) MEM_FB_VEX_DMA1_CH0_LLP_ADR(_BASE))
#define MEM_FB_VEX_DMA1_CH1_LLP_REG(_BASE) ((mem_fb_vex_dma1_ch1_llp_reg_t*) MEM_FB_VEX_DMA1_CH1_LLP_ADR(_BASE))
#define MEM_FB_VEX_DMA0_CH01_EN_REG(_BASE) ((mem_fb_vex_dma0_ch01_en_reg_t*) MEM_FB_VEX_DMA0_CH01_EN_ADR(_BASE))
#define MEM_FB_VEX_DMA1_CH01_EN_REG(_BASE) ((mem_fb_vex_dma1_ch01_en_reg_t*) MEM_FB_VEX_DMA1_CH01_EN_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    mem_fb_scratch_reg_t SCRATCH;         /*< Address offset = 0x0 */
    mem_fb_soft_rst_reg_t SOFT_RST;      /*< Address offset = 0x4 */
    mem_fb_en_reg_t EN;          /*< Address offset = 0x8 */
    mem_fb_ll_corrupt_reg_t LL_CORRUPT;      /*< Address offset = 0xc */
    mem_fb_pwr_down_ctrl_reg_t PWR_DOWN_CTRL; /*< Address offset = 0x10 */
    mem_fb_pwr_down_ctrl_chain_reg_t PWR_DOWN_CTRL_CHAIN; /*< Address offset = 0x14 */
    mem_fb_dmac_hold_req_reg_t DMAC_HOLD_REQ;   /*< Address offset = 0x18 */
    mem_fb_dmac_hold_ack_reg_t DMAC_HOLD_ACK;   /*< Address offset = 0x1c */
    mem_fb_la_dbg_sel_reg_t LA_DBG_SEL;    /*< Address offset = 0x20 */
    mem_fb_dmac_dbg_chan_sel_reg_t DMAC_DBG_CHAN_SEL; /*< Address offset = 0x24 */
    mem_fb_dmac_dma0_dbg_reg_t DMAC_DMA0_DBG; /*< Address offset = 0x28 */
    mem_fb_dmac_dma1_dbg_reg_t DMAC_DMA1_DBG; /*< Address offset = 0x2c */
    mem_fb_dmac0_ch_tfr_done_cnt_reg_t DMAC0_CH_TFR_DONE_CNT; /*< Address offset = 0x30 */
    mem_fb_dmac1_ch_tfr_done_cnt_reg_t DMAC1_CH_TFR_DONE_CNT; /*< Address offset = 0x34 */
    mem_fb_dmac0_dst_tfr_done_cnt_reg_t DMAC0_DST_TFR_DONE_CNT; /*< Address offset = 0x38 */
    mem_fb_dmac1_dst_tfr_done_cnt_reg_t DMAC1_DST_TFR_DONE_CNT; /*< Address offset = 0x3c */
    mem_fb_dmac0_src_tfr_done_cnt_reg_t DMAC0_SRC_TFR_DONE_CNT; /*< Address offset = 0x40 */
    mem_fb_dmac1_src_tfr_done_cnt_reg_t DMAC1_SRC_TFR_DONE_CNT; /*< Address offset = 0x44 */
    mem_fb_tdd_stall_reg_t TDD_STALL;       /*< Address offset = 0x48 */
    mem_fb_dmac0_ch0_pause_cnt_reg_t DMAC0_CH0_PAUSE_CNT; /*< Address offset = 0x4c */
    mem_fb_dmac1_ch0_pause_cnt_reg_t DMAC1_CH0_PAUSE_CNT; /*< Address offset = 0x50 */
    mem_fb_dmac0_ch1_pause_cnt_reg_t DMAC0_CH1_PAUSE_CNT; /*< Address offset = 0x54 */
    mem_fb_dmac1_ch1_pause_cnt_reg_t DMAC1_CH1_PAUSE_CNT; /*< Address offset = 0x58 */
    mem_fb_dmac_ll_invalid_reg_t DMAC_LL_INVALID; /*< Address offset = 0x5c */
    mem_fb_nsip_cm0_pkt_len_reg_t NSIP_CM0_PKT_LEN; /*< Address offset = 0x60 */
    mem_fb_nsip_cm1_pkt_len_reg_t NSIP_CM1_PKT_LEN; /*< Address offset = 0x64 */
    mem_fb_nsip_cm_halt_cfg_reg_t NSIP_CM_HALT_CFG; /*< Address offset = 0x68 */
    mem_fb_nsip_cm_halt_stat_reg_t NSIP_CM_HALT_STAT; /*< Address offset = 0x6c */
    mem_fb_nsip_cm_state_dbg_reg_t NSIP_CM_STATE_DBG; /*< Address offset = 0x70 */
    const uint8_t        reservedArea0 [4];   /*< Address offset = 0x74 */
    mem_fb_int_hi_agg_stat_reg_t INT_HI_AGG_STAT; /*< Address offset = 0x78 */
    mem_fb_int_lo_agg_stat_reg_t INT_LO_AGG_STAT; /*< Address offset = 0x7c */
    mem_fb_int_fb_stat_reg_t INT_FB_STAT;   /*< Address offset = 0x80 */
    mem_fb_int_fb_high_en_reg_t INT_FB_HIGH_EN;  /*< Address offset = 0x84 */
    mem_fb_int_fb_low_en_reg_t INT_FB_LOW_EN;   /*< Address offset = 0x88 */
    mem_fb_int_fb_clr_reg_t INT_FB_CLR;    /*< Address offset = 0x8c */
    mem_fb_int_fb_force_reg_t INT_FB_FORCE;    /*< Address offset = 0x90 */
    const uint8_t        reservedArea1 [12];  /*< Address offset = 0x94 */
    mem_fb_int_crux_stat_reg_t INT_CRUX_STAT; /*< Address offset = 0xa0 */
    mem_fb_int_crux_high_en_reg_t INT_CRUX_HIGH_EN; /*< Address offset = 0xa4 */
    mem_fb_int_crux_low_en_reg_t INT_CRUX_LOW_EN; /*< Address offset = 0xa8 */
    mem_fb_int_crux_clr_reg_t INT_CRUX_CLR;  /*< Address offset = 0xac */
    mem_fb_int_crux_force_reg_t INT_CRUX_FORCE;  /*< Address offset = 0xb0 */
    const uint8_t        reservedArea2 [76];  /*< Address offset = 0xb4 */
    mem_fb_axi_ecc_err_info_reg_t AXI_ECC_ERR_INFO0; /*< Address offset = 0x100 */
    mem_fb_axi_ecc_ctl_reg_t AXI_ECC_CTL0;    /*< Address offset = 0x104 */
    mem_fb_axi_ecc_err_stat_reg_t AXI_ECC_ERR_STAT0; /*< Address offset = 0x108 */
    const uint8_t        reservedArea3 [4];   /*< Address offset = 0x10c */
    mem_fb_axi_ecc_err_info_reg_t AXI_ECC_ERR_INFO1; /*< Address offset = 0x110 */
    mem_fb_axi_ecc_ctl_reg_t AXI_ECC_CTL1;    /*< Address offset = 0x114 */
    mem_fb_axi_ecc_err_stat_reg_t AXI_ECC_ERR_STAT1; /*< Address offset = 0x118 */
    const uint8_t        reservedArea4 [4];   /*< Address offset = 0x11c */
    mem_fb_axi_ecc_err_info_reg_t AXI_ECC_ERR_INFO2; /*< Address offset = 0x120 */
    mem_fb_axi_ecc_ctl_reg_t AXI_ECC_CTL2;    /*< Address offset = 0x124 */
    mem_fb_axi_ecc_err_stat_reg_t AXI_ECC_ERR_STAT2; /*< Address offset = 0x128 */
    const uint8_t        reservedArea5 [212]; /*< Address offset = 0x12c */
    mem_fb_mem_ptr_port0_reg_t FB_MEM_PTR_PORT0; /*< Address offset = 0x200 */
    mem_fb_mem_ptr_port1_reg_t FB_MEM_PTR_PORT1; /*< Address offset = 0x204 */
    mem_fb_mem_ptr_port2_reg_t FB_MEM_PTR_PORT2; /*< Address offset = 0x208 */
    mem_fb_mem_ptr_port3_reg_t FB_MEM_PTR_PORT3; /*< Address offset = 0x20c */
    mem_fb_sample_cnt_reg_t SAMPLE_CNT[4];   /*< Address offset = 0x210 */
    const uint8_t        reservedArea6 [8];   /*< Address offset = 0x220 */
    mem_fb_ant_intf_stat_reg_t ANT_INTF_STAT; /*< Address offset = 0x228 */
    const uint8_t        reservedArea7 [212]; /*< Address offset = 0x22c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR0; /*< Address offset = 0x300 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR0; /*< Address offset = 0x304 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR1; /*< Address offset = 0x308 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR1; /*< Address offset = 0x30c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR2; /*< Address offset = 0x310 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR2; /*< Address offset = 0x314 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR3; /*< Address offset = 0x318 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR3; /*< Address offset = 0x31c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR4; /*< Address offset = 0x320 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR4; /*< Address offset = 0x324 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR5; /*< Address offset = 0x328 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR5; /*< Address offset = 0x32c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR6; /*< Address offset = 0x330 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR6; /*< Address offset = 0x334 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR7; /*< Address offset = 0x338 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR7; /*< Address offset = 0x33c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR8; /*< Address offset = 0x340 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR8; /*< Address offset = 0x344 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR9; /*< Address offset = 0x348 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR9; /*< Address offset = 0x34c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR10; /*< Address offset = 0x350 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR10; /*< Address offset = 0x354 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR11; /*< Address offset = 0x358 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR11; /*< Address offset = 0x35c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR12; /*< Address offset = 0x360 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR12; /*< Address offset = 0x364 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR13; /*< Address offset = 0x368 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR13; /*< Address offset = 0x36c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR14; /*< Address offset = 0x370 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR14; /*< Address offset = 0x374 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR15; /*< Address offset = 0x378 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR15; /*< Address offset = 0x37c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR16; /*< Address offset = 0x380 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR16; /*< Address offset = 0x384 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR17; /*< Address offset = 0x388 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR17; /*< Address offset = 0x38c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR18; /*< Address offset = 0x390 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR18; /*< Address offset = 0x394 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR19; /*< Address offset = 0x398 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR19; /*< Address offset = 0x39c */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR20; /*< Address offset = 0x3a0 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR20; /*< Address offset = 0x3a4 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR21; /*< Address offset = 0x3a8 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR21; /*< Address offset = 0x3ac */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR22; /*< Address offset = 0x3b0 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR22; /*< Address offset = 0x3b4 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR23; /*< Address offset = 0x3b8 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR23; /*< Address offset = 0x3bc */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR24; /*< Address offset = 0x3c0 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR24; /*< Address offset = 0x3c4 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR25; /*< Address offset = 0x3c8 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR25; /*< Address offset = 0x3cc */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR26; /*< Address offset = 0x3d0 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR26; /*< Address offset = 0x3d4 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR27; /*< Address offset = 0x3d8 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR27; /*< Address offset = 0x3dc */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR28; /*< Address offset = 0x3e0 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR28; /*< Address offset = 0x3e4 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR29; /*< Address offset = 0x3e8 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR29; /*< Address offset = 0x3ec */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR30; /*< Address offset = 0x3f0 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR30; /*< Address offset = 0x3f4 */
    mem_fb_sector_end_ptr_reg_t SECTOR_END_PTR31; /*< Address offset = 0x3f8 */
    mem_fb_sector_next_ptr_reg_t SECTOR_NEXT_PTR31; /*< Address offset = 0x3fc */
    mem_fb_bfn_timer1_dma0_reg_t BFN_TIMER1_DMA00; /*< Address offset = 0x400 */
    mem_fb_bfn_timer2_dma0_reg_t BFN_TIMER2_DMA00; /*< Address offset = 0x404 */
    mem_fb_bfn_timer_sel_dma0_reg_t BFN_TIMER_SEL_DMA00; /*< Address offset = 0x408 */
    mem_fb_bfn_pause_soft_dma0_reg_t BFN_PAUSE_SOFT_DMA00; /*< Address offset = 0x40c */
    mem_fb_bfn_exit_timer_dma0_reg_t BFN_EXIT_TIMER_DMA00; /*< Address offset = 0x410 */
    mem_fb_soft_pause_st_dma0_reg_t SOFT_PAUSE_ST_DMA00; /*< Address offset = 0x414 */
    mem_fb_hard_pause_st_dma0_reg_t HARD_PAUSE_ST_DMA00; /*< Address offset = 0x418 */
    mem_fb_bfn_timer1_dma1_reg_t BFN_TIMER1_DMA10; /*< Address offset = 0x41c */
    mem_fb_bfn_timer2_dma1_reg_t BFN_TIMER2_DMA10; /*< Address offset = 0x420 */
    mem_fb_bfn_timer_sel_dma1_reg_t BFN_TIMER_SEL_DMA10; /*< Address offset = 0x424 */
    mem_fb_bfn_pause_soft_dma1_reg_t BFN_PAUSE_SOFT_DMA10; /*< Address offset = 0x428 */
    mem_fb_bfn_exit_timer_dma1_reg_t BFN_EXIT_TIMER_DMA10; /*< Address offset = 0x42c */
    mem_fb_soft_pause_st_dma1_reg_t SOFT_PAUSE_ST_DMA10; /*< Address offset = 0x430 */
    mem_fb_hard_pause_st_dma1_reg_t HARD_PAUSE_ST_DMA10; /*< Address offset = 0x434 */
    mem_fb_bfn_state_dbg_reg_t BFN_STATE_DBG0; /*< Address offset = 0x438 */
    const uint8_t        reservedArea8 [68];  /*< Address offset = 0x43c */
    mem_fb_bfn_timer1_dma0_reg_t BFN_TIMER1_DMA01; /*< Address offset = 0x480 */
    mem_fb_bfn_timer2_dma0_reg_t BFN_TIMER2_DMA01; /*< Address offset = 0x484 */
    mem_fb_bfn_timer_sel_dma0_reg_t BFN_TIMER_SEL_DMA01; /*< Address offset = 0x488 */
    mem_fb_bfn_pause_soft_dma0_reg_t BFN_PAUSE_SOFT_DMA01; /*< Address offset = 0x48c */
    mem_fb_bfn_exit_timer_dma0_reg_t BFN_EXIT_TIMER_DMA01; /*< Address offset = 0x490 */
    mem_fb_soft_pause_st_dma0_reg_t SOFT_PAUSE_ST_DMA01; /*< Address offset = 0x494 */
    mem_fb_hard_pause_st_dma0_reg_t HARD_PAUSE_ST_DMA01; /*< Address offset = 0x498 */
    mem_fb_bfn_timer1_dma1_reg_t BFN_TIMER1_DMA11; /*< Address offset = 0x49c */
    mem_fb_bfn_timer2_dma1_reg_t BFN_TIMER2_DMA11; /*< Address offset = 0x4a0 */
    mem_fb_bfn_timer_sel_dma1_reg_t BFN_TIMER_SEL_DMA11; /*< Address offset = 0x4a4 */
    mem_fb_bfn_pause_soft_dma1_reg_t BFN_PAUSE_SOFT_DMA11; /*< Address offset = 0x4a8 */
    mem_fb_bfn_exit_timer_dma1_reg_t BFN_EXIT_TIMER_DMA11; /*< Address offset = 0x4ac */
    mem_fb_soft_pause_st_dma1_reg_t SOFT_PAUSE_ST_DMA11; /*< Address offset = 0x4b0 */
    mem_fb_hard_pause_st_dma1_reg_t HARD_PAUSE_ST_DMA11; /*< Address offset = 0x4b4 */
    mem_fb_bfn_state_dbg_reg_t BFN_STATE_DBG1; /*< Address offset = 0x4b8 */
    const uint8_t        reservedArea9 [68];  /*< Address offset = 0x4bc */
    mem_fb_isync_ctrl_reg_t ISYNC_CTRL; /*< Address offset = 0x500 */
    mem_fb_isync_lcnt_inc_reg_t ISYNC_LCNT_INC; /*< Address offset = 0x504 */
    mem_fb_isync_ten_ms_cnt_reg_t ISYNC_TEN_MS_CNT; /*< Address offset = 0x508 */
    mem_fb_isync_inc_pre_reg_t ISYNC_INC_PRE; /*< Address offset = 0x50c */
    mem_fb_isync_cnt_adj_reg_t ISYNC_CNT_ADJ; /*< Address offset = 0x510 */
    mem_fb_isync_bfn_cnt_sync_reg_t ISYNC_BFN_CNT_SYNC; /*< Address offset = 0x514 */
    mem_fb_isync_bfn_cnt_reg_t ISYNC_BFN_CNT; /*< Address offset = 0x518 */
    const uint8_t        reservedArea10 [20]; /*< Address offset = 0x51c */
    mem_fb_bfne_cfg_reg_t BFNE_CFG[8]; /*< Address offset = 0x530 */
    mem_fb_bfne_incr_reg_t BFNE_INCR[8]; /*< Address offset = 0x550 */
    mem_fb_bfne_start_reg_t BFNE_START[8]; /*< Address offset = 0x570 */
    mem_fb_bfne_stat_reg_t BFNE_STAT[8]; /*< Address offset = 0x590 */
    const uint8_t        reservedArea11 [80]; /*< Address offset = 0x5b0 */
    mem_fb_desc_ecc_err_info_reg_t DESC_ECC_ERR_INFO0; /*< Address offset = 0x600 */
    mem_fb_desc_ecc_ctl_reg_t DESC_ECC_CTL0;   /*< Address offset = 0x604 */
    mem_fb_desc_ecc_err_stat_reg_t DESC_ECC_ERR_STAT0; /*< Address offset = 0x608 */
    const uint8_t        reservedArea12 [4];  /*< Address offset = 0x60c */
    mem_fb_desc_ecc_err_info_reg_t DESC_ECC_ERR_INFO1; /*< Address offset = 0x610 */
    mem_fb_desc_ecc_ctl_reg_t DESC_ECC_CTL1;   /*< Address offset = 0x614 */
    mem_fb_desc_ecc_err_stat_reg_t DESC_ECC_ERR_STAT1; /*< Address offset = 0x618 */
    const uint8_t        reservedArea13 [4];  /*< Address offset = 0x61c */
    mem_fb_dma0_ecc_err_info_reg_t DMA0_ECC_ERR_INFO0; /*< Address offset = 0x620 */
    mem_fb_dma0_ecc_ctl_reg_t DMA0_ECC_CTL0;   /*< Address offset = 0x624 */
    mem_fb_dma0_ecc_err_stat_reg_t DMA0_ECC_ERR_STAT0; /*< Address offset = 0x628 */
    const uint8_t        reservedArea14 [4];  /*< Address offset = 0x62c */
    mem_fb_dma0_ecc_err_info_reg_t DMA0_ECC_ERR_INFO1; /*< Address offset = 0x630 */
    mem_fb_dma0_ecc_ctl_reg_t DMA0_ECC_CTL1;   /*< Address offset = 0x634 */
    mem_fb_dma0_ecc_err_stat_reg_t DMA0_ECC_ERR_STAT1; /*< Address offset = 0x638 */
    const uint8_t        reservedArea15 [4];  /*< Address offset = 0x63c */
    mem_fb_dma1_ecc_err_info_reg_t DMA1_ECC_ERR_INFO0; /*< Address offset = 0x640 */
    mem_fb_dma1_ecc_ctl_reg_t DMA1_ECC_CTL0;   /*< Address offset = 0x644 */
    mem_fb_dma1_ecc_err_stat_reg_t DMA1_ECC_ERR_STAT0; /*< Address offset = 0x648 */
    const uint8_t        reservedArea16 [4];  /*< Address offset = 0x64c */
    mem_fb_dma1_ecc_err_info_reg_t DMA1_ECC_ERR_INFO1; /*< Address offset = 0x650 */
    mem_fb_dma1_ecc_ctl_reg_t DMA1_ECC_CTL1;   /*< Address offset = 0x654 */
    mem_fb_dma1_ecc_err_stat_reg_t DMA1_ECC_ERR_STAT1; /*< Address offset = 0x658 */
    const uint8_t        reservedArea17 [4];  /*< Address offset = 0x65c */
    mem_fb_dma_dp_init_reg_t DMA_DP_INIT;     /*< Address offset = 0x660 */
    mem_fb_dma_dp_init_done_reg_t DMA_DP_INIT_DONE; /*< Address offset = 0x664 */
    const uint8_t        reservedArea18 [24]; /*< Address offset = 0x668 */
    mem_fb_vex_dma_sel_halt_reg_t VEX_DMA_SEL_HALT; /*< Address offset = 0x680 */
    mem_fb_vex_mem_start_addr_reg_t VEX_MEM_START_ADDR; /*< Address offset = 0x684 */
    mem_fb_vex_mem_end_addr_reg_t VEX_MEM_END_ADDR; /*< Address offset = 0x688 */
    mem_fb_vex_desc_start_addr_reg_t VEX_DESC_START_ADDR; /*< Address offset = 0x68c */
    mem_fb_vex_desc_end_addr_reg_t VEX_DESC_END_ADDR; /*< Address offset = 0x690 */
    mem_fb_vex_start_addr_reg_t VEX_START_ADDR; /*< Address offset = 0x694 */
    mem_fb_vex_end_addr_reg_t VEX_END_ADDR; /*< Address offset = 0x698 */
    mem_fb_vex_addr_mask_reg_t VEX_ADDR_MASK;   /*< Address offset = 0x69c */
    mem_fb_vex_cm0_bad_addr_reg_t VEX_CM0_BAD_ADDR; /*< Address offset = 0x6a0 */
    mem_fb_vex_cm1_bad_addr_reg_t VEX_CM1_BAD_ADDR; /*< Address offset = 0x6a4 */
    mem_fb_vex_cm0_drop_idx_reg_t VEX_CM0_DROP_IDX; /*< Address offset = 0x6a8 */
    mem_fb_vex_cm1_drop_idx_reg_t VEX_CM1_DROP_IDX; /*< Address offset = 0x6ac */
    mem_fb_vex_timer_reg_t VEX_TIMER;       /*< Address offset = 0x6b0 */
    mem_fb_vex_dbg_reg_t VEX_DBG;       /*< Address offset = 0x6b4 */
    const uint8_t        reservedArea19 [8];  /*< Address offset = 0x6b8 */
    mem_fb_vex_dma0_ch0_llp_reg_t VEX_DMA0_CH0_LLP; /*< Address offset = 0x6c0 */
    mem_fb_vex_dma0_ch1_llp_reg_t VEX_DMA0_CH1_LLP; /*< Address offset = 0x6c4 */
    mem_fb_vex_dma1_ch0_llp_reg_t VEX_DMA1_CH0_LLP; /*< Address offset = 0x6c8 */
    mem_fb_vex_dma1_ch1_llp_reg_t VEX_DMA1_CH1_LLP; /*< Address offset = 0x6cc */
    mem_fb_vex_dma0_ch01_en_reg_t VEX_DMA0_CH01_EN; /*< Address offset = 0x6d0 */
    mem_fb_vex_dma1_ch01_en_reg_t VEX_DMA1_CH01_EN; /*< Address offset = 0x6d4 */
} mem_fb_t;     // size: 0x0324

// AddressSpace struct pointer
//
#define MEM_FB0_CFG      ((mem_fb_t*) MEM_FB0_CFG_BASE)
#define MEM_FB1_CFG      ((mem_fb_t*) MEM_FB1_CFG_BASE)

// ******************************************* /Address Space

#endif      // _MEM_FB_H_

