#ifndef _PHM_ACCEL_H_
#define _PHM_ACCEL_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define RCS_PHM0_ACCEL0_BASE  ( 0x00244000 )
#define RCS_PHM0_ACCEL1_BASE  ( 0x00244040 )
#define RCS_PHM0_ACCEL2_BASE  ( 0x00244080 )
#define RCS_PHM0_ACCEL3_BASE  ( 0x002440c0 )
#define RCS_PHM0_ACCEL4_BASE  ( 0x00244100 )
#define RCS_PHM0_ACCEL5_BASE  ( 0x00244140 )
#define RCS_PHM0_ACCEL6_BASE  ( 0x00244180 )
#define RCS_PHM0_ACCEL7_BASE  ( 0x002441c0 )
#define RCS_PHM0_ACCEL8_BASE  ( 0x00244200 )
#define RCS_PHM0_ACCEL9_BASE  ( 0x00244240 )
#define RCS_PHM1_ACCEL0_BASE  ( 0x00264000 )
#define RCS_PHM1_ACCEL1_BASE  ( 0x00264040 )
#define RCS_PHM1_ACCEL2_BASE  ( 0x00264080 )
#define RCS_PHM1_ACCEL3_BASE  ( 0x002640c0 )
#define RCS_PHM1_ACCEL4_BASE  ( 0x00264100 )
#define RCS_PHM1_ACCEL5_BASE  ( 0x00264140 )
#define RCS_PHM1_ACCEL6_BASE  ( 0x00264180 )
#define RCS_PHM1_ACCEL7_BASE  ( 0x002641c0 )
#define RCS_PHM1_ACCEL8_BASE  ( 0x00264200 )
#define RCS_PHM1_ACCEL9_BASE  ( 0x00264240 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define PHM_ACCEL_TSHOLD0_OFFSET ( 0x00000000U )
#define PHM_ACCEL_TSHOLD1_OFFSET ( 0x00000004U )
#define PHM_ACCEL_TSHOLD2_OFFSET ( 0x00000008U )
#define PHM_ACCEL_TSHOLD3_OFFSET ( 0x0000000cU )
#define PHM_ACCEL_TSHOLD_CNT0_OFFSET ( 0x00000010U )
#define PHM_ACCEL_TSHOLD_CNT1_OFFSET ( 0x00000014U )
#define PHM_ACCEL_TSHOLD_CNT2_OFFSET ( 0x00000018U )
#define PHM_ACCEL_TSHOLD_CNT3_OFFSET ( 0x0000001cU )
#define PHM_ACCEL_RSLT0_OFFSET ( 0x00000020U )
#define PHM_ACCEL_RSLT1_OFFSET ( 0x00000024U )
#define PHM_ACCEL_RSLT2_OFFSET ( 0x00000028U )
#define PHM_ACCEL_RSLT3_OFFSET ( 0x0000002cU )
#define PHM_ACCEL_SETUP_OFFSET ( 0x00000030U )
#define PHM_ACCEL_PHM_RD_FIFO_CFG_OFFSET ( 0x00000034U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define PHM_ACCEL_TSHOLD0_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD0_OFFSET ) ))
#define PHM_ACCEL_TSHOLD1_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD1_OFFSET ) ))
#define PHM_ACCEL_TSHOLD2_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD2_OFFSET ) ))
#define PHM_ACCEL_TSHOLD3_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD3_OFFSET ) ))
#define PHM_ACCEL_TSHOLD_CNT0_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD_CNT0_OFFSET ) ))
#define PHM_ACCEL_TSHOLD_CNT1_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD_CNT1_OFFSET ) ))
#define PHM_ACCEL_TSHOLD_CNT2_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD_CNT2_OFFSET ) ))
#define PHM_ACCEL_TSHOLD_CNT3_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_TSHOLD_CNT3_OFFSET ) ))
#define PHM_ACCEL_RSLT0_ADR(_BASE)    (( ( _BASE ) + ( PHM_ACCEL_RSLT0_OFFSET ) ))
#define PHM_ACCEL_RSLT1_ADR(_BASE)    (( ( _BASE ) + ( PHM_ACCEL_RSLT1_OFFSET ) ))
#define PHM_ACCEL_RSLT2_ADR(_BASE)    (( ( _BASE ) + ( PHM_ACCEL_RSLT2_OFFSET ) ))
#define PHM_ACCEL_RSLT3_ADR(_BASE)    (( ( _BASE ) + ( PHM_ACCEL_RSLT3_OFFSET ) ))
#define PHM_ACCEL_SETUP_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_SETUP_OFFSET ) ))
#define PHM_ACCEL_PHM_RD_FIFO_CFG_ADR(_BASE) (( ( _BASE ) + ( PHM_ACCEL_PHM_RD_FIFO_CFG_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief PHM_ACCEL_COM_REG_THRESHOLD[4] register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: phm_accel_com/reg/threshold
  * PHM Threshold value
  */

typedef union {
  struct {
    uint32_t THRESH_COMP : 16;
    ///< Value for which a PHM IQ sample will be compared. If the sample is
    ///< less than this value, the threshold counter will increment.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} phm_accel_tshold_reg_t;

#define PHM_ACCEL_TSHOLD_DEFAULT (0x00000000U)
#define PHM_ACCEL_TSHOLD_RD_MASK (0x0000ffffU)
#define PHM_ACCEL_TSHOLD_WR_MASK (0x0000ffffU)


///< Value for which a PHM IQ sample will be compared. If the sample is
///< less than this value, the threshold counter will increment.
#define PHM_ACCEL_TSHOLD_THRESH_BF_OFF ( 0)
#define PHM_ACCEL_TSHOLD_THRESH_BF_WID (16)
#define PHM_ACCEL_TSHOLD_THRESH_BF_MSK (0x0000FFFF)
#define PHM_ACCEL_TSHOLD_THRESH_BF_DEF (0x00000000)
#define PHM_ACCEL_TSHOLD_ARR_SZ0 (4)
#define PHM_ACCEL_TSHOLD_ARRAY_STRIDE0 (0x0004)


/** @brief PHM_ACCEL_COM_REG_THRESHOLD_CNT[4] register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: phm_accel_com/reg/threshold_cnt
  * PHM threshold Counts
  */

typedef union {
  struct {
    uint32_t THRESH_VAL : 16;
    ///< Number of times sampled IQ data must be less than THRESH_VAL before
    ///< an interrupt is created
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} phm_accel_tshold_cnt_reg_t;

#define PHM_ACCEL_TSHOLD_CNT_DEFAULT (0x00000000U)
#define PHM_ACCEL_TSHOLD_CNT_RD_MASK (0x0000ffffU)
#define PHM_ACCEL_TSHOLD_CNT_WR_MASK (0x0000ffffU)


///< Number of times sampled IQ data must be less than THRESH_VAL before
///< an interrupt is created
#define PHM_ACCEL_TSHOLD_CNT_THRESH_VAL_BF_OFF ( 0)
#define PHM_ACCEL_TSHOLD_CNT_THRESH_VAL_BF_WID (16)
#define PHM_ACCEL_TSHOLD_CNT_THRESH_VAL_BF_MSK (0x0000FFFF)
#define PHM_ACCEL_TSHOLD_CNT_THRESH_VAL_BF_DEF (0x00000000)
#define PHM_ACCEL_TSHOLD_CNT_ARR_SZ0 (4)
#define PHM_ACCEL_TSHOLD_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief PHM_ACCEL_COM_REG_RESULT[4] register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: phm_accel_com/reg/result
  * Theshold Counter Results
  */

typedef union {
  struct {
    uint32_t THRESH_COUNT : 16;
    ///< The number of times the sampled IQ data has been less than the corresponding
    ///< THRESH_VAL
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t THRESH_REACH : 1;
    ///< Indication that the THRESH_COUNT equals the THRESH_COMP
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} phm_accel_rslt_reg_t;

#define PHM_ACCEL_RSLT_DEFAULT (0x00000000U)
#define PHM_ACCEL_RSLT_RD_MASK (0x0001ffffU)
#define PHM_ACCEL_RSLT_WR_MASK (0x00000000U)


///< The number of times the sampled IQ data has been less than the corresponding
///< THRESH_VAL
#define PHM_ACCEL_RSLT_THRESH_CNT_BF_OFF ( 0)
#define PHM_ACCEL_RSLT_THRESH_CNT_BF_WID (16)
#define PHM_ACCEL_RSLT_THRESH_CNT_BF_MSK (0x0000FFFF)
#define PHM_ACCEL_RSLT_THRESH_CNT_BF_DEF (0x00000000)

///< Indication that the THRESH_COUNT equals the THRESH_COMP
#define PHM_ACCEL_RSLT_THRESH_REACH_BF_OFF (16)
#define PHM_ACCEL_RSLT_THRESH_REACH_BF_WID ( 1)
#define PHM_ACCEL_RSLT_THRESH_REACH_BF_MSK (0x00010000)
#define PHM_ACCEL_RSLT_THRESH_REACH_BF_DEF (0x00000000)
#define PHM_ACCEL_RSLT_ARR_SZ0 (4)
#define PHM_ACCEL_RSLT_ARRAY_STRIDE0 (0x0004)


/** @brief PHM_ACCEL_COM_REG_ACCEL_SETUP register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: phm_accel_com/reg/accel_setup
  * Basic Accelerator Setup
  */

typedef union {
  struct {
    uint32_t ACCEL_ENABLE : 1;
    ///< Set to 1 to enable this Accelerator
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
    uint32_t USE_SIGNED : 1;
    ///< 0 = All thresholds and IQ samples for this accelerator are unsigned.
    ///< 1 = All values and comparisons are signed
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} phm_accel_setup_reg_t;

#define PHM_ACCEL_SETUP_DEFAULT (0x00000000U)
#define PHM_ACCEL_SETUP_RD_MASK (0x00000011U)
#define PHM_ACCEL_SETUP_WR_MASK (0x00000011U)


///< Set to 1 to enable this Accelerator
#define PHM_ACCEL_SETUP_ACCEL_EN_BF_OFF ( 0)
#define PHM_ACCEL_SETUP_ACCEL_EN_BF_WID ( 1)
#define PHM_ACCEL_SETUP_ACCEL_EN_BF_MSK (0x00000001)
#define PHM_ACCEL_SETUP_ACCEL_EN_BF_DEF (0x00000000)

///< 0 = All thresholds and IQ samples for this accelerator are unsigned.
///< 1 = All values and comparisons are signed
#define PHM_ACCEL_SETUP_USE_SIGNED_BF_OFF ( 4)
#define PHM_ACCEL_SETUP_USE_SIGNED_BF_WID ( 1)
#define PHM_ACCEL_SETUP_USE_SIGNED_BF_MSK (0x00000010)
#define PHM_ACCEL_SETUP_USE_SIGNED_BF_DEF (0x00000000)


/** @brief PHM_ACCEL_COM_REG_PHM_RD_FIFO_CFG register description at address offset 0x34
  *
  * Register default value:        0x00000000
  * Register full path in IP: phm_accel_com/reg/phm_rd_fifo_cfg
  * PHM read fifo configuration
  */

typedef union {
  struct {
    uint32_t WM_VAL : 6;
    ///< water mark for each fifo; can not be set more than fifo size, which
    ///< is 32
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t FIFO_RESET : 1;
    ///< to reset this fifo
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 7;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FIFO_OVERFLOW_BEHAVIOR : 1;
    ///< 1: when fifo is full, new data is overwriting the previous data; 0:
    ///< when fifo is full, new data will be dropped
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="25" ResetValue="None"
    uint32_t FIFO_ENABLE : 1;
    ///< to enable phm read fifo feature
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} phm_accel_phm_rd_fifo_cfg_reg_t;

#define PHM_ACCEL_PHM_RD_FIFO_CFG_DEFAULT (0x00000000U)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_RD_MASK (0x1101003fU)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_WR_MASK (0x1101003fU)


///< water mark for each fifo; can not be set more than fifo size, which
///< is 32
#define PHM_ACCEL_PHM_RD_FIFO_CFG_WM_VAL_BF_OFF ( 0)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_WM_VAL_BF_WID ( 6)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_WM_VAL_BF_MSK (0x0000003F)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_WM_VAL_BF_DEF (0x00000000)

///< to reset this fifo
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_RST_BF_OFF (16)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_RST_BF_WID ( 1)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_RST_BF_MSK (0x00010000)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_RST_BF_DEF (0x00000000)

///< 1: when fifo is full, new data is overwriting the previous data; 0:
///< when fifo is full, new data will be dropped
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_OVERFLOW_BEHAVIOR_BF_OFF (24)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_OVERFLOW_BEHAVIOR_BF_WID ( 1)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_OVERFLOW_BEHAVIOR_BF_MSK (0x01000000)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_OVERFLOW_BEHAVIOR_BF_DEF (0x00000000)

///< to enable phm read fifo feature
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_EN_BF_OFF (28)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_EN_BF_WID ( 1)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_EN_BF_MSK (0x10000000)
#define PHM_ACCEL_PHM_RD_FIFO_CFG_FIFO_EN_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define PHM_ACCEL_TSHOLD0_REG(_BASE) ((phm_accel_tshold_reg_t*) PHM_ACCEL_TSHOLD0_ADR(_BASE))
#define PHM_ACCEL_TSHOLD1_REG(_BASE) ((phm_accel_tshold_reg_t*) PHM_ACCEL_TSHOLD1_ADR(_BASE))
#define PHM_ACCEL_TSHOLD2_REG(_BASE) ((phm_accel_tshold_reg_t*) PHM_ACCEL_TSHOLD2_ADR(_BASE))
#define PHM_ACCEL_TSHOLD3_REG(_BASE) ((phm_accel_tshold_reg_t*) PHM_ACCEL_TSHOLD3_ADR(_BASE))
#define PHM_ACCEL_TSHOLD_CNT0_REG(_BASE) ((phm_accel_tshold_cnt_reg_t*) PHM_ACCEL_TSHOLD_CNT0_ADR(_BASE))
#define PHM_ACCEL_TSHOLD_CNT1_REG(_BASE) ((phm_accel_tshold_cnt_reg_t*) PHM_ACCEL_TSHOLD_CNT1_ADR(_BASE))
#define PHM_ACCEL_TSHOLD_CNT2_REG(_BASE) ((phm_accel_tshold_cnt_reg_t*) PHM_ACCEL_TSHOLD_CNT2_ADR(_BASE))
#define PHM_ACCEL_TSHOLD_CNT3_REG(_BASE) ((phm_accel_tshold_cnt_reg_t*) PHM_ACCEL_TSHOLD_CNT3_ADR(_BASE))
#define PHM_ACCEL_RSLT0_REG(_BASE) ((phm_accel_rslt_reg_t*) PHM_ACCEL_RSLT0_ADR(_BASE))
#define PHM_ACCEL_RSLT1_REG(_BASE) ((phm_accel_rslt_reg_t*) PHM_ACCEL_RSLT1_ADR(_BASE))
#define PHM_ACCEL_RSLT2_REG(_BASE) ((phm_accel_rslt_reg_t*) PHM_ACCEL_RSLT2_ADR(_BASE))
#define PHM_ACCEL_RSLT3_REG(_BASE) ((phm_accel_rslt_reg_t*) PHM_ACCEL_RSLT3_ADR(_BASE))
#define PHM_ACCEL_SETUP_REG(_BASE) ((phm_accel_setup_reg_t*) PHM_ACCEL_SETUP_ADR(_BASE))
#define PHM_ACCEL_PHM_RD_FIFO_CFG_REG(_BASE) ((phm_accel_phm_rd_fifo_cfg_reg_t*) PHM_ACCEL_PHM_RD_FIFO_CFG_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    phm_accel_tshold_reg_t TSHOLD[4];    /*< Address offset = 0x0 */
    phm_accel_tshold_cnt_reg_t TSHOLD_CNT[4]; /*< Address offset = 0x10 */
    phm_accel_rslt_reg_t RSLT[4];       /*< Address offset = 0x20 */
    phm_accel_setup_reg_t ACCEL_SETUP;     /*< Address offset = 0x30 */
    phm_accel_phm_rd_fifo_cfg_reg_t PHM_RD_FIFO_CFG; /*< Address offset = 0x34 */
} phm_accel_t;     // size: 0x0014

// AddressSpace struct pointer
//
#define RCS_PHM0_ACCEL0  ((phm_accel_t*) RCS_PHM0_ACCEL0_BASE)
#define RCS_PHM0_ACCEL1  ((phm_accel_t*) RCS_PHM0_ACCEL1_BASE)
#define RCS_PHM0_ACCEL2  ((phm_accel_t*) RCS_PHM0_ACCEL2_BASE)
#define RCS_PHM0_ACCEL3  ((phm_accel_t*) RCS_PHM0_ACCEL3_BASE)
#define RCS_PHM0_ACCEL4  ((phm_accel_t*) RCS_PHM0_ACCEL4_BASE)
#define RCS_PHM0_ACCEL5  ((phm_accel_t*) RCS_PHM0_ACCEL5_BASE)
#define RCS_PHM0_ACCEL6  ((phm_accel_t*) RCS_PHM0_ACCEL6_BASE)
#define RCS_PHM0_ACCEL7  ((phm_accel_t*) RCS_PHM0_ACCEL7_BASE)
#define RCS_PHM0_ACCEL8  ((phm_accel_t*) RCS_PHM0_ACCEL8_BASE)
#define RCS_PHM0_ACCEL9  ((phm_accel_t*) RCS_PHM0_ACCEL9_BASE)
#define RCS_PHM1_ACCEL0  ((phm_accel_t*) RCS_PHM1_ACCEL0_BASE)
#define RCS_PHM1_ACCEL1  ((phm_accel_t*) RCS_PHM1_ACCEL1_BASE)
#define RCS_PHM1_ACCEL2  ((phm_accel_t*) RCS_PHM1_ACCEL2_BASE)
#define RCS_PHM1_ACCEL3  ((phm_accel_t*) RCS_PHM1_ACCEL3_BASE)
#define RCS_PHM1_ACCEL4  ((phm_accel_t*) RCS_PHM1_ACCEL4_BASE)
#define RCS_PHM1_ACCEL5  ((phm_accel_t*) RCS_PHM1_ACCEL5_BASE)
#define RCS_PHM1_ACCEL6  ((phm_accel_t*) RCS_PHM1_ACCEL6_BASE)
#define RCS_PHM1_ACCEL7  ((phm_accel_t*) RCS_PHM1_ACCEL7_BASE)
#define RCS_PHM1_ACCEL8  ((phm_accel_t*) RCS_PHM1_ACCEL8_BASE)
#define RCS_PHM1_ACCEL9  ((phm_accel_t*) RCS_PHM1_ACCEL9_BASE)

// ******************************************* /Address Space

#endif      // _PHM_ACCEL_H_

