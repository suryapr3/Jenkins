#ifndef _MOD_H_
#define _MOD_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define TRX_SYS0_MOD_BASE     ( 0x0527a000 )
#define TRX_SYS1_MOD_BASE     ( 0x0529a000 )
#define TRX_SYS2_MOD_BASE     ( 0x052ba000 )
#define TRX_SYS3_MOD_BASE     ( 0x052da000 )
#define TRX_SYS4_MOD_BASE     ( 0x052fa000 )
#define TRX_SYS5_MOD_BASE     ( 0x0531a000 )
#define TRX_SYS6_MOD_BASE     ( 0x0533a000 )
#define TRX_SYS7_MOD_BASE     ( 0x0535a000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define MOD_SCRATCH_OFFSET       ( 0x00000000U )
#define MOD_CFG_OFFSET        ( 0x00000004U )
#define MOD_EN_OFFSET        ( 0x00000008U )
#define MOD_SAT_VAL_OFFSET       ( 0x0000000cU )
#define MOD_APB_BRDG_STAT_OFFSET ( 0x00000060U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define MOD_SCRATCH_ADR(_BASE)          (( ( _BASE ) + ( MOD_SCRATCH_OFFSET ) ))
#define MOD_CFG_ADR(_BASE)           (( ( _BASE ) + ( MOD_CFG_OFFSET ) ))
#define MOD_EN_ADR(_BASE)           (( ( _BASE ) + ( MOD_EN_OFFSET ) ))
#define MOD_SAT_VAL_ADR(_BASE)          (( ( _BASE ) + ( MOD_SAT_VAL_OFFSET ) ))
#define MOD_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( MOD_APB_BRDG_STAT_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief MOD_MAP_REG_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mod_map/reg/SCRATCH
  * MOD scratchpad register.
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Do anything with this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mod_scratch_reg_t;

#define MOD_SCRATCH_DEFAULT (0x00000000U)
#define MOD_SCRATCH_RD_MASK (0xffffffffU)
#define MOD_SCRATCH_WR_MASK (0xffffffffU)


///< Do anything with this field.
#define MOD_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define MOD_SCRATCH_SCRATCHPAD_BF_WID (32)
#define MOD_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define MOD_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief MOD_MAP_REG_CONFIG register description at address offset 0x4
  *
  * Register default value:        0x00000000
  * Register full path in IP: mod_map/reg/CONFIG
  * MOD configuration register.
  */

typedef union {
  struct {
    uint32_t BYP_MOD : 2;
    ///< When bit 0 of this field is set, the modulation function of the even
    ///< data channel is bypassed. When bit 1 of this field is set, the modulation
    ///< function of the odd data channel is bypassed. When operating in bypass
    ///< mode, the real inputs (I) of the modulator drive the real outputs
    ///< of the modulator.  The quadrature components of the input IQ samples
    ///< are ignored. Additionally, the SWG inputs are ignored and no modulation
    ///< is performed.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CONJ : 2;
    ///< When bit i of this field is set, the Real and Imag samples of the
    ///< SWG input to the ith modulator are conjugated. The conjugate function
    ///< operates on an IQ sample in the following manner: If an IQ sample
    ///< is represented as  a + ib (where ib is the quadrature component of
    ///< an IQ sample), then conjugation of the IQ sample results in the negation
    ///< of the Q portion of the IQ portion. As a result, the output  will
    ///< be  a - ib. Because the selection is done with multiplixers, if the
    ///< bit i of the field is cleared, then the output (which had become a-ib)
    ///< will change back to a+ib. When bit 0 of this field is set, the IQ
    ///< samples of the SWG input to the even modulator of an odd/even pair
    ///< are conjugated. Otherwise, the SWG input is delivered unchanged. When
    ///< bit 1 of this field is set, the IQ samples of the SWG input to the
    ///< odd modulator of an odd/even pair are conjugated. Otherwise, the SWG
    ///< input is delivered unchanged. In the event that the swap  and conjugate
    ///< functions are both enabled, please note that  the swap function occurs
    ///< first followed by the conjugation function. So, in this case, if the
    ///< the input was a+ib, then the swap function results in b+ia, and then
    ///< applying the conjugate function results in b-ia.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mod_cfg_reg_t;

#define MOD_CFG_DEFAULT (0x00000000U)
#define MOD_CFG_RD_MASK (0x0000000fU)
#define MOD_CFG_WR_MASK (0x0000000fU)


///< When bit 0 of this field is set, the modulation function of the even
///< data channel is bypassed. When bit 1 of this field is set, the modulation
///< function of the odd data channel is bypassed. When operating in bypass
///< mode, the real inputs (I) of the modulator drive the real outputs
///< of the modulator.  The quadrature components of the input IQ samples
///< are ignored. Additionally, the SWG inputs are ignored and no modulation
///< is performed.
#define MOD_CFG_BYP_MOD_BF_OFF ( 0)
#define MOD_CFG_BYP_MOD_BF_WID ( 2)
#define MOD_CFG_BYP_MOD_BF_MSK (0x00000003)
#define MOD_CFG_BYP_MOD_BF_DEF (0x00000000)

///< When bit i of this field is set, the Real and Imag samples of the
///< SWG input to the ith modulator are conjugated. The conjugate function
///< operates on an IQ sample in the following manner: If an IQ sample
///< is represented as  a + ib (where ib is the quadrature component of
///< an IQ sample), then conjugation of the IQ sample results in the negation
///< of the Q portion of the IQ portion. As a result, the output  will
///< be  a - ib. Because the selection is done with multiplixers, if the
///< bit i of the field is cleared, then the output (which had become a-ib)
///< will change back to a+ib. When bit 0 of this field is set, the IQ
///< samples of the SWG input to the even modulator of an odd/even pair
///< are conjugated. Otherwise, the SWG input is delivered unchanged. When
///< bit 1 of this field is set, the IQ samples of the SWG input to the
///< odd modulator of an odd/even pair are conjugated. Otherwise, the SWG
///< input is delivered unchanged. In the event that the swap  and conjugate
///< functions are both enabled, please note that  the swap function occurs
///< first followed by the conjugation function. So, in this case, if the
///< the input was a+ib, then the swap function results in b+ia, and then
///< applying the conjugate function results in b-ia.
#define MOD_CFG_CONJ_BF_OFF ( 2)
#define MOD_CFG_CONJ_BF_WID ( 2)
#define MOD_CFG_CONJ_BF_MSK (0x0000000C)
#define MOD_CFG_CONJ_BF_DEF (0x00000000)


/** @brief MOD_MAP_REG_ENABLE register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: mod_map/reg/ENABLE
  * MOD enable register.
  */

typedef union {
  struct {
    uint32_t MOD_EN_ANT_EVEN : 1;
    ///< When 0, the even channel in an odd/even modulator pair is disabled.
    ///< When 1, the even channel in an odd/even modulator pair is enabled.
    ///< Enabling of an antenna channel is independent of enabling of up to
    ///< 16 lanes of samples which is accomplished by the field MOD_EN_PER_SAMPLE.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MOD_EN_ANT_ODD : 1;
    ///< When 0, the odd channel in an odd/even modulator pair is disabled.
    ///< When 1, the odd channel in an odd/even modulator pair is enabled.
    ///< Enabling of an antenna channel is independent of enabling of up to
    ///< 16 lanes of samples which is accomplished by the field MOD_EN_PER_SAMPLE.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MOD_EN_PER_SAMPLE : 16;
    ///< The Modulator supports rates of N GSPS were N = (3,4,6,8,12, 16).
    ///< The N least signficant bits of this register must be set to 1. The
    ///< 16-N most signlficants bits must be set to 0.  Using these settings
    ///< ensure that the modulators corresponding to the unused samples will
    ///< have their logic clock-gated, thus saving power.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
  } ;
  uint32_t value;
} mod_en_reg_t;

#define MOD_EN_DEFAULT (0x00000000U)
#define MOD_EN_RD_MASK (0x0003ffffU)
#define MOD_EN_WR_MASK (0x0003ffffU)


///< When 0, the even channel in an odd/even modulator pair is disabled.
///< When 1, the even channel in an odd/even modulator pair is enabled.
///< Enabling of an antenna channel is independent of enabling of up to
///< 16 lanes of samples which is accomplished by the field MOD_EN_PER_SAMPLE.
#define MOD_EN_MOD_EN_ANT_EVEN_BF_OFF ( 0)
#define MOD_EN_MOD_EN_ANT_EVEN_BF_WID ( 1)
#define MOD_EN_MOD_EN_ANT_EVEN_BF_MSK (0x00000001)
#define MOD_EN_MOD_EN_ANT_EVEN_BF_DEF (0x00000000)

///< When 0, the odd channel in an odd/even modulator pair is disabled.
///< When 1, the odd channel in an odd/even modulator pair is enabled.
///< Enabling of an antenna channel is independent of enabling of up to
///< 16 lanes of samples which is accomplished by the field MOD_EN_PER_SAMPLE.
#define MOD_EN_MOD_EN_ANT_ODD_BF_OFF ( 1)
#define MOD_EN_MOD_EN_ANT_ODD_BF_WID ( 1)
#define MOD_EN_MOD_EN_ANT_ODD_BF_MSK (0x00000002)
#define MOD_EN_MOD_EN_ANT_ODD_BF_DEF (0x00000000)

///< The Modulator supports rates of N GSPS were N = (3,4,6,8,12, 16).
///< The N least signficant bits of this register must be set to 1. The
///< 16-N most signlficants bits must be set to 0.  Using these settings
///< ensure that the modulators corresponding to the unused samples will
///< have their logic clock-gated, thus saving power.
#define MOD_EN_MOD_EN_PER_SAMPLE_BF_OFF ( 2)
#define MOD_EN_MOD_EN_PER_SAMPLE_BF_WID (16)
#define MOD_EN_MOD_EN_PER_SAMPLE_BF_MSK (0x0003FFFC)
#define MOD_EN_MOD_EN_PER_SAMPLE_BF_DEF (0x00000000)


/** @brief MOD_MAP_REG_SAT_VAL register description at address offset 0xc
  *
  * Register default value:        0x00007FFF
  * Register full path in IP: mod_map/reg/SAT_VAL
  * Saturation Value.
  */

typedef union {
  struct {
    uint32_t SAT_VAL : 15;
    ///< Saturation Value which allows the user to saturate the output of the
    ///< dc_offset addition function.       This assures the user that the
    ///< adding the DC offset does not cause the adjusted input to        dc_offset
    ///< addition to overflow. Typically, the DC offset would be set to the
    ///< unsigned max value of 15'7FFF.       However, without any limitation,
    ///< the DC offset can take on the full rate of 0 through 15'h7FFF.
    ///< Naturally, reducing the saturation value below 15'h7FFF may have an
    ///< impact of the achievable        range of the signal downstream.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7FFF"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} mod_sat_val_reg_t;

#define MOD_SAT_VAL_DEFAULT (0x00007fffU)
#define MOD_SAT_VAL_RD_MASK (0x00007fffU)
#define MOD_SAT_VAL_WR_MASK (0x00007fffU)


///< Saturation Value which allows the user to saturate the output of the
///< dc_offset addition function.       This assures the user that the
///< adding the DC offset does not cause the adjusted input to        dc_offset
///< addition to overflow. Typically, the DC offset would be set to the
///< unsigned max value of 15'7FFF.       However, without any limitation,
///< the DC offset can take on the full rate of 0 through 15'h7FFF.
///< Naturally, reducing the saturation value below 15'h7FFF may have an
///< impact of the achievable        range of the signal downstream.
#define MOD_SAT_VAL_SAT_VAL_BF_OFF ( 0)
#define MOD_SAT_VAL_SAT_VAL_BF_WID (15)
#define MOD_SAT_VAL_SAT_VAL_BF_MSK (0x00007FFF)
#define MOD_SAT_VAL_SAT_VAL_BF_DEF (0x00007FFF)


/** @brief MOD_MAP_REG_APB_BRIDGE_STATUS register description at address offset 0x60
  *
  * Register default value:        0x00010000
  * Register full path in IP: mod_map/reg/APB_BRIDGE_STATUS
  * MOD APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set.
    ///< AccessType="RW/1S" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received.
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set.
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out.
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} mod_apb_brdg_stat_reg_t;

#define MOD_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define MOD_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define MOD_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request.
#define MOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define MOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define MOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define MOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number.
#define MOD_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define MOD_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define MOD_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define MOD_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set.
#define MOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define MOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define MOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define MOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received.
#define MOD_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define MOD_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define MOD_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define MOD_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set.
#define MOD_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define MOD_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define MOD_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define MOD_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out.
#define MOD_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define MOD_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define MOD_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define MOD_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define MOD_SCRATCH_REG(_BASE) ((mod_scratch_reg_t*) MOD_SCRATCH_ADR(_BASE))
#define MOD_CFG_REG(_BASE) ((mod_cfg_reg_t*) MOD_CFG_ADR(_BASE))
#define MOD_EN_REG(_BASE) ((mod_en_reg_t*) MOD_EN_ADR(_BASE))
#define MOD_SAT_VAL_REG(_BASE) ((mod_sat_val_reg_t*) MOD_SAT_VAL_ADR(_BASE))
#define MOD_APB_BRDG_STAT_REG(_BASE) ((mod_apb_brdg_stat_reg_t*) MOD_APB_BRDG_STAT_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    mod_scratch_reg_t SCRATCH;         /*< Address offset = 0x0 */
    mod_cfg_reg_t CFG;          /*< Address offset = 0x4 */
    mod_en_reg_t EN;          /*< Address offset = 0x8 */
    mod_sat_val_reg_t SAT_VAL;         /*< Address offset = 0xc */
    const uint8_t        reservedArea0 [80];  /*< Address offset = 0x10 */
    mod_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x60 */
} mod_t;     // size: 0x0014

// AddressSpace struct pointer
//
#define TRX_SYS0_MOD     ((mod_t*) TRX_SYS0_MOD_BASE)
#define TRX_SYS1_MOD     ((mod_t*) TRX_SYS1_MOD_BASE)
#define TRX_SYS2_MOD     ((mod_t*) TRX_SYS2_MOD_BASE)
#define TRX_SYS3_MOD     ((mod_t*) TRX_SYS3_MOD_BASE)
#define TRX_SYS4_MOD     ((mod_t*) TRX_SYS4_MOD_BASE)
#define TRX_SYS5_MOD     ((mod_t*) TRX_SYS5_MOD_BASE)
#define TRX_SYS6_MOD     ((mod_t*) TRX_SYS6_MOD_BASE)
#define TRX_SYS7_MOD     ((mod_t*) TRX_SYS7_MOD_BASE)

// ******************************************* /Address Space

#endif      // _MOD_H_

