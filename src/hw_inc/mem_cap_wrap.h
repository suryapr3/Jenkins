#ifndef _MEM_CAP_WRAP_H_
#define _MEM_CAP_WRAP_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define MEM_CAP0_BASE         ( 0x041f0000 )
#define MEM_CAP1_BASE         ( 0x043f0000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define MEM_CAP_WRAP_MUX_SEL0_OFFSET ( 0x00000000U )
#define MEM_CAP_WRAP_MUX_SEL1_OFFSET ( 0x00000004U )
#define MEM_CAP_WRAP_MUX_SEL2_OFFSET ( 0x00000008U )
#define MEM_CAP_WRAP_MUX_SEL3_OFFSET ( 0x0000000cU )
#define MEM_CAP_WRAP_MUX_SEL4_OFFSET ( 0x00000010U )
#define MEM_CAP_WRAP_MUX_SEL5_OFFSET ( 0x00000014U )
#define MEM_CAP_WRAP_MUX_SEL6_OFFSET ( 0x00000018U )
#define MEM_CAP_WRAP_MEM_ERR0_OFFSET ( 0x00000020U )
#define MEM_CAP_WRAP_MEM_ERR1_OFFSET ( 0x00000024U )
#define MEM_CAP_WRAP_MEM_ERR2_OFFSET ( 0x00000028U )
#define MEM_CAP_WRAP_MEM_ERR3_OFFSET ( 0x0000002cU )
#define MEM_CAP_WRAP_MEM_ERR4_OFFSET ( 0x00000030U )
#define MEM_CAP_WRAP_MEM_ERR5_OFFSET ( 0x00000034U )
#define MEM_CAP_WRAP_MEM_ERR6_OFFSET ( 0x00000038U )
#define MEM_CAP_WRAP_ECC_ERR0_OFFSET ( 0x00000040U )
#define MEM_CAP_WRAP_ECC_ERR1_OFFSET ( 0x00000044U )
#define MEM_CAP_WRAP_ECC_ERR2_OFFSET ( 0x00000048U )
#define MEM_CAP_WRAP_ECC_ERR3_OFFSET ( 0x0000004cU )
#define MEM_CAP_WRAP_ECC_ERR4_OFFSET ( 0x00000050U )
#define MEM_CAP_WRAP_ECC_ERR5_OFFSET ( 0x00000054U )
#define MEM_CAP_WRAP_ECC_ERR6_OFFSET ( 0x00000058U )
#define MEM_CAP_WRAP_ECC_CORRECT_OFFSET ( 0x00000060U )
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_OFFSET ( 0x00000064U )
#define MEM_CAP_WRAP_ECC_CFG0_OFFSET ( 0x00000080U )
#define MEM_CAP_WRAP_ECC_CFG1_OFFSET ( 0x00000084U )
#define MEM_CAP_WRAP_ECC_CFG2_OFFSET ( 0x00000088U )
#define MEM_CAP_WRAP_ECC_CFG3_OFFSET ( 0x0000008cU )
#define MEM_CAP_WRAP_ECC_CFG4_OFFSET ( 0x00000090U )
#define MEM_CAP_WRAP_ECC_CFG5_OFFSET ( 0x00000094U )
#define MEM_CAP_WRAP_ECC_CFG6_OFFSET ( 0x00000098U )
#define MEM_CAP_WRAP_ECC_CFG7_OFFSET ( 0x0000009cU )
#define MEM_CAP_WRAP_ECC_CFG8_OFFSET ( 0x000000a0U )
#define MEM_CAP_WRAP_ECC_CFG9_OFFSET ( 0x000000a4U )
#define MEM_CAP_WRAP_ECC_CFG10_OFFSET ( 0x000000a8U )
#define MEM_CAP_WRAP_ECC_CFG11_OFFSET ( 0x000000acU )
#define MEM_CAP_WRAP_ECC_CFG12_OFFSET ( 0x000000b0U )
#define MEM_CAP_WRAP_ECC_CFG13_OFFSET ( 0x000000b4U )
#define MEM_CAP_WRAP_ECC_CFG14_OFFSET ( 0x000000b8U )
#define MEM_CAP_WRAP_ECC_CFG15_OFFSET ( 0x000000bcU )
#define MEM_CAP_WRAP_ECC_CFG16_OFFSET ( 0x000000c0U )
#define MEM_CAP_WRAP_ECC_CFG17_OFFSET ( 0x000000c4U )
#define MEM_CAP_WRAP_ECC_CFG18_OFFSET ( 0x000000c8U )
#define MEM_CAP_WRAP_ECC_CFG19_OFFSET ( 0x000000ccU )
#define MEM_CAP_WRAP_ECC_CFG20_OFFSET ( 0x000000d0U )
#define MEM_CAP_WRAP_ECC_CFG21_OFFSET ( 0x000000d4U )
#define MEM_CAP_WRAP_ECC_CFG22_OFFSET ( 0x000000d8U )
#define MEM_CAP_WRAP_ECC_CFG23_OFFSET ( 0x000000dcU )
#define MEM_CAP_WRAP_ECC_CFG24_OFFSET ( 0x000000e0U )
#define MEM_CAP_WRAP_ECC_CFG25_OFFSET ( 0x000000e4U )
#define MEM_CAP_WRAP_ECC_CFG26_OFFSET ( 0x000000e8U )
#define MEM_CAP_WRAP_ECC_CFG27_OFFSET ( 0x000000ecU )
#define MEM_CAP_WRAP_ECC_SBE_LVL0_OFFSET ( 0x00000100U )
#define MEM_CAP_WRAP_ECC_SBE_LVL1_OFFSET ( 0x00000104U )
#define MEM_CAP_WRAP_ECC_SBE_LVL2_OFFSET ( 0x00000108U )
#define MEM_CAP_WRAP_ECC_SBE_LVL3_OFFSET ( 0x0000010cU )
#define MEM_CAP_WRAP_ECC_DBE_LVL0_OFFSET ( 0x00000110U )
#define MEM_CAP_WRAP_ECC_DBE_LVL1_OFFSET ( 0x00000114U )
#define MEM_CAP_WRAP_ECC_DBE_LVL2_OFFSET ( 0x00000118U )
#define MEM_CAP_WRAP_ECC_DBE_LVL3_OFFSET ( 0x0000011cU )
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL0_OFFSET ( 0x00000120U )
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL1_OFFSET ( 0x00000124U )
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL2_OFFSET ( 0x00000128U )
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL3_OFFSET ( 0x0000012cU )
#define MEM_CAP_WRAP_ECC_STAT_INDEX_OFFSET ( 0x00000130U )
#define MEM_CAP_WRAP_ECC_STAT_OFFSET ( 0x00000134U )
#define MEM_CAP_WRAP_RX_START0_OFFSET ( 0x00000180U )
#define MEM_CAP_WRAP_RX_START1_OFFSET ( 0x00000184U )
#define MEM_CAP_WRAP_RX_START2_OFFSET ( 0x00000188U )
#define MEM_CAP_WRAP_RX_START3_OFFSET ( 0x0000018cU )
#define MEM_CAP_WRAP_RX_START4_OFFSET ( 0x00000190U )
#define MEM_CAP_WRAP_RX_END0_OFFSET ( 0x000001a0U )
#define MEM_CAP_WRAP_RX_END1_OFFSET ( 0x000001a4U )
#define MEM_CAP_WRAP_RX_END2_OFFSET ( 0x000001a8U )
#define MEM_CAP_WRAP_RX_END3_OFFSET ( 0x000001acU )
#define MEM_CAP_WRAP_RX_END4_OFFSET ( 0x000001b0U )
#define MEM_CAP_WRAP_RX_CUR0_OFFSET ( 0x000001c0U )
#define MEM_CAP_WRAP_RX_CUR1_OFFSET ( 0x000001c4U )
#define MEM_CAP_WRAP_RX_CUR2_OFFSET ( 0x000001c8U )
#define MEM_CAP_WRAP_RX_CUR3_OFFSET ( 0x000001ccU )
#define MEM_CAP_WRAP_RX_CUR4_OFFSET ( 0x000001d0U )
#define MEM_CAP_WRAP_RX_MODE0_OFFSET ( 0x000001e0U )
#define MEM_CAP_WRAP_RX_MODE1_OFFSET ( 0x000001e4U )
#define MEM_CAP_WRAP_RX_MODE2_OFFSET ( 0x000001e8U )
#define MEM_CAP_WRAP_RX_MODE3_OFFSET ( 0x000001ecU )
#define MEM_CAP_WRAP_RX_MODE4_OFFSET ( 0x000001f0U )
#define MEM_CAP_WRAP_TX_START0_OFFSET ( 0x00000200U )
#define MEM_CAP_WRAP_TX_START1_OFFSET ( 0x00000204U )
#define MEM_CAP_WRAP_TX_START2_OFFSET ( 0x00000208U )
#define MEM_CAP_WRAP_TX_START3_OFFSET ( 0x0000020cU )
#define MEM_CAP_WRAP_TX_END0_OFFSET ( 0x00000220U )
#define MEM_CAP_WRAP_TX_END1_OFFSET ( 0x00000224U )
#define MEM_CAP_WRAP_TX_END2_OFFSET ( 0x00000228U )
#define MEM_CAP_WRAP_TX_END3_OFFSET ( 0x0000022cU )
#define MEM_CAP_WRAP_TX_CUR0_OFFSET ( 0x00000240U )
#define MEM_CAP_WRAP_TX_CUR1_OFFSET ( 0x00000244U )
#define MEM_CAP_WRAP_TX_CUR2_OFFSET ( 0x00000248U )
#define MEM_CAP_WRAP_TX_CUR3_OFFSET ( 0x0000024cU )
#define MEM_CAP_WRAP_TX_MODE0_OFFSET ( 0x00000260U )
#define MEM_CAP_WRAP_TX_MODE1_OFFSET ( 0x00000264U )
#define MEM_CAP_WRAP_TX_MODE2_OFFSET ( 0x00000268U )
#define MEM_CAP_WRAP_TX_MODE3_OFFSET ( 0x0000026cU )
#define MEM_CAP_WRAP_LFSR_SEED_UPPER0_OFFSET ( 0x00000280U )
#define MEM_CAP_WRAP_LFSR_SEED_UPPER1_OFFSET ( 0x00000288U )
#define MEM_CAP_WRAP_LFSR_SEED_UPPER2_OFFSET ( 0x00000290U )
#define MEM_CAP_WRAP_LFSR_SEED_UPPER3_OFFSET ( 0x00000298U )
#define MEM_CAP_WRAP_LFSR_SEED_UPPER4_OFFSET ( 0x000002a0U )
#define MEM_CAP_WRAP_LFSR_SEED_UPPER5_OFFSET ( 0x000002a8U )
#define MEM_CAP_WRAP_LFSR_SEED_UPPER6_OFFSET ( 0x000002b0U )
#define MEM_CAP_WRAP_LFSR_SEED_LOWER0_OFFSET ( 0x000002c0U )
#define MEM_CAP_WRAP_LFSR_SEED_LOWER1_OFFSET ( 0x000002c8U )
#define MEM_CAP_WRAP_LFSR_SEED_LOWER2_OFFSET ( 0x000002d0U )
#define MEM_CAP_WRAP_LFSR_SEED_LOWER3_OFFSET ( 0x000002d8U )
#define MEM_CAP_WRAP_LFSR_SEED_LOWER4_OFFSET ( 0x000002e0U )
#define MEM_CAP_WRAP_LFSR_SEED_LOWER5_OFFSET ( 0x000002e8U )
#define MEM_CAP_WRAP_LFSR_SEED_LOWER6_OFFSET ( 0x000002f0U )
#define MEM_CAP_WRAP_FIXED_PATTERN0_OFFSET ( 0x00000300U )
#define MEM_CAP_WRAP_FIXED_PATTERN1_OFFSET ( 0x00000304U )
#define MEM_CAP_WRAP_FIXED_PATTERN2_OFFSET ( 0x00000308U )
#define MEM_CAP_WRAP_FIXED_PATTERN3_OFFSET ( 0x0000030cU )
#define MEM_CAP_WRAP_FIXED_PATTERN4_OFFSET ( 0x00000310U )
#define MEM_CAP_WRAP_FIXED_PATTERN5_OFFSET ( 0x00000314U )
#define MEM_CAP_WRAP_FIXED_PATTERN6_OFFSET ( 0x00000318U )
#define MEM_CAP_WRAP_RAMP_CFG0_OFFSET ( 0x00000320U )
#define MEM_CAP_WRAP_RAMP_CFG1_OFFSET ( 0x00000324U )
#define MEM_CAP_WRAP_RAMP_CFG2_OFFSET ( 0x00000328U )
#define MEM_CAP_WRAP_RAMP_CFG3_OFFSET ( 0x0000032cU )
#define MEM_CAP_WRAP_RAMP_CFG4_OFFSET ( 0x00000330U )
#define MEM_CAP_WRAP_RAMP_CFG5_OFFSET ( 0x00000334U )
#define MEM_CAP_WRAP_RAMP_CFG6_OFFSET ( 0x00000338U )
#define MEM_CAP_WRAP_INIT_RAM0_OFFSET ( 0x00000340U )
#define MEM_CAP_WRAP_INIT_RAM1_OFFSET ( 0x00000344U )
#define MEM_CAP_WRAP_INIT_RAM2_OFFSET ( 0x00000348U )
#define MEM_CAP_WRAP_INIT_RAM3_OFFSET ( 0x0000034cU )
#define MEM_CAP_WRAP_INIT_RAM4_OFFSET ( 0x00000350U )
#define MEM_CAP_WRAP_INIT_RAM5_OFFSET ( 0x00000354U )
#define MEM_CAP_WRAP_INIT_RAM6_OFFSET ( 0x00000358U )
#define MEM_CAP_WRAP_CAPT_OFFSET ( 0x00000360U )
#define MEM_CAP_WRAP_SCRATCH_OFFSET ( 0x00000364U )
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_OFFSET ( 0x00000370U )
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_OFFSET ( 0x00000374U )
#define MEM_CAP_WRAP_INT_STAT_OFFSET ( 0x00000380U )
#define MEM_CAP_WRAP_INT_HIGH_EN_OFFSET ( 0x00000384U )
#define MEM_CAP_WRAP_INT_LOW_EN_OFFSET ( 0x00000388U )
#define MEM_CAP_WRAP_INT_CLR_OFFSET ( 0x0000038cU )
#define MEM_CAP_WRAP_INT_FORCE_OFFSET ( 0x00000390U )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_OFFSET ( 0x000003a0U )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_OFFSET ( 0x000003a4U )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_OFFSET ( 0x000003a8U )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_OFFSET ( 0x000003acU )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_OFFSET ( 0x000003b0U )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_OFFSET ( 0x000003b4U )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_OFFSET ( 0x000003b8U )
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_OFFSET ( 0x000003bcU )
#define MEM_CAP_WRAP_APB_BRDG_STAT_OFFSET ( 0x000003fcU )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define MEM_CAP_WRAP_MUX_SEL0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MUX_SEL0_OFFSET ) ))
#define MEM_CAP_WRAP_MUX_SEL1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MUX_SEL1_OFFSET ) ))
#define MEM_CAP_WRAP_MUX_SEL2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MUX_SEL2_OFFSET ) ))
#define MEM_CAP_WRAP_MUX_SEL3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MUX_SEL3_OFFSET ) ))
#define MEM_CAP_WRAP_MUX_SEL4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MUX_SEL4_OFFSET ) ))
#define MEM_CAP_WRAP_MUX_SEL5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MUX_SEL5_OFFSET ) ))
#define MEM_CAP_WRAP_MUX_SEL6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MUX_SEL6_OFFSET ) ))
#define MEM_CAP_WRAP_MEM_ERR0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MEM_ERR0_OFFSET ) ))
#define MEM_CAP_WRAP_MEM_ERR1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MEM_ERR1_OFFSET ) ))
#define MEM_CAP_WRAP_MEM_ERR2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MEM_ERR2_OFFSET ) ))
#define MEM_CAP_WRAP_MEM_ERR3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MEM_ERR3_OFFSET ) ))
#define MEM_CAP_WRAP_MEM_ERR4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MEM_ERR4_OFFSET ) ))
#define MEM_CAP_WRAP_MEM_ERR5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MEM_ERR5_OFFSET ) ))
#define MEM_CAP_WRAP_MEM_ERR6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_MEM_ERR6_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_ERR0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_ERR0_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_ERR1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_ERR1_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_ERR2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_ERR2_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_ERR3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_ERR3_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_ERR4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_ERR4_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_ERR5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_ERR5_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_ERR6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_ERR6_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CORRECT_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CORRECT_OFFSET ) ))
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_PWR_DOWN_CTRL_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG0_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG1_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG2_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG3_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG4_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG5_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG6_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG7_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG7_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG8_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG8_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG9_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG9_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG10_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG10_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG11_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG11_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG12_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG12_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG13_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG13_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG14_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG14_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG15_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG15_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG16_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG16_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG17_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG17_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG18_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG18_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG19_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG19_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG20_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG20_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG21_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG21_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG22_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG22_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG23_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG23_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG24_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG24_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG25_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG25_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG26_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG26_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_CFG27_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_CFG27_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_LVL0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_LVL0_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_LVL1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_LVL1_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_LVL2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_LVL2_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_LVL3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_LVL3_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_DBE_LVL0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_DBE_LVL0_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_DBE_LVL1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_DBE_LVL1_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_DBE_LVL2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_DBE_LVL2_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_DBE_LVL3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_DBE_LVL3_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_CNT_OVFL0_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_CNT_OVFL1_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_CNT_OVFL2_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_SBE_CNT_OVFL3_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_STAT_INDEX_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_STAT_INDEX_OFFSET ) ))
#define MEM_CAP_WRAP_ECC_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_ECC_STAT_OFFSET ) ))
#define MEM_CAP_WRAP_RX_START0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_START0_OFFSET ) ))
#define MEM_CAP_WRAP_RX_START1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_START1_OFFSET ) ))
#define MEM_CAP_WRAP_RX_START2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_START2_OFFSET ) ))
#define MEM_CAP_WRAP_RX_START3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_START3_OFFSET ) ))
#define MEM_CAP_WRAP_RX_START4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_START4_OFFSET ) ))
#define MEM_CAP_WRAP_RX_END0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_END0_OFFSET ) ))
#define MEM_CAP_WRAP_RX_END1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_END1_OFFSET ) ))
#define MEM_CAP_WRAP_RX_END2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_END2_OFFSET ) ))
#define MEM_CAP_WRAP_RX_END3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_END3_OFFSET ) ))
#define MEM_CAP_WRAP_RX_END4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_END4_OFFSET ) ))
#define MEM_CAP_WRAP_RX_CUR0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_CUR0_OFFSET ) ))
#define MEM_CAP_WRAP_RX_CUR1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_CUR1_OFFSET ) ))
#define MEM_CAP_WRAP_RX_CUR2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_CUR2_OFFSET ) ))
#define MEM_CAP_WRAP_RX_CUR3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_CUR3_OFFSET ) ))
#define MEM_CAP_WRAP_RX_CUR4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_CUR4_OFFSET ) ))
#define MEM_CAP_WRAP_RX_MODE0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_MODE0_OFFSET ) ))
#define MEM_CAP_WRAP_RX_MODE1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_MODE1_OFFSET ) ))
#define MEM_CAP_WRAP_RX_MODE2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_MODE2_OFFSET ) ))
#define MEM_CAP_WRAP_RX_MODE3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_MODE3_OFFSET ) ))
#define MEM_CAP_WRAP_RX_MODE4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RX_MODE4_OFFSET ) ))
#define MEM_CAP_WRAP_TX_START0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_START0_OFFSET ) ))
#define MEM_CAP_WRAP_TX_START1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_START1_OFFSET ) ))
#define MEM_CAP_WRAP_TX_START2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_START2_OFFSET ) ))
#define MEM_CAP_WRAP_TX_START3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_START3_OFFSET ) ))
#define MEM_CAP_WRAP_TX_END0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_END0_OFFSET ) ))
#define MEM_CAP_WRAP_TX_END1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_END1_OFFSET ) ))
#define MEM_CAP_WRAP_TX_END2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_END2_OFFSET ) ))
#define MEM_CAP_WRAP_TX_END3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_END3_OFFSET ) ))
#define MEM_CAP_WRAP_TX_CUR0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_CUR0_OFFSET ) ))
#define MEM_CAP_WRAP_TX_CUR1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_CUR1_OFFSET ) ))
#define MEM_CAP_WRAP_TX_CUR2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_CUR2_OFFSET ) ))
#define MEM_CAP_WRAP_TX_CUR3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_CUR3_OFFSET ) ))
#define MEM_CAP_WRAP_TX_MODE0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_MODE0_OFFSET ) ))
#define MEM_CAP_WRAP_TX_MODE1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_MODE1_OFFSET ) ))
#define MEM_CAP_WRAP_TX_MODE2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_MODE2_OFFSET ) ))
#define MEM_CAP_WRAP_TX_MODE3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TX_MODE3_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_UPPER0_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_UPPER1_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_UPPER2_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_UPPER3_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_UPPER4_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_UPPER5_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_UPPER6_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_LOWER0_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_LOWER1_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_LOWER2_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_LOWER3_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_LOWER4_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_LOWER5_OFFSET ) ))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_LFSR_SEED_LOWER6_OFFSET ) ))
#define MEM_CAP_WRAP_FIXED_PATTERN0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_FIXED_PATTERN0_OFFSET ) ))
#define MEM_CAP_WRAP_FIXED_PATTERN1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_FIXED_PATTERN1_OFFSET ) ))
#define MEM_CAP_WRAP_FIXED_PATTERN2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_FIXED_PATTERN2_OFFSET ) ))
#define MEM_CAP_WRAP_FIXED_PATTERN3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_FIXED_PATTERN3_OFFSET ) ))
#define MEM_CAP_WRAP_FIXED_PATTERN4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_FIXED_PATTERN4_OFFSET ) ))
#define MEM_CAP_WRAP_FIXED_PATTERN5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_FIXED_PATTERN5_OFFSET ) ))
#define MEM_CAP_WRAP_FIXED_PATTERN6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_FIXED_PATTERN6_OFFSET ) ))
#define MEM_CAP_WRAP_RAMP_CFG0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RAMP_CFG0_OFFSET ) ))
#define MEM_CAP_WRAP_RAMP_CFG1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RAMP_CFG1_OFFSET ) ))
#define MEM_CAP_WRAP_RAMP_CFG2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RAMP_CFG2_OFFSET ) ))
#define MEM_CAP_WRAP_RAMP_CFG3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RAMP_CFG3_OFFSET ) ))
#define MEM_CAP_WRAP_RAMP_CFG4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RAMP_CFG4_OFFSET ) ))
#define MEM_CAP_WRAP_RAMP_CFG5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RAMP_CFG5_OFFSET ) ))
#define MEM_CAP_WRAP_RAMP_CFG6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_RAMP_CFG6_OFFSET ) ))
#define MEM_CAP_WRAP_INIT_RAM0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INIT_RAM0_OFFSET ) ))
#define MEM_CAP_WRAP_INIT_RAM1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INIT_RAM1_OFFSET ) ))
#define MEM_CAP_WRAP_INIT_RAM2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INIT_RAM2_OFFSET ) ))
#define MEM_CAP_WRAP_INIT_RAM3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INIT_RAM3_OFFSET ) ))
#define MEM_CAP_WRAP_INIT_RAM4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INIT_RAM4_OFFSET ) ))
#define MEM_CAP_WRAP_INIT_RAM5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INIT_RAM5_OFFSET ) ))
#define MEM_CAP_WRAP_INIT_RAM6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INIT_RAM6_OFFSET ) ))
#define MEM_CAP_WRAP_CAPT_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_CAPT_OFFSET ) ))
#define MEM_CAP_WRAP_SCRATCH_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SCRATCH_OFFSET ) ))
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TDPACK_FIFO_WM_OFFSET ) ))
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_TDPACK_FIFO_STAT_OFFSET ) ))
#define MEM_CAP_WRAP_INT_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INT_STAT_OFFSET ) ))
#define MEM_CAP_WRAP_INT_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INT_HIGH_EN_OFFSET ) ))
#define MEM_CAP_WRAP_INT_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INT_LOW_EN_OFFSET ) ))
#define MEM_CAP_WRAP_INT_CLR_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INT_CLR_OFFSET ) ))
#define MEM_CAP_WRAP_INT_FORCE_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_INT_FORCE_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R0_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R1_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R2_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R3_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R4_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R5_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R6_OFFSET ) ))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_SMON_CSR_SMON_R7_OFFSET ) ))
#define MEM_CAP_WRAP_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( MEM_CAP_WRAP_APB_BRDG_STAT_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_MUX_SEL[7] register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/MUX_SEL
  * Mem Mux Select
  */

typedef union {
  struct {
    uint32_t MUX_SEL : 4;
    ///< Specifies which memory function can access a given sector.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_mux_sel_reg_t;

#define MEM_CAP_WRAP_MUX_SEL_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_MUX_SEL_RD_MASK (0x0000000fU)
#define MEM_CAP_WRAP_MUX_SEL_WR_MASK (0x0000000fU)


///< Specifies which memory function can access a given sector.
#define MEM_CAP_WRAP_MUX_SEL_MUX_SEL_BF_OFF ( 0)
#define MEM_CAP_WRAP_MUX_SEL_MUX_SEL_BF_WID ( 4)
#define MEM_CAP_WRAP_MUX_SEL_MUX_SEL_BF_MSK (0x0000000F)
#define MEM_CAP_WRAP_MUX_SEL_MUX_SEL_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_MUX_SEL_ARR_SZ0 (7)
#define MEM_CAP_WRAP_MUX_SEL_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_MEM_ERR[7] register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/MEM_ERR
  * Memory Error Indication
  */

typedef union {
  struct {
    uint32_t MGMT_WR_ERR : 1;
    ///< Mgmt Write Access Error
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t MGMT_RD_ERR : 1;
    ///< Mgmt Read Access Error
    ///< AccessType="RW/1C/V" BitOffset="1" ResetValue="0x0"
    uint32_t INIT_ERR : 1;
    ///< Init Access Error
    ///< AccessType="RW/1C/V" BitOffset="2" ResetValue="0x0"
    uint32_t SBE : 1;
    ///< Single bit ECC Error
    ///< AccessType="RW/1C/V" BitOffset="3" ResetValue="0x0"
    uint32_t MBE : 1;
    ///< Multi bit ECC Error
    ///< AccessType="RW/1C/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_mem_err_reg_t;

#define MEM_CAP_WRAP_MEM_ERR_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_MEM_ERR_RD_MASK (0x0000001fU)
#define MEM_CAP_WRAP_MEM_ERR_WR_MASK (0x0000001fU)


///< Mgmt Write Access Error
#define MEM_CAP_WRAP_MEM_ERR_MGMT_WR_ERR_BF_OFF ( 0)
#define MEM_CAP_WRAP_MEM_ERR_MGMT_WR_ERR_BF_WID ( 1)
#define MEM_CAP_WRAP_MEM_ERR_MGMT_WR_ERR_BF_MSK (0x00000001)
#define MEM_CAP_WRAP_MEM_ERR_MGMT_WR_ERR_BF_DEF (0x00000000)

///< Mgmt Read Access Error
#define MEM_CAP_WRAP_MEM_ERR_MGMT_RD_ERR_BF_OFF ( 1)
#define MEM_CAP_WRAP_MEM_ERR_MGMT_RD_ERR_BF_WID ( 1)
#define MEM_CAP_WRAP_MEM_ERR_MGMT_RD_ERR_BF_MSK (0x00000002)
#define MEM_CAP_WRAP_MEM_ERR_MGMT_RD_ERR_BF_DEF (0x00000000)

///< Init Access Error
#define MEM_CAP_WRAP_MEM_ERR_INIT_ERR_BF_OFF ( 2)
#define MEM_CAP_WRAP_MEM_ERR_INIT_ERR_BF_WID ( 1)
#define MEM_CAP_WRAP_MEM_ERR_INIT_ERR_BF_MSK (0x00000004)
#define MEM_CAP_WRAP_MEM_ERR_INIT_ERR_BF_DEF (0x00000000)

///< Single bit ECC Error
#define MEM_CAP_WRAP_MEM_ERR_SBE_BF_OFF ( 3)
#define MEM_CAP_WRAP_MEM_ERR_SBE_BF_WID ( 1)
#define MEM_CAP_WRAP_MEM_ERR_SBE_BF_MSK (0x00000008)
#define MEM_CAP_WRAP_MEM_ERR_SBE_BF_DEF (0x00000000)

///< Multi bit ECC Error
#define MEM_CAP_WRAP_MEM_ERR_MBE_BF_OFF ( 4)
#define MEM_CAP_WRAP_MEM_ERR_MBE_BF_WID ( 1)
#define MEM_CAP_WRAP_MEM_ERR_MBE_BF_MSK (0x00000010)
#define MEM_CAP_WRAP_MEM_ERR_MBE_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_MEM_ERR_ARR_SZ0 (7)
#define MEM_CAP_WRAP_MEM_ERR_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_ERR[7] register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_ERR
  * Memory ECC Error Indication
  */

typedef union {
  struct {
    uint32_t SBE : 16;
    ///< Single bit ECC Error. ith bit corresponds to ith memory module (of
    ///< 16 memory modules) in given sector.
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t MBE : 16;
    ///< Multi bit ECC Error. ith bit corresponds to ith memory module (of
    ///< 16 memory modules) in given sector.
    ///< AccessType="RW/1C/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_err_reg_t;

#define MEM_CAP_WRAP_ECC_ERR_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_ECC_ERR_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_ECC_ERR_WR_MASK (0xffffffffU)


///< Single bit ECC Error. ith bit corresponds to ith memory module (of
///< 16 memory modules) in given sector.
#define MEM_CAP_WRAP_ECC_ERR_SBE_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_ERR_SBE_BF_WID (16)
#define MEM_CAP_WRAP_ECC_ERR_SBE_BF_MSK (0x0000FFFF)
#define MEM_CAP_WRAP_ECC_ERR_SBE_BF_DEF (0x00000000)

///< Multi bit ECC Error. ith bit corresponds to ith memory module (of
///< 16 memory modules) in given sector.
#define MEM_CAP_WRAP_ECC_ERR_MBE_BF_OFF (16)
#define MEM_CAP_WRAP_ECC_ERR_MBE_BF_WID (16)
#define MEM_CAP_WRAP_ECC_ERR_MBE_BF_MSK (0xFFFF0000)
#define MEM_CAP_WRAP_ECC_ERR_MBE_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_ECC_ERR_ARR_SZ0 (7)
#define MEM_CAP_WRAP_ECC_ERR_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_CORRECT register description at address offset 0x60
  *
  * Register default value:        0x00000001
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_CORRECT
  * Memory ECC Correct Enable Register
  */

typedef union {
  struct {
    uint32_t ECC_CORRECT : 1;
    ///< Enable ECC correction.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_correct_reg_t;

#define MEM_CAP_WRAP_ECC_CORRECT_DEFAULT (0x00000001U)
#define MEM_CAP_WRAP_ECC_CORRECT_RD_MASK (0x00000001U)
#define MEM_CAP_WRAP_ECC_CORRECT_WR_MASK (0x00000001U)


///< Enable ECC correction.
#define MEM_CAP_WRAP_ECC_CORRECT_ECC_CORRECT_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_CORRECT_ECC_CORRECT_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CORRECT_ECC_CORRECT_BF_MSK (0x00000001)
#define MEM_CAP_WRAP_ECC_CORRECT_ECC_CORRECT_BF_DEF (0x00000001)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_POWER_DOWN_CONTROL register description at address offset 0x64
  *
  * Register default value:        0x0000007F
  * Register full path in IP: mem_cap_wrap/mem_cap_map/POWER_DOWN_CONTROL
  * Power down control register
  */

typedef union {
  struct {
    uint32_t POWER_DOWN : 7;
    ///< The MEM_CAP_MEM memory block contains a MEM_CAP_MEM 1.75MByte memory
    ///< which is divided into 7 sectors. These sectors can be powered down
    ///< individually using these register bits. Here bit 0 corresponds to
    ///< Sector 0 and bit 6 corresponds to Sector 6. When the bit is set, the
    ///< sector corresponding to that bit is powered down and is not available
    ///< for normal operation. These memories come up in a powered down state
    ///< (i.e. the corresponding control bit is set to 1) after reset. The
    ///< user must actively turn off the power down state in order to use this
    ///< memory. This is done to ensure that the chip is configured to use
    ///< the minimum amount of power.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7F"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_pwr_down_ctrl_reg_t;

#define MEM_CAP_WRAP_PWR_DOWN_CTRL_DEFAULT (0x0000007fU)
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_RD_MASK (0x0000007fU)
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_WR_MASK (0x0000007fU)


///< The MEM_CAP_MEM memory block contains a MEM_CAP_MEM 1.75MByte memory
///< which is divided into 7 sectors. These sectors can be powered down
///< individually using these register bits. Here bit 0 corresponds to
///< Sector 0 and bit 6 corresponds to Sector 6. When the bit is set, the
///< sector corresponding to that bit is powered down and is not available
///< for normal operation. These memories come up in a powered down state
///< (i.e. the corresponding control bit is set to 1) after reset. The
///< user must actively turn off the power down state in order to use this
///< memory. This is done to ensure that the chip is configured to use
///< the minimum amount of power.
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_PWR_DOWN_BF_OFF ( 0)
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_PWR_DOWN_BF_WID ( 7)
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_PWR_DOWN_BF_MSK (0x0000007F)
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_PWR_DOWN_BF_DEF (0x0000007F)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_CFG[28] register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_CFG
  * ECC Config
  */

typedef union {
  struct {
    uint32_t ECC_REFRESH_DIS_0 : 1;
    ///< When set, this bit disables refresh function in AW_ecc_refresh that
    ///< supports data[31:0]. The inverse of this bit is connected to AW_ecc_refresh.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t ECC_CNT_CLR_0 : 1;
    ///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
    ///< that supports data [31:0]. It should retain the last written value,
    ///< like the Clear register in AW_intr_high_low.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t ECC_CHK_DIS_0 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [31:0]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t ECC_GEN_DIS_0 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [31:0]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t ECC_ERR_CLR_0 : 1;
    ///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
    ///< outputs associated with data[31:0]. Writing this bit to 1 should generate
    ///< a pulse to AW_ecc_refresh.int_clr. It should retain the last written
    ///< value.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ECC_FORCE_TYPE_0 : 1;
    ///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
    ///< supporting data[31:0]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t ECC_FORCE_ERR_0 : 1;
    ///< When set to 1, this bit enables the user to insert one ECC error determined
    ///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
    ///< data[31:0]. It should be cleared when the expected ECC error is seen.
    ///< Connected to AW_ecc_refresh.ecc_err_force_en.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t ECC_REFRESH_RSVD0 : 1;
    ///< This field is reserved..
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t ECC_REFRESH_DIS_1 : 1;
    ///< When set, this bit disables refresh function in AW_ecc_refresh that
    ///< supports data[63:32]. The inverse of this bit is connected to AW_ecc_refresh.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ECC_CNT_CLR_1 : 1;
    ///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
    ///< that supports data [63:32]. It should retain the last written value,
    ///< like the Clear register in AW_intr_high_low.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t ECC_CHK_DIS_1 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [63:32]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t ECC_GEN_DIS_1 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [63:32]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t ECC_ERR_CLR_1 : 1;
    ///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
    ///< outputs associated with data[63:32]. Writing this bit to 1 should
    ///< generate a pulse to AW_ecc_refresh.int_clr. It should retain the last
    ///< written value.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t ECC_FORCE_TYPE_1 : 1;
    ///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
    ///< supporting data[63:32]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t ECC_FORCE_ERR_1 : 1;
    ///< When set to 1, this bit enables the user to insert one ECC error determined
    ///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
    ///< data[63:32]. It should be cleared when the expected ECC error is seen.
    ///< Connected to AW_ecc_refresh.ecc_err_force_en.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t ECC_REFRESH_RSVD1 : 1;
    ///< This field is reserved..
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ECC_REFRESH_DIS_2 : 1;
    ///< When set, this bit disables refresh function in AW_ecc_refresh that
    ///< supports data[95:64]. The inverse of this bit is connected to AW_ecc_refresh.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t ECC_CNT_CLR_2 : 1;
    ///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
    ///< that supports data [95:64]. It should retain the last written value,
    ///< like the Clear register in AW_intr_high_low.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t ECC_CHK_DIS_2 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [95:64]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t ECC_GEN_DIS_2 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [95:64]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t ECC_ERR_CLR_2 : 1;
    ///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
    ///< outputs associated with data[95:64]. Writing this bit to 1 should
    ///< generate a pulse to AW_ecc_refresh.int_clr. It should retain the last
    ///< written value.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t ECC_FORCE_TYPE_2 : 1;
    ///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
    ///< supporting data[95:64]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t ECC_FORCE_ERR_2 : 1;
    ///< When set to 1, this bit enables the user to insert one ECC error determined
    ///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
    ///< data[95:64]. It should be cleared when the expected ECC error is seen.
    ///< Connected to AW_ecc_refresh.ecc_err_force_en.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t ECC_REFRESH_RSVD2 : 1;
    ///< This field is reserved..
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t ECC_REFRESH_DIS_3 : 1;
    ///< When set, this bit disables refresh function in AW_ecc_refresh that
    ///< supports data[127:96]. The inverse of this bit is connected to AW_ecc_refresh.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t ECC_CNT_CLR_3 : 1;
    ///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
    ///< that supports data [127:96]. It should retain the last written value,
    ///< like the Clear register in AW_intr_high_low.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t ECC_CHK_DIS_3 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [127:96]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t ECC_GEN_DIS_3 : 1;
    ///< When set, this bit disables ECC generation in AW_ecc_refresh that
    ///< supports data [127:96]. Used for debug and testing purpose. The inverse
    ///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t ECC_ERR_CLR_3 : 1;
    ///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
    ///< outputs associated with data[127:96]. Writing this bit to 1 should
    ///< generate a pulse to AW_ecc_refresh.int_clr. It should retain the last
    ///< written value.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t ECC_FORCE_TYPE_3 : 1;
    ///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
    ///< supporting data[127:96]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t ECC_FORCE_ERR_3 : 1;
    ///< When set to 1, this bit enables the user to insert one ECC error determined
    ///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
    ///< data[127:96]. It should be cleared when the expected ECC error is
    ///< seen.  Connected to AW_ecc_refresh.ecc_err_force_en.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t ECC_REFRESH_RSVD3 : 1;
    ///< This field is reserved..
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_cfg_reg_t;

#define MEM_CAP_WRAP_ECC_CFG_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_ECC_CFG_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_ECC_CFG_WR_MASK (0xffffffffU)


///< When set, this bit disables refresh function in AW_ecc_refresh that
///< supports data[31:0]. The inverse of this bit is connected to AW_ecc_refresh.
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_0_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_0_BF_MSK (0x00000001)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_0_BF_DEF (0x00000000)

///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
///< that supports data [31:0]. It should retain the last written value,
///< like the Clear register in AW_intr_high_low.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_0_BF_OFF ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_0_BF_MSK (0x00000002)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_0_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [31:0]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_0_BF_OFF ( 2)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_0_BF_MSK (0x00000004)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_0_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [31:0]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_0_BF_OFF ( 3)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_0_BF_MSK (0x00000008)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_0_BF_DEF (0x00000000)

///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
///< outputs associated with data[31:0]. Writing this bit to 1 should generate
///< a pulse to AW_ecc_refresh.int_clr. It should retain the last written
///< value.
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_0_BF_OFF ( 4)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_0_BF_MSK (0x00000010)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_0_BF_DEF (0x00000000)

///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
///< supporting data[31:0]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_0_BF_OFF ( 5)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_0_BF_MSK (0x00000020)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_0_BF_DEF (0x00000000)

///< When set to 1, this bit enables the user to insert one ECC error determined
///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
///< data[31:0]. It should be cleared when the expected ECC error is seen.
///< Connected to AW_ecc_refresh.ecc_err_force_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_0_BF_OFF ( 6)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_0_BF_MSK (0x00000040)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_0_BF_DEF (0x00000000)

///< This field is reserved..
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD0_BF_OFF ( 7)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD0_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD0_BF_MSK (0x00000080)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD0_BF_DEF (0x00000000)

///< When set, this bit disables refresh function in AW_ecc_refresh that
///< supports data[63:32]. The inverse of this bit is connected to AW_ecc_refresh.
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_1_BF_OFF ( 8)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_1_BF_MSK (0x00000100)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_1_BF_DEF (0x00000000)

///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
///< that supports data [63:32]. It should retain the last written value,
///< like the Clear register in AW_intr_high_low.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_1_BF_OFF ( 9)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_1_BF_MSK (0x00000200)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_1_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [63:32]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_1_BF_OFF (10)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_1_BF_MSK (0x00000400)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_1_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [63:32]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_1_BF_OFF (11)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_1_BF_MSK (0x00000800)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_1_BF_DEF (0x00000000)

///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
///< outputs associated with data[63:32]. Writing this bit to 1 should
///< generate a pulse to AW_ecc_refresh.int_clr. It should retain the last
///< written value.
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_1_BF_OFF (12)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_1_BF_MSK (0x00001000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_1_BF_DEF (0x00000000)

///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
///< supporting data[63:32]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_1_BF_OFF (13)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_1_BF_MSK (0x00002000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_1_BF_DEF (0x00000000)

///< When set to 1, this bit enables the user to insert one ECC error determined
///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
///< data[63:32]. It should be cleared when the expected ECC error is seen.
///< Connected to AW_ecc_refresh.ecc_err_force_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_1_BF_OFF (14)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_1_BF_MSK (0x00004000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_1_BF_DEF (0x00000000)

///< This field is reserved..
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD1_BF_OFF (15)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD1_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD1_BF_MSK (0x00008000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD1_BF_DEF (0x00000000)

///< When set, this bit disables refresh function in AW_ecc_refresh that
///< supports data[95:64]. The inverse of this bit is connected to AW_ecc_refresh.
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_2_BF_OFF (16)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_2_BF_MSK (0x00010000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_2_BF_DEF (0x00000000)

///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
///< that supports data [95:64]. It should retain the last written value,
///< like the Clear register in AW_intr_high_low.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_2_BF_OFF (17)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_2_BF_MSK (0x00020000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_2_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [95:64]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_2_BF_OFF (18)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_2_BF_MSK (0x00040000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_2_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [95:64]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_2_BF_OFF (19)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_2_BF_MSK (0x00080000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_2_BF_DEF (0x00000000)

///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
///< outputs associated with data[95:64]. Writing this bit to 1 should
///< generate a pulse to AW_ecc_refresh.int_clr. It should retain the last
///< written value.
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_2_BF_OFF (20)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_2_BF_MSK (0x00100000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_2_BF_DEF (0x00000000)

///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
///< supporting data[95:64]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_2_BF_OFF (21)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_2_BF_MSK (0x00200000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_2_BF_DEF (0x00000000)

///< When set to 1, this bit enables the user to insert one ECC error determined
///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
///< data[95:64]. It should be cleared when the expected ECC error is seen.
///< Connected to AW_ecc_refresh.ecc_err_force_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_2_BF_OFF (22)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_2_BF_MSK (0x00400000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_2_BF_DEF (0x00000000)

///< This field is reserved..
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD2_BF_OFF (23)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD2_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD2_BF_MSK (0x00800000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD2_BF_DEF (0x00000000)

///< When set, this bit disables refresh function in AW_ecc_refresh that
///< supports data[127:96]. The inverse of this bit is connected to AW_ecc_refresh.
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_3_BF_OFF (24)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_3_BF_MSK (0x01000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_DIS_3_BF_DEF (0x00000000)

///< Writing to 1 clears *_ECC_SBE_COUNT[3:0] associated with AW_ecc_fresh
///< that supports data [127:96]. It should retain the last written value,
///< like the Clear register in AW_intr_high_low.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_3_BF_OFF (25)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_3_BF_MSK (0x02000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CNT_CLR_3_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [127:96]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_chk_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_3_BF_OFF (26)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_3_BF_MSK (0x04000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_CHK_DIS_3_BF_DEF (0x00000000)

///< When set, this bit disables ECC generation in AW_ecc_refresh that
///< supports data [127:96]. Used for debug and testing purpose. The inverse
///< of this bit is connected to AW_ecc_refresh.ecc_gen_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_3_BF_OFF (27)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_3_BF_MSK (0x08000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_GEN_DIS_3_BF_DEF (0x00000000)

///< Writing to 1 clears AW_ecc_refresh.sbe_o/dbe_o/err_addr_o/err_synd_o
///< outputs associated with data[127:96]. Writing this bit to 1 should
///< generate a pulse to AW_ecc_refresh.int_clr. It should retain the last
///< written value.
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_3_BF_OFF (28)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_3_BF_MSK (0x10000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_ERR_CLR_3_BF_DEF (0x00000000)

///< This bit controls either SBE or DBE to be inserted into AW_ecc_fresh
///< supporting data[127:96]. 1 = DBE. Connected to AW_ecc_refresh.ecc_err_dbe_sbe_n.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_3_BF_OFF (29)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_3_BF_MSK (0x20000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_TYPE_3_BF_DEF (0x00000000)

///< When set to 1, this bit enables the user to insert one ECC error determined
///< by *_ECC_FORCE_TYPE. Error insertion into AW_ecc_refresh supporting
///< data[127:96]. It should be cleared when the expected ECC error is
///< seen.  Connected to AW_ecc_refresh.ecc_err_force_en.
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_3_BF_OFF (30)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_3_BF_MSK (0x40000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_FORCE_ERR_3_BF_DEF (0x00000000)

///< This field is reserved..
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD3_BF_OFF (31)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD3_BF_WID ( 1)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD3_BF_MSK (0x80000000)
#define MEM_CAP_WRAP_ECC_CFG_ECC_REFRESH_RSVD3_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_ECC_CFG_ARR_SZ0 (28)
#define MEM_CAP_WRAP_ECC_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_SBE_LVL[4] register description at address offset 0x100
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_SBE_LVL
  * ECC SBE LEVEL
  */

typedef union {
  struct {
    uint32_t ECC_SBE_LVL_EVEN : 16;
    ///< When bit i is set, indicates a single bit error occured in the ith
    ///< slice out of 16 32-bit slicdes in a 512 bit memory word.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ECC_SBE_LVL_ODD : 16;
    ///< When bit i is set, indicates a single bit error occured in the ith
    ///< slice out of 16 32-bit slicdes in a 512 bit memory word.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_sbe_lvl_reg_t;

#define MEM_CAP_WRAP_ECC_SBE_LVL_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_ECC_SBE_LVL_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_ECC_SBE_LVL_WR_MASK (0x00000000U)


///< When bit i is set, indicates a single bit error occured in the ith
///< slice out of 16 32-bit slicdes in a 512 bit memory word.
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_EVEN_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_EVEN_BF_WID (16)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_EVEN_BF_MSK (0x0000FFFF)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_EVEN_BF_DEF (0x00000000)

///< When bit i is set, indicates a single bit error occured in the ith
///< slice out of 16 32-bit slicdes in a 512 bit memory word.
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_ODD_BF_OFF (16)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_ODD_BF_WID (16)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_ODD_BF_MSK (0xFFFF0000)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ECC_SBE_LVL_ODD_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ARR_SZ0 (4)
#define MEM_CAP_WRAP_ECC_SBE_LVL_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_DBE_LVL[4] register description at address offset 0x110
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_DBE_LVL
  * ECC DBE LEVEL
  */

typedef union {
  struct {
    uint32_t ECC_DBE_LVL_EVEN : 16;
    ///< When bit i is set, indicates a double bit error occured in the ith
    ///< slice out of 16 32-bit slicdes in a 512 bit memory word.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ECC_DBE_LVL_ODD : 16;
    ///< When bit i is set, indicates a double bit error occured in the ith
    ///< slice out of 16 32-bit slicdes in a 512 bit memory word.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_dbe_lvl_reg_t;

#define MEM_CAP_WRAP_ECC_DBE_LVL_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_ECC_DBE_LVL_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_ECC_DBE_LVL_WR_MASK (0x00000000U)


///< When bit i is set, indicates a double bit error occured in the ith
///< slice out of 16 32-bit slicdes in a 512 bit memory word.
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_EVEN_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_EVEN_BF_WID (16)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_EVEN_BF_MSK (0x0000FFFF)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_EVEN_BF_DEF (0x00000000)

///< When bit i is set, indicates a double bit error occured in the ith
///< slice out of 16 32-bit slicdes in a 512 bit memory word.
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_ODD_BF_OFF (16)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_ODD_BF_WID (16)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_ODD_BF_MSK (0xFFFF0000)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ECC_DBE_LVL_ODD_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ARR_SZ0 (4)
#define MEM_CAP_WRAP_ECC_DBE_LVL_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_SBE_COUNT_OVFL[4] register description at address offset 0x120
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_SBE_COUNT_OVFL
  * ECC SBE COUNT OVERFLOW
  */

typedef union {
  struct {
    uint32_t ECC_SBE_COUNT_OVFL_EVEN : 16;
    ///< When bit i is set, indicates a the sbe count overflowed for ith slice
    ///< out of 16 32-bit slices in a 512 bit memory word.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ECC_SBE_COUNT_OVFL_ODD : 16;
    ///< When bit i is set, indicates a the sbe count overflowed for ith slice
    ///< out of 16 32-bit slices in a 512 bit memory word.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_sbe_cnt_ovfl_reg_t;

#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_WR_MASK (0x00000000U)


///< When bit i is set, indicates a the sbe count overflowed for ith slice
///< out of 16 32-bit slices in a 512 bit memory word.
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_EVEN_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_EVEN_BF_WID (16)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_EVEN_BF_MSK (0x0000FFFF)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_EVEN_BF_DEF (0x00000000)

///< When bit i is set, indicates a the sbe count overflowed for ith slice
///< out of 16 32-bit slices in a 512 bit memory word.
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_ODD_BF_OFF (16)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_ODD_BF_WID (16)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_ODD_BF_MSK (0xFFFF0000)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ECC_SBE_CNT_OVFL_ODD_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ARR_SZ0 (4)
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_STATUS_INDEX register description at address offset 0x130
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_STATUS_INDEX
  * ECC STATUS INDEX
  */

typedef union {
  struct {
    uint32_t ECC_INDEX : 7;
    ///< ECC_INDEX.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_stat_index_reg_t;

#define MEM_CAP_WRAP_ECC_STAT_INDEX_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_ECC_STAT_INDEX_RD_MASK (0x0000007fU)
#define MEM_CAP_WRAP_ECC_STAT_INDEX_WR_MASK (0x0000007fU)


///< ECC_INDEX.
#define MEM_CAP_WRAP_ECC_STAT_INDEX_ECC_INDEX_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_STAT_INDEX_ECC_INDEX_BF_WID ( 7)
#define MEM_CAP_WRAP_ECC_STAT_INDEX_ECC_INDEX_BF_MSK (0x0000007F)
#define MEM_CAP_WRAP_ECC_STAT_INDEX_ECC_INDEX_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_ECC_STATUS register description at address offset 0x134
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/ECC_STATUS
  * ECC STATUS
  */

typedef union {
  struct {
    uint32_t ECC_SBE_COUNT : 4;
    ///< SBE Count 0.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ECC_ADDR : 12;
    ///< Memory address at which the SBE or DBE error occured of the AW_ecc_refresh
    ///< module pointed to by ecc_index.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t ECC_SYND : 7;
    ///< Error Syndrome of the AW_ecc_refresh module pointed to by ecc_index.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_ecc_stat_reg_t;

#define MEM_CAP_WRAP_ECC_STAT_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_ECC_STAT_RD_MASK (0x007fffffU)
#define MEM_CAP_WRAP_ECC_STAT_WR_MASK (0x00000000U)


///< SBE Count 0.
#define MEM_CAP_WRAP_ECC_STAT_ECC_SBE_CNT_BF_OFF ( 0)
#define MEM_CAP_WRAP_ECC_STAT_ECC_SBE_CNT_BF_WID ( 4)
#define MEM_CAP_WRAP_ECC_STAT_ECC_SBE_CNT_BF_MSK (0x0000000F)
#define MEM_CAP_WRAP_ECC_STAT_ECC_SBE_CNT_BF_DEF (0x00000000)

///< Memory address at which the SBE or DBE error occured of the AW_ecc_refresh
///< module pointed to by ecc_index.
#define MEM_CAP_WRAP_ECC_STAT_ECC_ADDR_BF_OFF ( 4)
#define MEM_CAP_WRAP_ECC_STAT_ECC_ADDR_BF_WID (12)
#define MEM_CAP_WRAP_ECC_STAT_ECC_ADDR_BF_MSK (0x0000FFF0)
#define MEM_CAP_WRAP_ECC_STAT_ECC_ADDR_BF_DEF (0x00000000)

///< Error Syndrome of the AW_ecc_refresh module pointed to by ecc_index.
#define MEM_CAP_WRAP_ECC_STAT_ECC_SYND_BF_OFF (16)
#define MEM_CAP_WRAP_ECC_STAT_ECC_SYND_BF_WID ( 7)
#define MEM_CAP_WRAP_ECC_STAT_ECC_SYND_BF_MSK (0x007F0000)
#define MEM_CAP_WRAP_ECC_STAT_ECC_SYND_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_RX_START[5] register description at address offset 0x180
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/RX_START
  * RX Start Address
  */

typedef union {
  struct {
    uint32_t ADDR : 15;
    ///< Address
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_rx_start_reg_t;

#define MEM_CAP_WRAP_RX_START_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_RX_START_RD_MASK (0x00007fffU)
#define MEM_CAP_WRAP_RX_START_WR_MASK (0x00007fffU)


///< Address
#define MEM_CAP_WRAP_RX_START_ADDR_BF_OFF ( 0)
#define MEM_CAP_WRAP_RX_START_ADDR_BF_WID (15)
#define MEM_CAP_WRAP_RX_START_ADDR_BF_MSK (0x00007FFF)
#define MEM_CAP_WRAP_RX_START_ADDR_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_RX_START_ARR_SZ0 (5)
#define MEM_CAP_WRAP_RX_START_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_RX_END[5] register description at address offset 0x1a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/RX_END
  * RX End Address
  */

typedef union {
  struct {
    uint32_t ADDR : 15;
    ///< Address
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_rx_end_reg_t;

#define MEM_CAP_WRAP_RX_END_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_RX_END_RD_MASK (0x00007fffU)
#define MEM_CAP_WRAP_RX_END_WR_MASK (0x00007fffU)


///< Address
#define MEM_CAP_WRAP_RX_END_ADDR_BF_OFF ( 0)
#define MEM_CAP_WRAP_RX_END_ADDR_BF_WID (15)
#define MEM_CAP_WRAP_RX_END_ADDR_BF_MSK (0x00007FFF)
#define MEM_CAP_WRAP_RX_END_ADDR_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_RX_END_ARR_SZ0 (5)
#define MEM_CAP_WRAP_RX_END_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_RX_CUR[5] register description at address offset 0x1c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/RX_CUR
  * RX Current Address
  */

typedef union {
  struct {
    uint32_t ADDR : 15;
    ///< Address
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_rx_cur_reg_t;

#define MEM_CAP_WRAP_RX_CUR_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_RX_CUR_RD_MASK (0x00007fffU)
#define MEM_CAP_WRAP_RX_CUR_WR_MASK (0x00000000U)


///< Address
#define MEM_CAP_WRAP_RX_CUR_ADDR_BF_OFF ( 0)
#define MEM_CAP_WRAP_RX_CUR_ADDR_BF_WID (15)
#define MEM_CAP_WRAP_RX_CUR_ADDR_BF_MSK (0x00007FFF)
#define MEM_CAP_WRAP_RX_CUR_ADDR_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_RX_CUR_ARR_SZ0 (5)
#define MEM_CAP_WRAP_RX_CUR_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_RX_MODE[5] register description at address offset 0x1e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/RX_MODE
  * RX State Machine Mode
  */

typedef union {
  struct {
    uint32_t MODE : 1;
    ///< Write Mode
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_rx_mode_reg_t;

#define MEM_CAP_WRAP_RX_MODE_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_RX_MODE_RD_MASK (0x00000001U)
#define MEM_CAP_WRAP_RX_MODE_WR_MASK (0x00000001U)


///< Write Mode
#define MEM_CAP_WRAP_RX_MODE_BF_OFF ( 0)
#define MEM_CAP_WRAP_RX_MODE_BF_WID ( 1)
#define MEM_CAP_WRAP_RX_MODE_BF_MSK (0x00000001)
#define MEM_CAP_WRAP_RX_MODE_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_RX_MODE_ARR_SZ0 (5)
#define MEM_CAP_WRAP_RX_MODE_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_TX_START[4] register description at address offset 0x200
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/TX_START
  * TX Start Address
  */

typedef union {
  struct {
    uint32_t ADDR : 15;
    ///< Address
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_tx_start_reg_t;

#define MEM_CAP_WRAP_TX_START_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_TX_START_RD_MASK (0x00007fffU)
#define MEM_CAP_WRAP_TX_START_WR_MASK (0x00007fffU)


///< Address
#define MEM_CAP_WRAP_TX_START_ADDR_BF_OFF ( 0)
#define MEM_CAP_WRAP_TX_START_ADDR_BF_WID (15)
#define MEM_CAP_WRAP_TX_START_ADDR_BF_MSK (0x00007FFF)
#define MEM_CAP_WRAP_TX_START_ADDR_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_TX_START_ARR_SZ0 (4)
#define MEM_CAP_WRAP_TX_START_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_TX_END[4] register description at address offset 0x220
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/TX_END
  * TX End Address
  */

typedef union {
  struct {
    uint32_t ADDR : 15;
    ///< Address
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_tx_end_reg_t;

#define MEM_CAP_WRAP_TX_END_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_TX_END_RD_MASK (0x00007fffU)
#define MEM_CAP_WRAP_TX_END_WR_MASK (0x00007fffU)


///< Address
#define MEM_CAP_WRAP_TX_END_ADDR_BF_OFF ( 0)
#define MEM_CAP_WRAP_TX_END_ADDR_BF_WID (15)
#define MEM_CAP_WRAP_TX_END_ADDR_BF_MSK (0x00007FFF)
#define MEM_CAP_WRAP_TX_END_ADDR_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_TX_END_ARR_SZ0 (4)
#define MEM_CAP_WRAP_TX_END_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_TX_CUR[4] register description at address offset 0x240
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/TX_CUR
  * TX Current Address
  */

typedef union {
  struct {
    uint32_t ADDR : 15;
    ///< Address
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_tx_cur_reg_t;

#define MEM_CAP_WRAP_TX_CUR_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_TX_CUR_RD_MASK (0x00007fffU)
#define MEM_CAP_WRAP_TX_CUR_WR_MASK (0x00000000U)


///< Address
#define MEM_CAP_WRAP_TX_CUR_ADDR_BF_OFF ( 0)
#define MEM_CAP_WRAP_TX_CUR_ADDR_BF_WID (15)
#define MEM_CAP_WRAP_TX_CUR_ADDR_BF_MSK (0x00007FFF)
#define MEM_CAP_WRAP_TX_CUR_ADDR_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_TX_CUR_ARR_SZ0 (4)
#define MEM_CAP_WRAP_TX_CUR_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_TX_MODE[4] register description at address offset 0x260
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/TX_MODE
  * TX State Machine Mode
  */

typedef union {
  struct {
    uint32_t MODE : 1;
    ///< Read Mode
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_tx_mode_reg_t;

#define MEM_CAP_WRAP_TX_MODE_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_TX_MODE_RD_MASK (0x00000001U)
#define MEM_CAP_WRAP_TX_MODE_WR_MASK (0x00000001U)


///< Read Mode
#define MEM_CAP_WRAP_TX_MODE_BF_OFF ( 0)
#define MEM_CAP_WRAP_TX_MODE_BF_WID ( 1)
#define MEM_CAP_WRAP_TX_MODE_BF_MSK (0x00000001)
#define MEM_CAP_WRAP_TX_MODE_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_TX_MODE_ARR_SZ0 (4)
#define MEM_CAP_WRAP_TX_MODE_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_LFSR_SEED_UPPER[7] register description at address offset 0x280
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/LFSR_SEED_UPPER
  * LFSR Seed
  */

typedef union {
  struct {
    uint64_t SEED : 64;
    ///< LFSR Seed
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} mem_cap_wrap_lfsr_seed_upper_reg_t;

#define MEM_CAP_WRAP_LFSR_SEED_UPPER_DEFAULT (0x0000000000000000ULL)
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_RD_MASK (0xffffffffffffffffULL)
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_WR_MASK (0xffffffffffffffffULL)


///< LFSR Seed
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_SEED_BF_OFF ( 0)
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_SEED_BF_WID (64)
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_SEED_BF_MSK (0xFFFFFFFFFFFFFFFF)
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_SEED_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_ARR_SZ0 (7)
#define MEM_CAP_WRAP_LFSR_SEED_UPPER_ARRAY_STRIDE0 (0x0008)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_LFSR_SEED_LOWER[7] register description at address offset 0x2c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/LFSR_SEED_LOWER
  * LFSR Seed
  */

typedef union {
  struct {
    uint64_t SEED : 64;
    ///< LFSR Seed
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} mem_cap_wrap_lfsr_seed_lower_reg_t;

#define MEM_CAP_WRAP_LFSR_SEED_LOWER_DEFAULT (0x0000000000000000ULL)
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_RD_MASK (0xffffffffffffffffULL)
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_WR_MASK (0xffffffffffffffffULL)


///< LFSR Seed
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_SEED_BF_OFF ( 0)
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_SEED_BF_WID (64)
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_SEED_BF_MSK (0xFFFFFFFFFFFFFFFF)
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_SEED_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_ARR_SZ0 (7)
#define MEM_CAP_WRAP_LFSR_SEED_LOWER_ARRAY_STRIDE0 (0x0008)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_FIXED_PATTERN[7] register description at address offset 0x300
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/FIXED_PATTERN
  * Fixed Pattern
  */

typedef union {
  struct {
    uint32_t FIXED_VAL : 32;
    ///< Fixed value
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_fixed_pattern_reg_t;

#define MEM_CAP_WRAP_FIXED_PATTERN_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_FIXED_PATTERN_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_FIXED_PATTERN_WR_MASK (0xffffffffU)


///< Fixed value
#define MEM_CAP_WRAP_FIXED_PATTERN_FIXED_VAL_BF_OFF ( 0)
#define MEM_CAP_WRAP_FIXED_PATTERN_FIXED_VAL_BF_WID (32)
#define MEM_CAP_WRAP_FIXED_PATTERN_FIXED_VAL_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_FIXED_PATTERN_FIXED_VAL_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_FIXED_PATTERN_ARR_SZ0 (7)
#define MEM_CAP_WRAP_FIXED_PATTERN_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_RAMP_CFG[7] register description at address offset 0x320
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/RAMP_CFG
  * Ramp Config
  */

typedef union {
  struct {
    uint32_t RAMP_INIT : 16;
    ///< Ramp Init Value
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RAMP_STEP : 16;
    ///< Ramp Step Value
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_ramp_cfg_reg_t;

#define MEM_CAP_WRAP_RAMP_CFG_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_RAMP_CFG_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_RAMP_CFG_WR_MASK (0xffffffffU)


///< Ramp Init Value
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_INIT_BF_OFF ( 0)
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_INIT_BF_WID (16)
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_INIT_BF_MSK (0x0000FFFF)
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_INIT_BF_DEF (0x00000000)

///< Ramp Step Value
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_STEP_BF_OFF (16)
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_STEP_BF_WID (16)
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_STEP_BF_MSK (0xFFFF0000)
#define MEM_CAP_WRAP_RAMP_CFG_RAMP_STEP_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_RAMP_CFG_ARR_SZ0 (7)
#define MEM_CAP_WRAP_RAMP_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_INIT_RAM[7] register description at address offset 0x340
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/INIT_RAM
  * Initialize RAM
  */

typedef union {
  struct {
    uint32_t INIT_MODE : 3;
    ///< Init Mode
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t INIT_INVERT : 1;
    ///< Invert Init Pattern
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t INIT_LOOP : 1;
    ///< Continuous Init Loop
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t INIT_START : 1;
    ///< HW Init Start
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t INIT_DONE : 1;
    ///< HW Init Done
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_init_ram_reg_t;

#define MEM_CAP_WRAP_INIT_RAM_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_INIT_RAM_RD_MASK (0x0000007fU)
#define MEM_CAP_WRAP_INIT_RAM_WR_MASK (0x0000003fU)


///< Init Mode
#define MEM_CAP_WRAP_INIT_RAM_INIT_MODE_BF_OFF ( 0)
#define MEM_CAP_WRAP_INIT_RAM_INIT_MODE_BF_WID ( 3)
#define MEM_CAP_WRAP_INIT_RAM_INIT_MODE_BF_MSK (0x00000007)
#define MEM_CAP_WRAP_INIT_RAM_INIT_MODE_BF_DEF (0x00000000)

///< Invert Init Pattern
#define MEM_CAP_WRAP_INIT_RAM_INIT_INVERT_BF_OFF ( 3)
#define MEM_CAP_WRAP_INIT_RAM_INIT_INVERT_BF_WID ( 1)
#define MEM_CAP_WRAP_INIT_RAM_INIT_INVERT_BF_MSK (0x00000008)
#define MEM_CAP_WRAP_INIT_RAM_INIT_INVERT_BF_DEF (0x00000000)

///< Continuous Init Loop
#define MEM_CAP_WRAP_INIT_RAM_INIT_LOOP_BF_OFF ( 4)
#define MEM_CAP_WRAP_INIT_RAM_INIT_LOOP_BF_WID ( 1)
#define MEM_CAP_WRAP_INIT_RAM_INIT_LOOP_BF_MSK (0x00000010)
#define MEM_CAP_WRAP_INIT_RAM_INIT_LOOP_BF_DEF (0x00000000)

///< HW Init Start
#define MEM_CAP_WRAP_INIT_RAM_INIT_START_BF_OFF ( 5)
#define MEM_CAP_WRAP_INIT_RAM_INIT_START_BF_WID ( 1)
#define MEM_CAP_WRAP_INIT_RAM_INIT_START_BF_MSK (0x00000020)
#define MEM_CAP_WRAP_INIT_RAM_INIT_START_BF_DEF (0x00000000)

///< HW Init Done
#define MEM_CAP_WRAP_INIT_RAM_INIT_DONE_BF_OFF ( 6)
#define MEM_CAP_WRAP_INIT_RAM_INIT_DONE_BF_WID ( 1)
#define MEM_CAP_WRAP_INIT_RAM_INIT_DONE_BF_MSK (0x00000040)
#define MEM_CAP_WRAP_INIT_RAM_INIT_DONE_BF_DEF (0x00000000)
#define MEM_CAP_WRAP_INIT_RAM_ARR_SZ0 (7)
#define MEM_CAP_WRAP_INIT_RAM_ARRAY_STRIDE0 (0x0004)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_CAPT_COMP register description at address offset 0x360
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/CAPT_COMP
  * Memory Capture Complete Indication
  */

typedef union {
  struct {
    uint32_t MEM_CAPT_COMP : 5;
    ///< Memory Capture Complete. Bit i corresponds to the ith write function
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_capt_reg_t;

#define MEM_CAP_WRAP_CAPT_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_CAPT_RD_MASK (0x0000001fU)
#define MEM_CAP_WRAP_CAPT_WR_MASK (0x0000001fU)


///< Memory Capture Complete. Bit i corresponds to the ith write function
#define MEM_CAP_WRAP_CAPT_MEM_CAPT_BF_OFF ( 0)
#define MEM_CAP_WRAP_CAPT_MEM_CAPT_BF_WID ( 5)
#define MEM_CAP_WRAP_CAPT_MEM_CAPT_BF_MSK (0x0000001F)
#define MEM_CAP_WRAP_CAPT_MEM_CAPT_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SCRATCH register description at address offset 0x364
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SCRATCH
  * Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Scratch pad
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_scratch_reg_t;

#define MEM_CAP_WRAP_SCRATCH_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SCRATCH_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch pad
#define MEM_CAP_WRAP_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define MEM_CAP_WRAP_SCRATCH_SCRATCHPAD_BF_WID (32)
#define MEM_CAP_WRAP_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_TDPACK_FIFO_WM register description at address offset 0x370
  *
  * Register default value:        0x00000011
  * Register full path in IP: mem_cap_wrap/mem_cap_map/TDPACK_FIFO_WM
  * 8-Entry FIFO Watermarks Register
  */

typedef union {
  struct {
    uint32_t LOW_WM : 4;
    ///< FIFO Low Watermark
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t HIGH_WM : 4;
    ///< FIFO High Watermark
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_tdpack_fifo_wm_reg_t;

#define MEM_CAP_WRAP_TDPACK_FIFO_WM_DEFAULT (0x00000011U)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_RD_MASK (0x000000ffU)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_WR_MASK (0x000000ffU)


///< FIFO Low Watermark
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_LOW_WM_BF_OFF ( 0)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_LOW_WM_BF_WID ( 4)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_LOW_WM_BF_MSK (0x0000000F)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_LOW_WM_BF_DEF (0x00000001)

///< FIFO High Watermark
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_HIGH_WM_BF_OFF ( 4)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_HIGH_WM_BF_WID ( 4)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_HIGH_WM_BF_MSK (0x000000F0)
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_HIGH_WM_BF_DEF (0x00000010)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_TDPACK_FIFO_STAT register description at address offset 0x374
  *
  * Register default value:        0x0000000C
  * Register full path in IP: mem_cap_wrap/mem_cap_map/TDPACK_FIFO_STAT
  * 8-Entry FIFO Status Register
  */

typedef union {
  struct {
    uint32_t FIFO_UNDERFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_OVERFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t ALMOST_EMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t ALMOST_FULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 4;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_tdpack_fifo_stat_reg_t;

#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_DEFAULT (0x0000000cU)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_RD_MASK (0x000003ffU)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_UNDERFLOW_BF_OFF ( 0)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_UNDERFLOW_BF_WID ( 1)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_UNDERFLOW_BF_MSK (0x00000001)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_UNDERFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_OVERFLOW_BF_OFF ( 1)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_OVERFLOW_BF_WID ( 1)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_OVERFLOW_BF_MSK (0x00000002)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_OVERFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_EMPTY_BF_OFF ( 2)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_EMPTY_BF_WID ( 1)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_EMPTY_BF_MSK (0x00000004)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_EMPTY_BF_OFF ( 3)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_EMPTY_BF_WID ( 1)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_EMPTY_BF_MSK (0x00000008)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_EMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_FULL_BF_OFF ( 4)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_FULL_BF_WID ( 1)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_FULL_BF_MSK (0x00000010)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_ALMOST_FULL_BF_DEF (0x00000000)

///< FIFO Full
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_FULL_BF_OFF ( 5)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_FULL_BF_WID ( 1)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_FULL_BF_MSK (0x00000020)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_DEPTH_BF_OFF ( 6)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_DEPTH_BF_WID ( 4)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_DEPTH_BF_MSK (0x000003C0)
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_DEPTH_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_INT_STATUS register description at address offset 0x380
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/INT_STATUS
  * Interrupt Status
  */

typedef union {
  struct {
    uint32_t MEM_ERR : 7;
    ///< Indicates memory error interrupt status. Bit i of this field indicates
    ///< if a memory error occured in the ith memory sector.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_CAPT_COMP : 5;
    ///< Indicates memory capture complete. Bit i of this field indicates that
    ///< the ith memory write function has completed.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_int_stat_reg_t;

#define MEM_CAP_WRAP_INT_STAT_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_INT_STAT_RD_MASK (0x00000fffU)
#define MEM_CAP_WRAP_INT_STAT_WR_MASK (0x00000000U)


///< Indicates memory error interrupt status. Bit i of this field indicates
///< if a memory error occured in the ith memory sector.
#define MEM_CAP_WRAP_INT_STAT_MEM_ERR_BF_OFF ( 0)
#define MEM_CAP_WRAP_INT_STAT_MEM_ERR_BF_WID ( 7)
#define MEM_CAP_WRAP_INT_STAT_MEM_ERR_BF_MSK (0x0000007F)
#define MEM_CAP_WRAP_INT_STAT_MEM_ERR_BF_DEF (0x00000000)

///< Indicates memory capture complete. Bit i of this field indicates that
///< the ith memory write function has completed.
#define MEM_CAP_WRAP_INT_STAT_MEM_CAPT_BF_OFF ( 7)
#define MEM_CAP_WRAP_INT_STAT_MEM_CAPT_BF_WID ( 5)
#define MEM_CAP_WRAP_INT_STAT_MEM_CAPT_BF_MSK (0x00000F80)
#define MEM_CAP_WRAP_INT_STAT_MEM_CAPT_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_INT_HIGH_EN register description at address offset 0x384
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/INT_HIGH_EN
  * Interrupt High Enable
  */

typedef union {
  struct {
    uint32_t MEM_ERR : 7;
    ///< Indicates memory error interrupt status. Bit i of this field indicates
    ///< if a memory error occured in the ith memory sector.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_CAPT_COMP : 5;
    ///< Indicates memory capture complete. Bit i of this field indicates that
    ///< the ith memory write function has completed.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_int_high_en_reg_t;

#define MEM_CAP_WRAP_INT_HIGH_EN_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_INT_HIGH_EN_RD_MASK (0x00000fffU)
#define MEM_CAP_WRAP_INT_HIGH_EN_WR_MASK (0x00000fffU)


///< Indicates memory error interrupt status. Bit i of this field indicates
///< if a memory error occured in the ith memory sector.
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_ERR_BF_OFF ( 0)
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_ERR_BF_WID ( 7)
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_ERR_BF_MSK (0x0000007F)
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_ERR_BF_DEF (0x00000000)

///< Indicates memory capture complete. Bit i of this field indicates that
///< the ith memory write function has completed.
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_CAPT_BF_OFF ( 7)
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_CAPT_BF_WID ( 5)
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_CAPT_BF_MSK (0x00000F80)
#define MEM_CAP_WRAP_INT_HIGH_EN_MEM_CAPT_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_INT_LOW_EN register description at address offset 0x388
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/INT_LOW_EN
  * Interrupt Low Enable
  */

typedef union {
  struct {
    uint32_t MEM_ERR : 7;
    ///< Indicates memory error interrupt status. Bit i of this field indicates
    ///< if a memory error occured in the ith memory sector.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_CAPT_COMP : 5;
    ///< Indicates memory capture complete. Bit i of this field indicates that
    ///< the ith memory write function has completed.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_int_low_en_reg_t;

#define MEM_CAP_WRAP_INT_LOW_EN_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_INT_LOW_EN_RD_MASK (0x00000fffU)
#define MEM_CAP_WRAP_INT_LOW_EN_WR_MASK (0x00000fffU)


///< Indicates memory error interrupt status. Bit i of this field indicates
///< if a memory error occured in the ith memory sector.
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_ERR_BF_OFF ( 0)
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_ERR_BF_WID ( 7)
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_ERR_BF_MSK (0x0000007F)
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_ERR_BF_DEF (0x00000000)

///< Indicates memory capture complete. Bit i of this field indicates that
///< the ith memory write function has completed.
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_CAPT_BF_OFF ( 7)
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_CAPT_BF_WID ( 5)
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_CAPT_BF_MSK (0x00000F80)
#define MEM_CAP_WRAP_INT_LOW_EN_MEM_CAPT_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_INT_CLEAR register description at address offset 0x38c
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/INT_CLEAR
  * MEM_CAP Interrupt Clear Register
  */

typedef union {
  struct {
    uint32_t MEM_ERR : 7;
    ///< Indicates memory error interrupt status. Bit i of this field indicates
    ///< if a memory error occured in the ith memory sector.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_CAPT_COMP : 5;
    ///< Indicates memory capture complete. Bit i of this field indicates that
    ///< the ith memory write function has completed.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_int_clr_reg_t;

#define MEM_CAP_WRAP_INT_CLR_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_INT_CLR_RD_MASK (0x00000fffU)
#define MEM_CAP_WRAP_INT_CLR_WR_MASK (0x00000fffU)


///< Indicates memory error interrupt status. Bit i of this field indicates
///< if a memory error occured in the ith memory sector.
#define MEM_CAP_WRAP_INT_CLR_MEM_ERR_BF_OFF ( 0)
#define MEM_CAP_WRAP_INT_CLR_MEM_ERR_BF_WID ( 7)
#define MEM_CAP_WRAP_INT_CLR_MEM_ERR_BF_MSK (0x0000007F)
#define MEM_CAP_WRAP_INT_CLR_MEM_ERR_BF_DEF (0x00000000)

///< Indicates memory capture complete. Bit i of this field indicates that
///< the ith memory write function has completed.
#define MEM_CAP_WRAP_INT_CLR_MEM_CAPT_BF_OFF ( 7)
#define MEM_CAP_WRAP_INT_CLR_MEM_CAPT_BF_WID ( 5)
#define MEM_CAP_WRAP_INT_CLR_MEM_CAPT_BF_MSK (0x00000F80)
#define MEM_CAP_WRAP_INT_CLR_MEM_CAPT_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_INT_FORCE register description at address offset 0x390
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/INT_FORCE
  * MEM_CAP Interrupt Force Register
  */

typedef union {
  struct {
    uint32_t MEM_ERR : 7;
    ///< Indicates memory error interrupt status. Bit i of this field indicates
    ///< if a memory error occured in the ith memory sector.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_CAPT_COMP : 5;
    ///< Indicates memory capture complete. Bit i of this field indicates that
    ///< the ith memory write function has completed.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} mem_cap_wrap_int_force_reg_t;

#define MEM_CAP_WRAP_INT_FORCE_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_INT_FORCE_RD_MASK (0x00000fffU)
#define MEM_CAP_WRAP_INT_FORCE_WR_MASK (0x00000fffU)


///< Indicates memory error interrupt status. Bit i of this field indicates
///< if a memory error occured in the ith memory sector.
#define MEM_CAP_WRAP_INT_FORCE_MEM_ERR_BF_OFF ( 0)
#define MEM_CAP_WRAP_INT_FORCE_MEM_ERR_BF_WID ( 7)
#define MEM_CAP_WRAP_INT_FORCE_MEM_ERR_BF_MSK (0x0000007F)
#define MEM_CAP_WRAP_INT_FORCE_MEM_ERR_BF_DEF (0x00000000)

///< Indicates memory capture complete. Bit i of this field indicates that
///< the ith memory write function has completed.
#define MEM_CAP_WRAP_INT_FORCE_MEM_CAPT_BF_OFF ( 7)
#define MEM_CAP_WRAP_INT_FORCE_MEM_CAPT_BF_WID ( 5)
#define MEM_CAP_WRAP_INT_FORCE_MEM_CAPT_BF_MSK (0x00000F80)
#define MEM_CAP_WRAP_INT_FORCE_MEM_CAPT_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R0 register description at address offset 0x3a0
  *
  * Register default value:        0x40000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r0
  * AW_smon CONTROL0 register
  */

typedef union {
  struct {
    uint32_t SMON_ENABLE : 1;
    ///< enable the SMON counters
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t RSVD0 : 3;
    ///< reserved
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SMON0_FUNCTION : 3;
    ///< SMON0 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SMON0_FUNCTION_COMPARE : 1;
    ///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t SMON1_FUNCTION : 3;
    ///< SMON1 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t SMON1_FUNCTION_COMPARE : 1;
    ///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t SMON_MODE : 4;
    ///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
    ///< independantly as their function is configured.       4'h1 = Average
    ///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
    ///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
    ///< values. For multiple stop for a single start, accumulate  start_to_stop1,
    ///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
    ///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
    ///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
    ///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
    ///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
    ///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
    ///< the first start_to_stop1 if there are multiple stop for each start.
    ///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
    ///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
    ///< stop for each start.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t STOPCOUNTEROVFL : 1;
    ///< configure to stop on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INTCOUNTEROVFL : 1;
    ///< configure to interupt on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t STATCOUNTER0OVFL : 1;
    ///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
    ///< AccessType="RW/V" BitOffset="18" ResetValue="0x0"
    uint32_t STATCOUNTER1OVFL : 1;
    ///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
    ///< AccessType="RW/V" BitOffset="19" ResetValue="0x0"
    uint32_t STOPTIMEROVFL : 1;
    ///< configure to stop on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t INTTIMEROVFL : 1;
    ///< configure to interrupt on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t STATTIMEROVFL : 1;
    ///< status of timer overflow. A value of '1' signifies timer overflow,
    ///< or timer>maxvalue.
    ///< AccessType="RW/V" BitOffset="22" ResetValue="0x0"
    uint32_t RSVD1 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t TIMER_PRESCALE : 5;
    ///< timer prescale    5'h00 = mode00, increment timer every      1 clock
    ///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
    ///< increment timer every      4 clocks    5'h03 = mode03, increment timer
    ///< every      8 clocks    5'h04 = mode04, increment timer every     16
    ///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
    ///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
    ///< timer every    128 clocks    5'h08 = mode08, increment timer every
    ///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
    ///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
    ///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
    ///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
    ///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
    ///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
    ///< timer every  65536 clocks    5'h11 = mode17, increment timer every
    ///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
    ///< 5'h13 = mode19, increment timer every 524288 clocks
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t RSVD2 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t VERSION : 2;
    ///< version
    ///< AccessType="RO" BitOffset="30" ResetValue="0x1"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r0_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_DEFAULT (0x40000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_WR_MASK (0x3fffffffU)


///< enable the SMON counters
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_EN_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_EN_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_EN_BF_MSK (0x00000001)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_EN_BF_DEF (0x00000000)

///< reserved
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD0_BF_OFF ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD0_BF_WID ( 3)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD0_BF_MSK (0x0000000E)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD0_BF_DEF (0x00000000)

///< SMON0 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_OFF ( 4)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_WID ( 3)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_MSK (0x00000070)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_DEF (0x00000000)

///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_OFF ( 7)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_MSK (0x00000080)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON1 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_OFF ( 8)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_WID ( 3)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_MSK (0x00000700)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_DEF (0x00000000)

///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_OFF (11)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_MSK (0x00000800)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
///< independantly as their function is configured.       4'h1 = Average
///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
///< values. For multiple stop for a single start, accumulate  start_to_stop1,
///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
///< the first start_to_stop1 if there are multiple stop for each start.
///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
///< stop for each start.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_MODE_BF_OFF (12)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_MODE_BF_WID ( 4)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_MODE_BF_MSK (0x0000F000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_SMON_MODE_BF_DEF (0x00000000)

///< configure to stop on counter0 or counter1 overflow
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_OFF (16)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_MSK (0x00010000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_DEF (0x00000000)

///< configure to interupt on counter0 or counter1 overflow
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_OFF (17)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_MSK (0x00020000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_DEF (0x00000000)

///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_OFF (18)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_MSK (0x00040000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_DEF (0x00000000)

///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_OFF (19)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_MSK (0x00080000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_DEF (0x00000000)

///< configure to stop on timer overflow or timer>maxvalue
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_OFF (20)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_MSK (0x00100000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_DEF (0x00000000)

///< configure to interrupt on timer overflow or timer>maxvalue
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_OFF (21)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_MSK (0x00200000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_DEF (0x00000000)

///< status of timer overflow. A value of '1' signifies timer overflow,
///< or timer>maxvalue.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_OFF (22)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_MSK (0x00400000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_DEF (0x00000000)

///< reserved
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD1_BF_OFF (23)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD1_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD1_BF_MSK (0x00800000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD1_BF_DEF (0x00000000)

///< timer prescale    5'h00 = mode00, increment timer every      1 clock
///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
///< increment timer every      4 clocks    5'h03 = mode03, increment timer
///< every      8 clocks    5'h04 = mode04, increment timer every     16
///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
///< timer every    128 clocks    5'h08 = mode08, increment timer every
///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
///< timer every  65536 clocks    5'h11 = mode17, increment timer every
///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
///< 5'h13 = mode19, increment timer every 524288 clocks
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_OFF (24)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_WID ( 5)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_MSK (0x1F000000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_DEF (0x00000000)

///< reserved
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD2_BF_OFF (29)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD2_BF_WID ( 1)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD2_BF_MSK (0x20000000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_RSVD2_BF_DEF (0x00000000)

///< version
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_VER_BF_OFF (30)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_VER_BF_WID ( 2)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_VER_BF_MSK (0xC0000000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_VER_BF_DEF (0x40000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R1 register description at address offset 0x3a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r1
  * AW_smon CONTROL1 register
  */

typedef union {
  struct {
    uint32_t MODE0 : 8;
    ///< select input signal for SMON0 engine. <br/> You should add descriptions
    ///< of input selections here by overriding the parameter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MODE1 : 8;
    ///< select input signal for SMON1 engine. <br/> You should add descriptions
    ///< of input selections here by overriding the parameter.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t RSVD : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r1_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_WR_MASK (0xffffffffU)


///< select input signal for SMON0 engine. <br/> You should add descriptions
///< of input selections here by overriding the parameter.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE0_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE0_BF_WID ( 8)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE0_BF_MSK (0x000000FF)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE0_BF_DEF (0x00000000)

///< select input signal for SMON1 engine. <br/> You should add descriptions
///< of input selections here by overriding the parameter.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE1_BF_OFF ( 8)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE1_BF_WID ( 8)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE1_BF_MSK (0x0000FF00)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_MODE1_BF_DEF (0x00000000)

///< reserved
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_RSVD_BF_OFF (16)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_RSVD_BF_WID (16)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_RSVD_BF_MSK (0xFFFF0000)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_RSVD_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R2 register description at address offset 0x3a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r2
  * AW_smon SMON0_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE0 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r2_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_WR_MASK (0xffffffffU)


///< Comparison value.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_CMP0_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_CMP0_BF_WID (32)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_CMP0_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_CMP0_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R3 register description at address offset 0x3ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r3
  * AW_smon SMON1_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE1 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r3_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_WR_MASK (0xffffffffU)


///< Comparison value.
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_CMP1_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_CMP1_BF_WID (32)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_CMP1_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_CMP1_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R4 register description at address offset 0x3b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r4
  * AW_smon SMON0_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER0 : 32;
    ///< counter0
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r4_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_WR_MASK (0xffffffffU)


///< counter0
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_CNTER0_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_CNTER0_BF_WID (32)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_CNTER0_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_CNTER0_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R5 register description at address offset 0x3b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r5
  * AW_smon SMON1_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER1 : 32;
    ///< counter1
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r5_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_WR_MASK (0xffffffffU)


///< counter1
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_CNTER1_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_CNTER1_BF_WID (32)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_CNTER1_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_CNTER1_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R6 register description at address offset 0x3b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r6
  * AW_smon TIMER register
  */

typedef union {
  struct {
    uint32_t TIMER : 32;
    ///< timer
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r6_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_WR_MASK (0xffffffffU)


///< timer
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_TIMER_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_TIMER_BF_WID (32)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_TIMER_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_TIMER_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_SMON_CSR_SMON_R7 register description at address offset 0x3bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/SMON_CSR/SMON_r7
  * AW_smon TIMERMAXVAL register
  */

typedef union {
  struct {
    uint32_t MAXVALUE : 32;
    ///< maxvalue
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_smon_csr_smon_r7_reg_t;

#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_DEFAULT (0x00000000U)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_WR_MASK (0xffffffffU)


///< maxvalue
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_MAXVAL_BF_OFF ( 0)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_MAXVAL_BF_WID (32)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_MAXVAL_BF_MSK (0xFFFFFFFF)
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_MAXVAL_BF_DEF (0x00000000)


/** @brief MEM_CAP_WRAP_MEM_CAP_MAP_APB_BRIDGE_STATUS register description at address offset 0x3fc
  *
  * Register default value:        0x00010000
  * Register full path in IP: mem_cap_wrap/mem_cap_map/APB_BRIDGE_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} mem_cap_wrap_apb_brdg_stat_reg_t;

#define MEM_CAP_WRAP_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define MEM_CAP_WRAP_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define MEM_CAP_WRAP_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define MEM_CAP_WRAP_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define MEM_CAP_WRAP_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define MEM_CAP_WRAP_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define MEM_CAP_WRAP_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define MEM_CAP_WRAP_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define MEM_CAP_WRAP_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define MEM_CAP_WRAP_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define MEM_CAP_WRAP_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define MEM_CAP_WRAP_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define MEM_CAP_WRAP_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define MEM_CAP_WRAP_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define MEM_CAP_WRAP_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define MEM_CAP_WRAP_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define MEM_CAP_WRAP_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define MEM_CAP_WRAP_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define MEM_CAP_WRAP_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define MEM_CAP_WRAP_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define MEM_CAP_WRAP_MUX_SEL0_REG(_BASE) ((mem_cap_wrap_mux_sel_reg_t*) MEM_CAP_WRAP_MUX_SEL0_ADR(_BASE))
#define MEM_CAP_WRAP_MUX_SEL1_REG(_BASE) ((mem_cap_wrap_mux_sel_reg_t*) MEM_CAP_WRAP_MUX_SEL1_ADR(_BASE))
#define MEM_CAP_WRAP_MUX_SEL2_REG(_BASE) ((mem_cap_wrap_mux_sel_reg_t*) MEM_CAP_WRAP_MUX_SEL2_ADR(_BASE))
#define MEM_CAP_WRAP_MUX_SEL3_REG(_BASE) ((mem_cap_wrap_mux_sel_reg_t*) MEM_CAP_WRAP_MUX_SEL3_ADR(_BASE))
#define MEM_CAP_WRAP_MUX_SEL4_REG(_BASE) ((mem_cap_wrap_mux_sel_reg_t*) MEM_CAP_WRAP_MUX_SEL4_ADR(_BASE))
#define MEM_CAP_WRAP_MUX_SEL5_REG(_BASE) ((mem_cap_wrap_mux_sel_reg_t*) MEM_CAP_WRAP_MUX_SEL5_ADR(_BASE))
#define MEM_CAP_WRAP_MUX_SEL6_REG(_BASE) ((mem_cap_wrap_mux_sel_reg_t*) MEM_CAP_WRAP_MUX_SEL6_ADR(_BASE))
#define MEM_CAP_WRAP_MEM_ERR0_REG(_BASE) ((mem_cap_wrap_mem_err_reg_t*) MEM_CAP_WRAP_MEM_ERR0_ADR(_BASE))
#define MEM_CAP_WRAP_MEM_ERR1_REG(_BASE) ((mem_cap_wrap_mem_err_reg_t*) MEM_CAP_WRAP_MEM_ERR1_ADR(_BASE))
#define MEM_CAP_WRAP_MEM_ERR2_REG(_BASE) ((mem_cap_wrap_mem_err_reg_t*) MEM_CAP_WRAP_MEM_ERR2_ADR(_BASE))
#define MEM_CAP_WRAP_MEM_ERR3_REG(_BASE) ((mem_cap_wrap_mem_err_reg_t*) MEM_CAP_WRAP_MEM_ERR3_ADR(_BASE))
#define MEM_CAP_WRAP_MEM_ERR4_REG(_BASE) ((mem_cap_wrap_mem_err_reg_t*) MEM_CAP_WRAP_MEM_ERR4_ADR(_BASE))
#define MEM_CAP_WRAP_MEM_ERR5_REG(_BASE) ((mem_cap_wrap_mem_err_reg_t*) MEM_CAP_WRAP_MEM_ERR5_ADR(_BASE))
#define MEM_CAP_WRAP_MEM_ERR6_REG(_BASE) ((mem_cap_wrap_mem_err_reg_t*) MEM_CAP_WRAP_MEM_ERR6_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_ERR0_REG(_BASE) ((mem_cap_wrap_ecc_err_reg_t*) MEM_CAP_WRAP_ECC_ERR0_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_ERR1_REG(_BASE) ((mem_cap_wrap_ecc_err_reg_t*) MEM_CAP_WRAP_ECC_ERR1_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_ERR2_REG(_BASE) ((mem_cap_wrap_ecc_err_reg_t*) MEM_CAP_WRAP_ECC_ERR2_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_ERR3_REG(_BASE) ((mem_cap_wrap_ecc_err_reg_t*) MEM_CAP_WRAP_ECC_ERR3_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_ERR4_REG(_BASE) ((mem_cap_wrap_ecc_err_reg_t*) MEM_CAP_WRAP_ECC_ERR4_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_ERR5_REG(_BASE) ((mem_cap_wrap_ecc_err_reg_t*) MEM_CAP_WRAP_ECC_ERR5_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_ERR6_REG(_BASE) ((mem_cap_wrap_ecc_err_reg_t*) MEM_CAP_WRAP_ECC_ERR6_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CORRECT_REG(_BASE) ((mem_cap_wrap_ecc_correct_reg_t*) MEM_CAP_WRAP_ECC_CORRECT_ADR(_BASE))
#define MEM_CAP_WRAP_PWR_DOWN_CTRL_REG(_BASE) ((mem_cap_wrap_pwr_down_ctrl_reg_t*) MEM_CAP_WRAP_PWR_DOWN_CTRL_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG0_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG0_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG1_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG1_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG2_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG2_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG3_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG3_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG4_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG4_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG5_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG5_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG6_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG6_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG7_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG7_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG8_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG8_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG9_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG9_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG10_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG10_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG11_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG11_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG12_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG12_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG13_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG13_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG14_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG14_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG15_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG15_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG16_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG16_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG17_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG17_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG18_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG18_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG19_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG19_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG20_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG20_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG21_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG21_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG22_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG22_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG23_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG23_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG24_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG24_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG25_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG25_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG26_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG26_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_CFG27_REG(_BASE) ((mem_cap_wrap_ecc_cfg_reg_t*) MEM_CAP_WRAP_ECC_CFG27_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_LVL0_REG(_BASE) ((mem_cap_wrap_ecc_sbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_SBE_LVL0_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_LVL1_REG(_BASE) ((mem_cap_wrap_ecc_sbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_SBE_LVL1_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_LVL2_REG(_BASE) ((mem_cap_wrap_ecc_sbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_SBE_LVL2_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_LVL3_REG(_BASE) ((mem_cap_wrap_ecc_sbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_SBE_LVL3_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_DBE_LVL0_REG(_BASE) ((mem_cap_wrap_ecc_dbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_DBE_LVL0_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_DBE_LVL1_REG(_BASE) ((mem_cap_wrap_ecc_dbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_DBE_LVL1_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_DBE_LVL2_REG(_BASE) ((mem_cap_wrap_ecc_dbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_DBE_LVL2_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_DBE_LVL3_REG(_BASE) ((mem_cap_wrap_ecc_dbe_lvl_reg_t*) MEM_CAP_WRAP_ECC_DBE_LVL3_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL0_REG(_BASE) ((mem_cap_wrap_ecc_sbe_cnt_ovfl_reg_t*) MEM_CAP_WRAP_ECC_SBE_CNT_OVFL0_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL1_REG(_BASE) ((mem_cap_wrap_ecc_sbe_cnt_ovfl_reg_t*) MEM_CAP_WRAP_ECC_SBE_CNT_OVFL1_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL2_REG(_BASE) ((mem_cap_wrap_ecc_sbe_cnt_ovfl_reg_t*) MEM_CAP_WRAP_ECC_SBE_CNT_OVFL2_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_SBE_CNT_OVFL3_REG(_BASE) ((mem_cap_wrap_ecc_sbe_cnt_ovfl_reg_t*) MEM_CAP_WRAP_ECC_SBE_CNT_OVFL3_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_STAT_INDEX_REG(_BASE) ((mem_cap_wrap_ecc_stat_index_reg_t*) MEM_CAP_WRAP_ECC_STAT_INDEX_ADR(_BASE))
#define MEM_CAP_WRAP_ECC_STAT_REG(_BASE) ((mem_cap_wrap_ecc_stat_reg_t*) MEM_CAP_WRAP_ECC_STAT_ADR(_BASE))
#define MEM_CAP_WRAP_RX_START0_REG(_BASE) ((mem_cap_wrap_rx_start_reg_t*) MEM_CAP_WRAP_RX_START0_ADR(_BASE))
#define MEM_CAP_WRAP_RX_START1_REG(_BASE) ((mem_cap_wrap_rx_start_reg_t*) MEM_CAP_WRAP_RX_START1_ADR(_BASE))
#define MEM_CAP_WRAP_RX_START2_REG(_BASE) ((mem_cap_wrap_rx_start_reg_t*) MEM_CAP_WRAP_RX_START2_ADR(_BASE))
#define MEM_CAP_WRAP_RX_START3_REG(_BASE) ((mem_cap_wrap_rx_start_reg_t*) MEM_CAP_WRAP_RX_START3_ADR(_BASE))
#define MEM_CAP_WRAP_RX_START4_REG(_BASE) ((mem_cap_wrap_rx_start_reg_t*) MEM_CAP_WRAP_RX_START4_ADR(_BASE))
#define MEM_CAP_WRAP_RX_END0_REG(_BASE) ((mem_cap_wrap_rx_end_reg_t*) MEM_CAP_WRAP_RX_END0_ADR(_BASE))
#define MEM_CAP_WRAP_RX_END1_REG(_BASE) ((mem_cap_wrap_rx_end_reg_t*) MEM_CAP_WRAP_RX_END1_ADR(_BASE))
#define MEM_CAP_WRAP_RX_END2_REG(_BASE) ((mem_cap_wrap_rx_end_reg_t*) MEM_CAP_WRAP_RX_END2_ADR(_BASE))
#define MEM_CAP_WRAP_RX_END3_REG(_BASE) ((mem_cap_wrap_rx_end_reg_t*) MEM_CAP_WRAP_RX_END3_ADR(_BASE))
#define MEM_CAP_WRAP_RX_END4_REG(_BASE) ((mem_cap_wrap_rx_end_reg_t*) MEM_CAP_WRAP_RX_END4_ADR(_BASE))
#define MEM_CAP_WRAP_RX_CUR0_REG(_BASE) ((mem_cap_wrap_rx_cur_reg_t*) MEM_CAP_WRAP_RX_CUR0_ADR(_BASE))
#define MEM_CAP_WRAP_RX_CUR1_REG(_BASE) ((mem_cap_wrap_rx_cur_reg_t*) MEM_CAP_WRAP_RX_CUR1_ADR(_BASE))
#define MEM_CAP_WRAP_RX_CUR2_REG(_BASE) ((mem_cap_wrap_rx_cur_reg_t*) MEM_CAP_WRAP_RX_CUR2_ADR(_BASE))
#define MEM_CAP_WRAP_RX_CUR3_REG(_BASE) ((mem_cap_wrap_rx_cur_reg_t*) MEM_CAP_WRAP_RX_CUR3_ADR(_BASE))
#define MEM_CAP_WRAP_RX_CUR4_REG(_BASE) ((mem_cap_wrap_rx_cur_reg_t*) MEM_CAP_WRAP_RX_CUR4_ADR(_BASE))
#define MEM_CAP_WRAP_RX_MODE0_REG(_BASE) ((mem_cap_wrap_rx_mode_reg_t*) MEM_CAP_WRAP_RX_MODE0_ADR(_BASE))
#define MEM_CAP_WRAP_RX_MODE1_REG(_BASE) ((mem_cap_wrap_rx_mode_reg_t*) MEM_CAP_WRAP_RX_MODE1_ADR(_BASE))
#define MEM_CAP_WRAP_RX_MODE2_REG(_BASE) ((mem_cap_wrap_rx_mode_reg_t*) MEM_CAP_WRAP_RX_MODE2_ADR(_BASE))
#define MEM_CAP_WRAP_RX_MODE3_REG(_BASE) ((mem_cap_wrap_rx_mode_reg_t*) MEM_CAP_WRAP_RX_MODE3_ADR(_BASE))
#define MEM_CAP_WRAP_RX_MODE4_REG(_BASE) ((mem_cap_wrap_rx_mode_reg_t*) MEM_CAP_WRAP_RX_MODE4_ADR(_BASE))
#define MEM_CAP_WRAP_TX_START0_REG(_BASE) ((mem_cap_wrap_tx_start_reg_t*) MEM_CAP_WRAP_TX_START0_ADR(_BASE))
#define MEM_CAP_WRAP_TX_START1_REG(_BASE) ((mem_cap_wrap_tx_start_reg_t*) MEM_CAP_WRAP_TX_START1_ADR(_BASE))
#define MEM_CAP_WRAP_TX_START2_REG(_BASE) ((mem_cap_wrap_tx_start_reg_t*) MEM_CAP_WRAP_TX_START2_ADR(_BASE))
#define MEM_CAP_WRAP_TX_START3_REG(_BASE) ((mem_cap_wrap_tx_start_reg_t*) MEM_CAP_WRAP_TX_START3_ADR(_BASE))
#define MEM_CAP_WRAP_TX_END0_REG(_BASE) ((mem_cap_wrap_tx_end_reg_t*) MEM_CAP_WRAP_TX_END0_ADR(_BASE))
#define MEM_CAP_WRAP_TX_END1_REG(_BASE) ((mem_cap_wrap_tx_end_reg_t*) MEM_CAP_WRAP_TX_END1_ADR(_BASE))
#define MEM_CAP_WRAP_TX_END2_REG(_BASE) ((mem_cap_wrap_tx_end_reg_t*) MEM_CAP_WRAP_TX_END2_ADR(_BASE))
#define MEM_CAP_WRAP_TX_END3_REG(_BASE) ((mem_cap_wrap_tx_end_reg_t*) MEM_CAP_WRAP_TX_END3_ADR(_BASE))
#define MEM_CAP_WRAP_TX_CUR0_REG(_BASE) ((mem_cap_wrap_tx_cur_reg_t*) MEM_CAP_WRAP_TX_CUR0_ADR(_BASE))
#define MEM_CAP_WRAP_TX_CUR1_REG(_BASE) ((mem_cap_wrap_tx_cur_reg_t*) MEM_CAP_WRAP_TX_CUR1_ADR(_BASE))
#define MEM_CAP_WRAP_TX_CUR2_REG(_BASE) ((mem_cap_wrap_tx_cur_reg_t*) MEM_CAP_WRAP_TX_CUR2_ADR(_BASE))
#define MEM_CAP_WRAP_TX_CUR3_REG(_BASE) ((mem_cap_wrap_tx_cur_reg_t*) MEM_CAP_WRAP_TX_CUR3_ADR(_BASE))
#define MEM_CAP_WRAP_TX_MODE0_REG(_BASE) ((mem_cap_wrap_tx_mode_reg_t*) MEM_CAP_WRAP_TX_MODE0_ADR(_BASE))
#define MEM_CAP_WRAP_TX_MODE1_REG(_BASE) ((mem_cap_wrap_tx_mode_reg_t*) MEM_CAP_WRAP_TX_MODE1_ADR(_BASE))
#define MEM_CAP_WRAP_TX_MODE2_REG(_BASE) ((mem_cap_wrap_tx_mode_reg_t*) MEM_CAP_WRAP_TX_MODE2_ADR(_BASE))
#define MEM_CAP_WRAP_TX_MODE3_REG(_BASE) ((mem_cap_wrap_tx_mode_reg_t*) MEM_CAP_WRAP_TX_MODE3_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER0_REG(_BASE) ((mem_cap_wrap_lfsr_seed_upper_reg_t*) MEM_CAP_WRAP_LFSR_SEED_UPPER0_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER1_REG(_BASE) ((mem_cap_wrap_lfsr_seed_upper_reg_t*) MEM_CAP_WRAP_LFSR_SEED_UPPER1_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER2_REG(_BASE) ((mem_cap_wrap_lfsr_seed_upper_reg_t*) MEM_CAP_WRAP_LFSR_SEED_UPPER2_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER3_REG(_BASE) ((mem_cap_wrap_lfsr_seed_upper_reg_t*) MEM_CAP_WRAP_LFSR_SEED_UPPER3_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER4_REG(_BASE) ((mem_cap_wrap_lfsr_seed_upper_reg_t*) MEM_CAP_WRAP_LFSR_SEED_UPPER4_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER5_REG(_BASE) ((mem_cap_wrap_lfsr_seed_upper_reg_t*) MEM_CAP_WRAP_LFSR_SEED_UPPER5_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_UPPER6_REG(_BASE) ((mem_cap_wrap_lfsr_seed_upper_reg_t*) MEM_CAP_WRAP_LFSR_SEED_UPPER6_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER0_REG(_BASE) ((mem_cap_wrap_lfsr_seed_lower_reg_t*) MEM_CAP_WRAP_LFSR_SEED_LOWER0_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER1_REG(_BASE) ((mem_cap_wrap_lfsr_seed_lower_reg_t*) MEM_CAP_WRAP_LFSR_SEED_LOWER1_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER2_REG(_BASE) ((mem_cap_wrap_lfsr_seed_lower_reg_t*) MEM_CAP_WRAP_LFSR_SEED_LOWER2_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER3_REG(_BASE) ((mem_cap_wrap_lfsr_seed_lower_reg_t*) MEM_CAP_WRAP_LFSR_SEED_LOWER3_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER4_REG(_BASE) ((mem_cap_wrap_lfsr_seed_lower_reg_t*) MEM_CAP_WRAP_LFSR_SEED_LOWER4_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER5_REG(_BASE) ((mem_cap_wrap_lfsr_seed_lower_reg_t*) MEM_CAP_WRAP_LFSR_SEED_LOWER5_ADR(_BASE))
#define MEM_CAP_WRAP_LFSR_SEED_LOWER6_REG(_BASE) ((mem_cap_wrap_lfsr_seed_lower_reg_t*) MEM_CAP_WRAP_LFSR_SEED_LOWER6_ADR(_BASE))
#define MEM_CAP_WRAP_FIXED_PATTERN0_REG(_BASE) ((mem_cap_wrap_fixed_pattern_reg_t*) MEM_CAP_WRAP_FIXED_PATTERN0_ADR(_BASE))
#define MEM_CAP_WRAP_FIXED_PATTERN1_REG(_BASE) ((mem_cap_wrap_fixed_pattern_reg_t*) MEM_CAP_WRAP_FIXED_PATTERN1_ADR(_BASE))
#define MEM_CAP_WRAP_FIXED_PATTERN2_REG(_BASE) ((mem_cap_wrap_fixed_pattern_reg_t*) MEM_CAP_WRAP_FIXED_PATTERN2_ADR(_BASE))
#define MEM_CAP_WRAP_FIXED_PATTERN3_REG(_BASE) ((mem_cap_wrap_fixed_pattern_reg_t*) MEM_CAP_WRAP_FIXED_PATTERN3_ADR(_BASE))
#define MEM_CAP_WRAP_FIXED_PATTERN4_REG(_BASE) ((mem_cap_wrap_fixed_pattern_reg_t*) MEM_CAP_WRAP_FIXED_PATTERN4_ADR(_BASE))
#define MEM_CAP_WRAP_FIXED_PATTERN5_REG(_BASE) ((mem_cap_wrap_fixed_pattern_reg_t*) MEM_CAP_WRAP_FIXED_PATTERN5_ADR(_BASE))
#define MEM_CAP_WRAP_FIXED_PATTERN6_REG(_BASE) ((mem_cap_wrap_fixed_pattern_reg_t*) MEM_CAP_WRAP_FIXED_PATTERN6_ADR(_BASE))
#define MEM_CAP_WRAP_RAMP_CFG0_REG(_BASE) ((mem_cap_wrap_ramp_cfg_reg_t*) MEM_CAP_WRAP_RAMP_CFG0_ADR(_BASE))
#define MEM_CAP_WRAP_RAMP_CFG1_REG(_BASE) ((mem_cap_wrap_ramp_cfg_reg_t*) MEM_CAP_WRAP_RAMP_CFG1_ADR(_BASE))
#define MEM_CAP_WRAP_RAMP_CFG2_REG(_BASE) ((mem_cap_wrap_ramp_cfg_reg_t*) MEM_CAP_WRAP_RAMP_CFG2_ADR(_BASE))
#define MEM_CAP_WRAP_RAMP_CFG3_REG(_BASE) ((mem_cap_wrap_ramp_cfg_reg_t*) MEM_CAP_WRAP_RAMP_CFG3_ADR(_BASE))
#define MEM_CAP_WRAP_RAMP_CFG4_REG(_BASE) ((mem_cap_wrap_ramp_cfg_reg_t*) MEM_CAP_WRAP_RAMP_CFG4_ADR(_BASE))
#define MEM_CAP_WRAP_RAMP_CFG5_REG(_BASE) ((mem_cap_wrap_ramp_cfg_reg_t*) MEM_CAP_WRAP_RAMP_CFG5_ADR(_BASE))
#define MEM_CAP_WRAP_RAMP_CFG6_REG(_BASE) ((mem_cap_wrap_ramp_cfg_reg_t*) MEM_CAP_WRAP_RAMP_CFG6_ADR(_BASE))
#define MEM_CAP_WRAP_INIT_RAM0_REG(_BASE) ((mem_cap_wrap_init_ram_reg_t*) MEM_CAP_WRAP_INIT_RAM0_ADR(_BASE))
#define MEM_CAP_WRAP_INIT_RAM1_REG(_BASE) ((mem_cap_wrap_init_ram_reg_t*) MEM_CAP_WRAP_INIT_RAM1_ADR(_BASE))
#define MEM_CAP_WRAP_INIT_RAM2_REG(_BASE) ((mem_cap_wrap_init_ram_reg_t*) MEM_CAP_WRAP_INIT_RAM2_ADR(_BASE))
#define MEM_CAP_WRAP_INIT_RAM3_REG(_BASE) ((mem_cap_wrap_init_ram_reg_t*) MEM_CAP_WRAP_INIT_RAM3_ADR(_BASE))
#define MEM_CAP_WRAP_INIT_RAM4_REG(_BASE) ((mem_cap_wrap_init_ram_reg_t*) MEM_CAP_WRAP_INIT_RAM4_ADR(_BASE))
#define MEM_CAP_WRAP_INIT_RAM5_REG(_BASE) ((mem_cap_wrap_init_ram_reg_t*) MEM_CAP_WRAP_INIT_RAM5_ADR(_BASE))
#define MEM_CAP_WRAP_INIT_RAM6_REG(_BASE) ((mem_cap_wrap_init_ram_reg_t*) MEM_CAP_WRAP_INIT_RAM6_ADR(_BASE))
#define MEM_CAP_WRAP_CAPT_REG(_BASE) ((mem_cap_wrap_capt_reg_t*) MEM_CAP_WRAP_CAPT_ADR(_BASE))
#define MEM_CAP_WRAP_SCRATCH_REG(_BASE) ((mem_cap_wrap_scratch_reg_t*) MEM_CAP_WRAP_SCRATCH_ADR(_BASE))
#define MEM_CAP_WRAP_TDPACK_FIFO_WM_REG(_BASE) ((mem_cap_wrap_tdpack_fifo_wm_reg_t*) MEM_CAP_WRAP_TDPACK_FIFO_WM_ADR(_BASE))
#define MEM_CAP_WRAP_TDPACK_FIFO_STAT_REG(_BASE) ((mem_cap_wrap_tdpack_fifo_stat_reg_t*) MEM_CAP_WRAP_TDPACK_FIFO_STAT_ADR(_BASE))
#define MEM_CAP_WRAP_INT_STAT_REG(_BASE) ((mem_cap_wrap_int_stat_reg_t*) MEM_CAP_WRAP_INT_STAT_ADR(_BASE))
#define MEM_CAP_WRAP_INT_HIGH_EN_REG(_BASE) ((mem_cap_wrap_int_high_en_reg_t*) MEM_CAP_WRAP_INT_HIGH_EN_ADR(_BASE))
#define MEM_CAP_WRAP_INT_LOW_EN_REG(_BASE) ((mem_cap_wrap_int_low_en_reg_t*) MEM_CAP_WRAP_INT_LOW_EN_ADR(_BASE))
#define MEM_CAP_WRAP_INT_CLR_REG(_BASE) ((mem_cap_wrap_int_clr_reg_t*) MEM_CAP_WRAP_INT_CLR_ADR(_BASE))
#define MEM_CAP_WRAP_INT_FORCE_REG(_BASE) ((mem_cap_wrap_int_force_reg_t*) MEM_CAP_WRAP_INT_FORCE_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R0_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r0_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R0_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R1_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r1_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R1_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R2_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r2_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R2_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R3_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r3_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R3_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R4_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r4_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R4_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R5_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r5_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R5_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R6_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r6_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R6_ADR(_BASE))
#define MEM_CAP_WRAP_SMON_CSR_SMON_R7_REG(_BASE) ((mem_cap_wrap_smon_csr_smon_r7_reg_t*) MEM_CAP_WRAP_SMON_CSR_SMON_R7_ADR(_BASE))
#define MEM_CAP_WRAP_APB_BRDG_STAT_REG(_BASE) ((mem_cap_wrap_apb_brdg_stat_reg_t*) MEM_CAP_WRAP_APB_BRDG_STAT_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    mem_cap_wrap_mux_sel_reg_t MUX_SEL[7]; /*< Address offset = 0x0 */
    const uint8_t        reservedArea0 [4];   /*< Address offset = 0x1c */
    mem_cap_wrap_mem_err_reg_t MEM_ERR[7]; /*< Address offset = 0x20 */
    const uint8_t        reservedArea1 [4];   /*< Address offset = 0x3c */
    mem_cap_wrap_ecc_err_reg_t ECC_ERR[7]; /*< Address offset = 0x40 */
    const uint8_t        reservedArea2 [4];   /*< Address offset = 0x5c */
    mem_cap_wrap_ecc_correct_reg_t ECC_CORRECT; /*< Address offset = 0x60 */
    mem_cap_wrap_pwr_down_ctrl_reg_t PWR_DOWN_CTRL; /*< Address offset = 0x64 */
    const uint8_t        reservedArea3 [24];  /*< Address offset = 0x68 */
    mem_cap_wrap_ecc_cfg_reg_t ECC_CFG[28]; /*< Address offset = 0x80 */
    const uint8_t        reservedArea4 [16];  /*< Address offset = 0xf0 */
    mem_cap_wrap_ecc_sbe_lvl_reg_t ECC_SBE_LVL[4]; /*< Address offset = 0x100 */
    mem_cap_wrap_ecc_dbe_lvl_reg_t ECC_DBE_LVL[4]; /*< Address offset = 0x110 */
    mem_cap_wrap_ecc_sbe_cnt_ovfl_reg_t ECC_SBE_CNT_OVFL[4]; /*< Address offset = 0x120 */
    mem_cap_wrap_ecc_stat_index_reg_t ECC_STAT_INDEX; /*< Address offset = 0x130 */
    mem_cap_wrap_ecc_stat_reg_t ECC_STAT; /*< Address offset = 0x134 */
    const uint8_t        reservedArea5 [72];  /*< Address offset = 0x138 */
    mem_cap_wrap_rx_start_reg_t RX_START[5]; /*< Address offset = 0x180 */
    const uint8_t        reservedArea6 [12];  /*< Address offset = 0x194 */
    mem_cap_wrap_rx_end_reg_t RX_END[5]; /*< Address offset = 0x1a0 */
    const uint8_t        reservedArea7 [12];  /*< Address offset = 0x1b4 */
    mem_cap_wrap_rx_cur_reg_t RX_CUR[5]; /*< Address offset = 0x1c0 */
    const uint8_t        reservedArea8 [12];  /*< Address offset = 0x1d4 */
    mem_cap_wrap_rx_mode_reg_t RX_MODE[5]; /*< Address offset = 0x1e0 */
    const uint8_t        reservedArea9 [12];  /*< Address offset = 0x1f4 */
    mem_cap_wrap_tx_start_reg_t TX_START[4]; /*< Address offset = 0x200 */
    const uint8_t        reservedArea10 [16]; /*< Address offset = 0x210 */
    mem_cap_wrap_tx_end_reg_t TX_END[4]; /*< Address offset = 0x220 */
    const uint8_t        reservedArea11 [16]; /*< Address offset = 0x230 */
    mem_cap_wrap_tx_cur_reg_t TX_CUR[4]; /*< Address offset = 0x240 */
    const uint8_t        reservedArea12 [16]; /*< Address offset = 0x250 */
    mem_cap_wrap_tx_mode_reg_t TX_MODE[4]; /*< Address offset = 0x260 */
    const uint8_t        reservedArea13 [16]; /*< Address offset = 0x270 */
    mem_cap_wrap_lfsr_seed_upper_reg_t LFSR_SEED_UPPER[7]; /*< Address offset = 0x280 */
    const uint8_t        reservedArea14 [8];  /*< Address offset = 0x2b8 */
    mem_cap_wrap_lfsr_seed_lower_reg_t LFSR_SEED_LOWER[7]; /*< Address offset = 0x2c0 */
    const uint8_t        reservedArea15 [8];  /*< Address offset = 0x2f8 */
    mem_cap_wrap_fixed_pattern_reg_t FIXED_PATTERN[7]; /*< Address offset = 0x300 */
    const uint8_t        reservedArea16 [4];  /*< Address offset = 0x31c */
    mem_cap_wrap_ramp_cfg_reg_t RAMP_CFG[7]; /*< Address offset = 0x320 */
    const uint8_t        reservedArea17 [4];  /*< Address offset = 0x33c */
    mem_cap_wrap_init_ram_reg_t INIT_RAM[7]; /*< Address offset = 0x340 */
    const uint8_t        reservedArea18 [4];  /*< Address offset = 0x35c */
    mem_cap_wrap_capt_reg_t CAPT_COMP; /*< Address offset = 0x360 */
    mem_cap_wrap_scratch_reg_t SCRATCH; /*< Address offset = 0x364 */
    const uint8_t        reservedArea19 [8];  /*< Address offset = 0x368 */
    mem_cap_wrap_tdpack_fifo_wm_reg_t TDPACK_FIFO_WM; /*< Address offset = 0x370 */
    mem_cap_wrap_tdpack_fifo_stat_reg_t TDPACK_FIFO_STAT; /*< Address offset = 0x374 */
    const uint8_t        reservedArea20 [8];  /*< Address offset = 0x378 */
    mem_cap_wrap_int_stat_reg_t INT_STAT; /*< Address offset = 0x380 */
    mem_cap_wrap_int_high_en_reg_t INT_HIGH_EN; /*< Address offset = 0x384 */
    mem_cap_wrap_int_low_en_reg_t INT_LOW_EN; /*< Address offset = 0x388 */
    mem_cap_wrap_int_clr_reg_t INT_CLR; /*< Address offset = 0x38c */
    mem_cap_wrap_int_force_reg_t INT_FORCE; /*< Address offset = 0x390 */
    const uint8_t        reservedArea21 [12]; /*< Address offset = 0x394 */
    mem_cap_wrap_smon_csr_smon_r0_reg_t SMON_CSR_SMON_R0; /*< Address offset = 0x3a0 */
    mem_cap_wrap_smon_csr_smon_r1_reg_t SMON_CSR_SMON_R1; /*< Address offset = 0x3a4 */
    mem_cap_wrap_smon_csr_smon_r2_reg_t SMON_CSR_SMON_R2; /*< Address offset = 0x3a8 */
    mem_cap_wrap_smon_csr_smon_r3_reg_t SMON_CSR_SMON_R3; /*< Address offset = 0x3ac */
    mem_cap_wrap_smon_csr_smon_r4_reg_t SMON_CSR_SMON_R4; /*< Address offset = 0x3b0 */
    mem_cap_wrap_smon_csr_smon_r5_reg_t SMON_CSR_SMON_R5; /*< Address offset = 0x3b4 */
    mem_cap_wrap_smon_csr_smon_r6_reg_t SMON_CSR_SMON_R6; /*< Address offset = 0x3b8 */
    mem_cap_wrap_smon_csr_smon_r7_reg_t SMON_CSR_SMON_R7; /*< Address offset = 0x3bc */
    const uint8_t        reservedArea22 [60]; /*< Address offset = 0x3c0 */
    mem_cap_wrap_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x3fc */
} mem_cap_wrap_t;     // size: 0x00b0

// AddressSpace struct pointer
//
#define MEM_CAP0         ((mem_cap_wrap_t*) MEM_CAP0_BASE)
#define MEM_CAP1         ((mem_cap_wrap_t*) MEM_CAP1_BASE)

// ******************************************* /Address Space

#endif      // _MEM_CAP_WRAP_H_

