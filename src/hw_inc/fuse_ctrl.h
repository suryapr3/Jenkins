#ifndef _FUSE_CTRL_H_
#define _FUSE_CTRL_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define SYSCON_IFS_FC_APB_BASE  ( 0x01e30000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define FUSE_CTRL_OFFSET ( 0x00000000U )
#define FUSE_CTRL_CMD_OFFSET ( 0x00000004U )
#define FUSE_CTRL_CNTERS_OFFSET ( 0x00000008U )
#define FUSE_CTRL_DATA_OFFSET ( 0x00000020U )
#define FUSE_CTRL_ECC_DATA_OFFSET ( 0x00000024U )
#define FUSE_CTRL_STAT_OFFSET ( 0x00000100U )
#define FUSE_CTRL_HIP_ECC_STAT_OFFSET ( 0x00000104U )
#define FUSE_CTRL_DBG_CTRL_OFFSET ( 0x00000200U )
#define FUSE_CTRL_HIP_OFFSET ( 0x00000300U )
#define FUSE_CTRL_HIP_REGISTER_DATA_OFFSET ( 0x00000304U )
#define FUSE_CTRL_HIP_CTRL_OFFSET ( 0x00000308U )
#define FUSE_CTRL_DRNG_ES_CFG0_OFFSET ( 0x00000400U )
#define FUSE_CTRL_DRNG_ES_CFG1_OFFSET ( 0x00000408U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define FUSE_CTRL_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_OFFSET ) ))
#define FUSE_CTRL_CMD_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_CMD_OFFSET ) ))
#define FUSE_CTRL_CNTERS_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_CNTERS_OFFSET ) ))
#define FUSE_CTRL_DATA_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_DATA_OFFSET ) ))
#define FUSE_CTRL_ECC_DATA_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_ECC_DATA_OFFSET ) ))
#define FUSE_CTRL_STAT_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_STAT_OFFSET ) ))
#define FUSE_CTRL_HIP_ECC_STAT_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_HIP_ECC_STAT_OFFSET ) ))
#define FUSE_CTRL_DBG_CTRL_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_DBG_CTRL_OFFSET ) ))
#define FUSE_CTRL_HIP_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_HIP_OFFSET ) ))
#define FUSE_CTRL_HIP_REGISTER_DATA_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_HIP_REGISTER_DATA_OFFSET ) ))
#define FUSE_CTRL_HIP_CTRL_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_HIP_CTRL_OFFSET ) ))
#define FUSE_CTRL_DRNG_ES_CFG0_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_DRNG_ES_CFG0_OFFSET ) ))
#define FUSE_CTRL_DRNG_ES_CFG1_ADR (( ( SYSCON_IFS_FC_APB_BASE ) + ( FUSE_CTRL_DRNG_ES_CFG1_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief FUSE_CTRL_APB_REG_FUSE_ADDRESS_REG register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_ADDRESS_REG
  * Fuse Address Register
  */

typedef union {
  struct {
    uint32_t ROW_ADDRESS : 5;
    ///< this feild specifies the row address to program or fuse override
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t ARRAY_ADDRESS : 3;
    ///< The fuse controller supports up to 8 arrays per module.  This field
    ///< specifies the array address to program or fuse override.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t MODULE_ADDRESS : 7;
    ///< The fuse controller supports up to 128 modules.  This field specifies
    ///< the module address to program or fuse override.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ADDRESS_TYPE : 1;
    ///< 1b0 : Data Rows 1b1 : Special Rows
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t REDUNDANCY : 2;
    ///< 2b00 : Reserved 2b01 : Read/Program Redundanct Copy 0 2b10 : Read/Program
    ///< Redundanct Copy 1 2b11 : Read/Program all Redundant Copies
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 14;
    ///< RESERVED_31_18
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_reg_t;

#define FUSE_CTRL_DEFAULT (0x00000000U)
#define FUSE_CTRL_RD_MASK (0xffffffffU)
#define FUSE_CTRL_WR_MASK (0x0003ffffU)


///< this feild specifies the row address to program or fuse override
#define FUSE_CTRL_ROW_BF_OFF ( 0)
#define FUSE_CTRL_ROW_BF_WID ( 5)
#define FUSE_CTRL_ROW_BF_MSK (0x0000001F)
#define FUSE_CTRL_ROW_BF_DEF (0x00000000)

///< The fuse controller supports up to 8 arrays per module.  This field
///< specifies the array address to program or fuse override.
#define FUSE_CTRL_ARRAY_BF_OFF ( 5)
#define FUSE_CTRL_ARRAY_BF_WID ( 3)
#define FUSE_CTRL_ARRAY_BF_MSK (0x000000E0)
#define FUSE_CTRL_ARRAY_BF_DEF (0x00000000)

///< The fuse controller supports up to 128 modules.  This field specifies
///< the module address to program or fuse override.
#define FUSE_CTRL_MODULE_BF_OFF ( 8)
#define FUSE_CTRL_MODULE_BF_WID ( 7)
#define FUSE_CTRL_MODULE_BF_MSK (0x00007F00)
#define FUSE_CTRL_MODULE_BF_DEF (0x00000000)

///< 1b0 : Data Rows 1b1 : Special Rows
#define FUSE_CTRL_TYPE_BF_OFF (15)
#define FUSE_CTRL_TYPE_BF_WID ( 1)
#define FUSE_CTRL_TYPE_BF_MSK (0x00008000)
#define FUSE_CTRL_TYPE_BF_DEF (0x00000000)

///< 2b00 : Reserved 2b01 : Read/Program Redundanct Copy 0 2b10 : Read/Program
///< Redundanct Copy 1 2b11 : Read/Program all Redundant Copies
#define FUSE_CTRL_REDUNDANCY_BF_OFF (16)
#define FUSE_CTRL_REDUNDANCY_BF_WID ( 2)
#define FUSE_CTRL_REDUNDANCY_BF_MSK (0x00030000)
#define FUSE_CTRL_REDUNDANCY_BF_DEF (0x00000000)

///< RESERVED_31_18
#define FUSE_CTRL_RESERVED_31_18_BF_OFF (18)
#define FUSE_CTRL_RESERVED_31_18_BF_WID (14)
#define FUSE_CTRL_RESERVED_31_18_BF_MSK (0xFFFC0000)
#define FUSE_CTRL_RESERVED_31_18_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_COMMAND_REG register description at address offset 0x4
  *
  * Register default value:        0x0000000F
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_COMMAND_REG
  * Fuse Command Register
  */

typedef union {
  struct {
    uint32_t FUSE_COMMAND : 4;
    ///< command to execute on the fuse controller  4b0000: Fuse HIP Array
    ///< read 4b0001: Reserved 4b0010: Reserved 4b0011: Reserved 4b0100: Reserved
    ///< 4'B0101: Reserved 4b0110: Fuse HIP Array program (Data Only) 4b0111:
    ///< Fuse HIP Array program (ECC Only) 4b1000: Fuse HIP Array program (Data
    ///< + ECC) 4b1001: Reserved 4b1010: Reserved 4b1011: Override Done 4b1100:
    ///< Shadow Register Zeroing      (RED2/RED4 Only) 4b1101: Shadow Register
    ///< Read 4b1110: Shadow Register Write 4b1111: Fuse Sense
    ///< AccessType="RW" BitOffset="0" ResetValue="0xF"
    uint32_t  : 4;
    ///< RESERVED_7_4
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t FAV0R0 : 3;
    ///< Binary weighted sense current adjustment. Biases the output of the
    ///< column fuse sense amps to zero. During fuse read operation, verifies
    ///< the integrity of a fuse value of one.   Default must always remain
    ///< at 0 as sensing state machine takes the favor 0 bits from this field.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t FAV0R1 : 3;
    ///< Binary weighted sense current adjustment. Biases the output of the
    ///< column fuse sense amps to one. During fuse read operation, verifies
    ///< the integrity of a fuse value of zero.   Default must always remain
    ///< at zero as sensing state machine takes the favor one bits from this
    ///< field.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t SENSEHIZHD : 1;
    ///< Extra control signal for fuse sense.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SENSELVL2HD : 1;
    ///< Used to increase the reference side sense current.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t SENSELVLHD : 1;
    ///< Used to increase the reference side sense current.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t HVPROTECT : 1;
    ///< Must be set during fuse programming to enable the high voltage protection
    ///< circuits within the fuse arrays to prevent damage. This bit takes
    ///< effect immediately, it is no longer gated by Global Program Enable
    ///< being set.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t  : 14;
    ///< RESERVED_31_18
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_cmd_reg_t;

#define FUSE_CTRL_CMD_DEFAULT (0x0000000fU)
#define FUSE_CTRL_CMD_RD_MASK (0xffffffffU)
#define FUSE_CTRL_CMD_WR_MASK (0x0003ff0fU)


///< command to execute on the fuse controller  4b0000: Fuse HIP Array
///< read 4b0001: Reserved 4b0010: Reserved 4b0011: Reserved 4b0100: Reserved
///< 4'B0101: Reserved 4b0110: Fuse HIP Array program (Data Only) 4b0111:
///< Fuse HIP Array program (ECC Only) 4b1000: Fuse HIP Array program (Data
///< + ECC) 4b1001: Reserved 4b1010: Reserved 4b1011: Override Done 4b1100:
///< Shadow Register Zeroing      (RED2/RED4 Only) 4b1101: Shadow Register
///< Read 4b1110: Shadow Register Write 4b1111: Fuse Sense
#define FUSE_CTRL_CMD_FUSE_CMD_BF_OFF ( 0)
#define FUSE_CTRL_CMD_FUSE_CMD_BF_WID ( 4)
#define FUSE_CTRL_CMD_FUSE_CMD_BF_MSK (0x0000000F)
#define FUSE_CTRL_CMD_FUSE_CMD_BF_DEF (0x0000000F)

///< RESERVED_7_4
#define FUSE_CTRL_CMD_RESERVED_7_4_BF_OFF ( 4)
#define FUSE_CTRL_CMD_RESERVED_7_4_BF_WID ( 4)
#define FUSE_CTRL_CMD_RESERVED_7_4_BF_MSK (0x000000F0)
#define FUSE_CTRL_CMD_RESERVED_7_4_BF_DEF (0x00000000)

///< Binary weighted sense current adjustment. Biases the output of the
///< column fuse sense amps to zero. During fuse read operation, verifies
///< the integrity of a fuse value of one.   Default must always remain
///< at 0 as sensing state machine takes the favor 0 bits from this field.
#define FUSE_CTRL_CMD_FAV0R0_BF_OFF ( 8)
#define FUSE_CTRL_CMD_FAV0R0_BF_WID ( 3)
#define FUSE_CTRL_CMD_FAV0R0_BF_MSK (0x00000700)
#define FUSE_CTRL_CMD_FAV0R0_BF_DEF (0x00000000)

///< Binary weighted sense current adjustment. Biases the output of the
///< column fuse sense amps to one. During fuse read operation, verifies
///< the integrity of a fuse value of zero.   Default must always remain
///< at zero as sensing state machine takes the favor one bits from this
///< field.
#define FUSE_CTRL_CMD_FAV0R1_BF_OFF (11)
#define FUSE_CTRL_CMD_FAV0R1_BF_WID ( 3)
#define FUSE_CTRL_CMD_FAV0R1_BF_MSK (0x00003800)
#define FUSE_CTRL_CMD_FAV0R1_BF_DEF (0x00000000)

///< Extra control signal for fuse sense.
#define FUSE_CTRL_CMD_SENSEHIZHD_BF_OFF (14)
#define FUSE_CTRL_CMD_SENSEHIZHD_BF_WID ( 1)
#define FUSE_CTRL_CMD_SENSEHIZHD_BF_MSK (0x00004000)
#define FUSE_CTRL_CMD_SENSEHIZHD_BF_DEF (0x00000000)

///< Used to increase the reference side sense current.
#define FUSE_CTRL_CMD_SENSELVL2HD_BF_OFF (15)
#define FUSE_CTRL_CMD_SENSELVL2HD_BF_WID ( 1)
#define FUSE_CTRL_CMD_SENSELVL2HD_BF_MSK (0x00008000)
#define FUSE_CTRL_CMD_SENSELVL2HD_BF_DEF (0x00000000)

///< Used to increase the reference side sense current.
#define FUSE_CTRL_CMD_SENSELVLHD_BF_OFF (16)
#define FUSE_CTRL_CMD_SENSELVLHD_BF_WID ( 1)
#define FUSE_CTRL_CMD_SENSELVLHD_BF_MSK (0x00010000)
#define FUSE_CTRL_CMD_SENSELVLHD_BF_DEF (0x00000000)

///< Must be set during fuse programming to enable the high voltage protection
///< circuits within the fuse arrays to prevent damage. This bit takes
///< effect immediately, it is no longer gated by Global Program Enable
///< being set.
#define FUSE_CTRL_CMD_HVPROTECT_BF_OFF (17)
#define FUSE_CTRL_CMD_HVPROTECT_BF_WID ( 1)
#define FUSE_CTRL_CMD_HVPROTECT_BF_MSK (0x00020000)
#define FUSE_CTRL_CMD_HVPROTECT_BF_DEF (0x00000000)

///< RESERVED_31_18
#define FUSE_CTRL_CMD_RESERVED_31_18_BF_OFF (18)
#define FUSE_CTRL_CMD_RESERVED_31_18_BF_WID (14)
#define FUSE_CTRL_CMD_RESERVED_31_18_BF_MSK (0xFFFC0000)
#define FUSE_CTRL_CMD_RESERVED_31_18_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_COUNTERS_REG register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_COUNTERS_REG
  * Fuse Counters Register
  */

typedef union {
  struct {
    uint32_t PROGRAM_CNT : 16;
    ///< The number of clocks (fuse_ref_clk) required to properly program the
    ///< fuses.  Must be set to meet the TD Redbook programming time.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t SENSE_CNT : 16;
    ///< The number of ring oscillator clocks (fuse_ro_clk) required to properly
    ///< sense the fuses. Must be set to meet the TD Redbook sense time and
    ///< the propagation time of the sensed data traveling from the Fuse Arrays
    ///< back to the fuse controller.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_cnters_reg_t;

#define FUSE_CTRL_CNTERS_DEFAULT (0x00000000U)
#define FUSE_CTRL_CNTERS_RD_MASK (0xffffffffU)
#define FUSE_CTRL_CNTERS_WR_MASK (0xffffffffU)


///< The number of clocks (fuse_ref_clk) required to properly program the
///< fuses.  Must be set to meet the TD Redbook programming time.
#define FUSE_CTRL_CNTERS_PROGRAM_CNT_BF_OFF ( 0)
#define FUSE_CTRL_CNTERS_PROGRAM_CNT_BF_WID (16)
#define FUSE_CTRL_CNTERS_PROGRAM_CNT_BF_MSK (0x0000FFFF)
#define FUSE_CTRL_CNTERS_PROGRAM_CNT_BF_DEF (0x00000000)

///< The number of ring oscillator clocks (fuse_ro_clk) required to properly
///< sense the fuses. Must be set to meet the TD Redbook sense time and
///< the propagation time of the sensed data traveling from the Fuse Arrays
///< back to the fuse controller.
#define FUSE_CTRL_CNTERS_SENSE_CNT_BF_OFF (16)
#define FUSE_CTRL_CNTERS_SENSE_CNT_BF_WID (16)
#define FUSE_CTRL_CNTERS_SENSE_CNT_BF_MSK (0xFFFF0000)
#define FUSE_CTRL_CNTERS_SENSE_CNT_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_DATA_REG register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_DATA_REG
  * Fuse Data Register
  */

typedef union {
  struct {
    uint32_t FUSEDATA : 32;
    ///< Supplies the 32 bits of data for a Program / Write command.   Returns
    ///< the 32 bits of data returned from a Read command.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_data_reg_t;

#define FUSE_CTRL_DATA_DEFAULT (0x00000000U)
#define FUSE_CTRL_DATA_RD_MASK (0xffffffffU)
#define FUSE_CTRL_DATA_WR_MASK (0xffffffffU)


///< Supplies the 32 bits of data for a Program / Write command.   Returns
///< the 32 bits of data returned from a Read command.
#define FUSE_CTRL_DATA_FUSEDATA_BF_OFF ( 0)
#define FUSE_CTRL_DATA_FUSEDATA_BF_WID (32)
#define FUSE_CTRL_DATA_FUSEDATA_BF_MSK (0xFFFFFFFF)
#define FUSE_CTRL_DATA_FUSEDATA_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_ECC_DATA_REG register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_ECC_DATA_REG
  * Fuse ECC Data Register
  */

typedef union {
  struct {
    uint32_t FUSEECCDATA : 12;
    ///< Returns the 12 bits of ECC data returned from a Fuse HIP Array Read
    ///< command.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 4;
    ///< RESERVED
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
    uint32_t S1 : 6;
    ///< Returns the syndrome (s1) value of the fuse data from a Fuse HIP Array
    ///< Read command
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 1;
    ///< RESERVED
    ///< AccessType="RO" BitOffset="22" ResetValue="0x0"
    uint32_t S3 : 6;
    ///< Returns the syndrome (s3) value of the fuse data from a Fuse HIP Array
    ///< Read command.
    ///< AccessType="RO/V" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< RESERVED
    ///< AccessType="RO" BitOffset="29" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_ecc_data_reg_t;

#define FUSE_CTRL_ECC_DATA_DEFAULT (0x00000000U)
#define FUSE_CTRL_ECC_DATA_RD_MASK (0xffffffffU)
#define FUSE_CTRL_ECC_DATA_WR_MASK (0x00000000U)


///< Returns the 12 bits of ECC data returned from a Fuse HIP Array Read
///< command.
#define FUSE_CTRL_ECC_DATA_FUSEECCDATA_BF_OFF ( 0)
#define FUSE_CTRL_ECC_DATA_FUSEECCDATA_BF_WID (12)
#define FUSE_CTRL_ECC_DATA_FUSEECCDATA_BF_MSK (0x00000FFF)
#define FUSE_CTRL_ECC_DATA_FUSEECCDATA_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_ECC_DATA_RESERVED_15_12_BF_OFF (12)
#define FUSE_CTRL_ECC_DATA_RESERVED_15_12_BF_WID ( 4)
#define FUSE_CTRL_ECC_DATA_RESERVED_15_12_BF_MSK (0x0000F000)
#define FUSE_CTRL_ECC_DATA_RESERVED_15_12_BF_DEF (0x00000000)

///< Returns the syndrome (s1) value of the fuse data from a Fuse HIP Array
///< Read command
#define FUSE_CTRL_ECC_DATA_S1_BF_OFF (16)
#define FUSE_CTRL_ECC_DATA_S1_BF_WID ( 6)
#define FUSE_CTRL_ECC_DATA_S1_BF_MSK (0x003F0000)
#define FUSE_CTRL_ECC_DATA_S1_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_ECC_DATA_RESERVED_22_BF_OFF (22)
#define FUSE_CTRL_ECC_DATA_RESERVED_22_BF_WID ( 1)
#define FUSE_CTRL_ECC_DATA_RESERVED_22_BF_MSK (0x00400000)
#define FUSE_CTRL_ECC_DATA_RESERVED_22_BF_DEF (0x00000000)

///< Returns the syndrome (s3) value of the fuse data from a Fuse HIP Array
///< Read command.
#define FUSE_CTRL_ECC_DATA_S3_BF_OFF (23)
#define FUSE_CTRL_ECC_DATA_S3_BF_WID ( 6)
#define FUSE_CTRL_ECC_DATA_S3_BF_MSK (0x1F800000)
#define FUSE_CTRL_ECC_DATA_S3_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_ECC_DATA_RESERVED_31_29_BF_OFF (29)
#define FUSE_CTRL_ECC_DATA_RESERVED_31_29_BF_WID ( 3)
#define FUSE_CTRL_ECC_DATA_RESERVED_31_29_BF_MSK (0xE0000000)
#define FUSE_CTRL_ECC_DATA_RESERVED_31_29_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_STATUS_REG register description at address offset 0x100
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_STATUS_REG
  * Fuse Status Register
  */

typedef union {
  struct {
    uint32_t HWBUSY : 1;
    ///< Fuse hardware state machine is currently busy performing an Fuse operation
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FUSESENSEDONE : 1;
    ///< This bit is used to indicate that the fuse sensing process has completed.
    ///< Reflects the value of the output port (fuse_sense_done).
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t FUSEHIPALLZERO : 1;
    ///< During fuse sensing, the fuse controller checks each fuse data row
    ///< if it contains all 0 or not.  At the end of fuse sensing, this bit
    ///< indicates if all fuse data rows are 0 or not.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t FUSESENSEERROR : 1;
    ///< At the end of fuse sensing, if any error occurred, this bit will be
    ///< set.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t DFX_POLICY : 4;
    ///< The value of the input port, dfx_agg_policy[3:0]. 4b0000 : Functionality
    ///< Locked   (GREEN) 4b0010 : Security Unlocked       (RED 2) 4b0100 :
    ///< Intel Unlocked            (RED 4)
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t COMMANDSTATUS : 3;
    ///< 3b000 : IDLE, No Command Requested 3b001 : Command is currently being
    ///< Executed 3b010 : Command requested, but dropped as the HW controller
    ///< was currently processing another request. 3b011 : Command requested,
    ///< but dropped as the command requested is not valid and is one of the
    ///< Reserved commands. 3b100 : Command requested, but dropped as the command
    ///< requested is not valid in the current  Secure Policy. 3b101 : Command
    ///< Executed, but dropped as the specified address was not valid. 3b110
    ///< : Command Executed, but completed with errors.  Check bits [16:14]
    ///< and [13:11] for the reason. 3b111 : Command Executed, completed successfully
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t ADDRESSSTATUS : 3;
    ///< 3b000 : All addresses are valid 3b001 : Module Address is invalid.
    ///< The module address specified in the Fuse Address  register contains
    ///< a module that does not exist on this SoC. 3b010 : Row Address is invalid.
    ///< The row address specified in either the Fuse Address  or Fuse Address
    ///< (Fuse Repair) registers contains a logical row address that does not
    ///< exist on this SoC.  This can only happen if the Module contains a
    ///< 4K Fuse HIP and the address specified is >63. 3b011 : Jason TBD to
    ///< add redundancy error 3b100 : Reserved 3b101 : Reserved 3b110 : Reserved
    ///< 3b111 : Reserved
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t COMMANDERROR : 3;
    ///< 3b000 : No errors 3b001 : Fuse HIP Write Security failed.  An attempt
    ///< was made to perform a Fuse HIP Write, via APB or JTAG, however the
    ///< access controls prohibited the write.  3b010 : Fuse HIP Read Security
    ///< failed.  An attempt was made to perform a Fuse HIP Read, via APB or
    ///< JTAG, however the access controls are preventing the read.  The data
    ///< in the Fuse Data  is not valid. 3b011 : Shadow Register Write Security
    ///< failed.  An attempt was made to perform a Shadow Register Write, via
    ///< APB or JTAG, however the access controls prohibited the write. 3b100
    ///< : Shadow Register Read Security failed.  An attempt was made to perform
    ///< a Shadow Register Read, via APB or JTAG, however the access controls
    ///< are preventing the read.  The data in the Fuse Data  is not valid.
    ///< 3b101 : Reserved 3b110 : Reserved, not used with Intel Fuse HIPs 3b111
    ///< : Address Error.  An attempt was made to access an address that does
    ///< not exist.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t SORTONLYBUMPS : 3;
    ///< This field reflects the input port fuse_sort_only_bumps[2:0].
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t ATTACK : 8;
    ///< 7 = Over Voltage 6 = Under Voltage 5 = Reserved (Temperature) 4 =
    ///< Canary Error (Sense Amp) 3 = Reserved (Frequency) 2 = Module Address
    ///< Out of Range 1 = Array Address Out of Range 0 = Row Address Out of
    ///< Range Whenever an attack occurs, this field can be used to determine
    ///< which attack(s) occurred.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t A0DEBUGSTRAP : 1;
    ///< This field reflects the input port a0_debug_strap.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="0x0"
    uint32_t STATUSCLEAR : 1;
    ///< A write to this bit causes the Fuse Status register to be cleared.
    ///< There are a few bits that are not clearable, see the note in the individual
    ///< bits for details.
    ///< AccessType="RW/1C" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_stat_reg_t;

#define FUSE_CTRL_STAT_DEFAULT (0x00000000U)
#define FUSE_CTRL_STAT_RD_MASK (0xffffffffU)
#define FUSE_CTRL_STAT_WR_MASK (0x80000000U)


///< Fuse hardware state machine is currently busy performing an Fuse operation
#define FUSE_CTRL_STAT_HWBUSY_BF_OFF ( 0)
#define FUSE_CTRL_STAT_HWBUSY_BF_WID ( 1)
#define FUSE_CTRL_STAT_HWBUSY_BF_MSK (0x00000001)
#define FUSE_CTRL_STAT_HWBUSY_BF_DEF (0x00000000)

///< This bit is used to indicate that the fuse sensing process has completed.
///< Reflects the value of the output port (fuse_sense_done).
#define FUSE_CTRL_STAT_FUSESENSEDONE_BF_OFF ( 1)
#define FUSE_CTRL_STAT_FUSESENSEDONE_BF_WID ( 1)
#define FUSE_CTRL_STAT_FUSESENSEDONE_BF_MSK (0x00000002)
#define FUSE_CTRL_STAT_FUSESENSEDONE_BF_DEF (0x00000000)

///< During fuse sensing, the fuse controller checks each fuse data row
///< if it contains all 0 or not.  At the end of fuse sensing, this bit
///< indicates if all fuse data rows are 0 or not.
#define FUSE_CTRL_STAT_FUSEHIPALLZERO_BF_OFF ( 2)
#define FUSE_CTRL_STAT_FUSEHIPALLZERO_BF_WID ( 1)
#define FUSE_CTRL_STAT_FUSEHIPALLZERO_BF_MSK (0x00000004)
#define FUSE_CTRL_STAT_FUSEHIPALLZERO_BF_DEF (0x00000000)

///< At the end of fuse sensing, if any error occurred, this bit will be
///< set.
#define FUSE_CTRL_STAT_FUSESENSEERR_BF_OFF ( 3)
#define FUSE_CTRL_STAT_FUSESENSEERR_BF_WID ( 1)
#define FUSE_CTRL_STAT_FUSESENSEERR_BF_MSK (0x00000008)
#define FUSE_CTRL_STAT_FUSESENSEERR_BF_DEF (0x00000000)

///< The value of the input port, dfx_agg_policy[3:0]. 4b0000 : Functionality
///< Locked   (GREEN) 4b0010 : Security Unlocked       (RED 2) 4b0100 :
///< Intel Unlocked            (RED 4)
#define FUSE_CTRL_STAT_DFX_POLICY_BF_OFF ( 4)
#define FUSE_CTRL_STAT_DFX_POLICY_BF_WID ( 4)
#define FUSE_CTRL_STAT_DFX_POLICY_BF_MSK (0x000000F0)
#define FUSE_CTRL_STAT_DFX_POLICY_BF_DEF (0x00000000)

///< 3b000 : IDLE, No Command Requested 3b001 : Command is currently being
///< Executed 3b010 : Command requested, but dropped as the HW controller
///< was currently processing another request. 3b011 : Command requested,
///< but dropped as the command requested is not valid and is one of the
///< Reserved commands. 3b100 : Command requested, but dropped as the command
///< requested is not valid in the current  Secure Policy. 3b101 : Command
///< Executed, but dropped as the specified address was not valid. 3b110
///< : Command Executed, but completed with errors.  Check bits [16:14]
///< and [13:11] for the reason. 3b111 : Command Executed, completed successfully
#define FUSE_CTRL_STAT_CMDSTAT_BF_OFF ( 8)
#define FUSE_CTRL_STAT_CMDSTAT_BF_WID ( 3)
#define FUSE_CTRL_STAT_CMDSTAT_BF_MSK (0x00000700)
#define FUSE_CTRL_STAT_CMDSTAT_BF_DEF (0x00000000)

///< 3b000 : All addresses are valid 3b001 : Module Address is invalid.
///< The module address specified in the Fuse Address  register contains
///< a module that does not exist on this SoC. 3b010 : Row Address is invalid.
///< The row address specified in either the Fuse Address  or Fuse Address
///< (Fuse Repair) registers contains a logical row address that does not
///< exist on this SoC.  This can only happen if the Module contains a
///< 4K Fuse HIP and the address specified is >63. 3b011 : Jason TBD to
///< add redundancy error 3b100 : Reserved 3b101 : Reserved 3b110 : Reserved
///< 3b111 : Reserved
#define FUSE_CTRL_STAT_ADDRSTAT_BF_OFF (11)
#define FUSE_CTRL_STAT_ADDRSTAT_BF_WID ( 3)
#define FUSE_CTRL_STAT_ADDRSTAT_BF_MSK (0x00003800)
#define FUSE_CTRL_STAT_ADDRSTAT_BF_DEF (0x00000000)

///< 3b000 : No errors 3b001 : Fuse HIP Write Security failed.  An attempt
///< was made to perform a Fuse HIP Write, via APB or JTAG, however the
///< access controls prohibited the write.  3b010 : Fuse HIP Read Security
///< failed.  An attempt was made to perform a Fuse HIP Read, via APB or
///< JTAG, however the access controls are preventing the read.  The data
///< in the Fuse Data  is not valid. 3b011 : Shadow Register Write Security
///< failed.  An attempt was made to perform a Shadow Register Write, via
///< APB or JTAG, however the access controls prohibited the write. 3b100
///< : Shadow Register Read Security failed.  An attempt was made to perform
///< a Shadow Register Read, via APB or JTAG, however the access controls
///< are preventing the read.  The data in the Fuse Data  is not valid.
///< 3b101 : Reserved 3b110 : Reserved, not used with Intel Fuse HIPs 3b111
///< : Address Error.  An attempt was made to access an address that does
///< not exist.
#define FUSE_CTRL_STAT_CMDERR_BF_OFF (14)
#define FUSE_CTRL_STAT_CMDERR_BF_WID ( 3)
#define FUSE_CTRL_STAT_CMDERR_BF_MSK (0x0001C000)
#define FUSE_CTRL_STAT_CMDERR_BF_DEF (0x00000000)

///< This field reflects the input port fuse_sort_only_bumps[2:0].
#define FUSE_CTRL_STAT_SORTONLYBUMPS_BF_OFF (17)
#define FUSE_CTRL_STAT_SORTONLYBUMPS_BF_WID ( 3)
#define FUSE_CTRL_STAT_SORTONLYBUMPS_BF_MSK (0x000E0000)
#define FUSE_CTRL_STAT_SORTONLYBUMPS_BF_DEF (0x00000000)

///< 7 = Over Voltage 6 = Under Voltage 5 = Reserved (Temperature) 4 =
///< Canary Error (Sense Amp) 3 = Reserved (Frequency) 2 = Module Address
///< Out of Range 1 = Array Address Out of Range 0 = Row Address Out of
///< Range Whenever an attack occurs, this field can be used to determine
///< which attack(s) occurred.
#define FUSE_CTRL_STAT_ATTACK_BF_OFF (20)
#define FUSE_CTRL_STAT_ATTACK_BF_WID ( 8)
#define FUSE_CTRL_STAT_ATTACK_BF_MSK (0x0FF00000)
#define FUSE_CTRL_STAT_ATTACK_BF_DEF (0x00000000)

///< This field reflects the input port a0_debug_strap.
#define FUSE_CTRL_STAT_A0DBGSTRAP_BF_OFF (28)
#define FUSE_CTRL_STAT_A0DBGSTRAP_BF_WID ( 1)
#define FUSE_CTRL_STAT_A0DBGSTRAP_BF_MSK (0x10000000)
#define FUSE_CTRL_STAT_A0DBGSTRAP_BF_DEF (0x00000000)

///< Reserved
#define FUSE_CTRL_STAT_RESERVED_30_29_BF_OFF (29)
#define FUSE_CTRL_STAT_RESERVED_30_29_BF_WID ( 2)
#define FUSE_CTRL_STAT_RESERVED_30_29_BF_MSK (0x60000000)
#define FUSE_CTRL_STAT_RESERVED_30_29_BF_DEF (0x00000000)

///< A write to this bit causes the Fuse Status register to be cleared.
///< There are a few bits that are not clearable, see the note in the individual
///< bits for details.
#define FUSE_CTRL_STAT_STATCLR_BF_OFF (31)
#define FUSE_CTRL_STAT_STATCLR_BF_WID ( 1)
#define FUSE_CTRL_STAT_STATCLR_BF_MSK (0x80000000)
#define FUSE_CTRL_STAT_STATCLR_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_HIP_ECC_STATUS_REG register description at address offset 0x104
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_HIP_ECC_STATUS_REG
  * FUSE HIP Status Register
  */

typedef union {
  struct {
    uint32_t CORERR1 : 16;
    ///< This field is updated after power on fuse sensing or re-sensing completes.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CORERR2 : 14;
    ///< This field is updated after power on fuse sensing or re-sensing completes.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t NONCORERR : 1;
    ///< This field indicates that 3+ bit error occurred, which is detectable
    ///< only, and not corrected. This is indicated by the output indicator
    ///< bit (due) being set, or more than 1 of the output indicator bits being
    ///< set at the same time (noerror, ce_one, ce_two, due).   This is a catastrophic
    ///< error for the fuse controller and will result in a Fuse Sense Error.
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint32_t CLEAR : 1;
    ///< This register consists of Read Only bits providing current statistics
    ///< of the Fuse HIP ECC decoding logic during fuse sensing.   This bit
    ///< is used to clear the statistics explicitly if needed.
    ///< AccessType="RW/1C" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_hip_ecc_stat_reg_t;

#define FUSE_CTRL_HIP_ECC_STAT_DEFAULT (0x00000000U)
#define FUSE_CTRL_HIP_ECC_STAT_RD_MASK (0xffffffffU)
#define FUSE_CTRL_HIP_ECC_STAT_WR_MASK (0x80000000U)


///< This field is updated after power on fuse sensing or re-sensing completes.
#define FUSE_CTRL_HIP_ECC_STAT_CORERR1_BF_OFF ( 0)
#define FUSE_CTRL_HIP_ECC_STAT_CORERR1_BF_WID (16)
#define FUSE_CTRL_HIP_ECC_STAT_CORERR1_BF_MSK (0x0000FFFF)
#define FUSE_CTRL_HIP_ECC_STAT_CORERR1_BF_DEF (0x00000000)

///< This field is updated after power on fuse sensing or re-sensing completes.
#define FUSE_CTRL_HIP_ECC_STAT_CORERR2_BF_OFF (16)
#define FUSE_CTRL_HIP_ECC_STAT_CORERR2_BF_WID (14)
#define FUSE_CTRL_HIP_ECC_STAT_CORERR2_BF_MSK (0x3FFF0000)
#define FUSE_CTRL_HIP_ECC_STAT_CORERR2_BF_DEF (0x00000000)

///< This field indicates that 3+ bit error occurred, which is detectable
///< only, and not corrected. This is indicated by the output indicator
///< bit (due) being set, or more than 1 of the output indicator bits being
///< set at the same time (noerror, ce_one, ce_two, due).   This is a catastrophic
///< error for the fuse controller and will result in a Fuse Sense Error.
#define FUSE_CTRL_HIP_ECC_STAT_NONCORERR_BF_OFF (30)
#define FUSE_CTRL_HIP_ECC_STAT_NONCORERR_BF_WID ( 1)
#define FUSE_CTRL_HIP_ECC_STAT_NONCORERR_BF_MSK (0x40000000)
#define FUSE_CTRL_HIP_ECC_STAT_NONCORERR_BF_DEF (0x00000000)

///< This register consists of Read Only bits providing current statistics
///< of the Fuse HIP ECC decoding logic during fuse sensing.   This bit
///< is used to clear the statistics explicitly if needed.
#define FUSE_CTRL_HIP_ECC_STAT_CLR_BF_OFF (31)
#define FUSE_CTRL_HIP_ECC_STAT_CLR_BF_WID ( 1)
#define FUSE_CTRL_HIP_ECC_STAT_CLR_BF_MSK (0x80000000)
#define FUSE_CTRL_HIP_ECC_STAT_CLR_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_DEBUG_CONTROL_REG register description at address offset 0x200
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_DEBUG_CONTROL_REG
  * Fuse Debug Control Register
  */

typedef union {
  struct {
    uint32_t DEBUGMUXCNTRL : 5;
    ///< Selects which of the 32 input lanes to be routed to the 8-bit output
    ///< Debug Mux.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t POLICYGROUP : 2;
    ///< Selects which group of signals the lane is to be selected from. 00
    ///< security locked 01 security unlocked 10 inter locked 11 reserved
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 25;
    ///< RESERVED
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_dbg_ctrl_reg_t;

#define FUSE_CTRL_DBG_CTRL_DEFAULT (0x00000000U)
#define FUSE_CTRL_DBG_CTRL_RD_MASK (0xffffffffU)
#define FUSE_CTRL_DBG_CTRL_WR_MASK (0x0000007fU)


///< Selects which of the 32 input lanes to be routed to the 8-bit output
///< Debug Mux.
#define FUSE_CTRL_DBG_CTRL_DBGMUXCNTRL_BF_OFF ( 0)
#define FUSE_CTRL_DBG_CTRL_DBGMUXCNTRL_BF_WID ( 5)
#define FUSE_CTRL_DBG_CTRL_DBGMUXCNTRL_BF_MSK (0x0000001F)
#define FUSE_CTRL_DBG_CTRL_DBGMUXCNTRL_BF_DEF (0x00000000)

///< Selects which group of signals the lane is to be selected from. 00
///< security locked 01 security unlocked 10 inter locked 11 reserved
#define FUSE_CTRL_DBG_CTRL_POLICYGRP_BF_OFF ( 5)
#define FUSE_CTRL_DBG_CTRL_POLICYGRP_BF_WID ( 2)
#define FUSE_CTRL_DBG_CTRL_POLICYGRP_BF_MSK (0x00000060)
#define FUSE_CTRL_DBG_CTRL_POLICYGRP_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_DBG_CTRL_RESERVED_31_7_BF_OFF ( 7)
#define FUSE_CTRL_DBG_CTRL_RESERVED_31_7_BF_WID (25)
#define FUSE_CTRL_DBG_CTRL_RESERVED_31_7_BF_MSK (0xFFFFFF80)
#define FUSE_CTRL_DBG_CTRL_RESERVED_31_7_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_HIP_REGISTERS_ADDRESS_REG register description at address offset 0x300
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_HIP_REGISTERS_ADDRESS_REG
  * Fuse HIP Registers Address
  */

typedef union {
  struct {
    uint32_t REGISTER : 7;
    ///< The fuse controller supports up to 128 modules
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t IPNUMBER : 5;
    ///< The fuse controller supports up to 128 modules
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t ARRAYADDRESS : 3;
    ///< The fuse controller supports up to 8 arrays per module.  This field
    ///< specifies the array address to program or fuse override.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t MODULEADDRESS : 7;
    ///< The fuse controller supports up to 128 modules.  This field specifies
    ///< the module address to program or fuse override.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t  : 9;
    ///< RESERVED
    ///< AccessType="RO" BitOffset="22" ResetValue="0x0"
    uint32_t ARRAYTYPE : 1;
    ///< Must be specified to indicate if the Fuse HIP address specified is
    ///< target for an Intel HVM array or an OEM IFP Array.  It indicates to
    ///< the Fuse Controller which set of address and data registers to communicate
    ///< with.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_hip_reg_t;

#define FUSE_CTRL_HIP_DEFAULT (0x00000000U)
#define FUSE_CTRL_HIP_RD_MASK (0xffffffffU)
#define FUSE_CTRL_HIP_WR_MASK (0x803fffffU)


///< The fuse controller supports up to 128 modules
#define FUSE_CTRL_HIP_REGISTER_BF_OFF ( 0)
#define FUSE_CTRL_HIP_REGISTER_BF_WID ( 7)
#define FUSE_CTRL_HIP_REGISTER_BF_MSK (0x0000007F)
#define FUSE_CTRL_HIP_REGISTER_BF_DEF (0x00000000)

///< The fuse controller supports up to 128 modules
#define FUSE_CTRL_HIP_IPNUMBER_BF_OFF ( 7)
#define FUSE_CTRL_HIP_IPNUMBER_BF_WID ( 5)
#define FUSE_CTRL_HIP_IPNUMBER_BF_MSK (0x00000F80)
#define FUSE_CTRL_HIP_IPNUMBER_BF_DEF (0x00000000)

///< The fuse controller supports up to 8 arrays per module.  This field
///< specifies the array address to program or fuse override.
#define FUSE_CTRL_HIP_ARRAYADDR_BF_OFF (12)
#define FUSE_CTRL_HIP_ARRAYADDR_BF_WID ( 3)
#define FUSE_CTRL_HIP_ARRAYADDR_BF_MSK (0x00007000)
#define FUSE_CTRL_HIP_ARRAYADDR_BF_DEF (0x00000000)

///< The fuse controller supports up to 128 modules.  This field specifies
///< the module address to program or fuse override.
#define FUSE_CTRL_HIP_MODULEADDR_BF_OFF (15)
#define FUSE_CTRL_HIP_MODULEADDR_BF_WID ( 7)
#define FUSE_CTRL_HIP_MODULEADDR_BF_MSK (0x003F8000)
#define FUSE_CTRL_HIP_MODULEADDR_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_HIP_RESERVED_30_22_BF_OFF (22)
#define FUSE_CTRL_HIP_RESERVED_30_22_BF_WID ( 9)
#define FUSE_CTRL_HIP_RESERVED_30_22_BF_MSK (0x7FC00000)
#define FUSE_CTRL_HIP_RESERVED_30_22_BF_DEF (0x00000000)

///< Must be specified to indicate if the Fuse HIP address specified is
///< target for an Intel HVM array or an OEM IFP Array.  It indicates to
///< the Fuse Controller which set of address and data registers to communicate
///< with.
#define FUSE_CTRL_HIP_ARRAYTYPE_BF_OFF (31)
#define FUSE_CTRL_HIP_ARRAYTYPE_BF_WID ( 1)
#define FUSE_CTRL_HIP_ARRAYTYPE_BF_MSK (0x80000000)
#define FUSE_CTRL_HIP_ARRAYTYPE_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_HIP_REGISTER_DATA_REG register description at address offset 0x304
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_HIP_REGISTER_DATA_REG
  * Fuse HIP REGISTERS Data Register
  */

typedef union {
  struct {
    uint32_t HIPDATA : 32;
    ///< Fuse HIP uses indirect addressing to access all their registers. This
    ///< register is used together with the Fuse HIP Address register.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_hip_register_data_reg_t;

#define FUSE_CTRL_HIP_REGISTER_DATA_DEFAULT (0x00000000U)
#define FUSE_CTRL_HIP_REGISTER_DATA_RD_MASK (0xffffffffU)
#define FUSE_CTRL_HIP_REGISTER_DATA_WR_MASK (0xffffffffU)


///< Fuse HIP uses indirect addressing to access all their registers. This
///< register is used together with the Fuse HIP Address register.
#define FUSE_CTRL_HIP_REGISTER_DATA_HIPDATA_BF_OFF ( 0)
#define FUSE_CTRL_HIP_REGISTER_DATA_HIPDATA_BF_WID (32)
#define FUSE_CTRL_HIP_REGISTER_DATA_HIPDATA_BF_MSK (0xFFFFFFFF)
#define FUSE_CTRL_HIP_REGISTER_DATA_HIPDATA_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_FUSE_HIP_REGISTERS_CONTROL_REG register description at address offset 0x308
  *
  * Register default value:        0x00000000
  * Register full path in IP: fuse_ctrl/APB_REG/FUSE_HIP_REGISTERS_CONTROL_REG
  * Fuse HIP Registers Control Register
  */

typedef union {
  struct {
    uint32_t TRANSTYPE : 1;
    ///< Used to indicate if the transaction type to access the Fuse HIP Registers.
    ///< 0 = Read Fuse HIP Register 1 = Write Fuse HIP Register
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< RESERVED
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_hip_ctrl_reg_t;

#define FUSE_CTRL_HIP_CTRL_DEFAULT (0x00000000U)
#define FUSE_CTRL_HIP_CTRL_RD_MASK (0xffffffffU)
#define FUSE_CTRL_HIP_CTRL_WR_MASK (0x00000001U)


///< Used to indicate if the transaction type to access the Fuse HIP Registers.
///< 0 = Read Fuse HIP Register 1 = Write Fuse HIP Register
#define FUSE_CTRL_HIP_CTRL_TRANSTYPE_BF_OFF ( 0)
#define FUSE_CTRL_HIP_CTRL_TRANSTYPE_BF_WID ( 1)
#define FUSE_CTRL_HIP_CTRL_TRANSTYPE_BF_MSK (0x00000001)
#define FUSE_CTRL_HIP_CTRL_TRANSTYPE_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_HIP_CTRL_RESERVED_31_1_BF_OFF ( 1)
#define FUSE_CTRL_HIP_CTRL_RESERVED_31_1_BF_WID (31)
#define FUSE_CTRL_HIP_CTRL_RESERVED_31_1_BF_MSK (0xFFFFFFFE)
#define FUSE_CTRL_HIP_CTRL_RESERVED_31_1_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_DRNG_ES_CONFIG0_REG register description at address offset 0x400
  *
  * Register default value:        0x00001400
  * Register full path in IP: fuse_ctrl/APB_REG/DRNG_ES_CONFIG0_REG
  * DRNG ES Config 0 register
  */

typedef union {
  struct {
    uint32_t ES_MODE : 8;
    ///< Reserved for future use by the RNG-ES
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LOOPDELAY : 8;
    ///< These bits adjust the oscillation frequency of the ES and the internal
    ///< clock pulse width for the switched capacitor filter. They are intended
    ///< for process centering only and should not need to be changed. [15:14]:
    ///< Reserved                              (00) [13:11]: Stepper Pulse
    ///< Clock Adjust    (010) [10: 8]: ES Frequency Adjust              (100)
    ///< AccessType="RW" BitOffset="8" ResetValue="0x14"
    uint32_t STEPSIZE_P : 8;
    ///< TBD, need description from RNG-ES team
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t STEPSIZE_N : 8;
    ///< RESERVED
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_drng_es_cfg0_reg_t;

#define FUSE_CTRL_DRNG_ES_CFG0_DEFAULT (0x00001400U)
#define FUSE_CTRL_DRNG_ES_CFG0_RD_MASK (0xffffffffU)
#define FUSE_CTRL_DRNG_ES_CFG0_WR_MASK (0xffffffffU)


///< Reserved for future use by the RNG-ES
#define FUSE_CTRL_DRNG_ES_CFG0_ES_MODE_BF_OFF ( 0)
#define FUSE_CTRL_DRNG_ES_CFG0_ES_MODE_BF_WID ( 8)
#define FUSE_CTRL_DRNG_ES_CFG0_ES_MODE_BF_MSK (0x000000FF)
#define FUSE_CTRL_DRNG_ES_CFG0_ES_MODE_BF_DEF (0x00000000)

///< These bits adjust the oscillation frequency of the ES and the internal
///< clock pulse width for the switched capacitor filter. They are intended
///< for process centering only and should not need to be changed. [15:14]:
///< Reserved                              (00) [13:11]: Stepper Pulse
///< Clock Adjust    (010) [10: 8]: ES Frequency Adjust              (100)
#define FUSE_CTRL_DRNG_ES_CFG0_LOOPDELAY_BF_OFF ( 8)
#define FUSE_CTRL_DRNG_ES_CFG0_LOOPDELAY_BF_WID ( 8)
#define FUSE_CTRL_DRNG_ES_CFG0_LOOPDELAY_BF_MSK (0x0000FF00)
#define FUSE_CTRL_DRNG_ES_CFG0_LOOPDELAY_BF_DEF (0x00001400)

///< TBD, need description from RNG-ES team
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_P_BF_OFF (16)
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_P_BF_WID ( 8)
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_P_BF_MSK (0x00FF0000)
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_P_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_N_BF_OFF (24)
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_N_BF_WID ( 8)
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_N_BF_MSK (0xFF000000)
#define FUSE_CTRL_DRNG_ES_CFG0_STEPSIZE_N_BF_DEF (0x00000000)


/** @brief FUSE_CTRL_APB_REG_DRNG_ES_CONFIG1_REG register description at address offset 0x408
  *
  * Register default value:        0x00000007
  * Register full path in IP: fuse_ctrl/APB_REG/DRNG_ES_CONFIG1_REG
  * DRNG ES Config 1 register
  */

typedef union {
  struct {
    uint32_t ES_CTRL : 6;
    ///< Digitizer configuration [5:4]: Reserved [3]: Deterministic Test Mode
    ///< (bit 1 of 2) [2]: Enable digitizer recirculate [1]: Enable digitizer
    ///< divide by 4 [0]: Enable digitizer XOR  [3] Deterministic test mode
    ///< for post-Si debug use only. To enable, bit [3] must be set in conjunction
    ///< with idfx [2]. Will replace ES random bitstream with repeating 000111
    ///< output before digitizer. [2:0] Value depends on usage and DRNG version:
    ///< 3'b111: Digitizer included as SP800-90B Non-Vetted Conditioner (NVC).
    ///< Output data decimated by 4x 3'b010: No NVC. Output data decimated
    ///< by 4x 3'b000: No NVC. Output data full rate
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7"
    uint32_t RESERVED : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t DFX_MODE : 4;
    ///< Used to configure the Design for Excellence Mode of the Entropy Source
    ///< (ES). [11]: Reserved [10]: Deterministic Test Mode (bit 2 of 2) [9:8]
    ///< : Reserved Deterministic test mode for post-Si debug use only. To
    ///< enable, bit [10] must be set in conjunction with bit [3]. Will replace
    ///< ES random bitstream with repeating 000111 output before digitizer.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DEBUG_EN : 1;
    ///< When asserted, enables the debug bus out from the ES.  Observed on
    ///< the input port : rng_es_dfx_obs_data[15:0]
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t  : 19;
    ///< RESERVED
    ///< AccessType="RO" BitOffset="13" ResetValue="0x0"
  } ;
  uint32_t value;
} fuse_ctrl_drng_es_cfg1_reg_t;

#define FUSE_CTRL_DRNG_ES_CFG1_DEFAULT (0x00000007U)
#define FUSE_CTRL_DRNG_ES_CFG1_RD_MASK (0xffffffffU)
#define FUSE_CTRL_DRNG_ES_CFG1_WR_MASK (0x00001f3fU)


///< Digitizer configuration [5:4]: Reserved [3]: Deterministic Test Mode
///< (bit 1 of 2) [2]: Enable digitizer recirculate [1]: Enable digitizer
///< divide by 4 [0]: Enable digitizer XOR  [3] Deterministic test mode
///< for post-Si debug use only. To enable, bit [3] must be set in conjunction
///< with idfx [2]. Will replace ES random bitstream with repeating 000111
///< output before digitizer. [2:0] Value depends on usage and DRNG version:
///< 3'b111: Digitizer included as SP800-90B Non-Vetted Conditioner (NVC).
///< Output data decimated by 4x 3'b010: No NVC. Output data decimated
///< by 4x 3'b000: No NVC. Output data full rate
#define FUSE_CTRL_DRNG_ES_CFG1_ES_CTRL_BF_OFF ( 0)
#define FUSE_CTRL_DRNG_ES_CFG1_ES_CTRL_BF_WID ( 6)
#define FUSE_CTRL_DRNG_ES_CFG1_ES_CTRL_BF_MSK (0x0000003F)
#define FUSE_CTRL_DRNG_ES_CFG1_ES_CTRL_BF_DEF (0x00000007)

///< Reserved
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_BF_OFF ( 6)
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_BF_WID ( 2)
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_BF_MSK (0x000000C0)
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_BF_DEF (0x00000000)

///< Used to configure the Design for Excellence Mode of the Entropy Source
///< (ES). [11]: Reserved [10]: Deterministic Test Mode (bit 2 of 2) [9:8]
///< : Reserved Deterministic test mode for post-Si debug use only. To
///< enable, bit [10] must be set in conjunction with bit [3]. Will replace
///< ES random bitstream with repeating 000111 output before digitizer.
#define FUSE_CTRL_DRNG_ES_CFG1_DFX_MODE_BF_OFF ( 8)
#define FUSE_CTRL_DRNG_ES_CFG1_DFX_MODE_BF_WID ( 4)
#define FUSE_CTRL_DRNG_ES_CFG1_DFX_MODE_BF_MSK (0x00000F00)
#define FUSE_CTRL_DRNG_ES_CFG1_DFX_MODE_BF_DEF (0x00000000)

///< When asserted, enables the debug bus out from the ES.  Observed on
///< the input port : rng_es_dfx_obs_data[15:0]
#define FUSE_CTRL_DRNG_ES_CFG1_DBG_EN_BF_OFF (12)
#define FUSE_CTRL_DRNG_ES_CFG1_DBG_EN_BF_WID ( 1)
#define FUSE_CTRL_DRNG_ES_CFG1_DBG_EN_BF_MSK (0x00001000)
#define FUSE_CTRL_DRNG_ES_CFG1_DBG_EN_BF_DEF (0x00000000)

///< RESERVED
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_31_13_BF_OFF (13)
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_31_13_BF_WID (19)
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_31_13_BF_MSK (0xFFFFE000)
#define FUSE_CTRL_DRNG_ES_CFG1_RESERVED_31_13_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define FUSE_CTRL_REG ((fuse_ctrl_reg_t*) FUSE_CTRL_ADR)
#define FUSE_CTRL_CMD_REG ((fuse_ctrl_cmd_reg_t*) FUSE_CTRL_CMD_ADR)
#define FUSE_CTRL_CNTERS_REG ((fuse_ctrl_cnters_reg_t*) FUSE_CTRL_CNTERS_ADR)
#define FUSE_CTRL_DATA_REG ((fuse_ctrl_data_reg_t*) FUSE_CTRL_DATA_ADR)
#define FUSE_CTRL_ECC_DATA_REG ((fuse_ctrl_ecc_data_reg_t*) FUSE_CTRL_ECC_DATA_ADR)
#define FUSE_CTRL_STAT_REG ((fuse_ctrl_stat_reg_t*) FUSE_CTRL_STAT_ADR)
#define FUSE_CTRL_HIP_ECC_STAT_REG ((fuse_ctrl_hip_ecc_stat_reg_t*) FUSE_CTRL_HIP_ECC_STAT_ADR)
#define FUSE_CTRL_DBG_CTRL_REG ((fuse_ctrl_dbg_ctrl_reg_t*) FUSE_CTRL_DBG_CTRL_ADR)
#define FUSE_CTRL_HIP_REG ((fuse_ctrl_hip_reg_t*) FUSE_CTRL_HIP_ADR)
#define FUSE_CTRL_HIP_REGISTER_DATA_REG ((fuse_ctrl_hip_register_data_reg_t*) FUSE_CTRL_HIP_REGISTER_DATA_ADR)
#define FUSE_CTRL_HIP_CTRL_REG ((fuse_ctrl_hip_ctrl_reg_t*) FUSE_CTRL_HIP_CTRL_ADR)
#define FUSE_CTRL_DRNG_ES_CFG0_REG ((fuse_ctrl_drng_es_cfg0_reg_t*) FUSE_CTRL_DRNG_ES_CFG0_ADR)
#define FUSE_CTRL_DRNG_ES_CFG1_REG ((fuse_ctrl_drng_es_cfg1_reg_t*) FUSE_CTRL_DRNG_ES_CFG1_ADR)

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    fuse_ctrl_reg_t FUSE; /*< Address offset = 0x0 */
    fuse_ctrl_cmd_reg_t FUSE_CMD; /*< Address offset = 0x4 */
    fuse_ctrl_cnters_reg_t FUSE_CNTERS; /*< Address offset = 0x8 */
    const uint8_t        reservedArea0 [20];  /*< Address offset = 0xc */
    fuse_ctrl_data_reg_t FUSE_DATA; /*< Address offset = 0x20 */
    fuse_ctrl_ecc_data_reg_t FUSE_ECC_DATA; /*< Address offset = 0x24 */
    const uint8_t        reservedArea1 [216]; /*< Address offset = 0x28 */
    fuse_ctrl_stat_reg_t FUSE_STAT; /*< Address offset = 0x100 */
    fuse_ctrl_hip_ecc_stat_reg_t FUSE_HIP_ECC_STAT; /*< Address offset = 0x104 */
    const uint8_t        reservedArea2 [248]; /*< Address offset = 0x108 */
    fuse_ctrl_dbg_ctrl_reg_t FUSE_DBG_CTRL; /*< Address offset = 0x200 */
    const uint8_t        reservedArea3 [252]; /*< Address offset = 0x204 */
    fuse_ctrl_hip_reg_t FUSE_HIP; /*< Address offset = 0x300 */
    fuse_ctrl_hip_register_data_reg_t FUSE_HIP_REGISTER_DATA; /*< Address offset = 0x304 */
    fuse_ctrl_hip_ctrl_reg_t FUSE_HIP_CTRL; /*< Address offset = 0x308 */
    const uint8_t        reservedArea4 [244]; /*< Address offset = 0x30c */
    fuse_ctrl_drng_es_cfg0_reg_t DRNG_ES_CFG0; /*< Address offset = 0x400 */
    const uint8_t        reservedArea5 [4];   /*< Address offset = 0x404 */
    fuse_ctrl_drng_es_cfg1_reg_t DRNG_ES_CFG1; /*< Address offset = 0x408 */
} fuse_ctrl_t;     // size: 0x0034

// AddressSpace struct pointer
//
#define SYSCON_IFS_FC_APB  ((fuse_ctrl_t*) SYSCON_IFS_FC_APB_BASE)

// ******************************************* /Address Space

#endif      // _FUSE_CTRL_H_

