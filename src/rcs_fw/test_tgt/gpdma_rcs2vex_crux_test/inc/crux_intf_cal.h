#ifndef _CRUX_INTF_H_
#define _CRUX_INTF_H_

#ifndef UINT64_T_DEFINED
#define UINT64_T_DEFINED
 
//typedef unsigned __int64 uint64_t 
 
#endif

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
//    Soc ver:
//        abc_soc-srvrgen4-0p6_emul-23ww51a
//
//
//    Tool Version:
//        23.38.4p2
//
//    Generation Date:
//        2024-01-02
//
// ******************************************************************************

// ******************************************* Base address macros

// Stepping: A0
//

#define RCS_CRUX_INTF_BASE    0x00278000

// ******************************************* /Base address macros


// ******************************************* Register offset macros

// Stepping: A0
//
#define CRUX_INTF_CRUX_WDATA0_R_OFFSET ( 0x00000000U )
#define CRUX_INTF_CRUX_WDATA1_R_OFFSET ( 0x00000010U )
#define CRUX_INTF_CRUX_WDATA2_R_OFFSET ( 0x00000020U )
#define CRUX_INTF_CRUX_WDATA3_R_OFFSET ( 0x00000030U )
#define CRUX_INTF_CRUX_WROUTING_DATA_R_OFFSET ( 0x00000040U )
#define CRUX_INTF_CRUX_TX_PUSH_OFFSET ( 0x00000050U )
#define CRUX_INTF_CRUX_TX_FIFO_WM_OFFSET ( 0x00000060U )
#define CRUX_INTF_CRUX_INTF_MASKS_OFFSET ( 0x00000070U )
#define CRUX_INTF_CRUX_FIFO_SW_RST_OFFSET ( 0x00000080U )
#define CRUX_INTF_CRUX_RX_POP_OFFSET ( 0x00000090U )
#define CRUX_INTF_CRUX_RDATA0_R_OFFSET ( 0x000000a0U )
#define CRUX_INTF_CRUX_RDATA1_R_OFFSET ( 0x000000b0U )
#define CRUX_INTF_CRUX_RDATA2_R_OFFSET ( 0x000000c0U )
#define CRUX_INTF_CRUX_RDATA3_R_OFFSET ( 0x000000d0U )
#define CRUX_INTF_CRUX_RROUTING_DATA_R_OFFSET ( 0x000000e0U )
#define CRUX_INTF_CRUX_FIFO_STATUS_OFFSET ( 0x000000f0U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
// Stepping: A0
//
#define CRUX_INTF_CRUX_WDATA0_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_WDATA0_R_OFFSET ) ))
#define CRUX_INTF_CRUX_WDATA1_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_WDATA1_R_OFFSET ) ))
#define CRUX_INTF_CRUX_WDATA2_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_WDATA2_R_OFFSET ) ))
#define CRUX_INTF_CRUX_WDATA3_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_WDATA3_R_OFFSET ) ))
#define CRUX_INTF_CRUX_WROUTING_DATA_R_ADR (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_WROUTING_DATA_R_OFFSET ) ))
#define CRUX_INTF_CRUX_TX_PUSH_ADR   (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_TX_PUSH_OFFSET ) ))
#define CRUX_INTF_CRUX_TX_FIFO_WM_ADR (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_TX_FIFO_WM_OFFSET ) ))
#define CRUX_INTF_CRUX_INTF_MASKS_ADR (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_INTF_MASKS_OFFSET ) ))
#define CRUX_INTF_CRUX_FIFO_SW_RST_ADR (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_FIFO_SW_RST_OFFSET ) ))
#define CRUX_INTF_CRUX_RX_POP_ADR    (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_RX_POP_OFFSET ) ))
#define CRUX_INTF_CRUX_RDATA0_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_RDATA0_R_OFFSET ) ))
#define CRUX_INTF_CRUX_RDATA1_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_RDATA1_R_OFFSET ) ))
#define CRUX_INTF_CRUX_RDATA2_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_RDATA2_R_OFFSET ) ))
#define CRUX_INTF_CRUX_RDATA3_R_ADR  (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_RDATA3_R_OFFSET ) ))
#define CRUX_INTF_CRUX_RROUTING_DATA_R_ADR (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_RROUTING_DATA_R_OFFSET ) ))
#define CRUX_INTF_CRUX_FIFO_STATUS_ADR (( ( RCS_CRUX_INTF_BASE ) + ( CRUX_INTF_CRUX_FIFO_STATUS_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief CRUX_INTF_REG_CRUX_WDATA0_R register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_WDATA0_r
  * Bits [127:0] of Crux Data word
  */

typedef union {
  struct {
    uint64_t DATA : 64;
    ///< 64 bits of 512 bit data word.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_wdata0_r_reg_t;

#define CRUX_INTF_CRUX_WDATA0_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_WDATA0_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_WDATA0_R_WR_MASK (0xffffffffffffffffffffffffffffffffULL)


///< 64 bits of 512 bit data word.
#define CRUX_INTF_CRUX_WDATA0_R_DATA_BF_OFF ( 0)
#define CRUX_INTF_CRUX_WDATA0_R_DATA_BF_WID (64)
#define CRUX_INTF_CRUX_WDATA0_R_DATA_BF_MSK (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
#define CRUX_INTF_CRUX_WDATA0_R_DATA_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_WDATA1_R register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_WDATA1_r
  * Bits [255:64] of Crux Data word
  */

typedef union {
  struct {
    uint64_t DATA : 64;
    ///< 64 bits of a 512 bit data word.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_wdata1_r_reg_t;

#define CRUX_INTF_CRUX_WDATA1_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_WDATA1_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_WDATA1_R_WR_MASK (0xffffffffffffffffffffffffffffffffULL)


///< 64 bits of a 512 bit data word.
#define CRUX_INTF_CRUX_WDATA1_R_DATA_BF_OFF ( 0)
#define CRUX_INTF_CRUX_WDATA1_R_DATA_BF_WID (64)
#define CRUX_INTF_CRUX_WDATA1_R_DATA_BF_MSK (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
#define CRUX_INTF_CRUX_WDATA1_R_DATA_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_WDATA2_R register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_WDATA2_r
  * Bits [383:256] of Crux Data word
  */

typedef union {
  struct {
    uint64_t DATA : 64;
    ///< 64 bits of a 512 bit data word.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_wdata2_r_reg_t;

#define CRUX_INTF_CRUX_WDATA2_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_WDATA2_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_WDATA2_R_WR_MASK (0xffffffffffffffffffffffffffffffffULL)


///< 64 bits of a 512 bit data word.
#define CRUX_INTF_CRUX_WDATA2_R_DATA_BF_OFF ( 0)
#define CRUX_INTF_CRUX_WDATA2_R_DATA_BF_WID (64)
#define CRUX_INTF_CRUX_WDATA2_R_DATA_BF_MSK (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
#define CRUX_INTF_CRUX_WDATA2_R_DATA_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_WDATA3_R register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_WDATA3_r
  * Bits [511:384] of Crux Data word
  */

typedef union {
  struct {
    uint64_t DATA : 64;
    ///< 64 bits of a 512 bit data word.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_wdata3_r_reg_t;

#define CRUX_INTF_CRUX_WDATA3_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_WDATA3_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_WDATA3_R_WR_MASK (0xffffffffffffffffffffffffffffffffULL)


///< 64 bits of a 512 bit data word.
#define CRUX_INTF_CRUX_WDATA3_R_DATA_BF_OFF ( 0)
#define CRUX_INTF_CRUX_WDATA3_R_DATA_BF_WID (64)
#define CRUX_INTF_CRUX_WDATA3_R_DATA_BF_MSK (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
#define CRUX_INTF_CRUX_WDATA3_R_DATA_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_WROUTING_DATA_R register description at address offset 0x40
  *
  * Register default value:        0x004000C0
  * Register full path in IP: crux_intf/reg/CRUX_WROUTING_DATA_r
  * Routing data for the data.
  */

typedef union {
  struct {
    uint64_t FLIT_TYPE : 3;
    ///< The Type field indicates the number of valid bytes contained in the
    ///< streaming word format.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint64_t LEN : 3;
    ///< The Len field indicates the length of the packet (length is this value
    ///< + 1).  To gurrentee correct operation, in RCS, this should always
    ///< be set to 0 (indicating a one FLIT packet).  Otherwise packets from
    ///< the timestamp module might be intermixed.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint64_t EOP : 1;
    ///< EOP, this bit indicates if the FLIT is the last in a packet.  For
    ///< RCS traffic, all packets should be of len 1, so this should always
    ///< be set to 1.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint64_t SOP : 1;
    ///< SOP, this bit indicates if the FLIT is the first in a packet.  For
    ///< RCS traffic, all packets should be of len 1, so this should always
    ///< be set to 1.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint64_t INTF_ID : 3;
    ///< This is the interface ID associated with the packet.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint64_t HOST_ID : 11;
    ///< This is the Host ID associated with the packet.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint64_t BYPASS : 1;
    ///< Bypass mode.  This bit should always be set to 1, it indicates that
    ///< the routing data will be given directly to the common module and that
    ///< it does not need to calculate it.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x1"
    uint64_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint64_t ADDRESS : 26;
    ///< Address of the destination of the packet.
    ///< AccessType="RW" BitOffset="32" ResetValue="0x0"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="58" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_wrouting_data_r_reg_t;

#define CRUX_INTF_CRUX_WROUTING_DATA_R_DEFAULT (0x000000000000000000000000004000c0ULL)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_RD_MASK (0x000000000000000003ffffff007fffffULL)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_WR_MASK (0x000000000000000003ffffff007fffffULL)


///< The Type field indicates the number of valid bytes contained in the
///< streaming word format.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_FLIT_TYPE_BF_OFF ( 0)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_FLIT_TYPE_BF_WID ( 3)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_FLIT_TYPE_BF_MSK (0x00000007)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_FLIT_TYPE_BF_DEF (0x00000000)

///< The Len field indicates the length of the packet (length is this value
///< + 1).  To gurrentee correct operation, in RCS, this should always
///< be set to 0 (indicating a one FLIT packet).  Otherwise packets from
///< the timestamp module might be intermixed.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_LEN_BF_OFF ( 3)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_LEN_BF_WID ( 3)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_LEN_BF_MSK (0x00000038)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_LEN_BF_DEF (0x00000000)

///< EOP, this bit indicates if the FLIT is the last in a packet.  For
///< RCS traffic, all packets should be of len 1, so this should always
///< be set to 1.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_EOP_BF_OFF ( 6)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_EOP_BF_WID ( 1)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_EOP_BF_MSK (0x00000040)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_EOP_BF_DEF (0x00000040)

///< SOP, this bit indicates if the FLIT is the first in a packet.  For
///< RCS traffic, all packets should be of len 1, so this should always
///< be set to 1.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_SOP_BF_OFF ( 7)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_SOP_BF_WID ( 1)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_SOP_BF_MSK (0x00000080)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_SOP_BF_DEF (0x00000080)

///< This is the interface ID associated with the packet.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_INTF_ID_BF_OFF ( 8)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_INTF_ID_BF_WID ( 3)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_INTF_ID_BF_MSK (0x00000700)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_INTF_ID_BF_DEF (0x00000000)

///< This is the Host ID associated with the packet.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_HOST_ID_BF_OFF (11)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_HOST_ID_BF_WID (11)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_HOST_ID_BF_MSK (0x003FF800)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_HOST_ID_BF_DEF (0x00000000)

///< Bypass mode.  This bit should always be set to 1, it indicates that
///< the routing data will be given directly to the common module and that
///< it does not need to calculate it.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BYPASS_BF_OFF (22)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BYPASS_BF_WID ( 1)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BYPASS_BF_MSK (0x00400000)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BYPASS_BF_DEF (0x00400000)

///< Address of the destination of the packet.
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BF_OFF (32)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BF_WID (26)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BF_MSK (0x3FFFFFF00000000)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_TX_PUSH register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_TX_PUSH
  * Push tx data to a fifo.
  */

typedef union {
  struct {
    uint64_t PUSH : 1;
    ///< When this bit is set to 1, the contents of the above 5 registers will
    ///< be pushed as a single unit to a wide fifo so that it can be streamed
    ///< out to the vex array.  The bit is self-clearing.
    ///< AccessType="RW/AC" BitOffset="0" ResetValue="0x0"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_tx_push_reg_t;

#define CRUX_INTF_CRUX_TX_PUSH_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_TX_PUSH_RD_MASK (0x00000000000000000000000000000001ULL)
#define CRUX_INTF_CRUX_TX_PUSH_WR_MASK (0x00000000000000000000000000000001ULL)


///< When this bit is set to 1, the contents of the above 5 registers will
///< be pushed as a single unit to a wide fifo so that it can be streamed
///< out to the vex array.  The bit is self-clearing.
#define CRUX_INTF_CRUX_TX_PUSH_BF_OFF ( 0)
#define CRUX_INTF_CRUX_TX_PUSH_BF_WID ( 1)
#define CRUX_INTF_CRUX_TX_PUSH_BF_MSK (0x00000001)
#define CRUX_INTF_CRUX_TX_PUSH_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_TX_FIFO_WM register description at address offset 0x60
  *
  * Register default value:        0x0000000B
  * Register full path in IP: crux_intf/reg/CRUX_TX_FIFO_WM
  * Watermarks for fifo of depth 4 between Cores and tx arbitor for the nsib_hbi
  */

typedef union {
  struct {
    uint64_t HIGH_WM : 3;
    ///< High watermark.  Depth of fifo to trigger the fifo_afull status.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x3"
    uint64_t LOW_WM : 3;
    ///< Low watermark.  Depth of fifo to trigger the fifo_aempty status.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_tx_fifo_wm_reg_t;

#define CRUX_INTF_CRUX_TX_FIFO_WM_DEFAULT (0x0000000000000000000000000000000bULL)
#define CRUX_INTF_CRUX_TX_FIFO_WM_RD_MASK (0x0000000000000000000000000000003fULL)
#define CRUX_INTF_CRUX_TX_FIFO_WM_WR_MASK (0x0000000000000000000000000000003fULL)


///< High watermark.  Depth of fifo to trigger the fifo_afull status.
#define CRUX_INTF_CRUX_TX_FIFO_WM_HIGH_WM_BF_OFF ( 0)
#define CRUX_INTF_CRUX_TX_FIFO_WM_HIGH_WM_BF_WID ( 3)
#define CRUX_INTF_CRUX_TX_FIFO_WM_HIGH_WM_BF_MSK (0x00000007)
#define CRUX_INTF_CRUX_TX_FIFO_WM_HIGH_WM_BF_DEF (0x00000003)

///< Low watermark.  Depth of fifo to trigger the fifo_aempty status.
#define CRUX_INTF_CRUX_TX_FIFO_WM_LOW_WM_BF_OFF ( 3)
#define CRUX_INTF_CRUX_TX_FIFO_WM_LOW_WM_BF_WID ( 3)
#define CRUX_INTF_CRUX_TX_FIFO_WM_LOW_WM_BF_MSK (0x00000038)
#define CRUX_INTF_CRUX_TX_FIFO_WM_LOW_WM_BF_DEF (0x00000008)


/** @brief CRUX_INTF_REG_CRUX_INTF_MASKS register description at address offset 0x70
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_INTF_MASKS
  * Masks for interrupts
  */

typedef union {
  struct {
    uint64_t B2H_RX_FIFO_NEMPTY_MASK : 1;
    ///< B2H RX fifo not empty.  This indicates data is available to read from
    ///< B2H rx fifo, and a pop operation can be done.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint64_t H2B_TX_FIFO_OVERFLOW_MASK : 1;
    ///< H2B Timestamp fifo overflow.  There is a 4 deep fifo prior to the
    ///< tx arbitor for storing TX messages.  This masks the interrupt for
    ///< this fifo overflow.  NOTE: this interface has been designed such that
    ///< it should not be possible to overflow this FIFO.  This interrupt should
    ///< never happen.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint64_t H2B_TS_FIFO_OVERFLOW_MASK : 1;
    ///< H2B Timestamp fifo overflow.  There is a 16 deep fifo prior to the
    ///< tx arbitor.  This masks the interrupt for the timestamp fifo overflow.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_intf_masks_reg_t;

#define CRUX_INTF_CRUX_INTF_MASKS_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_INTF_MASKS_RD_MASK (0x00000000000000000000000000000007ULL)
#define CRUX_INTF_CRUX_INTF_MASKS_WR_MASK (0x00000000000000000000000000000007ULL)


///< B2H RX fifo not empty.  This indicates data is available to read from
///< B2H rx fifo, and a pop operation can be done.
#define CRUX_INTF_CRUX_INTF_MASKS_B2H_RX_FIFO_NEMPTY_MASK_BF_OFF ( 0)
#define CRUX_INTF_CRUX_INTF_MASKS_B2H_RX_FIFO_NEMPTY_MASK_BF_WID ( 1)
#define CRUX_INTF_CRUX_INTF_MASKS_B2H_RX_FIFO_NEMPTY_MASK_BF_MSK (0x00000001)
#define CRUX_INTF_CRUX_INTF_MASKS_B2H_RX_FIFO_NEMPTY_MASK_BF_DEF (0x00000000)

///< H2B Timestamp fifo overflow.  There is a 4 deep fifo prior to the
///< tx arbitor for storing TX messages.  This masks the interrupt for
///< this fifo overflow.  NOTE: this interface has been designed such that
///< it should not be possible to overflow this FIFO.  This interrupt should
///< never happen.
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TX_FIFO_OVERFLOW_MASK_BF_OFF ( 1)
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TX_FIFO_OVERFLOW_MASK_BF_WID ( 1)
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TX_FIFO_OVERFLOW_MASK_BF_MSK (0x00000002)
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TX_FIFO_OVERFLOW_MASK_BF_DEF (0x00000000)

///< H2B Timestamp fifo overflow.  There is a 16 deep fifo prior to the
///< tx arbitor.  This masks the interrupt for the timestamp fifo overflow.
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TS_FIFO_OVERFLOW_MASK_BF_OFF ( 2)
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TS_FIFO_OVERFLOW_MASK_BF_WID ( 1)
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TS_FIFO_OVERFLOW_MASK_BF_MSK (0x00000004)
#define CRUX_INTF_CRUX_INTF_MASKS_H2B_TS_FIFO_OVERFLOW_MASK_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_FIFO_SW_RST register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_FIFO_SW_RST
  * Fifo software resets
  */

typedef union {
  struct {
    uint64_t TX_FIFO_SW_RST : 1;
    ///< This bit resets the H2B tx fifo before the tx arbitor in the rcs crux
    ///< interface.  It will also have the effect of clearing the status bits
    ///< for this fifo.  It is self clearing.
    ///< AccessType="RW/AC" BitOffset="0" ResetValue="0x0"
    uint64_t TS_FIFO_SW_RST : 1;
    ///< This bit resets the H2B timestamp fifo before the tx arbitor in the
    ///< rcs crux interface.  It will also have the effect of clearing the
    ///< status bits for this fifo.  It is self clearing.
    ///< AccessType="RW/AC" BitOffset="1" ResetValue="0x0"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_fifo_sw_rst_reg_t;

#define CRUX_INTF_CRUX_FIFO_SW_RST_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_FIFO_SW_RST_RD_MASK (0x00000000000000000000000000000003ULL)
#define CRUX_INTF_CRUX_FIFO_SW_RST_WR_MASK (0x00000000000000000000000000000003ULL)


///< This bit resets the H2B tx fifo before the tx arbitor in the rcs crux
///< interface.  It will also have the effect of clearing the status bits
///< for this fifo.  It is self clearing.
#define CRUX_INTF_CRUX_FIFO_SW_RST_TX_FIFO_SW_RST_BF_OFF ( 0)
#define CRUX_INTF_CRUX_FIFO_SW_RST_TX_FIFO_SW_RST_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_SW_RST_TX_FIFO_SW_RST_BF_MSK (0x00000001)
#define CRUX_INTF_CRUX_FIFO_SW_RST_TX_FIFO_SW_RST_BF_DEF (0x00000000)

///< This bit resets the H2B timestamp fifo before the tx arbitor in the
///< rcs crux interface.  It will also have the effect of clearing the
///< status bits for this fifo.  It is self clearing.
#define CRUX_INTF_CRUX_FIFO_SW_RST_TS_FIFO_SW_RST_BF_OFF ( 1)
#define CRUX_INTF_CRUX_FIFO_SW_RST_TS_FIFO_SW_RST_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_SW_RST_TS_FIFO_SW_RST_BF_MSK (0x00000002)
#define CRUX_INTF_CRUX_FIFO_SW_RST_TS_FIFO_SW_RST_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_RX_POP register description at address offset 0x90
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_RX_POP
  * POP rx data from Common module fifo.
  */

typedef union {
  struct {
    uint64_t POP : 1;
    ///< When this register is read, it will cause a pop of the B2H (rx) fifo
    ///< in the nsip_hbi.  It is set to do this on read to avoid the situation
    ///< where a pop cant be done because writes are blocked on AXI interface
    ///< due to a full TX fifo.  This register will always read back as 0.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_rx_pop_reg_t;

#define CRUX_INTF_CRUX_RX_POP_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_RX_POP_RD_MASK (0x00000000000000000000000000000001ULL)
#define CRUX_INTF_CRUX_RX_POP_WR_MASK (0x00000000000000000000000000000000ULL)


///< When this register is read, it will cause a pop of the B2H (rx) fifo
///< in the nsip_hbi.  It is set to do this on read to avoid the situation
///< where a pop cant be done because writes are blocked on AXI interface
///< due to a full TX fifo.  This register will always read back as 0.
#define CRUX_INTF_CRUX_RX_POP_BF_OFF ( 0)
#define CRUX_INTF_CRUX_RX_POP_BF_WID ( 1)
#define CRUX_INTF_CRUX_RX_POP_BF_MSK (0x00000001)
#define CRUX_INTF_CRUX_RX_POP_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_RDATA0_R register description at address offset 0xa0
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_RDATA0_r
  * Bits [127:0] of Crux RX Data word
  */

typedef union {
  struct {
    uint64_t DATA0 : 32;
    ///< Bits 32:0 of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t DATA1 : 32;
    ///< Bits [63:32] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t DATA2 : 32;
    ///< Bits [95:64] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="64" ResetValue="0x0"
    uint64_t DATA3 : 32;
    ///< Bits [127:96] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="96" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_rdata0_r_reg_t;

#define CRUX_INTF_CRUX_RDATA0_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_RDATA0_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_RDATA0_R_WR_MASK (0x00000000000000000000000000000000ULL)


///< Bits 32:0 of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA0_R_DATA0_BF_OFF ( 0)
#define CRUX_INTF_CRUX_RDATA0_R_DATA0_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA0_R_DATA0_BF_MSK (0xFFFFFFFF)
#define CRUX_INTF_CRUX_RDATA0_R_DATA0_BF_DEF (0x00000000)

///< Bits [63:32] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA0_R_DATA1_BF_OFF (32)
#define CRUX_INTF_CRUX_RDATA0_R_DATA1_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA0_R_DATA1_BF_MSK (0xFFFFFFFF00000000)
#define CRUX_INTF_CRUX_RDATA0_R_DATA1_BF_DEF (0x00000000)

///< Bits [95:64] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA0_R_DATA2_BF_OFF (64)
#define CRUX_INTF_CRUX_RDATA0_R_DATA2_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA0_R_DATA2_BF_MSK (0xFFFFFFFF0000000000000000)
#define CRUX_INTF_CRUX_RDATA0_R_DATA2_BF_DEF (0x00000000)

///< Bits [127:96] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA0_R_DATA3_BF_OFF (96)
#define CRUX_INTF_CRUX_RDATA0_R_DATA3_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA0_R_DATA3_BF_MSK (0xFFFFFFFF000000000000000000000000)
#define CRUX_INTF_CRUX_RDATA0_R_DATA3_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_RDATA1_R register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_RDATA1_r
  * Bits [255:64] of Crux RX Data word
  */

typedef union {
  struct {
    uint64_t DATA0 : 32;
    ///< Bits [159:64] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t DATA1 : 32;
    ///< Bits [191:160] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t DATA2 : 32;
    ///< Bits [224:192] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="64" ResetValue="0x0"
    uint64_t DATA3 : 32;
    ///< Bits [255:224] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="96" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_rdata1_r_reg_t;

#define CRUX_INTF_CRUX_RDATA1_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_RDATA1_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_RDATA1_R_WR_MASK (0x00000000000000000000000000000000ULL)


///< Bits [159:64] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA1_R_DATA0_BF_OFF ( 0)
#define CRUX_INTF_CRUX_RDATA1_R_DATA0_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA1_R_DATA0_BF_MSK (0xFFFFFFFF)
#define CRUX_INTF_CRUX_RDATA1_R_DATA0_BF_DEF (0x00000000)

///< Bits [191:160] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA1_R_DATA1_BF_OFF (32)
#define CRUX_INTF_CRUX_RDATA1_R_DATA1_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA1_R_DATA1_BF_MSK (0xFFFFFFFF00000000)
#define CRUX_INTF_CRUX_RDATA1_R_DATA1_BF_DEF (0x00000000)

///< Bits [224:192] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA1_R_DATA2_BF_OFF (64)
#define CRUX_INTF_CRUX_RDATA1_R_DATA2_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA1_R_DATA2_BF_MSK (0xFFFFFFFF0000000000000000)
#define CRUX_INTF_CRUX_RDATA1_R_DATA2_BF_DEF (0x00000000)

///< Bits [255:224] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA1_R_DATA3_BF_OFF (96)
#define CRUX_INTF_CRUX_RDATA1_R_DATA3_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA1_R_DATA3_BF_MSK (0xFFFFFFFF000000000000000000000000)
#define CRUX_INTF_CRUX_RDATA1_R_DATA3_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_RDATA2_R register description at address offset 0xc0
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_RDATA2_r
  * Bits [383:256] of Crux RX Data word
  */

typedef union {
  struct {
    uint64_t DATA0 : 32;
    ///< Bits [287:256] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t DATA1 : 32;
    ///< Bits [319:288] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t DATA2 : 32;
    ///< Bits [351:320] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="64" ResetValue="0x0"
    uint64_t DATA3 : 32;
    ///< Bits [383:352] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="96" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_rdata2_r_reg_t;

#define CRUX_INTF_CRUX_RDATA2_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_RDATA2_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_RDATA2_R_WR_MASK (0x00000000000000000000000000000000ULL)


///< Bits [287:256] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA2_R_DATA0_BF_OFF ( 0)
#define CRUX_INTF_CRUX_RDATA2_R_DATA0_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA2_R_DATA0_BF_MSK (0xFFFFFFFF)
#define CRUX_INTF_CRUX_RDATA2_R_DATA0_BF_DEF (0x00000000)

///< Bits [319:288] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA2_R_DATA1_BF_OFF (32)
#define CRUX_INTF_CRUX_RDATA2_R_DATA1_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA2_R_DATA1_BF_MSK (0xFFFFFFFF00000000)
#define CRUX_INTF_CRUX_RDATA2_R_DATA1_BF_DEF (0x00000000)

///< Bits [351:320] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA2_R_DATA2_BF_OFF (64)
#define CRUX_INTF_CRUX_RDATA2_R_DATA2_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA2_R_DATA2_BF_MSK (0xFFFFFFFF0000000000000000)
#define CRUX_INTF_CRUX_RDATA2_R_DATA2_BF_DEF (0x00000000)

///< Bits [383:352] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA2_R_DATA3_BF_OFF (96)
#define CRUX_INTF_CRUX_RDATA2_R_DATA3_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA2_R_DATA3_BF_MSK (0xFFFFFFFF000000000000000000000000)
#define CRUX_INTF_CRUX_RDATA2_R_DATA3_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_RDATA3_R register description at address offset 0xd0
  *
  * Register default value:        0x00000000
  * Register full path in IP: crux_intf/reg/CRUX_RDATA3_r
  * Bits [511:384] of Crux RX Data word
  */

typedef union {
  struct {
    uint64_t DATA0 : 32;
    ///< Bits [415:384] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t DATA1 : 32;
    ///< Bits [447:416] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t DATA2 : 32;
    ///< Bits [479:448] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="64" ResetValue="0x0"
    uint64_t DATA3 : 32;
    ///< Bits [511:480] of 512 bit data word.
    ///< AccessType="RO/V" BitOffset="96" ResetValue="0x0"
  } ;
  uint64_t value;
} crux_intf_crux_rdata3_r_reg_t;

#define CRUX_INTF_CRUX_RDATA3_R_DEFAULT (0x00000000000000000000000000000000ULL)
#define CRUX_INTF_CRUX_RDATA3_R_RD_MASK (0xffffffffffffffffffffffffffffffffULL)
#define CRUX_INTF_CRUX_RDATA3_R_WR_MASK (0x00000000000000000000000000000000ULL)


///< Bits [415:384] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA3_R_DATA0_BF_OFF ( 0)
#define CRUX_INTF_CRUX_RDATA3_R_DATA0_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA3_R_DATA0_BF_MSK (0xFFFFFFFF)
#define CRUX_INTF_CRUX_RDATA3_R_DATA0_BF_DEF (0x00000000)

///< Bits [447:416] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA3_R_DATA1_BF_OFF (32)
#define CRUX_INTF_CRUX_RDATA3_R_DATA1_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA3_R_DATA1_BF_MSK (0xFFFFFFFF00000000)
#define CRUX_INTF_CRUX_RDATA3_R_DATA1_BF_DEF (0x00000000)

///< Bits [479:448] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA3_R_DATA2_BF_OFF (64)
#define CRUX_INTF_CRUX_RDATA3_R_DATA2_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA3_R_DATA2_BF_MSK (0xFFFFFFFF0000000000000000)
#define CRUX_INTF_CRUX_RDATA3_R_DATA2_BF_DEF (0x00000000)

///< Bits [511:480] of 512 bit data word.
#define CRUX_INTF_CRUX_RDATA3_R_DATA3_BF_OFF (96)
#define CRUX_INTF_CRUX_RDATA3_R_DATA3_BF_WID (32)
#define CRUX_INTF_CRUX_RDATA3_R_DATA3_BF_MSK (0xFFFFFFFF000000000000000000000000)
#define CRUX_INTF_CRUX_RDATA3_R_DATA3_BF_DEF (0x00000000)


/** @brief CRUX_INTF_REG_CRUX_RROUTING_DATA_R register description at address offset 0xe0
  *
  * Register default value:        0x2000000000000300
  * Register full path in IP: crux_intf/reg/CRUX_RROUTING_DATA_r
  * Routing data for the rx data.
  */

typedef union {
  struct {
    uint64_t STREAM_ID : 5;
    ///< This is the streaming ID for the packet
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t LEN : 3;
    ///< The Len field indicates the length of the packet (length is this value
    ///< + 1).
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint64_t EOP : 1;
    ///< EOP, this bit indicates if the FLIT is the last in a packet.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x1"
    uint64_t SOP : 1;
    ///< SOP, this bit indicates if the FLIT is the first in a packet.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x1"
    uint64_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint64_t ADDRESS : 26;
    ///< Address of the destination of the packet.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t FLIT_TYPE : 3;
    ///< The Type field indicates the number of valid bytes contained in the
    ///< streaming word format.
    ///< AccessType="RO/V" BitOffset="58" ResetValue="0x0"
    uint64_t BYPASS : 1;
    ///< Bypass mode.  This bit should always be set to 1, it indicates that
    ///< the routing data will be given directly to the common module and that
    ///< it does not need to calculate it.
    ///< AccessType="RO/V" BitOffset="61" ResetValue="0x1"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="62" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_rrouting_data_r_reg_t;

#define CRUX_INTF_CRUX_RROUTING_DATA_R_DEFAULT (0x00000000000000002000000000000300ULL)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_RD_MASK (0x00000000000000003fffffff000003ffULL)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_WR_MASK (0x00000000000000000000000000000000ULL)


///< This is the streaming ID for the packet
#define CRUX_INTF_CRUX_RROUTING_DATA_R_STREAM_ID_BF_OFF ( 0)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_STREAM_ID_BF_WID ( 5)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_STREAM_ID_BF_MSK (0x0000001F)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_STREAM_ID_BF_DEF (0x00000000)

///< The Len field indicates the length of the packet (length is this value
///< + 1).
#define CRUX_INTF_CRUX_RROUTING_DATA_R_LEN_BF_OFF ( 5)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_LEN_BF_WID ( 3)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_LEN_BF_MSK (0x000000E0)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_LEN_BF_DEF (0x00000000)

///< EOP, this bit indicates if the FLIT is the last in a packet.
#define CRUX_INTF_CRUX_RROUTING_DATA_R_EOP_BF_OFF ( 8)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_EOP_BF_WID ( 1)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_EOP_BF_MSK (0x00000100)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_EOP_BF_DEF (0x00000100)

///< SOP, this bit indicates if the FLIT is the first in a packet.
#define CRUX_INTF_CRUX_RROUTING_DATA_R_SOP_BF_OFF ( 9)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_SOP_BF_WID ( 1)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_SOP_BF_MSK (0x00000200)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_SOP_BF_DEF (0x00000200)

///< Address of the destination of the packet.
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BF_OFF (32)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BF_WID (26)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BF_MSK (0x3FFFFFF00000000)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BF_DEF (0x00000000)

///< The Type field indicates the number of valid bytes contained in the
///< streaming word format.
#define CRUX_INTF_CRUX_RROUTING_DATA_R_FLIT_TYPE_BF_OFF (58)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_FLIT_TYPE_BF_WID ( 3)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_FLIT_TYPE_BF_MSK (0x1C00000000000000)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_FLIT_TYPE_BF_DEF (0x00000000)

///< Bypass mode.  This bit should always be set to 1, it indicates that
///< the routing data will be given directly to the common module and that
///< it does not need to calculate it.
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BYPASS_BF_OFF (61)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BYPASS_BF_WID ( 1)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BYPASS_BF_MSK (0x2000000000000000)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_BYPASS_BF_DEF (0x2000000000000000)


/** @brief CRUX_INTF_REG_CRUX_FIFO_STATUS register description at address offset 0xf0
  *
  * Register default value:        0x000C000C
  * Register full path in IP: crux_intf/reg/CRUX_FIFO_STATUS
  * Status bits for the two fifos in the rcs_crux_interface
  */

typedef union {
  struct {
    uint64_t TS_FIFO_UNDERFLOW : 1;
    ///< Timestamp FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t TS_FIFO_OVERFLOW : 1;
    ///< Timestamp FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint64_t TS_FIFO_EMPTY : 1;
    ///< Timestamp FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint64_t TS_FIFO_ALMOST_EMPTY : 1;
    ///< Timestamp FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint64_t TS_FIFO_ALMOST_FULL : 1;
    ///< Timestamp FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint64_t TS_FIFO_FULL : 1;
    ///< Timestamp FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint64_t TS_FIFO_DEPTH : 5;
    ///< Timestamp FIFO Depth (0-16)
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint64_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint64_t TX_FIFO_UNDERFLOW : 1;
    ///< TX buffer FIFO Underflow
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint64_t TX_FIFO_OVERFLOW : 1;
    ///< TX buffer FIFO Overflow
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint64_t TX_FIFO_EMPTY : 1;
    ///< TX buffer FIFO Empty
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x1"
    uint64_t TX_FIFO_ALMOST_EMPTY : 1;
    ///< TX buffer FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x1"
    uint64_t TX_FIFO_ALMOST_FULL : 1;
    ///< TX buffer FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint64_t TX_FIFO_FULL : 1;
    ///< TX buffer FIFO Full
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint64_t TX_FIFO_DEPTH : 3;
    ///< TX buffer FIFO Depth (0-4)
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t  : 64;
    ///< Reserved
    ///< AccessType="RO" BitOffset="25" ResetValue="None"
  } ;
  uint64_t value;
} crux_intf_crux_fifo_status_reg_t;

#define CRUX_INTF_CRUX_FIFO_STATUS_DEFAULT (0x000000000000000000000000000c000cULL)
#define CRUX_INTF_CRUX_FIFO_STATUS_RD_MASK (0x00000000000000000000000001ff07ffULL)
#define CRUX_INTF_CRUX_FIFO_STATUS_WR_MASK (0x00000000000000000000000000000000ULL)


///< Timestamp FIFO Underflow
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_UNDERFLOW_BF_OFF ( 0)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_UNDERFLOW_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_UNDERFLOW_BF_MSK (0x00000001)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_UNDERFLOW_BF_DEF (0x00000000)

///< Timestamp FIFO Overflow
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_OVERFLOW_BF_OFF ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_OVERFLOW_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_OVERFLOW_BF_MSK (0x00000002)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_OVERFLOW_BF_DEF (0x00000000)

///< Timestamp FIFO Empty
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_EMPTY_BF_OFF ( 2)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_EMPTY_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_EMPTY_BF_MSK (0x00000004)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_EMPTY_BF_DEF (0x00000004)

///< Timestamp FIFO Almost Empty
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_EMPTY_BF_OFF ( 3)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_EMPTY_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_EMPTY_BF_MSK (0x00000008)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_EMPTY_BF_DEF (0x00000008)

///< Timestamp FIFO Almost Full
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_FULL_BF_OFF ( 4)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_FULL_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_FULL_BF_MSK (0x00000010)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_ALMOST_FULL_BF_DEF (0x00000000)

///< Timestamp FIFO Full
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_FULL_BF_OFF ( 5)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_FULL_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_FULL_BF_MSK (0x00000020)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_FULL_BF_DEF (0x00000000)

///< Timestamp FIFO Depth (0-16)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_DEPTH_BF_OFF ( 6)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_DEPTH_BF_WID ( 5)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_DEPTH_BF_MSK (0x000007C0)
#define CRUX_INTF_CRUX_FIFO_STATUS_TS_FIFO_DEPTH_BF_DEF (0x00000000)

///< TX buffer FIFO Underflow
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_UNDERFLOW_BF_OFF (16)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_UNDERFLOW_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_UNDERFLOW_BF_MSK (0x00010000)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_UNDERFLOW_BF_DEF (0x00000000)

///< TX buffer FIFO Overflow
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_OVERFLOW_BF_OFF (17)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_OVERFLOW_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_OVERFLOW_BF_MSK (0x00020000)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_OVERFLOW_BF_DEF (0x00000000)

///< TX buffer FIFO Empty
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_EMPTY_BF_OFF (18)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_EMPTY_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_EMPTY_BF_MSK (0x00040000)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_EMPTY_BF_DEF (0x00040000)

///< TX buffer FIFO Almost Empty
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_EMPTY_BF_OFF (19)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_EMPTY_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_EMPTY_BF_MSK (0x00080000)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_EMPTY_BF_DEF (0x00080000)

///< TX buffer FIFO Almost Full
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_FULL_BF_OFF (20)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_FULL_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_FULL_BF_MSK (0x00100000)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_ALMOST_FULL_BF_DEF (0x00000000)

///< TX buffer FIFO Full
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_FULL_BF_OFF (21)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_FULL_BF_WID ( 1)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_FULL_BF_MSK (0x00200000)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_FULL_BF_DEF (0x00000000)

///< TX buffer FIFO Depth (0-4)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_DEPTH_BF_OFF (22)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_DEPTH_BF_WID ( 3)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_DEPTH_BF_MSK (0x01C00000)
#define CRUX_INTF_CRUX_FIFO_STATUS_TX_FIFO_DEPTH_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

// Stepping: A0
//
#define CRUX_INTF_CRUX_WDATA0_R_REG ((crux_intf_crux_wdata0_r_reg_t*) CRUX_INTF_CRUX_WDATA0_R_ADR)
#define CRUX_INTF_CRUX_WDATA1_R_REG ((crux_intf_crux_wdata1_r_reg_t*) CRUX_INTF_CRUX_WDATA1_R_ADR)
#define CRUX_INTF_CRUX_WDATA2_R_REG ((crux_intf_crux_wdata2_r_reg_t*) CRUX_INTF_CRUX_WDATA2_R_ADR)
#define CRUX_INTF_CRUX_WDATA3_R_REG ((crux_intf_crux_wdata3_r_reg_t*) CRUX_INTF_CRUX_WDATA3_R_ADR)
#define CRUX_INTF_CRUX_WROUTING_DATA_R_REG ((crux_intf_crux_wrouting_data_r_reg_t*) CRUX_INTF_CRUX_WROUTING_DATA_R_ADR)
#define CRUX_INTF_CRUX_TX_PUSH_REG ((crux_intf_crux_tx_push_reg_t*) CRUX_INTF_CRUX_TX_PUSH_ADR)
#define CRUX_INTF_CRUX_TX_FIFO_WM_REG ((crux_intf_crux_tx_fifo_wm_reg_t*) CRUX_INTF_CRUX_TX_FIFO_WM_ADR)
#define CRUX_INTF_CRUX_INTF_MASKS_REG ((crux_intf_crux_intf_masks_reg_t*) CRUX_INTF_CRUX_INTF_MASKS_ADR)
#define CRUX_INTF_CRUX_FIFO_SW_RST_REG ((crux_intf_crux_fifo_sw_rst_reg_t*) CRUX_INTF_CRUX_FIFO_SW_RST_ADR)
#define CRUX_INTF_CRUX_RX_POP_REG ((crux_intf_crux_rx_pop_reg_t*) CRUX_INTF_CRUX_RX_POP_ADR)
#define CRUX_INTF_CRUX_RDATA0_R_REG ((crux_intf_crux_rdata0_r_reg_t*) CRUX_INTF_CRUX_RDATA0_R_ADR)
#define CRUX_INTF_CRUX_RDATA1_R_REG ((crux_intf_crux_rdata1_r_reg_t*) CRUX_INTF_CRUX_RDATA1_R_ADR)
#define CRUX_INTF_CRUX_RDATA2_R_REG ((crux_intf_crux_rdata2_r_reg_t*) CRUX_INTF_CRUX_RDATA2_R_ADR)
#define CRUX_INTF_CRUX_RDATA3_R_REG ((crux_intf_crux_rdata3_r_reg_t*) CRUX_INTF_CRUX_RDATA3_R_ADR)
#define CRUX_INTF_CRUX_RROUTING_DATA_R_REG ((crux_intf_crux_rrouting_data_r_reg_t*) CRUX_INTF_CRUX_RROUTING_DATA_R_ADR)
#define CRUX_INTF_CRUX_FIFO_STATUS_REG ((crux_intf_crux_fifo_status_reg_t*) CRUX_INTF_CRUX_FIFO_STATUS_ADR)

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
// Stepping: A0
//
typedef struct
{
   // crux_intf_crux_wdata0_r_reg_t CRUX_WDATA0_R;   /*< Address offset = 0x0 */
    crux_intf_crux_wdata1_r_reg_t CRUX_WDATA1_R;   /*< Address offset = 0x10 */
    crux_intf_crux_wdata2_r_reg_t CRUX_WDATA2_R;   /*< Address offset = 0x20 */
    crux_intf_crux_wdata3_r_reg_t CRUX_WDATA3_R;   /*< Address offset = 0x30 */
    crux_intf_crux_wrouting_data_r_reg_t CRUX_WROUTING_DATA_R; /*< Address offset = 0x40 */
    crux_intf_crux_tx_push_reg_t CRUX_TX_PUSH;    /*< Address offset = 0x50 */
    crux_intf_crux_tx_fifo_wm_reg_t CRUX_TX_FIFO_WM; /*< Address offset = 0x60 */
    crux_intf_crux_intf_masks_reg_t CRUX_INTF_MASKS; /*< Address offset = 0x70 */
    crux_intf_crux_fifo_sw_rst_reg_t CRUX_FIFO_SW_RST; /*< Address offset = 0x80 */
    crux_intf_crux_rx_pop_reg_t CRUX_RX_POP;     /*< Address offset = 0x90 */
    crux_intf_crux_rdata0_r_reg_t CRUX_RDATA0_R;   /*< Address offset = 0xa0 */
    crux_intf_crux_rdata1_r_reg_t CRUX_RDATA1_R;   /*< Address offset = 0xb0 */
    crux_intf_crux_rdata2_r_reg_t CRUX_RDATA2_R;   /*< Address offset = 0xc0 */
    crux_intf_crux_rdata3_r_reg_t CRUX_RDATA3_R;   /*< Address offset = 0xd0 */
    crux_intf_crux_rrouting_data_r_reg_t CRUX_RROUTING_DATA_R; /*< Address offset = 0xe0 */
    crux_intf_crux_fifo_status_reg_t CRUX_FIFO_STATUS; /*< Address offset = 0xf0 */
} crux_intf_t;     // size: 0x0100

// AddressSpace struct pointer
//
#define RCS_CRUX_INTF ((crux_intf_t*) RCS_CRUX_INTF_BASE)

// ******************************************* /Address Space

#endif      // _CRUX_INTF_H_

