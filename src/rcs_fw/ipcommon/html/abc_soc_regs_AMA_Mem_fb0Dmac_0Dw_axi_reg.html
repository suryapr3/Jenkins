<!DOCTYPE html>
<html>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
  <head>
<!-- INTEL CONFIDENTIAL
 -->
<!-- 
 -->
<!-- Copyright 2024 Intel Corporation All Rights Reserved.
 -->
<!-- 
 -->
<!-- The source code contained or described herein and all documents related
 -->
<!-- to the source code ("Material") are owned by Intel Corporation or its
 -->
<!-- suppliers or licensors. Title to the Material remains with Intel
 -->
<!-- Corporation or its suppliers and licensors. The Material contains trade
 -->
<!-- secrets and proprietary and confidential information of Intel or its
 -->
<!-- suppliers and licensors. The Material is protected by worldwide copyright
 -->
<!-- and trade secret laws and treaty provisions. No part of the Material may
 -->
<!-- be used, copied, reproduced, modified, published, uploaded, posted,
 -->
<!-- transmitted, distributed, or disclosed in any way without Intel's prior
 -->
<!-- express written permission.
 -->
<!-- 
 -->
<!-- No license under any patent, copyright, trade secret or other intellectual
 -->
<!-- property right is granted to or conferred upon you by disclosure or
 -->
<!-- delivery of the Materials, either expressly, by implication, inducement,
 -->
<!-- estoppel or otherwise. Any license under such intellectual property rights
 -->
<!-- must be express and approved by Intel in writing. -->
<!--  -->
    <title>Registers in AddressMap abc_soc_top/mem_fb0/dmac_0/DW_axi_reg</title>

    <!-- Default style sheet -->
    <style type="text/css">
      body        { font-family:Verdana,Helvetica,sans-serif; }
      th          { background:#E0C0C0; }
      td          { padding:0px 8px; border-width:1px; border-style:solid; border-color:black; }
      td.unboxed  { border-style:none; }
      ul          { list-style-type:disc; }
      code        { white-space:pre;font-family:monospace;display:block;font-size:1.3em; }
      code.tree   { display:inline;font-size:medium; }
      .namsp       { font-weight:bold; }
      .namprim     { font-style:italic; }
      .signature   { white-space:pre;font-family:monospace;display:left;font-size:1.1em; }
      .msgerror   { color:#FF0000; }
      .msgwarng   { color:#CC8800; }
      .boxed      { border-width:1px; border-style:solid; }
      .unboxed    { border-width:1px; }
      .tblcoll    { border-collapse:collapse; }
      .regname    { font-size:larger; font-weight:bold; }
      .regunalloc { background:#EEEEEE; }
      .sdescmap   { font-style:italic; }
      .sdescdet   { font-style:italic; font-weight:bold; }
      .ldescdet   { font-size:smaller; }
      .addr       { font-family:monospace; font-size:larger; }
      .agent      { font-size:smaller; }
      .fldview    { font-size:larger; }
      .flddesc    { background:#FFF0B0; }
      .tabrh      { background:#E0C0C0; }
      .tabry      { background:#FFF2CC; }
      .tabryd     { background:#EFD2AC; }
      .tabrb      { background:#DEEAFA; }
      .tabrbd     { background:#BECAEA; }
      .tabrt      { background:#ADD9FF; }
      .tabrtd     { background:#8DB9EF; }
      .tabrg      { background:#C6F8CC; }
      .tabrgl     { background:#D6FFDC; }
      .tabrv      { background:#E0E4FE; }
      .tabrs      { background:#DDDDDD; }
      .fldpos     { background:#E0E0E0; text-align:center; font-weight:bold; }
      .fldnorm    { background:#C0C0F0; text-align:center; font-weight:bold; }
      .fldrsvd    { background:#C080F0; text-align:center; font-weight:bold; }
      .fldgap     { text-align:center; font-weight:bold; }
      .fldrst     { background:#FFFFE0; text-align:center; }
      .fldrstuaf  { color:#DC143C; }
      .accga      { text-align:center; }
      .accno      { background:#E0E0F8; text-align:center; }
      .accro      { background:#F8E0E0; text-align:center; }
      .accwo      { background:#E0F8E0; text-align:center; }
      .accrw      { background:#F8F8E0; text-align:center; }
    </style>
  </head>
  <body>
    <hr/>
    <h1 id="TOPOFDOC">Registers in AddressMap abc_soc_top/mem_fb0/dmac_0/DW_axi_reg</h1>
    <h2><a href="abc_soc_regs.html">Back to main file</a></h2>
    <p><i>
INTEL CONFIDENTIAL
<br/>

<br/>
Copyright 2024 Intel Corporation All Rights Reserved.
<br/>

<br/>
The source code contained or described herein and all documents related
<br/>
to the source code ("Material") are owned by Intel Corporation or its
<br/>
suppliers or licensors. Title to the Material remains with Intel
<br/>
Corporation or its suppliers and licensors. The Material contains trade
<br/>
secrets and proprietary and confidential information of Intel or its
<br/>
suppliers and licensors. The Material is protected by worldwide copyright
<br/>
and trade secret laws and treaty provisions. No part of the Material may
<br/>
be used, copied, reproduced, modified, published, uploaded, posted,
<br/>
transmitted, distributed, or disclosed in any way without Intel's prior
<br/>
express written permission.
<br/>

<br/>
No license under any patent, copyright, trade secret or other intellectual
<br/>
property right is granted to or conferred upon you by disclosure or
<br/>
delivery of the Materials, either expressly, by implication, inducement,
<br/>
estoppel or otherwise. Any license under such intellectual property rights
<br/>
must be express and approved by Intel in writing.<br/>
<br/>
<br/>
This file was automatically generated by OneSource.
<br/>
Do not edit this file manually!<br/>
<br/>
<br/>
</i></p>

    <h3 class="sdescdet"></h3>
    <p class="ldescdet"></p>
    <hr/>
    <h2 id="G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">AddressMap abc_soc_top/mem_fb0/dmac_0/DW_axi_reg</h2>

    <!-- Registers for AddressMap abc_soc_top/mem_fb0/dmac_0/DW_axi_reg -->
      <p>AddressUnit: 8</p>
      <p><b>Accessible over:</b><br/>
        &emsp;<b><a href="abc_soc_regs.html#G_GR_NOC_rcs__axi_eaacf73c">Group NOC.rcs__axi</a></b> Mem with fixed address<br/>
      </p>
    <table>
      <tr>
        <th>Address</th>
        <th>EndAddress</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000000</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_B5048F57E29AC6C2">DMAC_IDREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Component ID Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000008</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_448961069E6DD7B9">DMAC_COMPVERREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Component Version Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000010</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_0A65592BE0E8480B">DMAC_CFGREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Global Configuration Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000018</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_9C11F7EFF896A298">DMAC_CHENREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel Enable Register</td>
      </tr>
      <tr class="regunalloc">
        <td class="unboxed addr">0x00000020</td>
        <td class="unboxed addr">0x0000002f</td>
        <td class="unboxed"><i>(Not allocated)</i></td>
        <td class="unboxed sdescmap"></td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000030</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_B876A19DE5541B58">DMAC_INTSTATUSREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Combined Interrupt Status Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000038</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_65D4ACA09DF45949">DMAC_COMMONREG_INTCLEARREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Common Register Space Interrupt Clear Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000040</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_21BAC076C02C10CF">DMAC_COMMONREG_INTSTATUS_ENABLEREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Common Register Space Interrupt Enable Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000048</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_582C36B1BBEBDAF1">DMAC_COMMONREG_INTSIGNAL_ENABLEREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Common Register Space Interrupt Signal Enable Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000050</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_90CB15F01C1571C4">DMAC_COMMONREG_INTSTATUSREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Common Register Space Interrupt Status Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000058</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_B1AA85F392679312">DMAC_RESETREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Software Reset Register</td>
      </tr>
      <tr class="regunalloc">
        <td class="unboxed addr">0x00000060</td>
        <td class="unboxed addr">0x000000ff</td>
        <td class="unboxed"><i>(Not allocated)</i></td>
        <td class="unboxed sdescmap"></td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000100</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_014C3EAC492811F1">CH1_SAR</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Source Address Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000108</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_2EAC2F08F2BA6DFA">CH1_DAR</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Destination Address Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000110</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_E350ABEC79FCF5FB">CH1_BLOCK_TS</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Block Transfer Size Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000118</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_4D756300A696A72A">CH1_CTL</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Control Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000120</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_C0C937AC85248272">CH1_CFG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Configuration Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000128</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_71B145535A8D3187">CH1_LLP</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Linked List Pointer Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000130</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_4A4FE61B784354CE">CH1_STATUSREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Status Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000138</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_9EE6EC28BCF70DBB">CH1_SWHSSRCREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Software Handshake Source Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000140</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_671F4B9225A11009">CH1_SWHSDSTREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Software Handshake Destination Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000148</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_7462C56213B43AAF">CH1_BLK_TFR_RESUMEREQREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Block Transfer Resume Request Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000150</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_02C99209CF1A5E85">CH1_AXI_IDREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x AXI ID Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000158</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_8FEA50529A2A870A">CH1_AXI_QOSREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x AXI QoS Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000160</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_B446CE0C5F33BB54">CH1_SSTAT</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Source Status Register</td>
      </tr>
      <tr class="regunalloc">
        <td class="unboxed addr">0x00000168</td>
        <td class="unboxed addr">0x0000016f</td>
        <td class="unboxed"><i>(Not allocated)</i></td>
        <td class="unboxed sdescmap"></td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000170</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_F2139129A0629FE5">CH1_SSTATAR</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Source Status Fetch Register</td>
      </tr>
      <tr class="regunalloc">
        <td class="unboxed addr">0x00000178</td>
        <td class="unboxed addr">0x0000017f</td>
        <td class="unboxed"><i>(Not allocated)</i></td>
        <td class="unboxed sdescmap"></td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000180</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_C566A6CD8C16B515">CH1_INTSTATUS_ENABLEREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Interrupt Status Enable Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000188</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_B6974B9CED41E15E">CH1_INTSTATUS</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Interrupt Status Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000190</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_DEEA4E0999AD557F">CH1_INTSIGNAL_ENABLEREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Interrupt Signal Enable Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000198</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_1DF1F2ED2A364F8D">CH1_INTCLEARREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Interrupt Status Clear Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x000001a0</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_78D371BB78761A50">CH1_CFG_EXTD</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel x Extended Configuration Register</td>
      </tr>
      <tr class="regunalloc">
        <td class="unboxed addr">0x000001a8</td>
        <td class="unboxed addr">0x000001ff</td>
        <td class="unboxed"><i>(Not allocated)</i></td>
        <td class="unboxed sdescmap"></td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000200</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_CA4655F435A412E7">CH2_SAR</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Source Address Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000208</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_718180FF7833D096">CH2_DAR</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Destination Address Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000210</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_B9CBFBEC6FDBE4C5">CH2_BLOCK_TS</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Block Transfer Size Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000218</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_6D8F9108C73D5E4B">CH2_CTL</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Control Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000220</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_45274B7D6394AC46">CH2_CFG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Configuration Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000228</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_84B098D267C7043A">CH2_LLP</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Linked List Pointer Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000230</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_B0A156E046A2EE36">CH2_STATUSREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Status Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000238</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_65108BCD5AE54EA8">CH2_SWHSSRCREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Software Handshake Source Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000240</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_D74F4B86ADCFEA08">CH2_SWHSDSTREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Software Handshake Destination Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000248</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_57DF07A168696559">CH2_BLK_TFR_RESUMEREQREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Block Transfer Resume Request Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000250</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_81EBCB46F6B10333">CH2_AXI_IDREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i AXI ID Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000258</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_9669614B2F5B5243">CH2_AXI_QOSREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i AXI QoS Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000260</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_CFF8F0052E675AEC">CH2_SSTAT</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Source Status Register</td>
      </tr>
      <tr class="regunalloc">
        <td class="unboxed addr">0x00000268</td>
        <td class="unboxed addr">0x0000026f</td>
        <td class="unboxed"><i>(Not allocated)</i></td>
        <td class="unboxed sdescmap"></td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000270</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_A8BA8D4B341A0E25">CH2_SSTATAR</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Source Status Fetch Register</td>
      </tr>
      <tr class="regunalloc">
        <td class="unboxed addr">0x00000278</td>
        <td class="unboxed addr">0x0000027f</td>
        <td class="unboxed"><i>(Not allocated)</i></td>
        <td class="unboxed sdescmap"></td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000280</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_05948AA33D393CD8">CH2_INTSTATUS_ENABLEREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Interrupt Status Enable Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000288</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_FD919E21AEB92B75">CH2_INTSTATUS</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Interrupt Status Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000290</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_28EED0CE6A0720E9">CH2_INTSIGNAL_ENABLEREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Interrupt Signal Enable Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x00000298</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_491727171F8EE205">CH2_INTCLEARREG</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Interrupt Status Clear Register</td>
      </tr>
      <tr class="tabrb">
        <td class="unboxed addr">0x000002a0</td>
        <td class="unboxed addr"></td>
        <td class="unboxed"><b><a href="#R_0E60AED72308A573">CH2_CFG_EXTD</a>  </b></td>
        <td class="unboxed sdescmap">DW_axi_dmac Channel $i Extended Configuration Register</td>
      </tr>
    </table>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <hr/>

    <!-- Registers details / bit fields -->
    <h2 id="G_BITFIELDS">Register Details for AddressMap abc_soc_top/mem_fb0/dmac_0/DW_axi_reg</h2>
    <p><b>Note:</b> AddressOffsets before register name are offsets inside AddressMap (that is what the "+" means)</p>
    <p id="R_B5048F57E29AC6C2" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000000</span> Register(64 bit) DMAC_IDREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Component ID Register</span><br/>
      <span class="ldescdet">DMAC ID Register contains a 32-bit value that is hardwired and read back by a read to the DW_axi_dmac ID Register.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502000</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="32">RSVD_DMAC_IDREG</td>
        <td class="fldnorm" colspan="32">DMAC_ID</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="32">RO</td>
        <td class="accno" colspan="32">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_IDREG</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC_IDREG Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMAC_ID</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC ID Number.</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_448961069E6DD7B9" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000008</span> Register(64 bit) DMAC_COMPVERREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Component Version Register</span><br/>
      <span class="ldescdet">This register contains a 32-bit value that is hardwired and read back by a read to the DW_axi_dmac Component Version Register.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502008</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x000000003230312a</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="32">RSVD_DMAC_COMPVERREG</td>
        <td class="fldnorm" colspan="32">DMAC_COMPVER</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="32">RO</td>
        <td class="accno" colspan="32">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMPVERREG</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC_COMPVERREG Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMAC_COMPVER</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Component Version Number.</span></p>
          <p><b>Reset: </b>hex:0x3230312a;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_0A65592BE0E8480B" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000010</span> Register(64 bit) DMAC_CFGREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Global Configuration Register</span><br/>
      <span class="ldescdet">This register is used to enable the DW_axi_dmac, which must be done before any channel<br/>activity can begin. This register also contains global interrupt enable bit.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502010</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="62">RSVD_DMAC_CFGREG</td>
        <td class="fldnorm" colspan="1">INT_EN</td>
        <td class="fldnorm" colspan="1">DMAC_EN</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="62">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:02]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CFGREG</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC_CFGREG Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">INT_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used to globally enable the interrupt generation.<br/> - 0: DW_axi_dmac Interrupts are disabled<br/> - 1: DW_axi_dmac Interrupt logic is enabled.<br/></span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">DW_axi_dmac Interrupts are disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">DW_axi_dmac Interrupts are enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMAC_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used to enable the DW_axi_dmac.<br/> - 0: DW_axi_dmac disabled<br/> - 1: DW_axi_dmac enabled<br/>Note: If this bit DMAC_EN bit is cleared while any channel is still active, then this bit still returns 1 to indicate that there are channels still active until DW_axi_dmac hardware has<br/>terminated all activity on all channels, at which point this bit returns zero (0).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">DW_axi_dmac is disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">DW_axi_dmac is enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_9C11F7EFF896A298" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000018</span> Register(64 bit) DMAC_CHENREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel Enable Register</span><br/>
      <span class="ldescdet">This is DW_axi_dmac Channel Enable Register. If software wants to set up a new channel, it can read this register to find out which channels are currently inactive and then enable an inactive channel with the required priority.<br/>All bits of this register are cleared to 0 when the DW_axi_dmac Global Enable bit (DMAC_CfgReg.DMAC_EN) is 0. When DMAC_CfgReg.DMAC_EN is 0, a write to the DMAC_ChEnReg register is ignored and a read always reads back 0.<br/>The channel enable bit, DMAC_ChEnReg.CH_EN, is written only if the corresponding channel write enable bit, DMAC_ChEnReg.CH_EN_WE, is asserted on the same register bus interface write transfer. For example, writing hex XXXX01X1 writes a 1 into DMAC_ChEnReg [0], while DMAC_ChEnReg [7:1] remains unchanged. Writing hex XXXX00XX leaves DMAC_ChEnReg [7:0] unchanged.<br/>The channel suspend bit, DMAC_ChEnReg.CH_SUSP, is written only if the corresponding channel write enable bit, DMAC_ChEnReg.CH_SUSP_WE, is asserted on the same register bus interface write transfer. For example, writing hex 01X1XXXX writes a 1 into DMAC_ChEnReg [16], while DMAC_ChEnReg [23:17] remains unchanged. Writing hex 00XXXXXX leaves DMAC_ChEnReg [23:16] unchanged. The channel terminate bit, DMAC_ChEnReg.CH_ABORT, is written only if the corresponding channel write enable bit, DMAC_ChEnReg.CH_ABORT_WE, is asserted on the same register bus interface write transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502018</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="16">RSVD_DMAC_CHENREG</td>
        <td class="fldnorm" colspan="6">RSVD_DMAC_CHENREG_CH_ABORT_WE</td>
        <td class="fldnorm" colspan="1">CH2_ABORT_WE</td>
        <td class="fldnorm" colspan="1">CH1_ABORT_WE</td>
        <td class="fldnorm" colspan="6">RSVD_DMAC_CHENREG_CH_ABORT</td>
        <td class="fldnorm" colspan="1">CH2_ABORT</td>
        <td class="fldnorm" colspan="1">CH1_ABORT</td>
        <td class="fldnorm" colspan="6">RSVD_DMAC_CHENREG_CH_SUSP_WE</td>
        <td class="fldnorm" colspan="1">CH2_SUSP_WE</td>
        <td class="fldnorm" colspan="1">CH1_SUSP_WE</td>
        <td class="fldnorm" colspan="6">RSVD_DMAC_CHENREG_CH_SUSP</td>
        <td class="fldnorm" colspan="1">CH2_SUSP</td>
        <td class="fldnorm" colspan="1">CH1_SUSP</td>
        <td class="fldnorm" colspan="6">RSVD_DMAC_CHENREG_CH_WE_EN</td>
        <td class="fldnorm" colspan="1">CH2_EN_WE</td>
        <td class="fldnorm" colspan="1">CH1_EN_WE</td>
        <td class="fldnorm" colspan="6">RSVD_DMAC_CHENREG_CH_EN</td>
        <td class="fldnorm" colspan="1">CH2_EN</td>
        <td class="fldnorm" colspan="1">CH1_EN</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="16">RO/V</td>
        <td class="accno" colspan="6">RO/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="6">RO/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="6">RO/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="6">RO/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="6">RO/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="6">RO/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:48]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHENREG</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC_CHENREG Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[47:42]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHENREG_CH_ABORT_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">CH_ABORT_WE Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[41:41]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH2_ABORT_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used to write enable the Channel-2 Terminate bit.<br/>The read back value of this register bit is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_WR_CH2_ABORT</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable Write to CH2_ABORT bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_WR_CH2_ABORT</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable  Write to CH2_ABORT bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[40:40]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH1_ABORT_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used to write enable the Channel-1 Terminate bit.<br/>The read back value of this register bit is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_WR_CH1_ABORT</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable Write to CH1_ABORT bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_WR_CH1_ABORT</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable  Write to CH1_ABORT bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[39:34]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHENREG_CH_ABORT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">CH_ABORT Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH2_ABORT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel-2 Terminate Request.<br/>Software sets this bit to 1 to request channel terminate. If this bit is set to 1, DW_axi_dmac disables the channel<br/>immediately. Terminating the channel might result in AXI Protocol violation as DW_axi_dmac does not make sure that all AXI transfers initiated on the manager interface are completed.Terminating the channel is not recommended and should be used only in situations where a particular channel hangs due to no response from the corresponding AXI manager interface and software wants to disable the channel without resetting the entire DW_axi_dmac. It is recommended to try channel disabling first and then only opt for channel terminating.<br/> - 0: No Channel Terminate Request. <br/> - 1: Request for Channel Terminate.<br/>DW_axi_dmac clears this bit to 0 once the channel is terminated (when it sets CH2_Status.CH_ABORTED bit to 1).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH2_ABORT</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Request for Channel-2 Terminate<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH2_ABORT</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Request for Channel-2 Terminate<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH1_ABORT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel-1 Terminate Request.<br/>Software sets this bit to 1 to request channel terminate. If this bit is set to 1, DW_axi_dmac disables the channel<br/>immediately. Terminating the channel might result in AXI Protocol violation as DW_axi_dmac does not make sure that all AXI transfers initiated on the manager interface are completed.Terminating the channel is not recommended and should be used only in situations where a particular channel hangs due to no response from the corresponding AXI manager interface and software wants to disable the channel without resetting the entire DW_axi_dmac. It is recommended to try channel disabling first and then only opt for channel terminating.<br/> - 0: No Channel Terminate Request. <br/> - 1: Request for Channel Terminate.<br/>DW_axi_dmac clears this bit to 0 once the channel is terminated (when it sets CH1_Status.CH_ABORTED bit to 1).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH1_ABORT</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Request for Channel-1 Terminate<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH1_ABORT</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Request for Channel-1 Terminate<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:26]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHENREG_CH_SUSP_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">CH_SUSP_WE Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH2_SUSP_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used as a write enable to the Channel-2 Suspend bit. The read back value of this register bit is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_WR_CH2_SUSP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable Write to CH2_SUSP bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_WR_CH2_SUSP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable  Write to respective CH2_SUSP bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH1_SUSP_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used as a write enable to the Channel-1 Suspend bit. The read back value of this register bit is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_WR_CH1_SUSP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable Write to CH1_SUSP bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_WR_CH1_SUSP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable  Write to respective CH1_SUSP bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:18]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHENREG_CH_SUSP</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">CH_SUSP Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH2_SUSP</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel-2 Suspend Request.<br/>Software sets this bit to 1 to request channel suspend. If this bit is set to 1, DW_axi_dmac suspends all DMA data transfers from the source gracefully until this bit is cleared. There is no guarantee that the current dma transaction will complete. This bit can also be used in conjunction with CH2_Status.CH_SUSPENDED to cleanly disable the channel without losing any data. In this case, software first sets CH2_SUSP bit to 1 and polls CH2_Status.CH_SUSPENDED till it is set to 1. Software can then clear CH2_EN bit to 0 to disable the channel.<br/> - 0: No Channel Suspend Request. <br/> - 1: Request for Channel Suspend.<br/>Software can clear CH2_SUSP bit to 0, after DW_axi_dmac sets CH2_Status.CH_SUSPENDED bit to 1, to exit the channel suspend mode.<br/>Note: CH_SUSP is cleared when channel is<br/>disabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH2_SUSP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Channel Suspend Request<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH2_SUSP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Request to Suspended Channel-2<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH1_SUSP</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel-1 Suspend Request.<br/>Software sets this bit to 1 to request channel suspend. If this bit is set to 1, DW_axi_dmac suspends all DMA data transfers from the source gracefully until this bit is cleared. There is no guarantee that the current dma transaction will complete. This bit can also be used in conjunction with CH1_Status.CH_SUSPENDED to cleanly disable the channel without losing any data. In this case, software first sets CH1_SUSP bit to 1 and polls CH1_Status.CH_SUSPENDED till it is set to 1. Software can then clear CH1_EN bit to 0 to disable the channel.<br/> - 0: No Channel Suspend Request. <br/> - 1: Request for Channel Suspend.<br/>Software can clear CH1_SUSP bit to 0, after DW_axi_dmac sets CH1_Status.CH_SUSPENDED bit to 1, to exit the channel suspend mode.<br/>Note: CH_SUSP is cleared when channel is<br/>disabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH1_SUSP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Channel Suspend Request<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH1_SUSP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Request to Suspended Channel-1<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:10]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHENREG_CH_WE_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">CH_WE_EN Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH2_EN_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DW_axi_dmac Channel-2 Enable Write Enable bit.<br/>Read back value of this register bit is always '0'.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_WR_CH2_EN</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable Write to respective CH2_EN bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_WR_CH2_EN</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable Write to CH2_EN bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH1_EN_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DW_axi_dmac Channel-1 Enable Write Enable bit.<br/>Read back value of this register bit is always '0'.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_WR_CH1_EN</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable Write to respective CH1_EN bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_WR_CH1_EN</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable Write to CH1_EN bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:02]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHENREG_CH_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">CH_EN Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH2_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used to enable the DW_axi_dmac Channel-2.<br/> - 0: DW_axi_dmac Channel-2 is disabled<br/> - 1: DW_axi_dmac Channel-2 is enabled<br/>The bit 'DMAC_ChEnReg.CH2_EN' is automatically cleared by hardware to disable the channel after the last AMBA transfer of the DMA transfer to the destination has completed. Software can therefore poll this bit to determine when this channel is free for a new DMA transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH2</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">DW_axi_dmac: Channel-2 is disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH2</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">DW_axi_dmac: Channel-2 is enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH1_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">This bit is used to enable the DW_axi_dmac Channel-1.<br/> - 0: DW_axi_dmac Channel-1 is disabled<br/> - 1: DW_axi_dmac Channel-1 is enabled<br/>The bit 'DMAC_ChEnReg.CH1_EN' is automatically cleared by hardware to disable the channel after the last AMBA transfer of the DMA transfer to the destination has completed. Software can therefore poll this bit to determine when this channel is free for a new DMA transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH1</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">DW_axi_dmac: Channel-1 is disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH1</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">DW_axi_dmac: Channel-1 is enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_B876A19DE5541B58" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000030</span> Register(64 bit) DMAC_INTSTATUSREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Combined Interrupt Status Register</span><br/>
      <span class="ldescdet">DMAC Interrupt Status Register captures the combined channel interrupt for each channel and Combined common register block interrupt. This register is present provided number of DMA channels are less than or equal to 8.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502030</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="47">RSVD_DMAC_INTSTATUSREG_63to17</td>
        <td class="fldnorm" colspan="1">CommonReg_IntStat</td>
        <td class="fldnorm" colspan="8">RSVD_DMAC_INTSTATUSREG</td>
        <td class="fldnorm" colspan="6">RSVD_DMAC_INTSTATUSREG_8to1</td>
        <td class="fldnorm" colspan="1">CH2_IntStat</td>
        <td class="fldnorm" colspan="1">CH1_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="47">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="8">RO/V</td>
        <td class="accno" colspan="6">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:17]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_INTSTATUSREG_63to17</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Interrupt Status Register (bits 63to17) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CommonReg_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Common Register Interrupt Status Bit.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Common Register Interrupt is Active<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Common Register Interrupt is Inactive<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:08]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_INTSTATUSREG</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Interrupt Status Register (bits 15to8) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[07:02]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_INTSTATUSREG_8to1</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC_INTSTATUSREG Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH2_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel 2 Interrupt Status Bit.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel ${ch_num} Interrupt is Active<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel ${ch_num} Interrupt is Inactive<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH1_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel 1 Interrupt Status Bit.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel ${ch_num} Interrupt is Active<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel ${ch_num} Interrupt is Inactive<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_65D4ACA09DF45949" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000038</span> Register(64 bit) DMAC_COMMONREG_INTCLEARREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Common Register Space Interrupt Clear Register</span><br/>
      <span class="ldescdet">Writing 1 to specific field clears the corresponding field in DMAC Common register Interrupt Status Register (DMAC_CommonReg_IntStatusReg).
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502038</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access WS</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="33">RSVD_DMAC_COMMONREG_INTCLEARREG_63to31</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_BCH_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_BCH_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_RCH1_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_RCH1_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_RCH0_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF2_RCH0_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_BCH_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_BCH_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_RCH1_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_RCH1_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_RCH0_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_MXIF1_RCH0_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_UndefinedReg_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_CommonReg_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_CommonReg_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_COMMONREG_INTCLEARREG_5to4</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_CommonReg_WrOnHold_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_CommonReg_RD2WO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_CommonReg_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_CommonReg_DEC_ERR_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="33">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="2">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:31]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTCLEARREG_63to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Clear Register (bits 63to31) Reserved bits - Write Only</span></p>
          <p><b>Reset: </b>hex:0x000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel BVALID Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_BCH_PROT_BVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_BCH_PROT_BVALID_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Data Channel RVALID Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_RCH_PROT_RVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_RCH_PROT_RVALID_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Data Channel WREADY Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_WCH_PROT_WREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_WCH_PROT_WREADY_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_AWCH_PROT_AWREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_ARCH_PROT_ARREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel BVALID Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_BCH_PROT_BVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_BCH_PROT_BVALID_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Data Channel RVALID Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_RCH_PROT_RVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_RCH_PROT_RVALID_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:23]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Data Channel WREADY Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_WCH_PROT_WREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_WCH_PROT_WREADY_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[22:22]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_AWCH_PROT_AWREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection related Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_ARCH_PROT_ARREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_BCH_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel Parity/ECC Protection related Uncorrectable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_BCH_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_BCH_PROT_UnCorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_BCH_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel ECC Protection related Correctable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_BCH_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_BCH_PROT_CorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_RCH1_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC Protection related Uncorrectable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_RCH1_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_RCH1_PROT_UnCorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_RCH1_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection related Correctable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_RCH1_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_RCH1_PROT_CorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_RCH0_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection related Uncorrectable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_RCH0_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_RCH0_PROT_UnCorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF2_RCH0_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Data) ECC Protection related Correctable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF2_RCH0_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF2_RCH0_PROT_CorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_BCH_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel Parity/ECC Protection related Uncorrectable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_BCH_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_BCH_PROT_UnCorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_BCH_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel ECC Protection related Correctable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_BCH_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_BCH_PROT_CorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_RCH1_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC Protection related Uncorrectable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_RCH1_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_RCH1_PROT_UnCorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_RCH1_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection related Correctable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_RCH1_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_RCH1_PROT_CorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_RCH0_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection related Uncorrectable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_RCH0_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_RCH0_PROT_UnCorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_MXIF1_RCH0_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Data) ECC Protection related Correctable Error Interrupt Clear bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_MXIF1_RCH0_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the MXIF1_RCH0_PROT_CorrERR_IntStat interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_UndefinedReg_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Undefined register Decode Error Interrupt clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_UndefinedReg_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_UndefinedReg_DEC_ERR interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_CommonReg_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write Parity Error Interrupt clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_CommonReg_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_CommonReg_WRPARITY_ERR interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_CommonReg_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Address Parity Error Interrupt clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_CommonReg_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_CommonReg_ADDRPARITY_ERR interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:04]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTCLEARREG_5to4</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Clear Register (bits 5to4). Reserved bits - Write only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_CommonReg_WrOnHold_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write On Hold Error Interrupt clear Bit.<br/>This bit is used to clear  the corresponding channel interrupt status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_CommonReg_WrOnHold_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_CommonReg_WrOnHold_ERR interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_CommonReg_RD2WO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Read to Write only Error Interrupt clear Bit.<br/>This bit is used to clear  the corresponding channel interrupt status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_CommonReg_RD2WO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_CommonReg_RD2WO_ERR interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_CommonReg_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write to Read only Error Interrupt clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_CommonReg_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_CommonReg_WR2RO_ERR interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_CommonReg_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Decode Error Interrupt clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_CommonReg_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_CommonReg_DEC_ERR interrupt in the interrupt register DMAC_CommonReg_IntStatusReg<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">No_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_21BAC076C02C10CF" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000040</span> Register(64 bit) DMAC_COMMONREG_INTSTATUS_ENABLEREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Common Register Space Interrupt Enable Register</span><br/>
      <span class="ldescdet">Writing 1 to specific field enables the corresponding interrupt status generation in DMAC Common register Interrupt Status Register (DMAC_CommonReg_IntStatusReg).
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502040</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0xffffffffffffffff</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="33">RSVD_DMAC_COMMONREG_INTSTATUS_ENABLEREG_63to31</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_BCH_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_BCH_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH1_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH1_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH0_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH0_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_BCH_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_BCH_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH1_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH1_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH0_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH0_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_UndefinedReg_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_COMMONREG_INTSTATUS_ENABLEREG_5to4</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_WrOnHold_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_RD2WO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_DEC_ERR_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="33">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="2">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:31]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTSTATUS_ENABLEREG_63to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Status Enable Register (bits 63to31). Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1ffffffff;</p>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel BVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_BVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_BVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Data Channel RVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH_PROT_RVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH_PROT_RVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Data Channel WREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_WCH_PROT_WREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_WCH_PROT_WREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel BVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_BVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_BVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Data Channel RVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH_PROT_RVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH_PROT_RVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:23]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Data Channel WREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_WCH_PROT_WREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_WCH_PROT_WREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[22:22]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_BCH_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_BCH_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH1_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH1_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH0_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH0_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Data) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_BCH_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_BCH_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH1_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH1_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH0_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH0_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Data) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg).</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_UndefinedReg_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Undefined register Decode Error Interrupt Status enable Bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_UndefinedReg_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_UndefinedReg_DEC_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_UndefinedReg_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_UndefinedReg_DEC_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write Parity Error Interrupt Status Enable Bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_WRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WRPARITY_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WRPARITY_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Address Parity Error Interrupt Status Enable Bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_ADDRPARITY_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_ADDRPARITY_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:04]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTSTATUS_ENABLEREG_5to4</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Status Enable Register (bits 5to4). Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_WrOnHold_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write On Hold Error Interrupt Status Enable Bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_WrOnHold_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WrOnHold_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_WrOnHold_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WrOnHold_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_RD2WO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Read to Write only Error Interrupt Status Enable Bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_RD2WO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_RD2WO_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_RD2WO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_RD2WO_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write to Read only Error Interrupt Status Enable Bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_WR2RO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WR2RO_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WR2RO_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Decode Error Interrupt Status Enable Bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_DEC_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_DEC_ERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_582C36B1BBEBDAF1" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000048</span> Register(64 bit) DMAC_COMMONREG_INTSIGNAL_ENABLEREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Common Register Space Interrupt Signal Enable Register</span><br/>
      <span class="ldescdet">Writing 1 to specific field will propagate the corresponding interrupt status in DMAC Common register Interrupt Status Register (DMAC_CommonReg_IntStatusReg) to generate an port level interrupt.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502048</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0xffffffffffffffff</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="33">RSVD_DMAC_COMMONREG_INTSIGNAL_ENABLEREG_63to31</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_BCH_PROT_BVALID_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH_PROT_RVALID_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_WCH_PROT_WREADY_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_AWCH_PROT_AWREADY_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_ARCH_PROT_ARREADY_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_BCH_PROT_BVALID_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH_PROT_RVALID_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_WCH_PROT_WREADY_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_AWCH_PROT_AWREADY_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_ARCH_PROT_ARREADY_ParErr_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_BCH_PROT_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_BCH_PROT_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH1_PROT_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH1_PROT_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH0_PROT_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF2_RCH0_PROT_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_BCH_PROT_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_BCH_PROT_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH1_PROT_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH1_PROT_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH0_PROT_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_MXIF1_RCH0_PROT_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_UndefinedReg_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_WRPARITY_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_ADDRPARITY_ERR_IntSignal</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_COMMONREG_INTSIGNAL_ENABLEREG_5to4</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_WrOnHold_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_RD2WO_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_WR2RO_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_CommonReg_DEC_ERR_IntSignal</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="33">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="2">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:31]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTSIGNAL_ENABLEREG_63to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Signal Enable Register (bits 63to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1ffffffff;</p>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_BCH_PROT_BVALID_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel BVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_BVALID_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_BVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH_PROT_RVALID_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Data Channel RVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH_PROT_RVALID_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH_PROT_RVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_WCH_PROT_WREADY_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Data Channel WREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_WCH_PROT_WREADY_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_WCH_PROT_WREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_AWCH_PROT_AWREADY_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_ARCH_PROT_ARREADY_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_BCH_PROT_BVALID_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel BVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_BVALID_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_BCH_PROT_BVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_BVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH_PROT_RVALID_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Data Channel RVALID Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH_PROT_RVALID_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH_PROT_RVALID_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH_PROT_RVALID_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:23]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_WCH_PROT_WREADY_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Data Channel WREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_WCH_PROT_WREADY_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_WCH_PROT_WREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_WCH_PROT_WREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[22:22]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_AWCH_PROT_AWREADY_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_ARCH_PROT_ARREADY_ParErr_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection related Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_BCH_PROT_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_UnCorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_BCH_PROT_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Write Response Channel ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_CorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_BCH_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH1_PROT_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_UnCorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH1_PROT_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCHPROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_CorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH1_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH0_PROT_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_UnCorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF2_RCH0_PROT_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 2 Read Channel (Data) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF2_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_CorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF2_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF2_RCH0_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_BCH_PROT_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_UnCorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_BCH_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_BCH_PROT_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Write Response Channel ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_CorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_BCH_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_BCH_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH1_PROT_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_UnCorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH1_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH1_PROT_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_CorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH1_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH1_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH0_PROT_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection related Uncorrectable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_UnCorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH0_PROT_UnCorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_UnCorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_MXIF1_RCH0_PROT_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Manager Interface 1 Read Channel (Data) ECC Protection related Correctable Error Interrupt Status bit.<br/>This bit is used to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_MXIF1_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_CorrERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_MXIF1_RCH0_PROT_CorrERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">MXIF1_RCH0_PROT_CorrERR_IntStat bit in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_UndefinedReg_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Undefined register Decode Error Interrupt Signal Enable Bit.<br/>This bit is used to enable the propagation of corresponding channel interrupt status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_UndefinedReg_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_UndefinedReg_DEC_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_UndefinedReg_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_UndefinedReg_DEC_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_WRPARITY_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error Interrupt Signal Enable Bit.<br/>This bit is used to enable the propagation of corresponding channel interrupt status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_WRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WRPARITY_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_WRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WRPARITY_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_ADDRPARITY_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error Interrupt Signal Enable Bit.<br/>This bit is used to enable the propagation of corresponding channel interrupt status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_ADDRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_ADDRPARITY_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_ADDRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_ADDRPARITY_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:04]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTSIGNAL_ENABLEREG_5to4</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Signal Enable Register (bits 5to4). Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_WrOnHold_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write On Hold Error Interrupt Signal Enable Bit.<br/>This bit is used to enable the propagation of corresponding channel interrupt status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_WrOnHold_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WrOnHold_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_WrOnHold_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WrOnHold_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_RD2WO_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Read to Write only Error Interrupt Signal Enable Bit.<br/>This bit is used to enable the propagation of corresponding channel interrupt status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_RD2WO_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_RD2WO_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_RD2WO_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_RD2WO_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_WR2RO_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write to Read only Error Interrupt Signal Enable Bit.<br/>This bit is used to enable the propagation of corresponding channel interrupt status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_WR2RO_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WR2RO_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_WR2RO_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_WR2RO_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_CommonReg_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Decode Error Interrupt Signal Enable Bit.<br/>This bit is used to enable the propagation of corresponding channel interrupt status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_CommonReg_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_DEC_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Disabled at port level<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_CommonReg_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">SLVIF_CommonReg_DEC_ERR_IntStat signal in DMAC_CommonReg_IntStatusReg is Enabled at port level<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_90CB15F01C1571C4" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000050</span> Register(64 bit) DMAC_COMMONREG_INTSTATUSREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Common Register Space Interrupt Status Register</span><br/>
      <span class="ldescdet">This Register captures Register bus interface access errors.<br/> - Decode Error.<br/> - Write to read only register. <br/> - Read to write only register.<br/> - write on hold.<br/> - undefined address.<br/> - Common Register Space - Write Parity Error
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502050</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="33">RSVD_DMAC_COMMONREG_INTSTATUSREG_63to31</td>
        <td class="fldnorm" colspan="1">MXIF2_BCH_PROT_BVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_RCH_PROT_RVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_WCH_PROT_WREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_BCH_PROT_BVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_RCH_PROT_RVALID_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_WCH_PROT_WREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_BCH_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_BCH_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_RCH1_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_RCH1_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_RCH0_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF2_RCH0_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_BCH_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_BCH_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_RCH1_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_RCH1_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_RCH0_PROT_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">MXIF1_RCH0_PROT_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_UndefinedReg_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_CommonReg_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_CommonReg_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_COMMONREG_INTSTATUSREG_5to4</td>
        <td class="fldnorm" colspan="1">SLVIF_CommonReg_WrOnHold_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_CommonReg_RD2WO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_CommonReg_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_CommonReg_DEC_ERR_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="33">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:31]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTSTATUSREG_63to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Signal Enable Register (bits 63to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_BCH_PROT_BVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Write Response Channel BVALID Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if BVALID Parity error is detected on the Write Response AXI Channel.<br/> - 0: No AXI Manager 2 Write Response Channel BVALID Parity Error.<br/> - 1: AXI Manager 2 Write Response Channel BVALID Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_BVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Response Channel BVALID Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_BVALID_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Response Channel BVALID Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_RCH_PROT_RVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Read Data Channel RVALID Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if RVALID Parity error is detected on the Read Data AXI Channel.<br/> - 0: No AXI Manager 2 Read Data Channel RVALID Parity Error.<br/> - 1: AXI Manager 2 Read Data Channel RVALID Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_RVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Data Channel RVALID Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_RVALID_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Data Channel RVALID Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_WCH_PROT_WREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Write Data Channel WREADY Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if WREADY Parity error is detected on the Write Data AXI Channel.<br/> - 0: No AXI Manager 2 Write Data Channel WREADY Parity Error.<br/> - 1: AXI Manager 2 Write Data Channel WREADY Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_WREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Data Channel WREADY Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_WREADY_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Data Channel WREADY Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if AWREADY Parity error is detected on the Write Address AXI Channel.<br/> - 0: No AXI Manager 2 Write Address Channel AWREADY Parity Error.<br/> - 1: AXI Manager 2 Write Address Channel AWREADY Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_AWREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Address Channel AWREADY Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_AWREADY_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Address Channel AWREADY Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if ARREADY Parity error is detected on the Read Address AXI Channel.<br/> - 0: No AXI Manager 2 Read Address Channel ARREADY Parity Error.<br/> - 1: AXI Manager 2 Read Address Channel ARREADY Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_ARREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Address Channel ARREADY Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_ARREADY_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Address Channel ARREADY Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_BCH_PROT_BVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Write Response Channel BVALID Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if BVALID Parity error is detected on the Write Response AXI Channel.<br/> - 0: No AXI Manager 1 Write Response Channel BVALID Parity Error.<br/> - 1: AXI Manager 1 Write Response Channel BVALID Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_BVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Response Channel BVALID Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_BVALID_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Response Channel BVALID Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_RCH_PROT_RVALID_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Read Data Channel RVALID Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if RVALID Parity error is detected on the Read Data AXI Channel.<br/> - 0: No AXI Manager 1 Read Data Channel RVALID Parity Error.<br/> - 1: AXI Manager 1 Read Data Channel RVALID Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_RVALID_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Data Channel RVALID Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_RVALID_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Data Channel RVALID Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:23]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_WCH_PROT_WREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Write Data Channel WREADY Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if WREADY Parity error is detected on the Write Data AXI Channel.<br/> - 0: No AXI Manager 1 Write Data Channel WREADY Parity Error.<br/> - 1: AXI Manager 1 Write Data Channel WREADY Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_WREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Data Channel WREADY Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_WREADY_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Data Channel WREADY Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[22:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if AWREADY Parity error is detected on the Write Address AXI Channel.<br/> - 0: No AXI Manager 1 Write Address Channel AWREADY Parity Error.<br/> - 1: AXI Manager 1 Write Address Channel AWREADY Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_AWREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Address Channel AWREADY Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_AWREADY_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Address Channel AWREADY Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection Error Interrupt Status bit.<br/><br/>   This error occurs if ARREADY Parity error is detected on the Read Address AXI Channel.<br/> - 0: No AXI Manager 1 Read Address Channel ARREADY Parity Error.<br/> - 1: AXI Manager 1 Read Address Channel ARREADY Parity Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_ARREADY_ParErr</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Address Channel ARREADY Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_ARREADY_ParErr</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Address Channel ARREADY Parity Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_BCH_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Write Response Channel Parity/ECC Protection Uncorrectable Error Interrupt Status bit.<br/><br/>   This error occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel Write Response payload.<br/> - 0: No AXI Manager 2 Write Response Channel Uncorrectable Error.<br/> - 1: AXI Manager 2 Write Response Channel Uncorrectable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Response Channel Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Response Channel Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_BCH_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Write Response Channel ECC Protection Correctable Error Interrupt Status bit.<br/><br/>   This error occurs if ECC Correctable error is detected on the AXI Channel Write Response payload.<br/> - 0: No AXI Manager 2 Write Response Channel Correctable Error.<br/> - 1: AXI Manager 2 Write Response Channel Correctable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Response Channel Correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Write Response Channel Correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_RCH1_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC Protection Uncorrectable Error Interrupt Status bit.<br/><br/>   This error occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel Read Control payload. <br/> - 0: No AXI Manager 2 Read Channel Control signals related Uncorrectable Error.<br/> - 1: AXI Manager 2 Read Channel Control signals related Uncorrectable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Other Control signals) Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Other Control signals) Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_RCH1_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection Correctable Error Interrupt Status bit.<br/><br/>   This error occurs if ECC Correctable error is detected on the AXI Channel Read Control payload. <br/> - 0: No AXI Manager 2 Read Channel Control signals related Correctable Error.<br/> - 1: AXI Manager 2 Read Channel Control signals related Correctable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Other Control signals) Correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Other Control signals) Correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_RCH0_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection Uncorrectable Error Interrupt Status bit.<br/><br/>   This error occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel Read Data payload.<br/> - 0: No AXI Manager 2 Read Channel Data related Uncorrectable Error.<br/> - 1: AXI Manager 2 Read Channel Data related Uncorrectable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Data) Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Data) Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF2_RCH0_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 2 Read Channel (Data) ECC Protection Correctable Error Interrupt Status bit.<br/><br/>   This error occurs if ECC Correctable error is detected on the AXI Channel Read Data payload.<br/> - 0: No AXI Manager 2 Read Channel Data related Correctable Error.<br/> - 1: AXI Manager 2 Read Channel Data related Correctable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Data) Correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 2 Read Channel (Data) Correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_BCH_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Write Response Channel Parity/ECC Protection Uncorrectable Error Interrupt Status bit.<br/><br/>   This error occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel Write Response payload.<br/> - 0: No AXI Manager 1 Write Response Channel Uncorrectable Error.<br/> - 1: AXI Manager 1 Write Response Channel Uncorrectable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Response Channel Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Response Channel Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_BCH_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Write Response Channel ECC Protection Correctable Error Interrupt Status bit.<br/><br/>   This error occurs if ECC Correctable error is detected on the AXI Channel Write Response payload.<br/> - 0: No AXI Manager 1 Write Response Channel Correctable Error.<br/> - 1: AXI Manager 1 Write Response Channel Correctable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Response Channel Correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Write Response Channel Correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_RCH1_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC Protection Uncorrectable Error Interrupt Status bit.<br/><br/>   This error occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel Read Control payload. <br/> - 0: No AXI Manager 1 Read Channel Control signals related Uncorrectable Error.<br/> - 1: AXI Manager 1 Read Channel Control signals related Uncorrectable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Other Control signals) Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Other Control signals) Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_RCH1_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection Correctable Error Interrupt Status bit.<br/><br/>   This error occurs if ECC Correctable error is detected on the AXI Channel Read Control payload. <br/> - 0: No AXI Manager 1 Read Channel Control signals related Correctable Error.<br/> - 1: AXI Manager 1 Read Channel Control signals related Correctable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Other Control signals) Correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Other Control signals) Correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_RCH0_PROT_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection Uncorrectable Error Interrupt Status bit.<br/><br/>   This error occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel Read Data payload.<br/> - 0: No AXI Manager 1 Read Channel Data related Uncorrectable Error.<br/> - 1: AXI Manager 1 Read Channel Data related Uncorrectable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Data) Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Data) Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">MXIF1_RCH0_PROT_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet"><br/>   AXI Manager Interface 1 Read Channel (Data) ECC Protection Correctable Error Interrupt Status bit.<br/><br/>   This error occurs if ECC Correctable error is detected on the AXI Channel Read Data payload.<br/> - 0: No AXI Manager 1 Read Channel Data related Correctable Error.<br/> - 1: AXI Manager 1 Read Channel Data related Correctable Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_PROT_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Data) Correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_PROT_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Manager 1 Read Channel (Data) Correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_UndefinedReg_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Undefined register Decode Error Interrupt Signal Enable Bit.<br/>Decode Error generated by DW_axi_dmac during register access. This error occurs if the register access is to undefined address range (&gt;0x8FF if 8 channels are configured, &gt;0x4FF if 4 channels are configured etc.) resulting in error response by DW_axi_dmac register bus interface. <br/> - 0: No Register Bus Interface Decode Errors.<br/> - 1: Register Bus Interface Decode Error detected.<br/>Error Interrupt Status is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set to 1. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG on enabling the channel (required when the interrupt is not enabled).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_UndefinedReg_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_UndefinedReg_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_CommonReg_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write Parity Error Interrupt Status Bit.<br/>This error occurs if write operation with data and parity is performed to a register in the common register space, but the locally computed parity bits not matching the received parity bits. <br/> - 0: No Common Register Space Write Parity Error.<br/> - 1: Common Register Space Write Parity Error detected.<br/>Error Interrupt Status is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG (required when the interrupt is not enabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_CommonReg_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Common Register Write Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_CommonReg_WRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Common Register Write Parity Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_CommonReg_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Address Parity Error Interrupt Status Bit.<br/>This error occurs if address is used to do write/read operation to a register in the common register space, but the locally computed parity bits not matching the received parity bits. <br/> - 0: No Common Register Space Address Parity Error.<br/> - 1: Common Register Space Address Parity Error detected.<br/>Error Interrupt Status is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG (required when the interrupt is not enabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_CommonReg_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Common Register Address Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_CommonReg_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Common Register Address Parity Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:04]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_COMMONREG_INTSTATUSREG_5to4</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Common Register Interrupt Status Register (bits 5to4) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_CommonReg_WrOnHold_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write On Hold Error Interrupt Status Bit.<br/>This error occurs if an illegal write operation is performed on a common register; this happens if a write operation is performed on a common register except DMAC_RESETREG with DMAC_RST field set to 1 when DW_axi_dmac is in Hold mode. <br/> - 0: No Register Bus Interface Common Register Write On Hold Errors.<br/> - 1: Register Bus Interface Common Register Write On Hold Error detected.<br/>Error Interrupt Status is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set to 1. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG on enabling the channel (required when the interrupt is not enabled).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_CommonReg_WrOnHold_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Common Register Write On Hold Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_CommonReg_WrOnHold_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Common Register Write On Hold Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_CommonReg_RD2WO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Read to Write only Error Interrupt Status bit.<br/>This error occurs if Read operation is performed to a Write Only register in the common register space (0x000 to 0x0FF). <br/> - 0: No Register Bus Interface Read to Write Only Errors.<br/> - 1: Register Bus Interface Read to Write Only Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set to 1. This bit is cleared to 0 on writing 1 to the corresponding<br/>channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG on enabling the channel (required when the interrupt is not enabled).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_CommonReg_RD2WO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Read to Write Only Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_CommonReg_RD2WO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Read to Write Only Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_CommonReg_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Write to Read Only Error Interrupt Status bit.<br/>This error occurs if write operation is performed to a Read Only register in the common register space (0x000 to 0x0FF). <br/> - 0: No Register Bus Interface Write to Read Only Errors.<br/> - 1: Register Bus Interface Write to Read Only Error detected.<br/>Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set to 1. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG on enabling the channel (required when the interrupt is not enabled).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_CommonReg_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write to Read Only Errors<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_CommonReg_WR2RO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Register Bus Interface Write to Read Only Error detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_CommonReg_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Common Register Decode Error Interrupt Status Bit.<br/>Decode Error generated by DW_axi_dmac during register access. This error occurs if<br/>the register access is to an invalid address in the common register space (0x000 to 0x0FF) resulting in error response by DW_axi_dmac register bus interface.<br/> - 0: No Register Bus Interface Decode Errors.<br/> - 1: Register Bus Interface Decode Error detected.<br/>The Error Interrupt status is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set to 1. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG on enabling the channel (required when the interrupt is not enabled).</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Active_CommonReg_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Inactive_CommonReg_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_B1AA85F392679312" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000058</span> Register(64 bit) DMAC_RESETREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Software Reset Register</span><br/>
      <span class="ldescdet">This register is used to initiate the Software Reset to DW_axi_dmac.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502058</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="63">RSVD_DMAC_ResetReg_1to63</td>
        <td class="fldnorm" colspan="1">DMAC_RST</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="63">RO/V</td>
        <td class="accno" colspan="1">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:01]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_ResetReg_1to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC_ResetReg (bits 1to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMAC_RST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Reset Request bit<br/>Software writes 1 to this bit to reset the DW_axi_dmac and polls this bit to see it as 0. DW_axi_dmac resets all the modules<br/>except the register bus interface module and clears this bit to 0.<br/>Note: Software is not allowed to write 0 to this bit.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_014C3EAC492811F1" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000100</span> Register(64 bit) CH1_SAR</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Source Address Register</span><br/>
      <span class="ldescdet">The starting source address is programmed by software before the DMA channel is enabled, or by an LLI update before the start of the DMA transfer. While<br/>the DMA transfer is in progress, this register is updated to reflect the source address of the current AXI transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502100</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="64">SAR</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="64">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SAR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Current Source Address of DMA transfer.<br/>Updated after each source transfer. The SINC fields in the CHx_CTL register determines whether the address increments or is left unchanged on every source transfer throughout the block transfer.</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_2EAC2F08F2BA6DFA" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000108</span> Register(64 bit) CH1_DAR</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Destination Address Register</span><br/>
      <span class="ldescdet">The starting destination address is programmed by the software before the DMA channel is enabled, or by an LLI update before the start of the DMA transfer.<br/>While the DMA transfer is in progress, this register is updated to reflect the destination address of the current AXI transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502108</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="64">DAR</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="64">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DAR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Current Destination Address of DMA transfer.<br/>Updated after each destination transfer. The DINC fields in the CHx_CTL register determines whether the address increments or is left unchanged on every destination transfer throughout the block transfer.</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_E350ABEC79FCF5FB" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000110</span> Register(64 bit) CH1_BLOCK_TS</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Block Transfer Size Register</span><br/>
      <span class="ldescdet">When DW_axi_dmac is the flow controller, the DMAC uses this register before the channel is enabled for block-size.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502110</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="42">RSVD_DMAC_CHx_BLOCK_TSREG_63to22</td>
        <td class="fldnorm" colspan="22">BLOCK_TS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="42">RO/V</td>
        <td class="accno" colspan="22">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_BLOCK_TSREG_63to22</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Block Transfer Size Register (bits 63to22) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">BLOCK_TS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Size.<br/>The number programmed into BLOCK_TS field indicates the total number of data of width CHx_CTL.SRC_TR_WIDTH to be transferred in a DMA block transfer.<br/>Block Transfer Size = BLOCK_TS+1<br/>Note: The value programmed to the BLOCK_TS field must be greater than or equal to the source or destination transfer width and the read back value of BLOCK_TS field is always the value programmed into it. This register field is not applicable when source or destination is flow controller and it is applicable when DMA is flow controller.</span></p>
          <p><b>Reset: </b>hex:0x000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_4D756300A696A72A" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000118</span> Register(64 bit) CH1_CTL</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Control Register</span><br/>
      <span class="ldescdet">This register contains fields that control the DMA transfer. This register should be programmed prior to enabling the channel except for LLI-based multi-block transfer. When LLI-based multi-block transfer is enabled, the CHx_CTL register is loaded from the corresponding location of the LLI and it can be varied on a block-by-block basis within a DMA transfer. The software is not allowed to directly update this register through DW_axi_dmac register bus interface. Any write to this register during LLI based multi-block transfer is ignored.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502118</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000003600</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="1">SHADOWREG_OR_LLI_VALID</td>
        <td class="fldnorm" colspan="1">SHADOWREG_OR_LLI_LAST</td>
        <td class="fldnorm" colspan="3">RSVD_DMAC_CHx_CTL_59to61</td>
        <td class="fldnorm" colspan="1">IOC_BlkTfr</td>
        <td class="fldnorm" colspan="1">DST_STAT_EN</td>
        <td class="fldnorm" colspan="1">SRC_STAT_EN</td>
        <td class="fldnorm" colspan="8">AWLEN</td>
        <td class="fldnorm" colspan="1">AWLEN_EN</td>
        <td class="fldnorm" colspan="8">ARLEN</td>
        <td class="fldnorm" colspan="1">ARLEN_EN</td>
        <td class="fldnorm" colspan="3">AW_PROT</td>
        <td class="fldnorm" colspan="3">AR_PROT</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_31</td>
        <td class="fldnorm" colspan="1">NonPosted_LastWrite_En</td>
        <td class="fldnorm" colspan="4">AW_CACHE</td>
        <td class="fldnorm" colspan="4">AR_CACHE</td>
        <td class="fldnorm" colspan="4">DST_MSIZE</td>
        <td class="fldnorm" colspan="4">SRC_MSIZE</td>
        <td class="fldnorm" colspan="3">DST_TR_WIDTH</td>
        <td class="fldnorm" colspan="3">SRC_TR_WIDTH</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_7</td>
        <td class="fldnorm" colspan="1">DINC</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_5</td>
        <td class="fldnorm" colspan="1">SINC</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_3</td>
        <td class="fldnorm" colspan="1">DMS</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_1</td>
        <td class="fldnorm" colspan="1">SMS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="3">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="8">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="8">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="3">RW</td>
        <td class="accno" colspan="3">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="3">RO</td>
        <td class="accno" colspan="3">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:63]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SHADOWREG_OR_LLI_VALID</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register content/Linked List Item valid.<br/>Indicates whether the content of shadow register or the linked list item fetched from the memory is valid.<br/> - 0: Shadow Register content/LLI is invalid.<br/> - 1: Last Shadow Register/LLI is valid.<br/>LLI based multi-block transfer: The CHx_CTL register is loaded from the LLI. Hence, the software is not allowed to directly update this register through the DW_axi_dmac subordinate<br/>interface.<br/>This field can be used to dynamically extend the LLI by the software. On noticing this bit as 0, DW_axi_dmac discards the LLI and generates the ShadowReg_Or_LII_Invalid_ERR Interrupt if<br/>the corresponding channel error interrupt mask bit is set to 0.<br/>In the case of LLI pre-fetching, the ShadowReg_Or_LLI_Invalid_ERR interrupt is not generated even if the ShadowReg_Or_LLI_Valid bit<br/>is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac attempts the LLI fetch operation again after completing the current block transfer and generates the ShadowReg_Or_LII_Invalid_ERR<br/>interrupt only if ShadowReg_Or_LII_Valid bit is still seen to be 0.<br/>This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully. DW_axi_dmac waits until software writes<br/>(any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid LLI availability before attempting another LLI read operation. This bit is cleared to 0 and written back to the corresponding LLI location<br/>after block transfer completion when LLI write-back option is enabled. Hence, for LLI-based multi-block transfers, the software might manipulate/redefine any descriptor with the ShadowReg_Or_LII_Valid<br/>bit set to 0 if LLI write-back option is enabled.<br/>Shadow Reg based multi-block transfer: On noticing this bit as 0 during shadow register fetch phase, DW_axi_dmac discards the Shadow Register<br/>contents and generates ShadowReg_Or_LLI_Invlid_ERR Interrupt. In this case, the software has to write (any value) to CHx_BLK_TFR_ResumeReqReg after updating the shadow registers and after setting<br/>ShadowReg_Or_LLI_Valid bit to 1 to indicate to DW_axi_dmac that shadow register contents are valid and the next block transfer can be resumed.<br/>DW_axi_dmac clears this bit to 0 after copying the<br/>shadow register contents. Software can reprogram the shadow registers only if ShadowReg_Or_LLI_Valid bit is 0. Software needs to read this register in block completion interrupt service routine (if<br/>interrupt is enabled)/continuously poll this register (if interrupt is not enabled) to make sure that this bit is 0 before updating the shadow registers.<br/>If shadow-register-based multi-block<br/>transfer is enabled and software attempts to write to the shadow register when ShadowReg_Or_LLI_Valid bit is 1, DW_axi_dmac generates SLVIF_ShadowReg_WrOnValid_ERR interrupt.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">INVALID</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is Invalid<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">VALID</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is Valid<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[62:62]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SHADOWREG_OR_LLI_LAST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Last Shadow Register/Linked List Item.<br/>Indicates whether shadow register content or the linked list item fetched from the memory is the last one or not.<br/> - 0: Not last Shadow Register/LLI<br/> - 1: Last Shadow Register/LLI<br/>LLI based multi-block transfer: DW_axi_dmac uses this bit to decide if another LLI fetch is needed in the current DMA transfer.<br/> - If this bit is 0, DW_axi_dmac fetches the next LLI from the address pointed out by LLP field in the current LLI.<br/> - If this bit is 1, DW_axi_dmac understands that current block is the final block in the dma transfer and ends the dma transfer once the AMBA transfer corresponding to the current block completes.<br/>Shadow Reg based multi-block transfer: DW_axi_dmac uses this bit to decide if another Shadow Register fetch is needed in the current DMA transfer.<br/> - If this bit is 0, DW_axi_dmac understands that there are one or more blocks to be transferred in the current block and hence one or more shadow register set contents will be valid and needs to be fetched.<br/> - If this bit is 1, DW_axi_dmac understands that current block is the final block in the dma transfer and ends the dma transfer once the AMBA transfer corresponding to the current block completes.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">LAST_ITEM</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is the last one<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NOT_LAST_ITEM</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is not the last one<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[61:59]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_59to61</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register (bits 59to61) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[58:58]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">IOC_BlkTfr</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Interrupt On completion of Block Transfer<br/>This bit is used to control the block transfer completion interrupt generation on a block by block<br/>basis for shadow register or linked list based multi-block transfers. Writing 1 to this register field enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat field if this interrupt generation is enabled in<br/>CHx_IntStatus_EnableReg register and the external interrupt output is asserted if this interrupt generation is enabled in CHx_IntSignal_EnableReg register.<br/>Note: If a linked-list or<br/>shadow-register-based multi-block transfer is not used for both source and destination (for instance if source and destination use contiguous address or auto-reload-based multi-block transfer), the<br/>value of this field cannot be modified per block. Additionally, the value programmed before the channel is enabled is used for all the blocks in the DMA transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_BLKTFR_INTR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat field<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_BLKTFR_INTR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat field<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[57:57]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_STAT_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Status Enable<br/>Enable the logic to fetch status from destination peripheral of channel x pointed to by the content of CHx_DSTATAR register and stores it in CHx_DSTAT register. This value is written back to the CHx_DSTAT location of linked list at end of each block transfer if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block transfer is used by either source or destination peripheral.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Enable_STAT_FETCH</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables status fetch for Destination and store the value in CH1_DSTAT register<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_STAT_FETCH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No status fetch for Destination device<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[56:56]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_STAT_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Status Enable<br/>Enable the logic to fetch status from source peripheral of channel x pointed to by the content of CHx_SSTATAR register and stores it in CHx_SSTAT register. This value is written back to the CHx_SSTAT location of linked list at end of each block transfer if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block transfer is used by either source or destination peripheral.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Enable_STAT_FETCH</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables status fetch for Source and store the value in CH1_SSTAT register<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_STAT_FETCH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No status fetch for Source device<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[55:48]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AWLEN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Burst Length<br/>AXI Burst length used for destination data transfer. The specified burst length is used for destination data transfer<br/>till the extent possible; remaining transfers use maximum possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.<br/>The maximum value of AWLEN is limited by<br/>DMAX_CHx_MAX_AMBA_BURST_LENGTH.<br/>Note: The AWLEN setting may not be honored towards end-to-block transfers, the end of a transaction (only applicable to non-memory peripherals), and during<br/>4K boundary crossings.</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[47:47]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AWLEN_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Burst Length Enable<br/>If this bit is set to 1, DW_axi_dmac uses the value of CHx_CTL.AWLEN as AXI Burst length for destination data<br/>transfer till the extent possible; remaining transfers use maximum possible burst length.<br/>If this bit is set to 0, DW_axi_dmac uses any possible value which is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH as AXI Burst length for destination data transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Burst Length is any possible value <= DMAX_CH1_MAX_AMBA_BURST_LENGTH for Destination data transfers<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Burst Length is CH1_CTL.AWLEN (till the extent possible) for Destination data transfers<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[46:39]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ARLEN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Burst Length<br/>AXI Burst length used for source data transfer. The specified burst length is used for source data transfer till the extent<br/>possible; remaining transfers use maximum possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.<br/>The maximum value of ARLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[38:38]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ARLEN_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Burst Length Enable<br/>If this bit is set to 1, DW_axi_dmac uses the value of CHx_CTL.ARLEN as AXI Burst length for source data transfer<br/>till the extent possible; remaining transfers use maximum possible burst length.<br/>If this bit is set to 0, DW_axi_dmac uses any possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH as AXI Burst length for source data transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Burst Length is any possible value <= DMAX_CH1_MAX_AMBA_BURST_LENGTH for Source data transfers<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Burst Length is CH1_CTL.ARLEN (till the extent possible) for Source data transfers<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[37:35]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AW_PROT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'aw_prot' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[34:32]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AR_PROT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'ar_prot' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit31 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">NonPosted_LastWrite_En</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Non Posted Last Write Enable<br/>This bit decides whether posted writes can be used throughout the block transfer.<br/> - 0: Posted writes may be used throughout the block transfer.<br/> - 1: Posted writes may be used till the end of the block (inside a block) and the last write in the block must be non-posted. This is to synchronize block completion interrupt generation to the last write data reaching the end memory/peripheral.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Posted writes may be used throughout the block transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Last write in the block must be non-posted<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:26]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AW_CACHE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'aw_cache' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:22]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AR_CACHE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'ar_cache' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:18]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_MSIZE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Burst Transaction Length.<br/>Number of data items, each of width CHx_CTL.DST_TR_WIDTH, to be written to the destination every time a<br/>destination burst transaction request is made from the corresponding hardware or software handshaking interface.<br/>Note: This Value is not related to the AXI awlen signal.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_1024</td>
          <td class="unboxed addr">0x09</td>
          <td class="unboxed scdescmap">1024 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_128</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">128 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_16</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">16 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_256</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">256 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_32</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">32 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_4</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">4 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_512</td>
          <td class="unboxed addr">0x08</td>
          <td class="unboxed scdescmap">512 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_64</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">64 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_8</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">8 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEM_1</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">1 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:14]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_MSIZE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Burst Transaction Length.<br/>Number of data items, each of width CHx_CTL.SRC_TR_WIDTH, to be read from the source every time a source<br/>burst transaction request is made from the corresponding hardware or software handshaking interface. The maximum value of DST_MSIZE is limited by DMAX_CHx_MAX_MSIZE.<br/>Note: This Value is not related to the AXI arlen signal.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_1024</td>
          <td class="unboxed addr">0x09</td>
          <td class="unboxed scdescmap">1024 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_128</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">128 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_16</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">16 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_256</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">256 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_32</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">32 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_4</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">4 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_512</td>
          <td class="unboxed addr">0x08</td>
          <td class="unboxed scdescmap">512 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_64</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">64 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_8</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">8 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEM_1</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">1 Data Item read from Source in the burst transaction<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:11]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_TR_WIDTH</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transfer Width.<br/>Mapped to AXI bus awsize, this value must be less than or equal to DMAX_M_DATA_WIDTH.</span></p>
          <p><b>Reset: </b>hex:0x6;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BITS_1024</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 1024 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_128</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 128 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_16</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 16 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_256</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 256 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_32</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 32 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_512</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 512 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_64</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 64 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_8</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 8 bits<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:08]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_TR_WIDTH</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transfer Width.<br/>Mapped to AXI bus arsize, this value must be less than or equal to DMAX_M_DATA_WIDTH.</span></p>
          <p><b>Reset: </b>hex:0x6;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BITS_1024</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">Source Transfer Width is 1024 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_128</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">Source Transfer Width is 128 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_16</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source Transfer Width is 16 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_256</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">Source Transfer Width is 256 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_32</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Source Transfer Width is 32 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_512</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">Source Transfer Width is 512 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_64</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Source Transfer Width is 64 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_8</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source Transfer Width is 8 bits<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_7</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit7 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DINC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Address Increment.<br/>Indicates whether to increment the destination address on every destination transfer. If the device is writing data from a source peripheral FIFO with a fixed address, then set this field to 'No change'.<br/> - 0: Increment <br/> - 1: No Change<br/>NOTE: Increment aligns the address to the next CHx_CTL.DST_TR_WIDTH boundary.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">FIXED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination address is fixed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INCREMENTAL</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination address incremented on every source transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_5</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit5 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SINC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Address Increment.<br/>Indicates whether to increment the source address on every source transfer. If the device is fetching data from a source peripheral FIFO with a fixed address, then set this field to 'No change'.<br/> - 0: Increment <br/> - 1: No Change<br/>NOTE: Increment aligns the address to the next CHx_CTL.SRC_TR_WIDTH boundary.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">FIXED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source address is fixed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INCREMENTAL</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source address incremented on every source transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_3</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit3 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Manager Select.<br/>Identifies the Manager Interface layer from which the destination device (peripheral or memory) is accessed.<br/> - 0: AXI manager 1 <br/> - 1: AXI Manager 2<br/></span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MASTER1_INTF</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination device on Manager-1 interface layer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MASTER2_INTF</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination device on Manager-2 interface layer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_1</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit1 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SMS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Manager Select.<br/>Identifies the Manager Interface layer from which the source device (peripheral or memory) is accessed.<br/> - 0: AXI manager 1 <br/> - 1: AXI Manager 2<br/></span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MASTER1_INTF</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source device on Manager-1 interface layer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MASTER2_INTF</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source device on Manager-2 interface layer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_C0C937AC85248272" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000120</span> Register(64 bit) CH1_CFG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Configuration Register</span><br/>
      <span class="ldescdet">This register contains fields that configure the DMA transfer. This register should be programmed prior to enabling the channel.<br/>Bits [63:32] of the<br/>channel configuration register remains fixed for all blocks of a multi-block transfer and can be programmed only when channel is disabled.<br/>Bits [3:0] of the channel configuration register can be<br/>programmed even when channel is enabled.<br/>Software clears these bits to end the multi-block transfers. For Contiguous-Address and Auto-Reloading-based multi-block transfers (if neither source nor destination peripheral uses Shadow-Register or Linked-List-based multi-block transfers), if the corresponding multi-block type selection bits namely CHx_CFG.SRC_MLTBLK_TYPE and/or CHx_CFG.DST_MLTBLK_TYPE bits are seen to be 2'b00 at the end of a block transfer, the DW_axi_dmac understands that the previous block was the final block in the transfer and completes the DMA transfer operation.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502120</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0002001b00000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CFG_63</td>
        <td class="fldnorm" colspan="4">DST_OSR_LMT</td>
        <td class="fldnorm" colspan="4">SRC_OSR_LMT</td>
        <td class="fldnorm" colspan="2">LOCK_CH_L</td>
        <td class="fldnorm" colspan="1">LOCK_CH</td>
        <td class="fldnorm" colspan="3">CH_PRIOR</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CFG_48</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_CFG_47_44</td>
        <td class="fldnorm" colspan="2">DST_PER</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CFG_43</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_CFG_42_39</td>
        <td class="fldnorm" colspan="2">SRC_PER</td>
        <td class="fldnorm" colspan="1">DST_HWHS_POL</td>
        <td class="fldnorm" colspan="1">SRC_HWHS_POL</td>
        <td class="fldnorm" colspan="1">HS_SEL_DST</td>
        <td class="fldnorm" colspan="1">HS_SEL_SRC</td>
        <td class="fldnorm" colspan="3">TT_FC</td>
        <td class="fldnorm" colspan="3">RSVD_DMAC_CHx_CFG_29to31</td>
        <td class="fldnorm" colspan="4">WR_UID</td>
        <td class="fldnorm" colspan="3">RSVD_DMAC_CHx_CFG_22to24</td>
        <td class="fldnorm" colspan="4">RD_UID</td>
        <td class="fldnorm" colspan="14">RSVD_DMAC_CHx_CFG_4to17</td>
        <td class="fldnorm" colspan="2">DST_MULTBLK_TYPE</td>
        <td class="fldnorm" colspan="2">SRC_MULTBLK_TYPE</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="4">RW/V</td>
        <td class="accno" colspan="4">RW/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="3">RW/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="2">RW/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="2">RW/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="3">RW/V</td>
        <td class="accno" colspan="3">RO/V</td>
        <td class="accno" colspan="4">RO/V</td>
        <td class="accno" colspan="3">RO/V</td>
        <td class="accno" colspan="4">RO/V</td>
        <td class="accno" colspan="14">RO/V</td>
        <td class="accno" colspan="2">RW/V</td>
        <td class="accno" colspan="2">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:63]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (63bit) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[62:59]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_OSR_LMT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Outstanding Request Limit<br/> - Maximum outstanding request supported is 16.<br/> - Destination Outstanding Request Limit = DST_OSR_LMT + 1</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[58:55]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_OSR_LMT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Outstanding Request Limit<br/> - Maximum outstanding request supported is 16.<br/> - Source Outstanding Request Limit = SRC_OSR_LMT + 1</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[54:53]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LOCK_CH_L</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Level<br/>This bit indicates the duration over which CHx_CFG.LOCK_CH bit applies.<br/> - 00: Over complete DMA transfer<br/> - 01: Over DMA block transfer<br/> - 1x: Reserved<br/>This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN is set to False; in that case, the read-back value is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BLOCK_TRANFER_CH_LOCK</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Duration of the Channel locking is for the current block transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DMA_transfer_CH_LOCK</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Duration of the Channel locking is for the entire DMA transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[52:52]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LOCK_CH</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock bit<br/>When the channel is granted control of the manager bus interface and if the CHx_CFG.LOCK_CH bit is asserted, then no other<br/>channels are granted control of the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L. Indicates to the manager bus interface arbiter that this channel wants exclusive access to<br/>the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L.<br/>This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN is set to False; in this case, the<br/>read-back value is always 0.<br/>Locking the channel locks AXI Read Address, Write Address and Write Data channels on the corresponding manager interface.<br/>Note: Channel locking feature is<br/>supported only for memory-to-memory transfer at Block Transfer and DMA Transfer levels. Hardware does not check for the validity of channel locking setting, hence the software must take care of<br/>enabling the channel locking only for memory-to-memory transfers at Block Transfer or DMA Transfer levels. Illegal programming of channel locking might result in unpredictable behavior.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CHANNEL_LOCK</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is locked and granted exclusive access to the Manager Bus Interface<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_CHANNEL_LOCK</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not locked during the transfers<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[51:49]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_PRIOR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Priority<br/>A priority of DMAX_NUM_CHANNELS-1 is the highest priority, and 0 is the lowest. This field must be programmed within the following range:<br/><br/>     0: DMAX_NUM_CHANNELS-1<br/>A programmed value outside this range will cause erroneous behavior.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[48:48]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_48</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (48bit) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[47:46]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_47_44</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+44) to 47) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[45:44]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_PER</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to the destination of Channelx if the CHx_CFG.HS_SEL_DST field is 0;<br/>otherwise, this field is ignored. The channel can then communicate with the destination peripheral connected to that interface through the assigned hardware handshaking interface.<br/><br/>Note: For correct DW_axi_dmac operation, only one peripheral (source or destination) should be assigned to the same handshaking interface. <br/>This field does not exist if the configuration<br/>parameter DMAX_NUM_HS_IF is set to 0.<br/>x = 44 if DMAC_NUM_HS_IF is 1<br/>x = ceil(log2(DMAC_NUM_HS_IF)) + 43 if DMAC_NUM_HS_IF is greater than 1<br/>Bits 47: (x+1) do not exist and return 0 on a read.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[43:43]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_43</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (43bit) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[42:41]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_42_39</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+39) to 42) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[40:39]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_PER</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to the source of Channelx if the CHx_CFG.HS_SEL_SRC field is 0; otherwise,<br/>this field is ignored. The channel can then communicate with the source peripheral connected to that interface through the assigned hardware handshaking interface.<br/><br/>Note: For correct DW_axi_dmac operation, only one peripheral (source or destination) should be assigned to the same handshaking interface.<br/>This field does not exist if the configuration<br/>parameter DMAX_NUM_HS_IF is set to 0.<br/>x = 39 if DMAC_NUM_HS_IF is 1<br/>x = ceil(log2(DMAC_NUM_HS_IF) + 38 if DMAC_NUM_HS_IF is greater than 1.<br/>Bits 42: (x+1) do not exist and return 0 on a read.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[38:38]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_HWHS_POL</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Hardware Handshaking Interface Polarity.<br/> - 0: ACTIVE HIGH<br/> - 1: ACTIVE LOW <br/>Note: This field is reserved for future use and currently this is always active high.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_HIGH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Destination peripheral is Active High<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LOW</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Destination peripheral is Active Low<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[37:37]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_HWHS_POL</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Hardware Handshaking Interface Polarity.<br/> - 0: ACTIVE HIGH<br/> - 1: ACTIVE LOW <br/>Note: This field is reserved for future use and currently this is always active high.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_HIGH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Source peripheral is Active High<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LOW</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Source peripheral is Active Low<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[36:36]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">HS_SEL_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Software or Hardware Handshaking Select.<br/>This register selects which of the handshaking interfaces (hardware or software) is active for destination requests on this channel.<br/> - 0: Hardware handshaking interface. Software-initiated transaction requests are ignored.<br/> - 1: Software handshaking interface. Hardware-initiated transaction requests are ignored.<br/>If the destination peripheral is memory, then this bit is ignored.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">HARDWARE_HS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Hardware Handshaking Interface is used for the Destination peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SOFTWARE_HS</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Software Handshaking Interface is used for the Destination peripheral<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">HS_SEL_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Software or Hardware Handshaking Select.<br/>This register selects which of the handshaking interfaces (hardware or software) is active for source requests on this channel.<br/> - 0: Hardware handshaking interface. Software-initiated transaction requests are ignored.<br/> - 1: Software handshaking interface. Hardware-initiated transaction requests are ignored.<br/>If the source peripheral is memory, then this bit is ignored.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">HARDWARE_HS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Hardware Handshaking Interface is used for the Source peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SOFTWARE_HS</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Software Handshaking Interface is used for the Source peripheral<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:32]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">TT_FC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Transfer Type and Flow Control.<br/>The following transfer types are supported.<br/> - Memory to Memory <br/> - Memory to Peripheral <br/> - Peripheral to Memory <br/> - Peripheral to Peripheral <br/> Flow Control can be assigned to the DW_axi_dmac, the source peripheral, or the destination peripheral.</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MEM_TO_MEM_DMAC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Transfer Type is memory to memory and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MEM_TO_PER_DMAC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Transfer Type is memory to peripheral and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MEM_TO_PER_DST</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">Transfer Type is memory to peripheral and Flow Controller is Destination peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_MEM_DMAC</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to memory and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_MEM_SRC</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to Memory and Flow Controller is Source peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_PER_DMAC</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to peripheral and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_PER_DST</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to peripheral and Flow Controller is Destination peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_PER_SRC</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to peripheral and Flow Controller is Source peripheral<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:29]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_29to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits 29to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[28:25]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">WR_UID</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Defines the number of AXI Unique ID's supported for the AXI Write Channel. The value programmed must be less than or equal to DMAX_CH(x)_WR_UID. Otherwise, it is limited by the value DMAX_CH(x)_WR_UID.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[24:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_22to24</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits 22to24) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:18]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RD_UID</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Defines the number of AXI Unique ID's supported for the AXI Read Channel. The value programmed must be less than or equal to DMAX_CH(x)_RD_UID. Otherwise, it is limited by the value DMAX_CH(x)_RD_UID.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[17:04]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_4to17</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits 4to17) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:02]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_MULTBLK_TYPE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Multi Block Transfer Type.<br/>These bits define the type of multi-block transfer used for destination peripheral.<br/> - 00: Contiguous<br/> - 01: Reload<br/> - 10: Shadow Register<br/> - 11: Linked List<br/>If the type selected is Contiguous, the CHx_DAR register is loaded with the value of the end source address of previous block + 1 at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Reload, the CHx_DAR register is reloaded from the initial value of DAR at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Shadow Register, the CHx_DAR register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1<br/>at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>If the type selected is Linked List, the CHx_DAR register is loaded from the Linked List if<br/>CTL.ShadowReg_Or_LLI_Valid bit is set to 1 at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>CHx_CTL and CHx_BLOCK_TS registers are loaded from<br/>their initial values or from the contents of their shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set to 1) at<br/>the end of every block for multi-block transfers based on the multi-block transfer type programmed for source and destination peripherals.<br/>Contiguous transfer on both source and destination<br/>peripheral is not a valid multi-block transfer configuration.<br/>This field does not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is not selected; in that case, the read-back value is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CONTINGUOUS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Contiguous Multiblock Type used for Destination Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">LINKED_LIST</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Linked List based Multiblock Type used for Destination Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">RELOAD</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Reload Multiblock Type used for Destination Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SHADOW_REGISTER</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Shadow Register based Multiblock Type used for Destination Transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_MULTBLK_TYPE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Multi Block Transfer Type.<br/>These bits define the type of multi-block transfer used for source peripheral.<br/> - 00: Contiguous<br/> - 01: Reload<br/> - 10: Shadow Register<br/> - 11: Linked List<br/>If the type selected is Contiguous, the CHx_SAR register is loaded with the value of the end source address of previous block + 1 at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Reload, the CHx_SAR register is reloaded from the initial value of SAR at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Shadow Register, the CHx_SAR register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1<br/>at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>If the type selected is Linked List, the CHx_SAR register is loaded from the Linked List if<br/>CTL.ShadowReg_Or_LLI_Valid bit is set to 1 at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>CHx_CTL and CHx_BLOCK_TS registers are loaded from<br/>their initial values or from the contents of their shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set to 1) at<br/>the end of every block for multi-block transfers based on the multi-block transfer type programmed for source and destination peripherals.<br/>Contiguous transfer on both source and destination<br/>peripheral is not a valid multi-block transfer configuration.<br/>This field does not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is not selected; in that case, the read-back value is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CONTINGUOUS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Contiguous Multiblock Type used for Source Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">LINKED_LIST</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Linked List based Multiblock Type used for Source Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">RELOAD</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Reload Multiblock Type used for Source Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SHADOW_REGISTER</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Shadow Register based Multiblock Type used for Source Transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_71B145535A8D3187" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000128</span> Register(64 bit) CH1_LLP</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Linked List Pointer Register</span><br/>
      <span class="ldescdet">This is the Linked List Pointer register. This register must be programmed to point to the first Linked List Item (LLI) in memory prior to enabling the<br/>channel if linked-list-based block chaining is enabled. This register is updated with new value of linked list pointer during the LLI update stage of dma transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502128</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="58">LOC</td>
        <td class="fldnorm" colspan="5">RSVD_DMAC_CHx_LLP_1to5</td>
        <td class="fldnorm" colspan="1">LMS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="58">RW/V</td>
        <td class="accno" colspan="5">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:06]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LOC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Starting Address Memory of LLI block<br/>Starting Address In Memory of next LLI if block chaining is enabled. The six LSBs of the starting address<br/>are not stored because the address is assumed to be aligned to a 64-byte boundary.<br/>LLI access always uses the burst size (arsize/awsize) that is same as the data bus width and cannot be changed or<br/>programmed to anything other than this. Burst length (awlen/arlen) is chosen based on the data bus width so that the access does not cross one complete LLI structure of 64 bytes. DW_axi_dmac will fetch<br/>the entire LLI (40 bytes) in one AXI burst if the burst length is not limited by other settings.</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[05:01]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_LLP_1to5</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Linked List Pointer Register (bits 1to5) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LMS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI manager Select<br/>This bit identifies the AXI layer/interface where the memory device that stores the next linked list item resides. <br/> - 0: AXI Manager 1<br/> - 1: AXI Manager 2<br/>This field does not exist if the configuration parameter DMAX_CHx_LMS is not set to NO_HARDCODE.<br/>In this case, the read-back value is always the hardcoded value. The maximum value of this field that can be read back is 'DMAX_NUM_MASTER_IF-1'.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MANAGER1_INTF</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">next Linked List item resides on AXI Manager1 interface<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MANAGER2_INTF</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">next Linked List item resides on AXI Manager2 interface<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_4A4FE61B784354CE" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000130</span> Register(64 bit) CH1_STATUSREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Status Register</span><br/>
      <span class="ldescdet">Channelx Status Register contains fields that indicate the status of DMA transfers for Channelx.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502130</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="17">RSVD_DMAC_CHx_STATUSREG_47to63</td>
        <td class="fldnorm" colspan="15">DATA_LEFT_IN_FIFO</td>
        <td class="fldnorm" colspan="10">RSVD_DMAC_CHx_STATUSREG_22to31</td>
        <td class="fldnorm" colspan="22">CMPLTD_BLK_TFR_SIZE</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="17">RO/V</td>
        <td class="accno" colspan="15">RO/V</td>
        <td class="accno" colspan="10">RO/V</td>
        <td class="accno" colspan="22">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:47]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_STATUSREG_47to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Status Register (bits 47to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[46:32]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DATA_LEFT_IN_FIFO</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Data Left in FIFO.<br/> The data left in the FIFO status indicates the total number of data left in the channel FIFO after completing the current DMA block transfer or DMA block abnormal termination due to the following reasons: <br/> - AXI Transfer Error response (SLVERR or DECERR) reception<br/><br/> - Channel Terminate<br/>The width of the data in channel FIFO is defined in terms of CHx_CTL.SRC_TR_WIDTH. For more information, see "DMA Status Register - CHx_STATUSREG" section of the databook.</span></p>
          <p><b>Reset: </b>hex:0x0000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_STATUSREG_22to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Status Register (bits 22to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CMPLTD_BLK_TFR_SIZE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Completed Block Transfer Size.<br/>The Completed Block Transfer Size status indicates the total number of data items transferred from the Source memory/peripheral to the Destination memory/peripheral at any point in the DMA block transfer.<br/>The completed block transfer size or data items is defined as follows:<br/> - When DMA or Source is a Flow controller, this field is defined in terms of the CHx_CTL.SRC_TR_WIDTH.<br/> - When Destination is a Flow Controller, this field is defined in terms of the CHx_CTL.DST_TR_WIDTH.<br/>For more information, see "DMA Status Register - CHx_STATUSREG" section of the databook.</span></p>
          <p><b>Reset: </b>hex:0x000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_9EE6EC28BCF70DBB" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000138</span> Register(64 bit) CH1_SWHSSRCREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Software Handshake Source Register</span><br/>
      <span class="ldescdet">Channelx Software handshake Source Register.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502138</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="58">RSVD_DMAC_CHx_SWHSSRCREG_6to63</td>
        <td class="fldnorm" colspan="1">SWHS_LST_SRC_WE</td>
        <td class="fldnorm" colspan="1">SWHS_LST_SRC</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_SRC_WE</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_SRC</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_SRC_WE</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_SRC</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="58">RO/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:06]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_SWHSSRCREG_6to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Software Handshake Source Register (bits 6to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_SRC_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Last Request for Channel Source.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_LAST_SRC bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_LAST_SRC bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Last Request for Channel Source.<br/>This bit is used to request LAST dma source data transfer if software handshaking method is<br/>selected for the source of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the source of the Channelx or if the source of Channelx is not the flow<br/>controller.<br/>CHx_SWHSSrcReg.SWHS_Req_Src bit must be set to 1 for DW_axi_dmac to treat it as a valid software handshaking request.<br/>If CHx_SWHSSrcReg.SWHS_SglReq_Src is set to 1, the LAST<br/>request is for SINGLE dma transaction (AXI burst length = 1), else the request is treated as a BURST transaction request.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Lst_Src bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSSrcReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source peripheral indication to DMAC that the current transfer is the last transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source peripheral indication that the current transfer is not the last transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_SRC_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Single Request for Channel Source.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_SGLREQ_SRC bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_SGLREQ_SRC bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Single Request for Channel Source.<br/>This bit is used to request SINGLE (AXI burst length = 1) dma source data transfer if<br/>software handshaking method is selected for the source of the corresponding channel. This bit is ignored if software handshaking is not enabled for the source of the Channelx. The functionality of<br/>this field depends on whether the peripheral is the flow controller.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_SglReq_Src bit is written only if the corresponding write enable bit, SWHS_SglReq_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSSrcReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source peripheral request for a single dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source peripheral is not requesting for a single transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_SRC_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Request for Channel Source.<br/>Note: This bit always returns 0 on a read back.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_REQ_SRC bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_REQ_SRC bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Request for Channel Source.<br/>This bit is used to request dma source data transfer if software handshaking method is selected<br/>for the source of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the source of the Channelx. The functionality of this field depends on whether the<br/>peripheral is the flow controller or not.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Req_Src bit is written only if the corresponding write enable bit, SWHS_Req_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSSrcReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source peripheral request for a dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source peripheral is not requesting for a burst transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_671F4B9225A11009" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000140</span> Register(64 bit) CH1_SWHSDSTREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Software Handshake Destination Register</span><br/>
      <span class="ldescdet">Channelx Software handshake Destination Register.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502140</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="58">RSVD_DMAC_CHx_SWHSDSTREG_6to63</td>
        <td class="fldnorm" colspan="1">SWHS_LST_DST_WE</td>
        <td class="fldnorm" colspan="1">SWHS_LST_DST</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_DST_WE</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_DST</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_DST_WE</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_DST</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="58">RO/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:06]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_SWHSDSTREG_6to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Software Handshake Destination Register (bits 6to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_DST_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Last Request for Channel Destination.<br/>Note: This bit always returns 0 on a read back.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_LAST_DST bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_LAST_DST bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Last Request for Channel Destination.<br/>This bit is used to request LAST dma destination data transfer if software handshaking<br/>method is selected for the destination of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the destination of the Channelx or if the destination of<br/>Channelx is not the flow controller. CHx_SWHSDstReg.SWHS_Req_Dst bit must be set to 1 for DW_axi_dmac to treat it as a valid software handshaking request.<br/>If CHx_SWHSDstReg.SWHS_SglReq_Dst<br/>is set to 1, the LAST request is for SINGLE dma transaction (AXI burst length = 1), else the request is treated as a BURST transaction request.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Lst_Src bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination peripheral indication to DMAC that the current transfer is the last transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination peripheral indication that the current transfer is not the last transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_DST_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Single Request for Channel Destination.<br/>Note: This bit always returns 0 on a read block.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_SGLREQ_DST bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_SGLREQ_DST bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Single Request for Channel Destination.<br/>This bit is used to request SINGLE (AXI burst length = 1) dma destination data<br/>transfer if software handshaking method is selected for the destination of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the destination of the<br/>Channelx. The functionality of this field depends on whether the peripheral is the flow controller.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_SglReq_Dst bit is written only if the corresponding write enable bit, SWHS_SglReq_Dst_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination peripheral request for a single dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination peripheral is not requesting for a single transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_DST_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Request for Channel Destination.<br/>Note: This bit always returns 0 on a read block.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_REQ_DST bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_REQ_DST bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Request for Channel Destination.<br/>This bit is used to request dma destination data transfer if software handshaking method is<br/>selected for the destination of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the source of the Channelx. The functionality of this field depends on<br/>whether the peripheral is the flow controller.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Req_Dst bit is written only if the corresponding write enable bit, SWHS_Req_Dst_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination peripheral request for a dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination peripheral is not requesting for a burst transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_7462C56213B43AAF" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000148</span> Register(64 bit) CH1_BLK_TFR_RESUMEREQREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Block Transfer Resume Request Register</span><br/>
      <span class="ldescdet">Channelx Block Transfer Resume Request Register. This register is used during Linked List or Shadow Register based multi-block transfer.<br/>     - For Linked-List-based multi-block transfer, ShadowReg_Or_LLI_Valid bit in LLI.CHx_CTL indicates whether the linked list item fetched from the memory is valid (0: LLI is invalid, 1: LLI is<br/>       valid). On noticing this bit as 0, DW_axi_dmac discards the LLI and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt if the corresponding channel error interrupt mask bit is set to 0. This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully. DW_axi_dmac waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid LLI availability, before attempting another LLI read operation.<br/>    - For Shadow-Register-based multi-block transfer, ShadowReg_Or_LLI_Valid bit in CHx_CTL register indicates whether the shadow register contents are valid (0: Shadow Register contents are<br/>      invalid, 1: Shadow Register contents are valid). On noticing this bit as 0 during shadow register fetch phase, DW_axi_dmac discards the Shadow Register contents and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt. DW_axi_dmac waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid shadow register availability, before attempting another shadow register fetch operation and continue the next block transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502148</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access WS</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="63">RSVD_DMAC_CHx_BLK_TFR_RESUMEREQREG_1to63</td>
        <td class="fldnorm" colspan="1">BLK_TFR_RESUMEREQ</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="63">WS</td>
        <td class="accno" colspan="1">WS</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:01]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_BLK_TFR_RESUMEREQREG_1to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Block Transfer Resume Request Register (bits 1to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">BLK_TFR_RESUMEREQ</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Resume Request during Linked-List or Shadow-Register-based multi-block transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_BLK_TFR_RESUMEREQ</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Request for resuming the block transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_BLK_TFR_RESUMEREQ</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No request to resume the block transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_02C99209CF1A5E85" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000150</span> Register(64 bit) CH1_AXI_IDREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x AXI ID Register</span><br/>
      <span class="ldescdet">Channelx AXI ID Register. This register is allowed to be updated only when the channel is disabled, which means that it remains fixed for the entire<br/>DMA transfer.<br/>Note:  The presence of this register is determined by the DMAC_M_ID_WIDTH and DMAC_NUM_CHANNELS configuration parameters.<br/> - If LLI is enabled for any of the channel, then the register is present only when:<br/>DMAX_M_ID_WIDTH - (log2(DMAC_NUM_CHANNELS) +1) &gt; 0<br/> - Otherwise:<br/>DMAX_M_ID_WIDTH - log2(DMAC_NUM_CHANNELS) &gt; 0
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502150</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="32">RSVD_DMAC_CHx_AXI_IDREG_32to63</td>
        <td class="fldnorm" colspan="11">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm32to63</td>
        <td class="fldnorm" colspan="5">AXI_WRITE_ID_SUFFIX</td>
        <td class="fldnorm" colspan="11">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm1to31</td>
        <td class="fldnorm" colspan="5">AXI_READ_ID_SUFFIX</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="32">RO</td>
        <td class="accno" colspan="11">RO</td>
        <td class="accno" colspan="5">RW</td>
        <td class="accno" colspan="11">RO</td>
        <td class="accno" colspan="5">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_IDREG_32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI ID Register (bits 32to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:21]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to32) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[20:16]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_WRITE_ID_SUFFIX</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Write ID Suffix.<br/>These bits form part of the AWID output of AXI3/AXI4 manager interface.<br/>     IDW = DMAX_M_ID_WIDTH<br/>     L2NC =<br/>log2(DMAX_NUM_CHANNELS)<br/>The upper L2NC+1 bits of awidN is derived from the channel number which is currently accessing the manager interface.<br/>This varies for LLI fetch and source data<br/>transfer.<br/>For source data transfer, awidN for channel1 4'b0000, awidN for channel8 4'b0111 and so on.<br/>For LLI fetch access, awidN for channel1 4'b1000, awidN for channel8 4'b1111 and so<br/>on.<br/>Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Write_ID_Suffix filed.</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[15:05]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm1to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[04:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_READ_ID_SUFFIX</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Read ID Suffix<br/>These bits form part of the ARID output of AXI3/AXI4 manager interface.<br/><br/>     IDW = DMAX_M_ID_WIDTH<br/><br/>     L2NC = log2(DMAX_NUM_CHANNELS)<br/><br/>The upper L2NC+1 bits of aridN is derived from the channel number which is currently accessing the manager interface.<br/>This varies for LLI fetch and source data transfer.<br/>For source data transfer,<br/>aridN  for channel1 4'b0000, aridN for channel8 4'b0111 and so on.<br/>For LLI fetch access, aridN  for channel1 4'b1000, aridN for channel8 4'b1111 and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Read_ID_Suffix filed.</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_8FEA50529A2A870A" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000158</span> Register(64 bit) CH1_AXI_QOSREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x AXI QoS Register</span><br/>
      <span class="ldescdet">Channelx AXI QOS Register. This register is allowed to be updated only when the channel is disabled, which means that it remains fixed for the entire<br/>DMA transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502158</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="56">RSVD_DMAC_CHx_AXI_QOSREG_8to63</td>
        <td class="fldnorm" colspan="4">AXI_ARQOS</td>
        <td class="fldnorm" colspan="4">AXI_AWQOS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="56">RO</td>
        <td class="accno" colspan="4">RO</td>
        <td class="accno" colspan="4">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:08]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_QOSREG_8to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI QOS Register (bits 8to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[07:04]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_ARQOS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI ARQOS.<br/>These bits form the arqos output of AXI4 manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_AWQOS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI AWQOS.<br/>These bits form the awqos output of AXI4 manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_B446CE0C5F33BB54" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000160</span> Register(64 bit) CH1_SSTAT</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Source Status Register</span><br/>
      <span class="ldescdet">Channelx Source Status Register. After each block transfer completes, hardware can retrieve the source status information from the address pointed to by<br/>the contents of the CHx_SSTATAR register. This status information is then stored in the CHx_SSTAT register and written out to the CHx_SSTAT register location of the LLI before the start of<br/>the next block.<br/>Source status write-back to the CHx_SSTAT register location of the LLI is performed only if DMAX_CHx_LLI_WB_EN = 1 and linked-list-based multi-block transfer is enabled for<br/>either source or destination peripheral of the channel.<br/>This register does not exist if DMAC_CHx_SRC_STAT_EN is set to False; in this case, the read-back value is always 0.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502160</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="32">RSVD_DMAC_CHx_SSTAT_32to63</td>
        <td class="fldnorm" colspan="32">SSTAT</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="32">RO</td>
        <td class="accno" colspan="32">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_SSTAT_32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Source Status Register (bits 32to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SSTAT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Status<br/>Source status information retrieved by hardware from the address pointed to by the contents of the CHx_SSTATAR<br/>register.<br/>Source peripheral should update the source status information, if any, at the location pointed to by CHx_SSTATAR to utilize this feature.This status is not related to any internal<br/>status of DW_axi_dmac.<br/>This status is not related to any internal status of DW_axi_dmac.</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_F2139129A0629FE5" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000170</span> Register(64 bit) CH1_SSTATAR</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Source Status Fetch Register</span><br/>
      <span class="ldescdet">Channelx Source Status Fetch Register. After completion of each block transfer, hardware can retrieve the source status information from the<br/>user-defined address to which the contents of the CHx_SSTATAR register point. You can select any location in system memory that provides a 64-bit value to indicate the status of the source<br/>transfer.<br/>This register does not exist if DMAC_CHx_SRC_STAT_EN is set to False; in this case, the read-back value is always 0.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502170</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="64">SSTATAR</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="64">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SSTATAR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Status Fetch Address<br/>Pointer from where hardware can fetch the source status information, which is registered in the CHx_SSTAT<br/>register and written out to the CHx_SSTAT register location of the LLI before the start of the next block if DMAX_CHx_LLI_WB_EN = 1 and linked list based multi-block transfer is enabled for<br/>either source or destination peripheral of the channel.<br/>Source peripheral should update the source status information, if any, at the location pointed to by CHx_SSTATAR to utilize this<br/>feature.<br/>This status is not related to any internal status of DW_axi_dmac.</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_C566A6CD8C16B515" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000180</span> Register(64 bit) CH1_INTSTATUS_ENABLEREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Interrupt Status Enable Register</span><br/>
      <span class="ldescdet">Writing 1 to specific field enables the corresponding interrupt status generation in Channelx Interrupt Status Register(CH1_IntStatusReg).
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502180</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0xffffffffffffffff</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_32to63</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_ABORTED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_DISABLED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_SRC_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_LOCK_CLEARED_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_26</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_22to23</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONHOLD_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONCHEN_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_RD2RWO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_MULTIBLKTYPE_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_DST_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SRC_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_DST_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SRC_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_DST_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SRC_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</td>
        <td class="fldnorm" colspan="1">Enable_DMA_TFR_DONE_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_BLOCK_TFR_DONE_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="2">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Enable Register (bits 32to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0xfffffff;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Uncorrectable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation Channel x UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Uncorrectable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Uncorrectable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Correctable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x UID Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation Channel x UID Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Correctable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Correctable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Uncorrectable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x Channel Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation Channel x Channel Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Uncorrectable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Uncorrectable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Correctable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x Channel Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation of Channel x Channel Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Correctable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Correctable error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_ABORTED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated Status Enable.<br/> - 0: Disable the generation of Channel Terminated Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Terminated Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_ABORTED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Terminated Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_ABORTED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Terminated Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_DISABLED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled Status Enable.<br/> - 0: Disable the generation of Channel Disabled Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Disabled Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_DISABLED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Disabled Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_DISABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Disabled Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended Status Enable.<br/> - 0: Disable the generation of Channel Suspended Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Suspended Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Suspended Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Suspended Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SRC_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended Status Enable.<br/> - 0: Disable the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Source Suspended Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Source Suspended Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_LOCK_CLEARED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared Status Enable.<br/> - 0: Disable the generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel LOCK CLEARED Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel LOCK CLEARED Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bit 26) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error Enable.<br/> - 0: Disable the generation of Register Bus Interface Write Parity Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write Parity Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write Parity Error in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write Parity Error in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error Enable.<br/> - 0: Disable the generation of Register Bus Interface Address Parity Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Address Parity Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Address Parity Error in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Address Parity Error in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bits 22to23) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONHOLD_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Write On Hold Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write On Hold Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write On Hold Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write On Hold Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error Status Enable.<br/> - 0: Disable the generation of Shadow Register Write On Valid Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Shadow register Write On Valid Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Shadow Register Write On Valid Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Shadow register Write On Valid Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONCHEN_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_RD2RWO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Read to Write only Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Read to Write Only Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Read to Write only Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Read to Write Only Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Write to Read only Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write to Read Only Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write to Read only Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write to Read Only Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bit 15) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_MULTIBLKTYPE_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Multi Block type Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Multi Block type Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error Status Enable.<br/> - 0: Disable the generation of Shadow Register or LLI Invalid Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Shadow Register or LLI Invalid  Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Shadow Register or LLI Invalid Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Shadow Register or LLI Invalid  Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error Status Enable.<br/> - 0: Disable the generation of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI WRITE Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI WRITE Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error Status Enable.<br/> - 0: Disable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI Read Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI Read Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error Status Enable.<br/> - 0: Disable the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI WRITE Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI WRITE Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error Status Enable.<br/> - 0: Disable the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI Read Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI Read Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error Status Enable.<br/> - 0: Disable the generation of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Destination Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Destination Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error Status Enable.<br/> - 0: Disable the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Source Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Source Subordinate Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error Status Enable.<br/> - 0: Disable the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Destination Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Destination Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error Status Enable.<br/> - 0: Disable the generation of Source Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Source Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Source Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Source Decode Error Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed Status Enable.<br/> - 0: Disable the generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Destination Transaction complete Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Destination Transaction complete Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed Status Enable.<br/> - 0: Disable the generation of Source Transaction Complete Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Source Transaction Complete Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Source Transaction Complete Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Source Transaction Complete Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bit 2) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DMA_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done Interrupt Status Enable.<br/> - 0: Disable the generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DMA_TFR_DONE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of DMA Transfer Done Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DMA_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of DMA Transfer Done Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_BLOCK_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done Interrupt Status Enable.<br/> - 0: Disable the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_BLOCK_TFR_DONE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Block Transfer Done Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_BLOCK_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Block Transfer Done Interrupt in CH1_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_B6974B9CED41E15E" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000188</span> Register(64 bit) CH1_INTSTATUS</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Interrupt Status Register</span><br/>
      <span class="ldescdet">Channelx Interrupt Status Register captures the Channelx specific interrupts
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502188</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTSTATUSREG_36to63</td>
        <td class="fldnorm" colspan="1">ECC_PROT_UIDMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">ECC_PROT_UIDMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">ECC_PROT_CHMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">ECC_PROT_CHMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">CH_ABORTED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_DISABLED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_SRC_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_LOCK_CLEARED_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUSREG_26</td>
        <td class="fldnorm" colspan="1">SLVIF_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTSTATUSREG_22to23</td>
        <td class="fldnorm" colspan="1">SLVIF_WRONHOLD_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_WRONCHEN_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_RD2RWO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUSREG_15</td>
        <td class="fldnorm" colspan="1">SLVIF_MULTIBLKTYPE_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SHADOWREG_OR_LLI_INVALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_WR_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_RD_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_WR_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_RD_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">DST_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SRC_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">DST_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SRC_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">DST_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">SRC_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUSREG_2</td>
        <td class="fldnorm" colspan="1">DMA_TFR_DONE_IntStat</td>
        <td class="fldnorm" colspan="1">BLOCK_TFR_DONE_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_36to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bits 36to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_UIDMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x UID Memory Interface ECC Protection related Uncorrectable Error Interrupt Status bit.<br/><br/>This error occurs if ECC Uncorrectable error is detected on the UID Memory Interface data. <br/><br/> - 0: No Channel x UID Memory Interface Uncorrectable Error.<br/> - 1: Channel x UID Memory Interface Uncorrectable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_UIDMem_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_UIDMem_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_UIDMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x UID Memory Interface ECC Protection related Correctable Error Interrupt Status bit.<br/><br/>This error occurs if ECC correctable error is detected on the UID Memory Interface data. <br/><br/> - 0: No Channel x UID Memory Interface correctable Error.<br/> - 1: Channel x UID Memory Interface correctable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_UIDMem_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_UIDMem_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_CHMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x FIFO Memory Interface ECC Protection related Uncorrectable Error Interrupt Status bit.<br/><br/>This error occurs if ECC Uncorrectable error is detected on the FIFO Memory Interface data. <br/><br/> - 0: No Channel x FIFO Memory Interface Uncorrectable Error.<br/> - 1: Channel x FIFO Memory Interface Uncorrectable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_CHMem_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_CHMem_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_CHMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x FIFO Memory Interface ECC Protection related Correctable Error Interrupt Status bit.<br/><br/>This error occurs if ECC correctable error is detected on the FIFO Memory Interface data. <br/><br/> - 0: No Channel x FIFO Memory Interface correctable Error.<br/> - 1: Channel x FIFO Memory Interface correctable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_CHMem_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_CHMem_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_ABORTED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated.<br/>This indicates to the software that the corresponding channel in DW_axi_dmac is terminated.<br/> - 0: Channel is not terminated<br/> - 1: Channel is terminated<br/><br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_ABORTED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is terminated<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_ABORTED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not terminated<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_DISABLED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled.<br/>This indicates to the software that the corresponding channel in DW_axi_dmac is disabled.<br/> - 0: Channel is not disabled.<br/> - 1: Channel is disabled.<br/>    Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_DISABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_DISABLED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not disabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended.<br/>This indicates to the software that the corresponding channel in DW_axi_dmac is suspended.<br/> - 0: Channel is not suspended.<br/> - 1: Channel is suspended.<br/><br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is suspended<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not suspended<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_SRC_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended.<br/>This indicates to the software that the corresponding channel source data transfer in DW_axi_dmac is suspended.<br/> - 0: Channel source is not suspended<br/> - 1: Channel Source is suspended.<br/><br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel Source is suspended<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel source is not suspended<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_LOCK_CLEARED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared.<br/>This indicates to the software that the locking of the corresponding channel in DW_axi_dmac is cleared.<br/> - 0: Channel locking is not cleared.<br/> - 1: Channel locking is cleared.<br/><br/>Channel locking is cleared by DW_axi_dmac during the following situations:<br/> - Channel locking is cleared and the channel locking settings in CHx_CFG register is reset if DW_axi_dmac disables the channel upon request from software.<br/> - Channel locking is cleared and the channel locking settings in CHx_CFG register is reset if DW_axi_dmac disables the channel upon receiving error response on the manager interface.<br/><br/>This bit is cleared to 0 on enabling the channel.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel Locking is cleared<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel locking is not cleared, if present.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bit 26) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error.<br/>This error occurs if a Write operation is performed on a channel register; But the Write data fails the even/odd parity check.<br/> - 0: No Register Bus Interface Write Parity Errors.<br/> - 1: Register Bus Interface Write Parity Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write Parity Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error.<br/>This error occurs if address is used to do write/read operation on a channel register; But the Address fails the even/odd parity check.<br/> - 0: No Register Bus Interface Address Parity Errors.<br/> - 1: Register Bus Interface Address Parity Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Address Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Address Parity Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bits 22to23) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WRONHOLD_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error.<br/>This error occurs if an illegal write operation is performed on a register; this happens if a write operation is performed on a channel register when DW_axi_dmac is in Hold mode.<br/> - 0: No Register Bus Interface Write On Hold Errors.<br/> - 1: Register Bus Interface Write On Hold Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write On Hold Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write On Hold Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error.<br/>This error occurs if shadow register based multi-block transfer is enabled and software tries to write to the shadow register when CHx_CTL.ShadowReg_Or_LLI_Valid bit is 1.<br/> - 0: No Register Bus Interface Shadow Register Write On Valid Errors.<br/> - 1: Register Bus Interface Shadow Register Write On Valid Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Shadow Register Write On Valid Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Shadow Register Write On Valid Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WRONCHEN_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error.<br/>This error occurs if an illegal write operation is performed on a register; this happens if a write operation is performed on a register when the channel is enabled and if it is not allowed for the corresponding register as per the DW_axi_dmac specification.<br/> - 0: No Register Bus Interface Write On Channel Enabled Errors.<br/> - 1: Register Bus Interface Write On Channel Enabled Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write On Channel Enabled Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write On Channel Enabled Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_RD2RWO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error.<br/>This error occurs if read operation is performed to a Write Only register.<br/> - 0: No Register Bus Interface Read to Write Only Errors.<br/> - 1: Register Bus Interface Read to Write Only Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Read to Write Only Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Read to Write Only Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error.<br/>This error occurs if write operation is performed to a Read Only register.<br/> - 0: No Register Bus Interface Write to Read Only Errors.<br/> - 1: Register Bus Interface Write to Read Only Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write to Read Only Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write to Read Only Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error.<br/>Decode Error generated by DW_axi_dmac during register access. This error occurs if the register access is to invalid address in Channelx register space resulting in error response by DW_axi_dmac register bus interface.<br/> - 0: No Register Bus Interface Decode errors.<br/> - 1: Register Bus Interface Decode Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHxINTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Decode errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bit 15) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_MULTIBLKTYPE_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error.<br/>This error occurs if multi-block transfer type programmed in CHx_CFG register (SRC_MLTBLK_TYPE and DST_MLTBLK_TYPE) is invalid. This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully; Error Interrupt is generated if the corresponding channel error interrupt mask bit is set to 0 and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid multi-block transfer type availability.<br/> - 0: No Multi-block transfer type Errors.<br/> - 1: Multi-block transfer type Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Multi-block transfer type Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Multi-block transfer type Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SHADOWREG_OR_LLI_INVALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error.<br/>This error occurs if CHx_CTL.ShadowReg_Or_LLI_Valid bit is seen to be 0 during DW_axi_dmac Shadow<br/>Register / LLI fetch phase. This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully; Error Interrupt is generated if the corresponding channel error interrupt mask bit<br/>is set to 0 and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid Shadow Register availability.<br/>In the case of LLI pre-fetching, ShadowReg_Or_LLI_Invalid_ERR Interrupt is not generated even if ShadowReg_Or_LLI_Valid bit is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac re-attempts the LLI fetch operation after completing the current block transfer and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt only if ShadowReg_Or_LLI_Valid bit is still seen to be 0.<br/> - 0: No Shadow Register / LLI Invalid errors.<br/> - 1: Shadow Register / LLI Invalid error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Shadow Register / LLI Invalid error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Shadow Register / LLI Invalid errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_WR_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error.<br/>Subordinate Error detected by Manager Interface during LLI write-back operation. This error occurs if the register bus interface on which LLI resides issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the error is set to 0.<br/> - 0: No LLI write Subordinate Errors.<br/> - 1: LLI Write SUBORDINATE Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_WR_SLV</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI Write SUBORDINATE Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_WR_SLV</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No LLI write Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_RD_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error.<br/>Subordinate Error detected by Manager Interface during LLI read operation. This error occurs if the register bus interface on which LLI resides issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the error is set to 0.<br/> - 0: No LLI Read Subordinate Errors.<br/> - 1: LLI read Subordinate Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI read Subordinate Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No LLI Read Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_WR_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error.<br/>Decode Error detected by Manager Interface during LLI write-back operation. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the error is set to 0.<br/> - 0: NO LLI Write Decode Errors.<br/> - 1: LLI write Decode Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI write Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">NO LLI Write Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_RD_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error.<br/>Decode Error detected by Manager Interface during LLI read operation. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the error is set to 0.<br/> - 0: NO LLI Read Decode Errors.<br/> - 1: LLI Read Decode Error detected<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI Read Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">NO LLI Read Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error.<br/>Subordinate Error detected by Manager Interface during destination data transfer. This error occurs if the register bus interface to which the data is written issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0.<br/> - 0: No Destination Subordinate Errors<br/> - 1: Destination Subordinate Errors Detected<br/><br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination Subordinate Errors Detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Destination Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error.<br/>Subordinate Error detected by Manager Interface during source data transfer. This error occurs if the register bus interface from which the data is read issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0. <br/> - 0: No Source Subordinate Errors<br/> - 1: Source Subordinate Error Detected<br/><br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source Subordinate Error Detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Source Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error.<br/>Decode Error detected by Manager Interface during destination data transfer. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0.<br/> - 0: No destination Decode Errors.<br/> - 1: Destination Decode Error Detected<br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination Decode Error Detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No destination Decode Errors.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error.<br/>Decode Error detected by Manager Interface during source data transfer. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0.<br/> - 0: No Source Decode Errors.<br/> - 1: Source Decode Error detected.<br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Source Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register or on enabling the channel (needed when interrupt is not enabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination transaction is complete<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination transaction is not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register or on enabling the channel (needed when interrupt is not enabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source transaction is complete<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source transaction is not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bit 2) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMA_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done.<br/>This indicates to the software that the DW_axi_dmac has completed the requested DMA transfer.<br/>The DW_axi_dmac sets this<br/>bit to 1 along with setting CHx_INTSTATUS.BLOCK_TFR_DONE bit to 1 when the last block transfer is completed.<br/> - 0: DMA Transfer not completed.<br/> - 1: DMA Transfer Completed<br/><br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DMA_TFR_COMPLETED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">DMA Transfer completed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DMA_TFR_NOT_COMPLETE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">DMA Transfer not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">BLOCK_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done.<br/>This indicates to the software that the DW_axi_dmac has completed the requested block transfer.<br/>The DW_axi_dmac sets this bit to 1 when the transfer is successfully completed.<br/> - 0: Block Transfer not completed.<br/> - 1: Block Transfer completed.<br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BLOCK_TFR_COMPLETED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Block Transfer completed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BLOCK_TFR_NOT_COMPLETE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Block Transfer not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_DEEA4E0999AD557F" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000190</span> Register(64 bit) CH1_INTSIGNAL_ENABLEREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Interrupt Signal Enable Register</span><br/>
      <span class="ldescdet">This register contains fields that are used to enable the generation of port level interrupt at the channel level.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502190</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0xffffffffffffffff</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_36to63</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_ABORTED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_DISABLED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_SUSPENDED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_SRC_SUSPENDED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_LOCK_CLEARED_IntSignal</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_26</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRPARITY_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_ADDRPARITY_ERR_IntSignal</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_22to23</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONHOLD_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONCHEN_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_RD2RWO_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WR2RO_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_MULTIBLKTYPE_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_DST_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SRC_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_DST_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SRC_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_DST_TRANSCOMP_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SRC_TRANSCOMP_IntSignal</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</td>
        <td class="fldnorm" colspan="1">Enable_DMA_TFR_DONE_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_BLOCK_TFR_DONE_IntSignal</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="2">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_36to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Signal Enable Register (bits 36to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0xfffffff;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Uncorrectable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x UID Memory Interface Uncorrectable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x UID Memory Interface Uncorrectable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Correctable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x UID Memory Interface Correctable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x UID Memory Interface Correctable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Uncorrectable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x Channel Memory Interface Uncorrectable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x Channel Memory Interface Uncorrectable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Correctable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x Channel Memory Interface Correctable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x Channel Memory Interface Correctable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_ABORTED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated Signal Enable.<br/> - 0: Disable the propagation of Channel Terminated Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Terminated Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_ABORTED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Terminated Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_ABORTED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Terminated Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_DISABLED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled Signal Enable.<br/> - 0: Disable the propagation of Channel Disabled Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Disabled Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_DISABLED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Disabled Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_DISABLED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Disabled Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SUSPENDED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended Signal Enable.<br/> - 0: Disable the propagation of Channel Suspended Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Suspended Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SRC_SUSPENDED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended Signal Enable.<br/> - 0: Disable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SRC_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SRC_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_LOCK_CLEARED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared Signal Enable.<br/> - 0: Disable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_LOCK_CLEARED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_LOCK_CLEARED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Signal Enable Register (bit 26) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRPARITY_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_WRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_WRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_ADDRPARITY_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_ADDRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_ADDRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Signal Enable Register (bits 22to23) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONHOLD_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONHOLD_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONHOLD_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error Signal Enable.<br/> - 0: Disable the propagation of Shadow Register Write On Valid Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Shadow register Write On Valid Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Shadow Register Write On Valid Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Shadow register Write On Valid Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONCHEN_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONCHEN_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONCHEN_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_RD2RWO_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Read to Write only Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Read to Write Only Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_RD2RWO_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Read to Write only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_RD2RWO_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Read to Write Only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WR2RO_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write to Read only Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write to Read Only Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WR2RO_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write to Read only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WR2RO_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write to Read Only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Enable Register (bit 15) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_MULTIBLKTYPE_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_MULTIBLKTYPE_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_MULTIBLKTYPE_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error Signal Enable.<br/> - 0: Disable the propagation of Shadow Register or LLI Invalid Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Shadow Register or LLI Invalid  Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Shadow Register or LLI Invalid Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Shadow Register or LLI Invalid  Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error Signal Enable.<br/> - 0: Disable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error Signal Enable.<br/> - 0: Disable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error Signal Enable.<br/> - 0: Disable the propagation of Destination Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Destination Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Destination Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Destination Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error Signal Enable.<br/> - 0: Disable the propagation of Source Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Source Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Source Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Source Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_TRANSCOMP_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed Signal Enable.<br/> - 0: Disable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_TRANSCOMP_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed Signal Enable.<br/> - 0: Disable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Enable Register (bit 2) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DMA_TFR_DONE_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done Interrupt Signal Enable.<br/> - 0: Disable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DMA_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DMA_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_BLOCK_TFR_DONE_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done Interrupt Signal Enable.<br/> - 0: Disable the propagation of Block Transfer Done Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Block Transfer Done Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_BLOCK_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Block Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_BLOCK_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Block Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_1DF1F2ED2A364F8D" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000198</span> Register(64 bit) CH1_INTCLEARREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Interrupt Status Clear Register</span><br/>
      <span class="ldescdet">Writing 1 to specific field will clear the corresponding field in Channelx Interrupt Status Register(CHx_IntStatusReg).
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502198</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access WS</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTCLEARREG_36to63</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_UIDMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_UIDMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_CHMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_CHMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_ABORTED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_DISABLED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_SRC_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_LOCK_CLEARED_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTCLEARREG_26</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTCLEARREG_22to23</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WRONHOLD_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WRONCHEN_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_RD2RWO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTCLEARREG_15</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_MULTIBLKTYPE_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_WR_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_RD_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_WR_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_RD_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_DST_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SRC_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_DST_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SRC_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_DST_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SRC_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTCLEARREG_2</td>
        <td class="fldnorm" colspan="1">Clear_DMA_TFR_DONE_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_BLOCK_TFR_DONE_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="2">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_36to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bits 36to63) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_UIDMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Uncorrectable UID Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Clear_ECC_UIDMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_UIDMem_UnCorrERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_UIDMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Correctable UID Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_ECC_UIDMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_UIDMem_CorrERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_CHMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Uncorrectable Channel Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_ECC_CHMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_CHMem_UnCorrERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_CHMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Correctable Channel Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_ECC_CHMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_CHMem_CorrERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_ABORTED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_ABORTED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_ABORTED interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_DISABLED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_DISABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_DISABLED interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_SUSPENDED interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_SRC_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_SRC_SUSPENDED interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_LOCK_CLEARED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_LOCK_CLEARED interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bit 26) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WRPARITY_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_ADDRPARITY_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bits 22to23) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WRONHOLD_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WRONHOLD_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_SHADOWREG_WRON_VALID_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WRONCHEN_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WRONCHEN_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_RD2RWO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_RD2RWO_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WR2RO_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_DEC_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bit 15) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_MULTIBLKTYPE_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_MULTIBLKTYPE_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SHADOWREG_OR_LLI_INVALID_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_WR_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_WR_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_WR_SLV_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_RD_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_RD_SLV_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_WR_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_WR_DEC_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_RD_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_RD_DEC_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DST_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DST_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DST_SLV_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SRC_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SRC_SLV_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DST_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DST_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DST_DEC_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SRC_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SRC_DEC_ERR interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DST_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DST_TRANSCOMP interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SRC_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SRC_TRANSCOMP interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bit 2) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DMA_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DMA_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DMA_TFR_DONE interrupt in the Interrupt Status Register(CH1_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_BLOCK_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CH1_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_BLOCK_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the interrupt in the Interrupt Status Register(CHx_IntStatusReg). Writing a 1 to this register field clears the corresponding bit in the CHx_IntStatusReg register.<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_78D371BB78761A50" class="boxed tabrb"><span class="regname">+<span class="addr">0x000001a0</span> Register(64 bit) CH1_CFG_EXTD</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel x Extended Configuration Register</span><br/>
      <span class="ldescdet">Channel x Extended Configuration Register. This register is allowed to be updated only when the channel is disabled, which means that it remains fixed for the entire<br/>DMA transfer. This feature adds register fields - CHx_CFG_EXTD.LLI_AXPROT and CHx_CFG_EXTD.LLI_AXCACHE. For the next LLI Fetch and/or LLI Write Back, this programmed AXI Protection/Cache value is used as AxPROT and AxCACHE.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x045021a0</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="57">RSVD_DMAC_CHx_CFG_EXTD_7to63</td>
        <td class="fldnorm" colspan="4">LLI_AXCACHE</td>
        <td class="fldnorm" colspan="3">LLI_AXPROT</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="57">RO</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="3">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:07]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_EXTD_7to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channel x Extended Configuration Register (bits 7to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[06:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_AXCACHE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Fetch and LLI Writeback AXI AxCACHE.<br/>These bits form the arcache/awcache output of AXI manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[02:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_AXPROT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Fetch and LLI Writeback AXI AxPROT.<br/>These bits form the arprot/awprot output of AXI manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_CA4655F435A412E7" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000200</span> Register(64 bit) CH2_SAR</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Source Address Register</span><br/>
      <span class="ldescdet">The starting source address is programmed by software before the DMA channel is enabled, or by an LLI update before the start of the DMA transfer. While<br/>the DMA transfer is in progress, this register is updated to reflect the source address of the current AXI transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502200</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="64">SAR</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="64">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SAR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Current Source Address of DMA transfer.<br/>Updated after each source transfer. The SINC fields in the CHx_CTL register determines whether the address increments or is left unchanged on every source transfer throughout the block transfer.</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_718180FF7833D096" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000208</span> Register(64 bit) CH2_DAR</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Destination Address Register</span><br/>
      <span class="ldescdet">The starting destination address is programmed by the software before the DMA channel is enabled, or by an LLI update before the start of the DMA transfer.<br/>While the DMA transfer is in progress, this register is updated to reflect the destination address of the current AXI transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502208</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="64">DAR</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="64">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DAR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Current Destination Address of DMA transfer.<br/>Updated after each destination transfer. The DINC fields in the CHx_CTL register determines whether the address increments or is left unchanged on every destination transfer throughout the block transfer.</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_B9CBFBEC6FDBE4C5" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000210</span> Register(64 bit) CH2_BLOCK_TS</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Block Transfer Size Register</span><br/>
      <span class="ldescdet">When DW_axi_dmac is the flow controller, the DMAC uses this register before the channel is enabled for block-size.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502210</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="42">RSVD_DMAC_CHx_BLOCK_TSREG_63to22</td>
        <td class="fldnorm" colspan="22">BLOCK_TS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="42">RO/V</td>
        <td class="accno" colspan="22">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_BLOCK_TSREG_63to22</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Block Transfer Size Register (bits 63to22) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">BLOCK_TS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Size.<br/>The number programmed into BLOCK_TS field indicates the total number of data of width CHx_CTL.SRC_TR_WIDTH to be transferred in a DMA block transfer.<br/>Block Transfer Size = BLOCK_TS+1<br/>Note: The value programmed to the BLOCK_TS field must be greater than or equal to the source or destination transfer width and the read back value of BLOCK_TS field is always the value programmed into it. This register field is not applicable when source or destination is flow controller and it is applicable when DMA is flow controller.</span></p>
          <p><b>Reset: </b>hex:0x000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_6D8F9108C73D5E4B" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000218</span> Register(64 bit) CH2_CTL</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Control Register</span><br/>
      <span class="ldescdet">This register contains fields that control the DMA transfer. This register should be programmed prior to enabling the channel except for LLI-based multi-block transfer. When LLI-based multi-block transfer is enabled, the CHx_CTL register is loaded from the corresponding location of the LLI and it can be varied on a block-by-block basis within a DMA transfer. The software is not allowed to directly update this register through DW_axi_dmac register bus interface. Any write to this register during LLI based multi-block transfer is ignored.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502218</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000003600</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="1">SHADOWREG_OR_LLI_VALID</td>
        <td class="fldnorm" colspan="1">SHADOWREG_OR_LLI_LAST</td>
        <td class="fldnorm" colspan="3">RSVD_DMAC_CHx_CTL_59to61</td>
        <td class="fldnorm" colspan="1">IOC_BlkTfr</td>
        <td class="fldnorm" colspan="1">DST_STAT_EN</td>
        <td class="fldnorm" colspan="1">SRC_STAT_EN</td>
        <td class="fldnorm" colspan="8">AWLEN</td>
        <td class="fldnorm" colspan="1">AWLEN_EN</td>
        <td class="fldnorm" colspan="8">ARLEN</td>
        <td class="fldnorm" colspan="1">ARLEN_EN</td>
        <td class="fldnorm" colspan="3">AW_PROT</td>
        <td class="fldnorm" colspan="3">AR_PROT</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_31</td>
        <td class="fldnorm" colspan="1">NonPosted_LastWrite_En</td>
        <td class="fldnorm" colspan="4">AW_CACHE</td>
        <td class="fldnorm" colspan="4">AR_CACHE</td>
        <td class="fldnorm" colspan="4">DST_MSIZE</td>
        <td class="fldnorm" colspan="4">SRC_MSIZE</td>
        <td class="fldnorm" colspan="3">DST_TR_WIDTH</td>
        <td class="fldnorm" colspan="3">SRC_TR_WIDTH</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_7</td>
        <td class="fldnorm" colspan="1">DINC</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_5</td>
        <td class="fldnorm" colspan="1">SINC</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_3</td>
        <td class="fldnorm" colspan="1">DMS</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CTL_1</td>
        <td class="fldnorm" colspan="1">SMS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="3">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="8">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="8">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="3">RW</td>
        <td class="accno" colspan="3">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="3">RO</td>
        <td class="accno" colspan="3">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:63]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SHADOWREG_OR_LLI_VALID</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register content/Linked List Item valid.<br/>Indicates whether the content of shadow register or the linked list item fetched from the memory is valid.<br/> - 0: Shadow Register content/LLI is invalid.<br/> - 1: Last Shadow Register/LLI is valid.<br/>LLI based multi-block transfer: The CHx_CTL register is loaded from the LLI. Hence, the software is not allowed to directly update this register through the DW_axi_dmac subordinate<br/>interface.<br/>This field can be used to dynamically extend the LLI by the software. On noticing this bit as 0, DW_axi_dmac discards the LLI and generates the ShadowReg_Or_LII_Invalid_ERR Interrupt if<br/>the corresponding channel error interrupt mask bit is set to 0.<br/>In the case of LLI pre-fetching, the ShadowReg_Or_LLI_Invalid_ERR interrupt is not generated even if the ShadowReg_Or_LLI_Valid bit<br/>is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac attempts the LLI fetch operation again after completing the current block transfer and generates the ShadowReg_Or_LII_Invalid_ERR<br/>interrupt only if ShadowReg_Or_LII_Valid bit is still seen to be 0.<br/>This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully. DW_axi_dmac waits until software writes<br/>(any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid LLI availability before attempting another LLI read operation. This bit is cleared to 0 and written back to the corresponding LLI location<br/>after block transfer completion when LLI write-back option is enabled. Hence, for LLI-based multi-block transfers, the software might manipulate/redefine any descriptor with the ShadowReg_Or_LII_Valid<br/>bit set to 0 if LLI write-back option is enabled.<br/>Shadow Reg based multi-block transfer: On noticing this bit as 0 during shadow register fetch phase, DW_axi_dmac discards the Shadow Register<br/>contents and generates ShadowReg_Or_LLI_Invlid_ERR Interrupt. In this case, the software has to write (any value) to CHx_BLK_TFR_ResumeReqReg after updating the shadow registers and after setting<br/>ShadowReg_Or_LLI_Valid bit to 1 to indicate to DW_axi_dmac that shadow register contents are valid and the next block transfer can be resumed.<br/>DW_axi_dmac clears this bit to 0 after copying the<br/>shadow register contents. Software can reprogram the shadow registers only if ShadowReg_Or_LLI_Valid bit is 0. Software needs to read this register in block completion interrupt service routine (if<br/>interrupt is enabled)/continuously poll this register (if interrupt is not enabled) to make sure that this bit is 0 before updating the shadow registers.<br/>If shadow-register-based multi-block<br/>transfer is enabled and software attempts to write to the shadow register when ShadowReg_Or_LLI_Valid bit is 1, DW_axi_dmac generates SLVIF_ShadowReg_WrOnValid_ERR interrupt.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">INVALID</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is Invalid<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">VALID</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is Valid<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[62:62]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SHADOWREG_OR_LLI_LAST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Last Shadow Register/Linked List Item.<br/>Indicates whether shadow register content or the linked list item fetched from the memory is the last one or not.<br/> - 0: Not last Shadow Register/LLI<br/> - 1: Last Shadow Register/LLI<br/>LLI based multi-block transfer: DW_axi_dmac uses this bit to decide if another LLI fetch is needed in the current DMA transfer.<br/> - If this bit is 0, DW_axi_dmac fetches the next LLI from the address pointed out by LLP field in the current LLI.<br/> - If this bit is 1, DW_axi_dmac understands that current block is the final block in the dma transfer and ends the dma transfer once the AMBA transfer corresponding to the current block completes.<br/>Shadow Reg based multi-block transfer: DW_axi_dmac uses this bit to decide if another Shadow Register fetch is needed in the current DMA transfer.<br/> - If this bit is 0, DW_axi_dmac understands that there are one or more blocks to be transferred in the current block and hence one or more shadow register set contents will be valid and needs to be fetched.<br/> - If this bit is 1, DW_axi_dmac understands that current block is the final block in the dma transfer and ends the dma transfer once the AMBA transfer corresponding to the current block completes.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">LAST_ITEM</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is the last one<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NOT_LAST_ITEM</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Indicates shadowreg/LLI content is not the last one<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[61:59]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_59to61</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register (bits 59to61) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[58:58]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">IOC_BlkTfr</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Interrupt On completion of Block Transfer<br/>This bit is used to control the block transfer completion interrupt generation on a block by block<br/>basis for shadow register or linked list based multi-block transfers. Writing 1 to this register field enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat field if this interrupt generation is enabled in<br/>CHx_IntStatus_EnableReg register and the external interrupt output is asserted if this interrupt generation is enabled in CHx_IntSignal_EnableReg register.<br/>Note: If a linked-list or<br/>shadow-register-based multi-block transfer is not used for both source and destination (for instance if source and destination use contiguous address or auto-reload-based multi-block transfer), the<br/>value of this field cannot be modified per block. Additionally, the value programmed before the channel is enabled is used for all the blocks in the DMA transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_BLKTFR_INTR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat field<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_BLKTFR_INTR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat field<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[57:57]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_STAT_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Status Enable<br/>Enable the logic to fetch status from destination peripheral of channel x pointed to by the content of CHx_DSTATAR register and stores it in CHx_DSTAT register. This value is written back to the CHx_DSTAT location of linked list at end of each block transfer if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block transfer is used by either source or destination peripheral.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Enable_STAT_FETCH</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables status fetch for Destination and store the value in CH2_DSTAT register<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_STAT_FETCH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No status fetch for Destination device<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[56:56]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_STAT_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Status Enable<br/>Enable the logic to fetch status from source peripheral of channel x pointed to by the content of CHx_SSTATAR register and stores it in CHx_SSTAT register. This value is written back to the CHx_SSTAT location of linked list at end of each block transfer if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block transfer is used by either source or destination peripheral.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Enable_STAT_FETCH</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables status fetch for Source and store the value in CH2_SSTAT register<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_STAT_FETCH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No status fetch for Source device<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[55:48]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AWLEN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Burst Length<br/>AXI Burst length used for destination data transfer. The specified burst length is used for destination data transfer<br/>till the extent possible; remaining transfers use maximum possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.<br/>The maximum value of AWLEN is limited by<br/>DMAX_CHx_MAX_AMBA_BURST_LENGTH.<br/>Note: The AWLEN setting may not be honored towards end-to-block transfers, the end of a transaction (only applicable to non-memory peripherals), and during<br/>4K boundary crossings.</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[47:47]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AWLEN_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Burst Length Enable<br/>If this bit is set to 1, DW_axi_dmac uses the value of CHx_CTL.AWLEN as AXI Burst length for destination data<br/>transfer till the extent possible; remaining transfers use maximum possible burst length.<br/>If this bit is set to 0, DW_axi_dmac uses any possible value which is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH as AXI Burst length for destination data transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Burst Length is any possible value <= DMAX_CH2_MAX_AMBA_BURST_LENGTH for Destination data transfers<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Burst Length is CH2_CTL.AWLEN (till the extent possible) for Destination data transfers<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[46:39]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ARLEN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Burst Length<br/>AXI Burst length used for source data transfer. The specified burst length is used for source data transfer till the extent<br/>possible; remaining transfers use maximum possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.<br/>The maximum value of ARLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[38:38]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ARLEN_EN</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Burst Length Enable<br/>If this bit is set to 1, DW_axi_dmac uses the value of CHx_CTL.ARLEN as AXI Burst length for source data transfer<br/>till the extent possible; remaining transfers use maximum possible burst length.<br/>If this bit is set to 0, DW_axi_dmac uses any possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH as AXI Burst length for source data transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">AXI Burst Length is any possible value <= DMAX_CH2_MAX_AMBA_BURST_LENGTH for Source data transfers<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">AXI Burst Length is CH2_CTL.ARLEN (till the extent possible) for Source data transfers<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[37:35]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AW_PROT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'aw_prot' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[34:32]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AR_PROT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'ar_prot' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit31 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">NonPosted_LastWrite_En</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Non Posted Last Write Enable<br/>This bit decides whether posted writes can be used throughout the block transfer.<br/> - 0: Posted writes may be used throughout the block transfer.<br/> - 1: Posted writes may be used till the end of the block (inside a block) and the last write in the block must be non-posted. This is to synchronize block completion interrupt generation to the last write data reaching the end memory/peripheral.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Posted writes may be used throughout the block transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Last write in the block must be non-posted<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:26]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AW_CACHE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'aw_cache' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:22]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AR_CACHE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI 'ar_cache' signal</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:18]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_MSIZE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Burst Transaction Length.<br/>Number of data items, each of width CHx_CTL.DST_TR_WIDTH, to be written to the destination every time a<br/>destination burst transaction request is made from the corresponding hardware or software handshaking interface.<br/>Note: This Value is not related to the AXI awlen signal.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_1024</td>
          <td class="unboxed addr">0x09</td>
          <td class="unboxed scdescmap">1024 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_128</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">128 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_16</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">16 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_256</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">256 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_32</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">32 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_4</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">4 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_512</td>
          <td class="unboxed addr">0x08</td>
          <td class="unboxed scdescmap">512 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_64</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">64 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_8</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">8 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEM_1</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">1 Data Item write to Destination in the burst transaction<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:14]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_MSIZE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Burst Transaction Length.<br/>Number of data items, each of width CHx_CTL.SRC_TR_WIDTH, to be read from the source every time a source<br/>burst transaction request is made from the corresponding hardware or software handshaking interface. The maximum value of DST_MSIZE is limited by DMAX_CHx_MAX_MSIZE.<br/>Note: This Value is not related to the AXI arlen signal.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_1024</td>
          <td class="unboxed addr">0x09</td>
          <td class="unboxed scdescmap">1024 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_128</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">128 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_16</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">16 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_256</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">256 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_32</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">32 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_4</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">4 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_512</td>
          <td class="unboxed addr">0x08</td>
          <td class="unboxed scdescmap">512 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_64</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">64 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEMS_8</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">8 Data Item read from Source in the burst transaction<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DATA_ITEM_1</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">1 Data Item read from Source in the burst transaction<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:11]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_TR_WIDTH</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transfer Width.<br/>Mapped to AXI bus awsize, this value must be less than or equal to DMAX_M_DATA_WIDTH.</span></p>
          <p><b>Reset: </b>hex:0x6;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BITS_1024</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 1024 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_128</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 128 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_16</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 16 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_256</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 256 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_32</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 32 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_512</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 512 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_64</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 64 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_8</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination Transfer Width is 8 bits<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:08]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_TR_WIDTH</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transfer Width.<br/>Mapped to AXI bus arsize, this value must be less than or equal to DMAX_M_DATA_WIDTH.</span></p>
          <p><b>Reset: </b>hex:0x6;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BITS_1024</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">Source Transfer Width is 1024 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_128</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">Source Transfer Width is 128 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_16</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source Transfer Width is 16 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_256</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">Source Transfer Width is 256 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_32</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Source Transfer Width is 32 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_512</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">Source Transfer Width is 512 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_64</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Source Transfer Width is 64 bits<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BITS_8</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source Transfer Width is 8 bits<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_7</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit7 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DINC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Address Increment.<br/>Indicates whether to increment the destination address on every destination transfer. If the device is writing data from a source peripheral FIFO with a fixed address, then set this field to 'No change'.<br/> - 0: Increment <br/> - 1: No Change<br/>NOTE: Increment aligns the address to the next CHx_CTL.DST_TR_WIDTH boundary.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">FIXED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination address is fixed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INCREMENTAL</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination address incremented on every source transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_5</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit5 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SINC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Address Increment.<br/>Indicates whether to increment the source address on every source transfer. If the device is fetching data from a source peripheral FIFO with a fixed address, then set this field to 'No change'.<br/> - 0: Increment <br/> - 1: No Change<br/>NOTE: Increment aligns the address to the next CHx_CTL.SRC_TR_WIDTH boundary.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">FIXED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source address is fixed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INCREMENTAL</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source address incremented on every source transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_3</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit3 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Manager Select.<br/>Identifies the Manager Interface layer from which the destination device (peripheral or memory) is accessed.<br/> - 0: AXI manager 1 <br/> - 1: AXI Manager 2<br/></span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MASTER1_INTF</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination device on Manager-1 interface layer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MASTER2_INTF</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination device on Manager-2 interface layer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CTL_1</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Control Transfer Register bit1 Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SMS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Manager Select.<br/>Identifies the Manager Interface layer from which the source device (peripheral or memory) is accessed.<br/> - 0: AXI manager 1 <br/> - 1: AXI Manager 2<br/></span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MASTER1_INTF</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source device on Manager-1 interface layer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MASTER2_INTF</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source device on Manager-2 interface layer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_45274B7D6394AC46" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000220</span> Register(64 bit) CH2_CFG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Configuration Register</span><br/>
      <span class="ldescdet">This register contains fields that configure the DMA transfer. This register should be programmed prior to enabling the channel.<br/>Bits [63:32] of the<br/>channel configuration register remains fixed for all blocks of a multi-block transfer and can be programmed only when channel is disabled.<br/>Bits [3:0] of the channel configuration register can be<br/>programmed even when channel is enabled.<br/>Software clears these bits to end the multi-block transfers. For Contiguous-Address and Auto-Reloading-based multi-block transfers (if neither source nor destination peripheral uses Shadow-Register or Linked-List-based multi-block transfers), if the corresponding multi-block type selection bits namely CHx_CFG.SRC_MLTBLK_TYPE and/or CHx_CFG.DST_MLTBLK_TYPE bits are seen to be 2'b00 at the end of a block transfer, the DW_axi_dmac understands that the previous block was the final block in the transfer and completes the DMA transfer operation.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502220</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000001b00000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CFG_63</td>
        <td class="fldnorm" colspan="4">DST_OSR_LMT</td>
        <td class="fldnorm" colspan="4">SRC_OSR_LMT</td>
        <td class="fldnorm" colspan="2">LOCK_CH_L</td>
        <td class="fldnorm" colspan="1">LOCK_CH</td>
        <td class="fldnorm" colspan="3">CH_PRIOR</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CFG_48</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_CFG_47_44</td>
        <td class="fldnorm" colspan="2">DST_PER</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_CFG_43</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_CFG_42_39</td>
        <td class="fldnorm" colspan="2">SRC_PER</td>
        <td class="fldnorm" colspan="1">DST_HWHS_POL</td>
        <td class="fldnorm" colspan="1">SRC_HWHS_POL</td>
        <td class="fldnorm" colspan="1">HS_SEL_DST</td>
        <td class="fldnorm" colspan="1">HS_SEL_SRC</td>
        <td class="fldnorm" colspan="3">TT_FC</td>
        <td class="fldnorm" colspan="3">RSVD_DMAC_CHx_CFG_29to31</td>
        <td class="fldnorm" colspan="4">WR_UID</td>
        <td class="fldnorm" colspan="3">RSVD_DMAC_CHx_CFG_22to24</td>
        <td class="fldnorm" colspan="4">RD_UID</td>
        <td class="fldnorm" colspan="14">RSVD_DMAC_CHx_CFG_4to17</td>
        <td class="fldnorm" colspan="2">DST_MULTBLK_TYPE</td>
        <td class="fldnorm" colspan="2">SRC_MULTBLK_TYPE</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="4">RW/V</td>
        <td class="accno" colspan="4">RW/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="3">RW/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="2">RW/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="2">RW/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="3">RW/V</td>
        <td class="accno" colspan="3">RO/V</td>
        <td class="accno" colspan="4">RO/V</td>
        <td class="accno" colspan="3">RO/V</td>
        <td class="accno" colspan="4">RO/V</td>
        <td class="accno" colspan="14">RO/V</td>
        <td class="accno" colspan="2">RW/V</td>
        <td class="accno" colspan="2">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:63]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (63bit) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[62:59]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_OSR_LMT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Outstanding Request Limit<br/> - Maximum outstanding request supported is 16.<br/> - Destination Outstanding Request Limit = DST_OSR_LMT + 1</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[58:55]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_OSR_LMT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Outstanding Request Limit<br/> - Maximum outstanding request supported is 16.<br/> - Source Outstanding Request Limit = SRC_OSR_LMT + 1</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[54:53]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LOCK_CH_L</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Level<br/>This bit indicates the duration over which CHx_CFG.LOCK_CH bit applies.<br/> - 00: Over complete DMA transfer<br/> - 01: Over DMA block transfer<br/> - 1x: Reserved<br/>This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN is set to False; in that case, the read-back value is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BLOCK_TRANFER_CH_LOCK</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Duration of the Channel locking is for the current block transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DMA_transfer_CH_LOCK</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Duration of the Channel locking is for the entire DMA transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[52:52]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LOCK_CH</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock bit<br/>When the channel is granted control of the manager bus interface and if the CHx_CFG.LOCK_CH bit is asserted, then no other<br/>channels are granted control of the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L. Indicates to the manager bus interface arbiter that this channel wants exclusive access to<br/>the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L.<br/>This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN is set to False; in this case, the<br/>read-back value is always 0.<br/>Locking the channel locks AXI Read Address, Write Address and Write Data channels on the corresponding manager interface.<br/>Note: Channel locking feature is<br/>supported only for memory-to-memory transfer at Block Transfer and DMA Transfer levels. Hardware does not check for the validity of channel locking setting, hence the software must take care of<br/>enabling the channel locking only for memory-to-memory transfers at Block Transfer or DMA Transfer levels. Illegal programming of channel locking might result in unpredictable behavior.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CHANNEL_LOCK</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is locked and granted exclusive access to the Manager Bus Interface<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_CHANNEL_LOCK</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not locked during the transfers<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[51:49]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_PRIOR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Priority<br/>A priority of DMAX_NUM_CHANNELS-1 is the highest priority, and 0 is the lowest. This field must be programmed within the following range:<br/><br/>     0: DMAX_NUM_CHANNELS-1<br/>A programmed value outside this range will cause erroneous behavior.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[48:48]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_48</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (48bit) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[47:46]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_47_44</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+44) to 47) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[45:44]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_PER</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to the destination of Channelx if the CHx_CFG.HS_SEL_DST field is 0;<br/>otherwise, this field is ignored. The channel can then communicate with the destination peripheral connected to that interface through the assigned hardware handshaking interface.<br/><br/>Note: For correct DW_axi_dmac operation, only one peripheral (source or destination) should be assigned to the same handshaking interface. <br/>This field does not exist if the configuration<br/>parameter DMAX_NUM_HS_IF is set to 0.<br/>x = 44 if DMAC_NUM_HS_IF is 1<br/>x = ceil(log2(DMAC_NUM_HS_IF)) + 43 if DMAC_NUM_HS_IF is greater than 1<br/>Bits 47: (x+1) do not exist and return 0 on a read.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[43:43]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_43</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (43bit) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[42:41]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_42_39</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+39) to 42) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[40:39]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_PER</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to the source of Channelx if the CHx_CFG.HS_SEL_SRC field is 0; otherwise,<br/>this field is ignored. The channel can then communicate with the source peripheral connected to that interface through the assigned hardware handshaking interface.<br/><br/>Note: For correct DW_axi_dmac operation, only one peripheral (source or destination) should be assigned to the same handshaking interface.<br/>This field does not exist if the configuration<br/>parameter DMAX_NUM_HS_IF is set to 0.<br/>x = 39 if DMAC_NUM_HS_IF is 1<br/>x = ceil(log2(DMAC_NUM_HS_IF) + 38 if DMAC_NUM_HS_IF is greater than 1.<br/>Bits 42: (x+1) do not exist and return 0 on a read.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[38:38]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_HWHS_POL</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Hardware Handshaking Interface Polarity.<br/> - 0: ACTIVE HIGH<br/> - 1: ACTIVE LOW <br/>Note: This field is reserved for future use and currently this is always active high.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_HIGH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Destination peripheral is Active High<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LOW</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Destination peripheral is Active Low<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[37:37]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_HWHS_POL</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Hardware Handshaking Interface Polarity.<br/> - 0: ACTIVE HIGH<br/> - 1: ACTIVE LOW <br/>Note: This field is reserved for future use and currently this is always active high.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_HIGH</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Source peripheral is Active High<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LOW</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Polarity of the Handshaking Interface used for the Source peripheral is Active Low<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[36:36]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">HS_SEL_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Software or Hardware Handshaking Select.<br/>This register selects which of the handshaking interfaces (hardware or software) is active for destination requests on this channel.<br/> - 0: Hardware handshaking interface. Software-initiated transaction requests are ignored.<br/> - 1: Software handshaking interface. Hardware-initiated transaction requests are ignored.<br/>If the destination peripheral is memory, then this bit is ignored.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">HARDWARE_HS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Hardware Handshaking Interface is used for the Destination peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SOFTWARE_HS</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Software Handshaking Interface is used for the Destination peripheral<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">HS_SEL_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Software or Hardware Handshaking Select.<br/>This register selects which of the handshaking interfaces (hardware or software) is active for source requests on this channel.<br/> - 0: Hardware handshaking interface. Software-initiated transaction requests are ignored.<br/> - 1: Software handshaking interface. Hardware-initiated transaction requests are ignored.<br/>If the source peripheral is memory, then this bit is ignored.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">HARDWARE_HS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Hardware Handshaking Interface is used for the Source peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SOFTWARE_HS</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Software Handshaking Interface is used for the Source peripheral<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:32]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">TT_FC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Transfer Type and Flow Control.<br/>The following transfer types are supported.<br/> - Memory to Memory <br/> - Memory to Peripheral <br/> - Peripheral to Memory <br/> - Peripheral to Peripheral <br/> Flow Control can be assigned to the DW_axi_dmac, the source peripheral, or the destination peripheral.</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MEM_TO_MEM_DMAC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Transfer Type is memory to memory and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MEM_TO_PER_DMAC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Transfer Type is memory to peripheral and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MEM_TO_PER_DST</td>
          <td class="unboxed addr">0x6</td>
          <td class="unboxed scdescmap">Transfer Type is memory to peripheral and Flow Controller is Destination peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_MEM_DMAC</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to memory and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_MEM_SRC</td>
          <td class="unboxed addr">0x4</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to Memory and Flow Controller is Source peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_PER_DMAC</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to peripheral and Flow Controller is DW_axi_dmac<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_PER_DST</td>
          <td class="unboxed addr">0x7</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to peripheral and Flow Controller is Destination peripheral<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">PER_TO_PER_SRC</td>
          <td class="unboxed addr">0x5</td>
          <td class="unboxed scdescmap">Transfer Type is peripheral to peripheral and Flow Controller is Source peripheral<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:29]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_29to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits 29to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[28:25]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">WR_UID</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Defines the number of AXI Unique ID's supported for the AXI Write Channel. The value programmed must be less than or equal to DMAX_CH(x)_WR_UID. Otherwise, it is limited by the value DMAX_CH(x)_WR_UID.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[24:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_22to24</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits 22to24) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:18]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RD_UID</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Defines the number of AXI Unique ID's supported for the AXI Read Channel. The value programmed must be less than or equal to DMAX_CH(x)_RD_UID. Otherwise, it is limited by the value DMAX_CH(x)_RD_UID.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[17:04]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_4to17</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Transfer Configuration Register (bits 4to17) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:02]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_MULTBLK_TYPE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Multi Block Transfer Type.<br/>These bits define the type of multi-block transfer used for destination peripheral.<br/> - 00: Contiguous<br/> - 01: Reload<br/> - 10: Shadow Register<br/> - 11: Linked List<br/>If the type selected is Contiguous, the CHx_DAR register is loaded with the value of the end source address of previous block + 1 at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Reload, the CHx_DAR register is reloaded from the initial value of DAR at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Shadow Register, the CHx_DAR register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1<br/>at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>If the type selected is Linked List, the CHx_DAR register is loaded from the Linked List if<br/>CTL.ShadowReg_Or_LLI_Valid bit is set to 1 at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>CHx_CTL and CHx_BLOCK_TS registers are loaded from<br/>their initial values or from the contents of their shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set to 1) at<br/>the end of every block for multi-block transfers based on the multi-block transfer type programmed for source and destination peripherals.<br/>Contiguous transfer on both source and destination<br/>peripheral is not a valid multi-block transfer configuration.<br/>This field does not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is not selected; in that case, the read-back value is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CONTINGUOUS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Contiguous Multiblock Type used for Destination Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">LINKED_LIST</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Linked List based Multiblock Type used for Destination Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">RELOAD</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Reload Multiblock Type used for Destination Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SHADOW_REGISTER</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Shadow Register based Multiblock Type used for Destination Transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_MULTBLK_TYPE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Multi Block Transfer Type.<br/>These bits define the type of multi-block transfer used for source peripheral.<br/> - 00: Contiguous<br/> - 01: Reload<br/> - 10: Shadow Register<br/> - 11: Linked List<br/>If the type selected is Contiguous, the CHx_SAR register is loaded with the value of the end source address of previous block + 1 at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Reload, the CHx_SAR register is reloaded from the initial value of SAR at the end of every block for multi-block transfers. A new block<br/>transfer is then initiated.<br/>If the type selected is Shadow Register, the CHx_SAR register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1<br/>at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>If the type selected is Linked List, the CHx_SAR register is loaded from the Linked List if<br/>CTL.ShadowReg_Or_LLI_Valid bit is set to 1 at the end of every block for multi-block transfers. A new block transfer is then initiated.<br/>CHx_CTL and CHx_BLOCK_TS registers are loaded from<br/>their initial values or from the contents of their shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set to 1) at<br/>the end of every block for multi-block transfers based on the multi-block transfer type programmed for source and destination peripherals.<br/>Contiguous transfer on both source and destination<br/>peripheral is not a valid multi-block transfer configuration.<br/>This field does not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is not selected; in that case, the read-back value is always 0.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CONTINGUOUS</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Contiguous Multiblock Type used for Source Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">LINKED_LIST</td>
          <td class="unboxed addr">0x3</td>
          <td class="unboxed scdescmap">Linked List based Multiblock Type used for Source Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">RELOAD</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Reload Multiblock Type used for Source Transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">SHADOW_REGISTER</td>
          <td class="unboxed addr">0x2</td>
          <td class="unboxed scdescmap">Shadow Register based Multiblock Type used for Source Transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_84B098D267C7043A" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000228</span> Register(64 bit) CH2_LLP</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Linked List Pointer Register</span><br/>
      <span class="ldescdet">This is the Linked List Pointer register. This register must be programmed to point to the first Linked List Item (LLI) in memory prior to enabling the<br/>channel if linked-list-based block chaining is enabled. This register is updated with new value of linked list pointer during the LLI update stage of dma transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502228</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="58">LOC</td>
        <td class="fldnorm" colspan="5">RSVD_DMAC_CHx_LLP_1to5</td>
        <td class="fldnorm" colspan="1">LMS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="58">RW/V</td>
        <td class="accno" colspan="5">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:06]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LOC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Starting Address Memory of LLI block<br/>Starting Address In Memory of next LLI if block chaining is enabled. The six LSBs of the starting address<br/>are not stored because the address is assumed to be aligned to a 64-byte boundary.<br/>LLI access always uses the burst size (arsize/awsize) that is same as the data bus width and cannot be changed or<br/>programmed to anything other than this. Burst length (awlen/arlen) is chosen based on the data bus width so that the access does not cross one complete LLI structure of 64 bytes. DW_axi_dmac will fetch<br/>the entire LLI (40 bytes) in one AXI burst if the burst length is not limited by other settings.</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[05:01]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_LLP_1to5</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Linked List Pointer Register (bits 1to5) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LMS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI manager Select<br/>This bit identifies the AXI layer/interface where the memory device that stores the next linked list item resides. <br/> - 0: AXI Manager 1<br/> - 1: AXI Manager 2<br/>This field does not exist if the configuration parameter DMAX_CHx_LMS is not set to NO_HARDCODE.<br/>In this case, the read-back value is always the hardcoded value. The maximum value of this field that can be read back is 'DMAX_NUM_MASTER_IF-1'.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">MANAGER1_INTF</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">next Linked List item resides on AXI Manager1 interface<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">MANAGER2_INTF</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">next Linked List item resides on AXI Manager2 interface<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_B0A156E046A2EE36" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000230</span> Register(64 bit) CH2_STATUSREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Status Register</span><br/>
      <span class="ldescdet">Channelx Status Register contains fields that indicate the status of DMA transfers for Channelx.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502230</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="17">RSVD_DMAC_CHx_STATUSREG_47to63</td>
        <td class="fldnorm" colspan="15">DATA_LEFT_IN_FIFO</td>
        <td class="fldnorm" colspan="10">RSVD_DMAC_CHx_STATUSREG_22to31</td>
        <td class="fldnorm" colspan="22">CMPLTD_BLK_TFR_SIZE</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="17">RO/V</td>
        <td class="accno" colspan="15">RO/V</td>
        <td class="accno" colspan="10">RO/V</td>
        <td class="accno" colspan="22">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:47]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_STATUSREG_47to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Status Register (bits 47to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[46:32]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DATA_LEFT_IN_FIFO</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Data Left in FIFO.<br/> The data left in the FIFO status indicates the total number of data left in the channel FIFO after completing the current DMA block transfer or DMA block abnormal termination due to the following reasons: <br/> - AXI Transfer Error response (SLVERR or DECERR) reception<br/><br/> - Channel Terminate<br/>The width of the data in channel FIFO is defined in terms of CHx_CTL.SRC_TR_WIDTH. For more information, see "DMA Status Register - CHx_STATUSREG" section of the databook.</span></p>
          <p><b>Reset: </b>hex:0x0000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_STATUSREG_22to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Status Register (bits 22to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CMPLTD_BLK_TFR_SIZE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Completed Block Transfer Size.<br/>The Completed Block Transfer Size status indicates the total number of data items transferred from the Source memory/peripheral to the Destination memory/peripheral at any point in the DMA block transfer.<br/>The completed block transfer size or data items is defined as follows:<br/> - When DMA or Source is a Flow controller, this field is defined in terms of the CHx_CTL.SRC_TR_WIDTH.<br/> - When Destination is a Flow Controller, this field is defined in terms of the CHx_CTL.DST_TR_WIDTH.<br/>For more information, see "DMA Status Register - CHx_STATUSREG" section of the databook.</span></p>
          <p><b>Reset: </b>hex:0x000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_65108BCD5AE54EA8" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000238</span> Register(64 bit) CH2_SWHSSRCREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Software Handshake Source Register</span><br/>
      <span class="ldescdet">Channelx Software handshake Source Register.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502238</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="58">RSVD_DMAC_CHx_SWHSSRCREG_6to63</td>
        <td class="fldnorm" colspan="1">SWHS_LST_SRC_WE</td>
        <td class="fldnorm" colspan="1">SWHS_LST_SRC</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_SRC_WE</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_SRC</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_SRC_WE</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_SRC</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="58">RO/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:06]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_SWHSSRCREG_6to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Software Handshake Source Register (bits 6to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_SRC_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Last Request for Channel Source.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_LAST_SRC bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_LAST_SRC bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Last Request for Channel Source.<br/>This bit is used to request LAST dma source data transfer if software handshaking method is<br/>selected for the source of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the source of the Channelx or if the source of Channelx is not the flow<br/>controller.<br/>CHx_SWHSSrcReg.SWHS_Req_Src bit must be set to 1 for DW_axi_dmac to treat it as a valid software handshaking request.<br/>If CHx_SWHSSrcReg.SWHS_SglReq_Src is set to 1, the LAST<br/>request is for SINGLE dma transaction (AXI burst length = 1), else the request is treated as a BURST transaction request.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Lst_Src bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSSrcReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source peripheral indication to DMAC that the current transfer is the last transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_LAST_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source peripheral indication that the current transfer is not the last transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_SRC_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Single Request for Channel Source.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_SGLREQ_SRC bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_SGLREQ_SRC bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Single Request for Channel Source.<br/>This bit is used to request SINGLE (AXI burst length = 1) dma source data transfer if<br/>software handshaking method is selected for the source of the corresponding channel. This bit is ignored if software handshaking is not enabled for the source of the Channelx. The functionality of<br/>this field depends on whether the peripheral is the flow controller.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_SglReq_Src bit is written only if the corresponding write enable bit, SWHS_SglReq_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSSrcReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source peripheral request for a single dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_SGLREQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source peripheral is not requesting for a single transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_SRC_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Request for Channel Source.<br/>Note: This bit always returns 0 on a read back.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_REQ_SRC bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_REQ_SRC bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_SRC</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Request for Channel Source.<br/>This bit is used to request dma source data transfer if software handshaking method is selected<br/>for the source of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the source of the Channelx. The functionality of this field depends on whether the<br/>peripheral is the flow controller or not.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Req_Src bit is written only if the corresponding write enable bit, SWHS_Req_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSSrcReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source peripheral request for a dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_REQ_SRC</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source peripheral is not requesting for a burst transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_D74F4B86ADCFEA08" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000240</span> Register(64 bit) CH2_SWHSDSTREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Software Handshake Destination Register</span><br/>
      <span class="ldescdet">Channelx Software handshake Destination Register.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502240</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="58">RSVD_DMAC_CHx_SWHSDSTREG_6to63</td>
        <td class="fldnorm" colspan="1">SWHS_LST_DST_WE</td>
        <td class="fldnorm" colspan="1">SWHS_LST_DST</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_DST_WE</td>
        <td class="fldnorm" colspan="1">SWHS_SGLREQ_DST</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_DST_WE</td>
        <td class="fldnorm" colspan="1">SWHS_REQ_DST</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="58">RO/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
        <td class="accno" colspan="1">WS/V</td>
        <td class="accno" colspan="1">RW/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:06]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_SWHSDSTREG_6to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Software Handshake Destination Register (bits 6to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_DST_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Last Request for Channel Destination.<br/>Note: This bit always returns 0 on a read back.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_LAST_DST bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_LAST_DST bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_LST_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Last Request for Channel Destination.<br/>This bit is used to request LAST dma destination data transfer if software handshaking<br/>method is selected for the destination of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the destination of the Channelx or if the destination of<br/>Channelx is not the flow controller. CHx_SWHSDstReg.SWHS_Req_Dst bit must be set to 1 for DW_axi_dmac to treat it as a valid software handshaking request.<br/>If CHx_SWHSDstReg.SWHS_SglReq_Dst<br/>is set to 1, the LAST request is for SINGLE dma transaction (AXI burst length = 1), else the request is treated as a BURST transaction request.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Lst_Src bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination peripheral indication to DMAC that the current transfer is the last transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_LAST_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination peripheral indication that the current transfer is not the last transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_DST_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Single Request for Channel Destination.<br/>Note: This bit always returns 0 on a read block.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_SGLREQ_DST bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_SGLREQ_DST bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_SGLREQ_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Single Request for Channel Destination.<br/>This bit is used to request SINGLE (AXI burst length = 1) dma destination data<br/>transfer if software handshaking method is selected for the destination of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the destination of the<br/>Channelx. The functionality of this field depends on whether the peripheral is the flow controller.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_SglReq_Dst bit is written only if the corresponding write enable bit, SWHS_SglReq_Dst_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination peripheral request for a single dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_SGLREQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination peripheral is not requesting for a single transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>WS/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_DST_WE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Write Enable bit for Software Handshake Request for Channel Destination.<br/>Note: This bit always returns 0 on a read block.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disables write to the SWHS_REQ_DST bit<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enables write to the SWHS_REQ_DST bit<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SWHS_REQ_DST</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Software Handshake Request for Channel Destination.<br/>This bit is used to request dma destination data transfer if software handshaking method is<br/>selected for the destination of the corresponding channel.<br/>This bit is ignored if software handshaking is not enabled for the source of the Channelx. The functionality of this field depends on<br/>whether the peripheral is the flow controller.<br/>Software can only set this bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac can clear this bit.<br/>Note: SWHS_Req_Dst bit is written only if the corresponding write enable bit, SWHS_Req_Dst_WE is asserted on the same register write operation and if the Channelx is enabled in the DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg register without performing a read-modified write operation.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination peripheral request for a dma transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SWHS_REQ_DST</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination peripheral is not requesting for a burst transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_57DF07A168696559" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000248</span> Register(64 bit) CH2_BLK_TFR_RESUMEREQREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Block Transfer Resume Request Register</span><br/>
      <span class="ldescdet">Channelx Block Transfer Resume Request Register. This register is used during Linked List or Shadow Register based multi-block transfer.<br/>     - For Linked-List-based multi-block transfer, ShadowReg_Or_LLI_Valid bit in LLI.CHx_CTL indicates whether the linked list item fetched from the memory is valid (0: LLI is invalid, 1: LLI is<br/>       valid). On noticing this bit as 0, DW_axi_dmac discards the LLI and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt if the corresponding channel error interrupt mask bit is set to 0. This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully. DW_axi_dmac waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid LLI availability, before attempting another LLI read operation.<br/>    - For Shadow-Register-based multi-block transfer, ShadowReg_Or_LLI_Valid bit in CHx_CTL register indicates whether the shadow register contents are valid (0: Shadow Register contents are<br/>      invalid, 1: Shadow Register contents are valid). On noticing this bit as 0 during shadow register fetch phase, DW_axi_dmac discards the Shadow Register contents and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt. DW_axi_dmac waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid shadow register availability, before attempting another shadow register fetch operation and continue the next block transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502248</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access WS</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="63">RSVD_DMAC_CHx_BLK_TFR_RESUMEREQREG_1to63</td>
        <td class="fldnorm" colspan="1">BLK_TFR_RESUMEREQ</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="63">WS</td>
        <td class="accno" colspan="1">WS</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:01]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_BLK_TFR_RESUMEREQREG_1to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Block Transfer Resume Request Register (bits 1to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">BLK_TFR_RESUMEREQ</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Resume Request during Linked-List or Shadow-Register-based multi-block transfer.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_BLK_TFR_RESUMEREQ</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Request for resuming the block transfer<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_BLK_TFR_RESUMEREQ</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No request to resume the block transfer<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_81EBCB46F6B10333" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000250</span> Register(64 bit) CH2_AXI_IDREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i AXI ID Register</span><br/>
      <span class="ldescdet">Channelx AXI ID Register. This register is allowed to be updated only when the channel is disabled, which means that it remains fixed for the entire<br/>DMA transfer.<br/>Note:  The presence of this register is determined by the DMAC_M_ID_WIDTH and DMAC_NUM_CHANNELS configuration parameters.<br/> - If LLI is enabled for any of the channel, then the register is present only when:<br/>DMAX_M_ID_WIDTH - (log2(DMAC_NUM_CHANNELS) +1) &gt; 0<br/> - Otherwise:<br/>DMAX_M_ID_WIDTH - log2(DMAC_NUM_CHANNELS) &gt; 0
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502250</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="32">RSVD_DMAC_CHx_AXI_IDREG_32to63</td>
        <td class="fldnorm" colspan="11">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm32to63</td>
        <td class="fldnorm" colspan="5">AXI_WRITE_ID_SUFFIX</td>
        <td class="fldnorm" colspan="11">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm1to31</td>
        <td class="fldnorm" colspan="5">AXI_READ_ID_SUFFIX</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="32">RO</td>
        <td class="accno" colspan="11">RO</td>
        <td class="accno" colspan="5">RW</td>
        <td class="accno" colspan="11">RO</td>
        <td class="accno" colspan="5">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_IDREG_32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI ID Register (bits 32to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:21]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to32) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[20:16]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_WRITE_ID_SUFFIX</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Write ID Suffix.<br/>These bits form part of the AWID output of AXI3/AXI4 manager interface.<br/>     IDW = DMAX_M_ID_WIDTH<br/>     L2NC =<br/>log2(DMAX_NUM_CHANNELS)<br/>The upper L2NC+1 bits of awidN is derived from the channel number which is currently accessing the manager interface.<br/>This varies for LLI fetch and source data<br/>transfer.<br/>For source data transfer, awidN for channel1 4'b0000, awidN for channel8 4'b0111 and so on.<br/>For LLI fetch access, awidN for channel1 4'b1000, awidN for channel8 4'b1111 and so<br/>on.<br/>Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Write_ID_Suffix filed.</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
      <tr>
        <td><b>[15:05]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_IDREG_IDW_L2NCm1to31</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to31) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[04:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_READ_ID_SUFFIX</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI Read ID Suffix<br/>These bits form part of the ARID output of AXI3/AXI4 manager interface.<br/><br/>     IDW = DMAX_M_ID_WIDTH<br/><br/>     L2NC = log2(DMAX_NUM_CHANNELS)<br/><br/>The upper L2NC+1 bits of aridN is derived from the channel number which is currently accessing the manager interface.<br/>This varies for LLI fetch and source data transfer.<br/>For source data transfer,<br/>aridN  for channel1 4'b0000, aridN for channel8 4'b0111 and so on.<br/>For LLI fetch access, aridN  for channel1 4'b1000, aridN for channel8 4'b1111 and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Read_ID_Suffix filed.</span></p>
          <p><b>Reset: </b>hex:0x00;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_9669614B2F5B5243" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000258</span> Register(64 bit) CH2_AXI_QOSREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i AXI QoS Register</span><br/>
      <span class="ldescdet">Channelx AXI QOS Register. This register is allowed to be updated only when the channel is disabled, which means that it remains fixed for the entire<br/>DMA transfer.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502258</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="56">RSVD_DMAC_CHx_AXI_QOSREG_8to63</td>
        <td class="fldnorm" colspan="4">AXI_ARQOS</td>
        <td class="fldnorm" colspan="4">AXI_AWQOS</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="56">RO</td>
        <td class="accno" colspan="4">RO</td>
        <td class="accno" colspan="4">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:08]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_AXI_QOSREG_8to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx AXI QOS Register (bits 8to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[07:04]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_ARQOS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI ARQOS.<br/>These bits form the arqos output of AXI4 manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[03:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">AXI_AWQOS</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">AXI AWQOS.<br/>These bits form the awqos output of AXI4 manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_CFF8F0052E675AEC" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000260</span> Register(64 bit) CH2_SSTAT</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Source Status Register</span><br/>
      <span class="ldescdet">Channelx Source Status Register. After each block transfer completes, hardware can retrieve the source status information from the address pointed to by<br/>the contents of the CHx_SSTATAR register. This status information is then stored in the CHx_SSTAT register and written out to the CHx_SSTAT register location of the LLI before the start of<br/>the next block.<br/>Source status write-back to the CHx_SSTAT register location of the LLI is performed only if DMAX_CHx_LLI_WB_EN = 1 and linked-list-based multi-block transfer is enabled for<br/>either source or destination peripheral of the channel.<br/>This register does not exist if DMAC_CHx_SRC_STAT_EN is set to False; in this case, the read-back value is always 0.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502260</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="32">RSVD_DMAC_CHx_SSTAT_32to63</td>
        <td class="fldnorm" colspan="32">SSTAT</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="32">RO</td>
        <td class="accno" colspan="32">RO</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_SSTAT_32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Source Status Register (bits 32to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[31:00]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SSTAT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Status<br/>Source status information retrieved by hardware from the address pointed to by the contents of the CHx_SSTATAR<br/>register.<br/>Source peripheral should update the source status information, if any, at the location pointed to by CHx_SSTATAR to utilize this feature.This status is not related to any internal<br/>status of DW_axi_dmac.<br/>This status is not related to any internal status of DW_axi_dmac.</span></p>
          <p><b>Reset: </b>hex:0x00000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_A8BA8D4B341A0E25" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000270</span> Register(64 bit) CH2_SSTATAR</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Source Status Fetch Register</span><br/>
      <span class="ldescdet">Channelx Source Status Fetch Register. After completion of each block transfer, hardware can retrieve the source status information from the<br/>user-defined address to which the contents of the CHx_SSTATAR register point. You can select any location in system memory that provides a 64-bit value to indicate the status of the source<br/>transfer.<br/>This register does not exist if DMAC_CHx_SRC_STAT_EN is set to False; in this case, the read-back value is always 0.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502270</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="64">SSTATAR</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="64">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SSTATAR</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Status Fetch Address<br/>Pointer from where hardware can fetch the source status information, which is registered in the CHx_SSTAT<br/>register and written out to the CHx_SSTAT register location of the LLI before the start of the next block if DMAX_CHx_LLI_WB_EN = 1 and linked list based multi-block transfer is enabled for<br/>either source or destination peripheral of the channel.<br/>Source peripheral should update the source status information, if any, at the location pointed to by CHx_SSTATAR to utilize this<br/>feature.<br/>This status is not related to any internal status of DW_axi_dmac.</span></p>
          <p><b>Reset: </b>hex:0x0000000000000000;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_05948AA33D393CD8" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000280</span> Register(64 bit) CH2_INTSTATUS_ENABLEREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Interrupt Status Enable Register</span><br/>
      <span class="ldescdet">Writing 1 to specific field enables the corresponding interrupt status generation in Channelx Interrupt Status Register(CH2_IntStatusReg).
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502280</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0xffffffffffffffff</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_32to63</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_ABORTED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_DISABLED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_SRC_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_CH_LOCK_CLEARED_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_26</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_22to23</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONHOLD_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONCHEN_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_RD2RWO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_MULTIBLKTYPE_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_DST_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SRC_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_DST_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SRC_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_DST_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_SRC_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</td>
        <td class="fldnorm" colspan="1">Enable_DMA_TFR_DONE_IntStat</td>
        <td class="fldnorm" colspan="1">Enable_BLOCK_TFR_DONE_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="2">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_32to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Enable Register (bits 32to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0xfffffff;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Uncorrectable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation Channel x UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Uncorrectable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Uncorrectable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Correctable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x UID Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation Channel x UID Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Correctable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Correctable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Uncorrectable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x Channel Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation Channel x Channel Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Uncorrectable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Uncorrectable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Correctable Error Interrupt enable.<br/> - 0: Disable the generation of Channel x Channel Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.<br/> - 1: Enable the generation of Channel x Channel Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Correctable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Correctable error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_ABORTED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated Status Enable.<br/> - 0: Disable the generation of Channel Terminated Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Terminated Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_ABORTED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Terminated Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_ABORTED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Terminated Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_DISABLED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled Status Enable.<br/> - 0: Disable the generation of Channel Disabled Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Disabled Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_DISABLED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Disabled Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_DISABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Disabled Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended Status Enable.<br/> - 0: Disable the generation of Channel Suspended Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Suspended Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Suspended Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Suspended Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SRC_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended Status Enable.<br/> - 0: Disable the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel Source Suspended Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel Source Suspended Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_LOCK_CLEARED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared Status Enable.<br/> - 0: Disable the generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Channel LOCK CLEARED Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Channel LOCK CLEARED Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bit 26) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error Enable.<br/> - 0: Disable the generation of Register Bus Interface Write Parity Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write Parity Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write Parity Error in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write Parity Error in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error Enable.<br/> - 0: Disable the generation of Register Bus Interface Address Parity Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Address Parity Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Address Parity Error in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Address Parity Error in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bits 22to23) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONHOLD_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Write On Hold Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write On Hold Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write On Hold Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write On Hold Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error Status Enable.<br/> - 0: Disable the generation of Shadow Register Write On Valid Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Shadow register Write On Valid Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Shadow Register Write On Valid Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Shadow register Write On Valid Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONCHEN_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write On Channel enabled Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_RD2RWO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Read to Write only Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Read to Write Only Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Read to Write only Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Read to Write Only Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Write to Read only Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Write to Read Only Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Write to Read only Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Write to Read Only Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bit 15) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_MULTIBLKTYPE_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error Status Enable.<br/> - 0: Disable the generation of Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Register Bus Interface Multi Block type Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Register Bus Interface Multi Block type Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error Status Enable.<br/> - 0: Disable the generation of Shadow Register or LLI Invalid Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Shadow Register or LLI Invalid  Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Shadow Register or LLI Invalid Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Shadow Register or LLI Invalid  Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error Status Enable.<br/> - 0: Disable the generation of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI WRITE Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI WRITE Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error Status Enable.<br/> - 0: Disable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI Read Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI Read Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error Status Enable.<br/> - 0: Disable the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI WRITE Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI WRITE Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error Status Enable.<br/> - 0: Disable the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of LLI Read Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of LLI Read Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error Status Enable.<br/> - 0: Disable the generation of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Destination Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Destination Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error Status Enable.<br/> - 0: Disable the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Source Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Source Subordinate Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error Status Enable.<br/> - 0: Disable the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Destination Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Destination Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error Status Enable.<br/> - 0: Disable the generation of Source Decode Error Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Source Decode Error Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Source Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Source Decode Error Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed Status Enable.<br/> - 0: Disable the generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Destination Transaction complete Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Destination Transaction complete Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed Status Enable.<br/> - 0: Disable the generation of Source Transaction Complete Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Source Transaction Complete Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Source Transaction Complete Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Source Transaction Complete Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Register (bit 2) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DMA_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done Interrupt Status Enable.<br/> - 0: Disable the generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DMA_TFR_DONE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of DMA Transfer Done Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DMA_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of DMA Transfer Done Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_BLOCK_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done Interrupt Status Enable.<br/> - 0: Disable the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG<br/> - 1: Enable the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_BLOCK_TFR_DONE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the generation of Block Transfer Done Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_BLOCK_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the generation of Block Transfer Done Interrupt in CH2_INTSTATUSREG<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_FD919E21AEB92B75" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000288</span> Register(64 bit) CH2_INTSTATUS</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Interrupt Status Register</span><br/>
      <span class="ldescdet">Channelx Interrupt Status Register captures the Channelx specific interrupts
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502288</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RO/V</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTSTATUSREG_36to63</td>
        <td class="fldnorm" colspan="1">ECC_PROT_UIDMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">ECC_PROT_UIDMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">ECC_PROT_CHMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">ECC_PROT_CHMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">CH_ABORTED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_DISABLED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_SRC_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">CH_LOCK_CLEARED_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUSREG_26</td>
        <td class="fldnorm" colspan="1">SLVIF_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTSTATUSREG_22to23</td>
        <td class="fldnorm" colspan="1">SLVIF_WRONHOLD_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_WRONCHEN_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_RD2RWO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SLVIF_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUSREG_15</td>
        <td class="fldnorm" colspan="1">SLVIF_MULTIBLKTYPE_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SHADOWREG_OR_LLI_INVALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_WR_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_RD_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_WR_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">LLI_RD_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">DST_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SRC_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">DST_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">SRC_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">DST_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">SRC_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUSREG_2</td>
        <td class="fldnorm" colspan="1">DMA_TFR_DONE_IntStat</td>
        <td class="fldnorm" colspan="1">BLOCK_TFR_DONE_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="2">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
        <td class="accno" colspan="1">RO/V</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_36to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bits 36to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_UIDMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x UID Memory Interface ECC Protection related Uncorrectable Error Interrupt Status bit.<br/><br/>This error occurs if ECC Uncorrectable error is detected on the UID Memory Interface data. <br/><br/> - 0: No Channel x UID Memory Interface Uncorrectable Error.<br/> - 1: Channel x UID Memory Interface Uncorrectable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_UIDMem_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_UIDMem_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_UIDMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x UID Memory Interface ECC Protection related Correctable Error Interrupt Status bit.<br/><br/>This error occurs if ECC correctable error is detected on the UID Memory Interface data. <br/><br/> - 0: No Channel x UID Memory Interface correctable Error.<br/> - 1: Channel x UID Memory Interface correctable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_UIDMem_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_UIDMem_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x UID Memory Interface correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_CHMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x FIFO Memory Interface ECC Protection related Uncorrectable Error Interrupt Status bit.<br/><br/>This error occurs if ECC Uncorrectable error is detected on the FIFO Memory Interface data. <br/><br/> - 0: No Channel x FIFO Memory Interface Uncorrectable Error.<br/> - 1: Channel x FIFO Memory Interface Uncorrectable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_CHMem_UnCorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface Uncorrectable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_CHMem_UnCorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface Uncorrectable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">ECC_PROT_CHMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x FIFO Memory Interface ECC Protection related Correctable Error Interrupt Status bit.<br/><br/>This error occurs if ECC correctable error is detected on the FIFO Memory Interface data. <br/><br/> - 0: No Channel x FIFO Memory Interface correctable Error.<br/> - 1: Channel x FIFO Memory Interface correctable Error detected. <br/><br/>Error Interrupt status is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg register is set to 1. This bit is cleared to 0 on writing 1 to the corresponding interrupt clear bit in CHx_IntClearReg.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_EccPROT_CHMem_CorrERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface correctable Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_EccPROT_CHMem_CorrERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel x FIFO Memory Interface correctable Error not detected<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_ABORTED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated.<br/>This indicates to the software that the corresponding channel in DW_axi_dmac is terminated.<br/> - 0: Channel is not terminated<br/> - 1: Channel is terminated<br/><br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_ABORTED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is terminated<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_ABORTED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not terminated<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_DISABLED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled.<br/>This indicates to the software that the corresponding channel in DW_axi_dmac is disabled.<br/> - 0: Channel is not disabled.<br/> - 1: Channel is disabled.<br/>    Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_DISABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is disabled<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_DISABLED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not disabled<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended.<br/>This indicates to the software that the corresponding channel in DW_axi_dmac is suspended.<br/> - 0: Channel is not suspended.<br/> - 1: Channel is suspended.<br/><br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel is suspended<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel is not suspended<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_SRC_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended.<br/>This indicates to the software that the corresponding channel source data transfer in DW_axi_dmac is suspended.<br/> - 0: Channel source is not suspended<br/> - 1: Channel Source is suspended.<br/><br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel Source is suspended<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel source is not suspended<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">CH_LOCK_CLEARED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared.<br/>This indicates to the software that the locking of the corresponding channel in DW_axi_dmac is cleared.<br/> - 0: Channel locking is not cleared.<br/> - 1: Channel locking is cleared.<br/><br/>Channel locking is cleared by DW_axi_dmac during the following situations:<br/> - Channel locking is cleared and the channel locking settings in CHx_CFG register is reset if DW_axi_dmac disables the channel upon request from software.<br/> - Channel locking is cleared and the channel locking settings in CHx_CFG register is reset if DW_axi_dmac disables the channel upon receiving error response on the manager interface.<br/><br/>This bit is cleared to 0 on enabling the channel.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Channel Locking is cleared<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Channel locking is not cleared, if present.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bit 26) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error.<br/>This error occurs if a Write operation is performed on a channel register; But the Write data fails the even/odd parity check.<br/> - 0: No Register Bus Interface Write Parity Errors.<br/> - 1: Register Bus Interface Write Parity Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write Parity Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error.<br/>This error occurs if address is used to do write/read operation on a channel register; But the Address fails the even/odd parity check.<br/> - 0: No Register Bus Interface Address Parity Errors.<br/> - 1: Register Bus Interface Address Parity Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Address Parity Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Address Parity Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bits 22to23) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WRONHOLD_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error.<br/>This error occurs if an illegal write operation is performed on a register; this happens if a write operation is performed on a channel register when DW_axi_dmac is in Hold mode.<br/> - 0: No Register Bus Interface Write On Hold Errors.<br/> - 1: Register Bus Interface Write On Hold Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write On Hold Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write On Hold Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error.<br/>This error occurs if shadow register based multi-block transfer is enabled and software tries to write to the shadow register when CHx_CTL.ShadowReg_Or_LLI_Valid bit is 1.<br/> - 0: No Register Bus Interface Shadow Register Write On Valid Errors.<br/> - 1: Register Bus Interface Shadow Register Write On Valid Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Shadow Register Write On Valid Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Shadow Register Write On Valid Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WRONCHEN_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error.<br/>This error occurs if an illegal write operation is performed on a register; this happens if a write operation is performed on a register when the channel is enabled and if it is not allowed for the corresponding register as per the DW_axi_dmac specification.<br/> - 0: No Register Bus Interface Write On Channel Enabled Errors.<br/> - 1: Register Bus Interface Write On Channel Enabled Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write On Channel Enabled Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write On Channel Enabled Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_RD2RWO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error.<br/>This error occurs if read operation is performed to a Write Only register.<br/> - 0: No Register Bus Interface Read to Write Only Errors.<br/> - 1: Register Bus Interface Read to Write Only Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Read to Write Only Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Read to Write Only Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error.<br/>This error occurs if write operation is performed to a Read Only register.<br/> - 0: No Register Bus Interface Write to Read Only Errors.<br/> - 1: Register Bus Interface Write to Read Only Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Write to Read Only Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Write to Read Only Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error.<br/>Decode Error generated by DW_axi_dmac during register access. This error occurs if the register access is to invalid address in Channelx register space resulting in error response by DW_axi_dmac register bus interface.<br/> - 0: No Register Bus Interface Decode errors.<br/> - 1: Register Bus Interface Decode Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHxINTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Register Bus Interface Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Register Bus Interface Decode errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bit 15) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SLVIF_MULTIBLKTYPE_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error.<br/>This error occurs if multi-block transfer type programmed in CHx_CFG register (SRC_MLTBLK_TYPE and DST_MLTBLK_TYPE) is invalid. This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully; Error Interrupt is generated if the corresponding channel error interrupt mask bit is set to 0 and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid multi-block transfer type availability.<br/> - 0: No Multi-block transfer type Errors.<br/> - 1: Multi-block transfer type Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Multi-block transfer type Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Multi-block transfer type Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SHADOWREG_OR_LLI_INVALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error.<br/>This error occurs if CHx_CTL.ShadowReg_Or_LLI_Valid bit is seen to be 0 during DW_axi_dmac Shadow<br/>Register / LLI fetch phase. This error condition causes the DW_axi_dmac to halt the corresponding channel gracefully; Error Interrupt is generated if the corresponding channel error interrupt mask bit<br/>is set to 0 and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate valid Shadow Register availability.<br/>In the case of LLI pre-fetching, ShadowReg_Or_LLI_Invalid_ERR Interrupt is not generated even if ShadowReg_Or_LLI_Valid bit is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac re-attempts the LLI fetch operation after completing the current block transfer and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt only if ShadowReg_Or_LLI_Valid bit is still seen to be 0.<br/> - 0: No Shadow Register / LLI Invalid errors.<br/> - 1: Shadow Register / LLI Invalid error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Shadow Register / LLI Invalid error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Shadow Register / LLI Invalid errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_WR_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error.<br/>Subordinate Error detected by Manager Interface during LLI write-back operation. This error occurs if the register bus interface on which LLI resides issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the error is set to 0.<br/> - 0: No LLI write Subordinate Errors.<br/> - 1: LLI Write SUBORDINATE Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_WR_SLV</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI Write SUBORDINATE Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_WR_SLV</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No LLI write Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_RD_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error.<br/>Subordinate Error detected by Manager Interface during LLI read operation. This error occurs if the register bus interface on which LLI resides issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the error is set to 0.<br/> - 0: No LLI Read Subordinate Errors.<br/> - 1: LLI read Subordinate Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI read Subordinate Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No LLI Read Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_WR_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error.<br/>Decode Error detected by Manager Interface during LLI write-back operation. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the error is set to 0.<br/> - 0: NO LLI Write Decode Errors.<br/> - 1: LLI write Decode Error detected.<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI write Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">NO LLI Write Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_RD_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error.<br/>Decode Error detected by Manager Interface during LLI read operation. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the error is set to 0.<br/> - 0: NO LLI Read Decode Errors.<br/> - 1: LLI Read Decode Error detected<br/>Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">LLI Read Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">NO LLI Read Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error.<br/>Subordinate Error detected by Manager Interface during destination data transfer. This error occurs if the register bus interface to which the data is written issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0.<br/> - 0: No Destination Subordinate Errors<br/> - 1: Destination Subordinate Errors Detected<br/><br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination Subordinate Errors Detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_DST_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Destination Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error.<br/>Subordinate Error detected by Manager Interface during source data transfer. This error occurs if the register bus interface from which the data is read issues a Subordinate Error. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0. <br/> - 0: No Source Subordinate Errors<br/> - 1: Source Subordinate Error Detected<br/><br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source Subordinate Error Detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Source Subordinate Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error.<br/>Decode Error detected by Manager Interface during destination data transfer. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0.<br/> - 0: No destination Decode Errors.<br/> - 1: Destination Decode Error Detected<br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination Decode Error Detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_DST_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No destination Decode Errors.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error.<br/>Decode Error detected by Manager Interface during source data transfer. This error occurs if the access is to invalid address and a Decode Error is returned from interconnect/subordinate. This error condition causes the DW_axi_dmac to disable the corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the channel which received the error is set to 0.<br/> - 0: No Source Decode Errors.<br/> - 1: Source Decode Error detected.<br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source Decode Error detected<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">No Source Decode Errors<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DST_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register or on enabling the channel (needed when interrupt is not enabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Destination transaction is complete<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Destination transaction is not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">SRC_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed.<br/><br/>    This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register or on enabling the channel (needed when interrupt is not enabled.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">ACTIVE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Source transaction is complete<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">INACTIVE_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Source transaction is not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUSREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Specific Interrupt Register (bit 2) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">DMA_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done.<br/>This indicates to the software that the DW_axi_dmac has completed the requested DMA transfer.<br/>The DW_axi_dmac sets this<br/>bit to 1 along with setting CHx_INTSTATUS.BLOCK_TFR_DONE bit to 1 when the last block transfer is completed.<br/> - 0: DMA Transfer not completed.<br/> - 1: DMA Transfer Completed<br/><br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DMA_TFR_COMPLETED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">DMA Transfer completed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">DMA_TFR_NOT_COMPLETE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">DMA Transfer not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RO/V</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">BLOCK_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done.<br/>This indicates to the software that the DW_axi_dmac has completed the requested block transfer.<br/>The DW_axi_dmac sets this bit to 1 when the transfer is successfully completed.<br/> - 0: Block Transfer not completed.<br/> - 1: Block Transfer completed.<br/>This bit is cleared to 0 on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg register.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">BLOCK_TFR_COMPLETED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Block Transfer completed<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">BLOCK_TFR_NOT_COMPLETE</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Block Transfer not complete<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_28EED0CE6A0720E9" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000290</span> Register(64 bit) CH2_INTSIGNAL_ENABLEREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Interrupt Signal Enable Register</span><br/>
      <span class="ldescdet">This register contains fields that are used to enable the generation of port level interrupt at the channel level.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502290</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0xffffffffffffffff</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_36to63</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_UIDMem_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_UnCorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_ECC_PROT_CHMem_CorrERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_ABORTED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_DISABLED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_SUSPENDED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_SRC_SUSPENDED_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_CH_LOCK_CLEARED_IntSignal</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_26</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRPARITY_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_ADDRPARITY_ERR_IntSignal</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_22to23</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONHOLD_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WRONCHEN_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_RD2RWO_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_WR2RO_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</td>
        <td class="fldnorm" colspan="1">Enable_SLVIF_MULTIBLKTYPE_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_WR_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_LLI_RD_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_DST_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SRC_SLV_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_DST_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SRC_DEC_ERR_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_DST_TRANSCOMP_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_SRC_TRANSCOMP_IntSignal</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</td>
        <td class="fldnorm" colspan="1">Enable_DMA_TFR_DONE_IntSignal</td>
        <td class="fldnorm" colspan="1">Enable_BLOCK_TFR_DONE_IntSignal</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="2">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RO</td>
        <td class="accno" colspan="1">RW</td>
        <td class="accno" colspan="1">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_36to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Signal Enable Register (bits 36to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0xfffffff;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Uncorrectable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x UID Memory Interface Uncorrectable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x UID Memory Interface Uncorrectable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_UIDMem_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Unique ID Memory Interface ECC Protection Correctable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x UID Memory Interface Correctable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x UID Memory Interface Correctable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of UID Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_UIDMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of UID Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_UnCorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Uncorrectable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x Channel Memory Interface Uncorrectable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x Channel Memory Interface Uncorrectable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_UNCORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Uncorrectable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_ECC_PROT_CHMem_CorrERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel x Channel Memory Interface ECC Protection Correctable Error Interrupt Signal enable.<br/> - 0: Disable the propagation of Channel x Channel Memory Interface Correctable Error to generate a port level interrupt.<br/> - 1: Enable the propagation of Channel x Channel Memory Interface Correctable Error to generate a port level interrupt.</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_ECC_CHMEM_CORRERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Memory ECC Correctable error Interrupt to port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_ABORTED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated Signal Enable.<br/> - 0: Disable the propagation of Channel Terminated Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Terminated Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_ABORTED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Terminated Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_ABORTED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Terminated Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_DISABLED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled Signal Enable.<br/> - 0: Disable the propagation of Channel Disabled Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Disabled Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_DISABLED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Disabled Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_DISABLED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Disabled Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SUSPENDED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended Signal Enable.<br/> - 0: Disable the propagation of Channel Suspended Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Suspended Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_SRC_SUSPENDED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended Signal Enable.<br/> - 0: Disable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_SRC_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_SRC_SUSPENDED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Source Suspended Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_CH_LOCK_CLEARED_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared Signal Enable.<br/> - 0: Disable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_CH_LOCK_CLEARED_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_CH_LOCK_CLEARED_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Channel Lock Cleared Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Signal Enable Register (bit 26) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRPARITY_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_WRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_WRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_ADDRPARITY_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Disable_SLVIF_ADDRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">Enable_SLVIF_ADDRPARITY_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Address Parity Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSIGNAL_ENABLEREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Signal Enable Register (bits 22to23) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x3;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONHOLD_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONHOLD_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONHOLD_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write On Hold Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error Signal Enable.<br/> - 0: Disable the propagation of Shadow Register Write On Valid Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Shadow register Write On Valid Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Shadow Register Write On Valid Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Shadow register Write On Valid Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WRONCHEN_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WRONCHEN_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WRONCHEN_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write On Channel enabled Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_RD2RWO_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Read to Write only Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Read to Write Only Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_RD2RWO_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Read to Write only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_RD2RWO_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Read to Write Only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_WR2RO_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Write to Read only Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Write to Read Only Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_WR2RO_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Write to Read only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_WR2RO_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Write to Read Only Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Enable Register (bit 15) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SLVIF_MULTIBLKTYPE_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error Signal Enable.<br/> - 0: Disable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SLVIF_MULTIBLKTYPE_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SLVIF_MULTIBLKTYPE_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Register Bus Interface Multi Block type Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error Signal Enable.<br/> - 0: Disable the propagation of Shadow Register or LLI Invalid Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Shadow Register or LLI Invalid  Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Shadow Register or LLI Invalid Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SHADOWREG_OR_LLI_INVALID_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Shadow Register or LLI Invalid  Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI WRITE Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI Read Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_WR_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error Signal Enable.<br/> - 0: Disable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_WR_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_WR_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI WRITE Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_LLI_RD_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error Signal Enable.<br/> - 0: Disable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_LLI_RD_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_LLI_RD_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of LLI Read Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Destination Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_SLV_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error Signal Enable.<br/> - 0: Disable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_SLV_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Source Subordinate Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error Signal Enable.<br/> - 0: Disable the propagation of Destination Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Destination Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Destination Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Destination Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_DEC_ERR_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error Signal Enable.<br/> - 0: Disable the propagation of Source Decode Error Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Source Decode Error Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Source Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_DEC_ERR_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Source Decode Error Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DST_TRANSCOMP_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed Signal Enable.<br/> - 0: Disable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DST_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DST_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Destination Transaction complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_SRC_TRANSCOMP_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed Signal Enable.<br/> - 0: Disable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_SRC_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_SRC_TRANSCOMP_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Source Transaction Complete Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTSTATUS_ENABLEREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Status Enable Register (bit 2) Reserved bit - Read Only</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_DMA_TFR_DONE_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done Interrupt Signal Enable.<br/> - 0: Disable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_DMA_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_DMA_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of DMA Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Enable_BLOCK_TFR_DONE_IntSignal</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done Interrupt Signal Enable.<br/> - 0: Disable the propagation of Block Transfer Done Interrupt to generate a port level interrupt<br/> - 1: Enable the propagation of Block Transfer Done Interrupt to generate a port level interrupt</span></p>
          <p><b>Reset: </b>hex:0x1;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">DISABLE_BLOCK_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Disable the propagation of Block Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">ENABLE_BLOCK_TFR_DONE_IntSignal</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Enable the propagation of Block Transfer Done Interrupt to generate a port level interrupt<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_491727171F8EE205" class="boxed tabrb"><span class="regname">+<span class="addr">0x00000298</span> Register(64 bit) CH2_INTCLEARREG</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Interrupt Status Clear Register</span><br/>
      <span class="ldescdet">Writing 1 to specific field will clear the corresponding field in Channelx Interrupt Status Register(CHx_IntStatusReg).
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x04502298</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access WS</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="28">RSVD_DMAC_CHx_INTCLEARREG_36to63</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_UIDMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_UIDMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_CHMem_UnCorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_ECC_PROT_CHMem_CorrERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_ABORTED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_DISABLED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_SRC_SUSPENDED_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_CH_LOCK_CLEARED_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTCLEARREG_26</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_ADDRPARITY_ERR_IntStat</td>
        <td class="fldnorm" colspan="2">RSVD_DMAC_CHx_INTCLEARREG_22to23</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WRONHOLD_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WRONCHEN_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_RD2RWO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_WR2RO_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTCLEARREG_15</td>
        <td class="fldnorm" colspan="1">Clear_SLVIF_MULTIBLKTYPE_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_WR_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_RD_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_WR_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_LLI_RD_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_DST_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SRC_SLV_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_DST_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SRC_DEC_ERR_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_DST_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_SRC_TRANSCOMP_IntStat</td>
        <td class="fldnorm" colspan="1">RSVD_DMAC_CHx_INTCLEARREG_2</td>
        <td class="fldnorm" colspan="1">Clear_DMA_TFR_DONE_IntStat</td>
        <td class="fldnorm" colspan="1">Clear_BLOCK_TFR_DONE_IntStat</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="28">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="2">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
        <td class="accno" colspan="1">WS</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:36]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_36to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bits 36to63) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[35:35]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_UIDMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Uncorrectable UID Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">Clear_ECC_UIDMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_UIDMem_UnCorrERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[34:34]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_UIDMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Correctable UID Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_ECC_UIDMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_UIDMem_CorrERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[33:33]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_CHMem_UnCorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Uncorrectable Channel Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_ECC_CHMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_CHMem_UnCorrERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[32:32]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_ECC_PROT_CHMem_CorrERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">ECC Protection Correctable Channel Memory Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_ECC_CHMEM_CORRERR_IntStat</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the ECC_PROT_CHMem_CorrERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[31:31]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_ABORTED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Terminated Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_ABORTED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_ABORTED interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[30:30]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_DISABLED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Disabled Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_DISABLED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_DISABLED interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[29:29]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Suspended Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_SUSPENDED interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[28:28]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_SRC_SUSPENDED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Source Suspended Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_SRC_SUSPENDED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_SRC_SUSPENDED interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[27:27]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_CH_LOCK_CLEARED_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Channel Lock Cleared Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_CH_LOCK_CLEARED</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the CH_LOCK_CLEARED interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[26:26]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_26</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bit 26) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[25:25]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write Parity Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WRPARITY_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[24:24]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_ADDRPARITY_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Address Parity Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_ADDRPARITY_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_ADDRPARITY_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[23:22]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_22to23</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bits 22to23) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[21:21]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WRONHOLD_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Hold Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WRONHOLD_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WRONHOLD_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[20:20]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_SHADOWREG_WRON_VALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow Register Write On Valid Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_SHADOWREG_WRON_VALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_SHADOWREG_WRON_VALID_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[19:19]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WRONCHEN_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write On Channel Enabled Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WRONCHEN_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WRONCHEN_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[18:18]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_RD2RWO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Read to write Only Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_RD2RWO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_RD2RWO_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[17:17]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_WR2RO_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Write to Read Only Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_WR2RO_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_WR2RO_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[16:16]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_DEC_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[15:15]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_15</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bit 15) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[14:14]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SLVIF_MULTIBLKTYPE_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Register Bus Interface Multi Block type Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SLVIF_MULTIBLKTYPE_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SLVIF_MULTIBLKTYPE_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[13:13]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SHADOWREG_OR_LLI_INVALID_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Shadow register or LLI Invalid Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SHADOWREG_OR_LLI_INVALID_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SHADOWREG_OR_LLI_INVALID_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[12:12]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_WR_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_WR_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_WR_SLV_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[11:11]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_RD_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_RD_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_RD_SLV_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[10:10]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_WR_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI WRITE Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_WR_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_WR_DEC_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[09:09]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_LLI_RD_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Read Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_LLI_RD_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the LLI_RD_DEC_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[08:08]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DST_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DST_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DST_SLV_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[07:07]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SRC_SLV_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Subordinate Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SRC_SLV_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SRC_SLV_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[06:06]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DST_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DST_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DST_DEC_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[05:05]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SRC_DEC_ERR_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Decode Error Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SRC_DEC_ERR</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SRC_DEC_ERR interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[04:04]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DST_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Destination Transaction Completed Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DST_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DST_TRANSCOMP interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[03:03]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_SRC_TRANSCOMP_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Source Transaction Completed Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_SRC_TRANSCOMP</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the SRC_TRANSCOMP interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[02:02]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_INTCLEARREG_2</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channelx Interrupt Clear Register (bit 2) Reserved bit - Write Only</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[01:01]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_DMA_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMA Transfer Done Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in<br/>CHx_INTSTATUSREG.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_DMA_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the DMA_TFR_DONE interrupt in the Interrupt Status Register(CH2_IntStatusReg).<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
      <tr>
        <td><b>[00:00]</b><br/>WS</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">Clear_BLOCK_TFR_DONE_IntStat</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">Block Transfer Done Interrupt Clear Bit.<br/>This bit is used to clear the corresponding channel interrupt status bit in CH2_INTSTATUSREG</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
      <table>
        <tr><th colspan="3">Valid Values</th></tr>
        <tr><th>Name</th><th>Value(s)</th><th>Description</th></tr>
        <tr class="tabry"><td class="unboxed">CLEAR_BLOCK_TFR_DONE</td>
          <td class="unboxed addr">0x1</td>
          <td class="unboxed scdescmap">Clear the interrupt in the Interrupt Status Register(CHx_IntStatusReg). Writing a 1 to this register field clears the corresponding bit in the CHx_IntStatusReg register.<br/></td>
        </tr>
        <tr class="tabry"><td class="unboxed">NO_ACTION</td>
          <td class="unboxed addr">0x0</td>
          <td class="unboxed scdescmap">Inactive signal. No action taken.<br/></td>
        </tr>
      </table>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
    <p id="R_0E60AED72308A573" class="boxed tabrb"><span class="regname">+<span class="addr">0x000002a0</span> Register(64 bit) CH2_CFG_EXTD</span><br/>
      <span class="sdescdet">DW_axi_dmac Channel $i Extended Configuration Register</span><br/>
      <span class="ldescdet">Channel x Extended Configuration Register. This register is allowed to be updated only when the channel is disabled, which means that it remains fixed for the entire<br/>DMA transfer. This feature adds register fields - CHx_CFG_EXTD.LLI_AXPROT and CHx_CFG_EXTD.LLI_AXCACHE. For the next LLI Fetch and/or LLI Write Back, this programmed AXI Protection/Cache value is used as AxPROT and AxCACHE.
</span></p>
      <p><b>Addresses</b> <i>AccessRestrictions are printed as (&lt;Agent&gt;:&lt;Restriction&gt;)</i>:<br/>
      <span class="addr">&#x2003;&#x2003;0x045022a0</span> at NOC.mem_fb__axi (Mem) <br/>
      </p>
          <p><b>Access RW</b>          </p>
    <table>
      <tr><th colspan="3">Reset Information</th><th></th>
      </tr>
      <tr>
        <th>Prio</th>
        <th>Type</th>
        <th>Properties</th>
        <th>Value/Mask (hex)</th>
      </tr>
      <tr class="tabry">
        <td class="unboxed">0</td>
        <td class="unboxed">PowerUp</td>
        <td class="unboxed">, fully affected, fully defined</td>
        <td class="unboxed addr">0x0000000000000000</td>
      </tr>
    </table>
    <p/><table class="tblcoll">
      <tr class="fldpos"><td>Bit</td>
        <td>63</td>
        <td>62</td>
        <td>61</td>
        <td>60</td>
        <td>59</td>
        <td>58</td>
        <td>57</td>
        <td>56</td>
        <td>55</td>
        <td>54</td>
        <td>53</td>
        <td>52</td>
        <td>51</td>
        <td>50</td>
        <td>49</td>
        <td>48</td>
        <td>47</td>
        <td>46</td>
        <td>45</td>
        <td>44</td>
        <td>43</td>
        <td>42</td>
        <td>41</td>
        <td>40</td>
        <td>39</td>
        <td>38</td>
        <td>37</td>
        <td>36</td>
        <td>35</td>
        <td>34</td>
        <td>33</td>
        <td>32</td>
        <td>31</td>
        <td>30</td>
        <td>29</td>
        <td>28</td>
        <td>27</td>
        <td>26</td>
        <td>25</td>
        <td>24</td>
        <td>23</td>
        <td>22</td>
        <td>21</td>
        <td>20</td>
        <td>19</td>
        <td>18</td>
        <td>17</td>
        <td>16</td>
        <td>15</td>
        <td>14</td>
        <td>13</td>
        <td>12</td>
        <td>11</td>
        <td>10</td>
        <td>9</td>
        <td>8</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr class="fldrst"><td style="text-align:left;">Reset</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr><td class="fldnorm" style="text-align:left">Name</td>
        <td class="fldnorm" colspan="57">RSVD_DMAC_CHx_CFG_EXTD_7to63</td>
        <td class="fldnorm" colspan="4">LLI_AXCACHE</td>
        <td class="fldnorm" colspan="3">LLI_AXPROT</td>
      </tr>
      <tr><td class="accno" style="text-align:left">Access</td>
        <td class="accno" colspan="57">RO</td>
        <td class="accno" colspan="4">RW</td>
        <td class="accno" colspan="3">RW</td>
      </tr>
    </table><p/>
    <table class="tblcoll">
      <tr>
        <td><b>[63:07]</b><br/>RO</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">RSVD_DMAC_CHx_CFG_EXTD_7to63</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">DMAC Channel x Extended Configuration Register (bits 7to63) Reserved bits - Read Only</span></p>
          <p><b>Reset: </b>hex:0x000000000000000;</p>
        </td>
      </tr>
      <tr>
        <td><b>[06:03]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_AXCACHE</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Fetch and LLI Writeback AXI AxCACHE.<br/>These bits form the arcache/awcache output of AXI manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
      <tr>
        <td><b>[02:00]</b><br/>RW</td>
        <td style="width:50vw"><p class="flddesc"><span class="regname">LLI_AXPROT</span><br/>
          <span class="sdescdet"></span><br/>
          <span class="ldescdet">LLI Fetch and LLI Writeback AXI AxPROT.<br/>These bits form the arprot/awprot output of AXI manager interface.</span></p>
          <p><b>Reset: </b>hex:0x0;</p>
        </td>
      </tr>
    </table>
    <p><a href="#G_AR_abc_soc_top_mem_fb0_dmac_0_DW_axi_reg">Back to AddressMap</a></p>
    <p><a href="#TOPOFDOC">Back to top</a></p>
  </body>
</html>
