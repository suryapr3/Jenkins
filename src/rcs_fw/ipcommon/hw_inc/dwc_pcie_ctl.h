#ifndef _DWC_PCIE_CTLDBI_SLAVEMEMSPACE_1_H_
#define _DWC_PCIE_CTLDBI_SLAVEMEMSPACE_1_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define DLNK_PCIE_DWC_DBI_USP_BASE  ( 0x01000000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_OFFSET ( 0x00000000U )
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_OFFSET ( 0x00000004U )
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_OFFSET ( 0x00000008U )
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_OFFSET ( 0x0000000cU )
#define PCIE_CTL_TYPE0_HDR_BAR0_OFFSET ( 0x00000010U )
#define PCIE_CTL_TYPE0_HDR_BAR1_OFFSET ( 0x00000014U )
#define PCIE_CTL_TYPE0_HDR_BAR2_OFFSET ( 0x00000018U )
#define PCIE_CTL_TYPE0_HDR_BAR3_OFFSET ( 0x0000001cU )
#define PCIE_CTL_TYPE0_HDR_BAR4_OFFSET ( 0x00000020U )
#define PCIE_CTL_TYPE0_HDR_BAR5_OFFSET ( 0x00000024U )
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_OFFSET ( 0x00000028U )
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_OFFSET ( 0x0000002cU )
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_OFFSET ( 0x00000030U )
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_OFFSET ( 0x00000034U )
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_OFFSET ( 0x0000003cU )
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_OFFSET ( 0x00000040U )
#define PCIE_CTL_PM_CAP_CON_STAT_OFFSET ( 0x00000044U )
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_OFFSET ( 0x00000050U )
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_OFFSET ( 0x00000054U )
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_OFFSET ( 0x00000058U )
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_OFFSET ( 0x0000005cU )
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_OFFSET ( 0x00000060U )
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_OFFSET ( 0x00000064U )
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_OFFSET ( 0x00000070U )
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_OFFSET ( 0x00000074U )
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_OFFSET ( 0x00000078U )
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_OFFSET ( 0x0000007cU )
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_OFFSET ( 0x00000080U )
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_OFFSET ( 0x00000094U )
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_OFFSET ( 0x00000098U )
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_OFFSET ( 0x0000009cU )
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_OFFSET ( 0x000000a0U )
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_OFFSET ( 0x000000b0U )
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET ( 0x000000b4U )
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET ( 0x000000b8U )
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_OFFSET ( 0x00000100U )
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_OFFSET ( 0x00000104U )
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_OFFSET ( 0x00000108U )
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_OFFSET ( 0x0000010cU )
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_OFFSET ( 0x00000110U )
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_OFFSET ( 0x00000114U )
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_OFFSET ( 0x00000118U )
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_OFFSET ( 0x0000011cU )
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_OFFSET ( 0x00000120U )
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_OFFSET ( 0x00000124U )
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_OFFSET ( 0x00000128U )
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_OFFSET ( 0x00000138U )
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_OFFSET ( 0x0000013cU )
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_OFFSET ( 0x00000140U )
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_OFFSET ( 0x00000144U )
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_OFFSET ( 0x00000148U )
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_OFFSET ( 0x0000014cU )
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_OFFSET ( 0x00000150U )
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_OFFSET ( 0x00000154U )
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_OFFSET ( 0x00000158U )
#define PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_OFFSET ( 0x0000015cU )
#define PCIE_CTL_PL16G_CAP_PL16G_CTRL_OFFSET ( 0x00000160U )
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_OFFSET ( 0x00000164U )
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_OFFSET ( 0x00000168U )
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_OFFSET ( 0x0000016cU )
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_OFFSET ( 0x00000170U )
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_OFFSET ( 0x00000178U )
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_OFFSET ( 0x0000017cU )
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_OFFSET ( 0x00000180U )
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_OFFSET ( 0x00000184U )
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_OFFSET ( 0x00000188U )
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_OFFSET ( 0x0000018cU )
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_OFFSET ( 0x00000190U )
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_OFFSET ( 0x00000194U )
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_OFFSET ( 0x00000198U )
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_OFFSET ( 0x0000019cU )
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_OFFSET ( 0x000001a0U )
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_OFFSET ( 0x000001a4U )
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_OFFSET ( 0x000001a8U )
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_OFFSET ( 0x000001acU )
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_OFFSET ( 0x000001b0U )
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_OFFSET ( 0x000001b4U )
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_OFFSET ( 0x000001b8U )
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_OFFSET ( 0x000001bcU )
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_OFFSET ( 0x000001e0U )
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_OFFSET ( 0x000001e4U )
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_OFFSET ( 0x000001e8U )
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_OFFSET ( 0x000001ecU )
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_OFFSET ( 0x000001f0U )
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_OFFSET ( 0x000001f4U )
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_OFFSET ( 0x000001f8U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_OFFSET ( 0x000001fcU )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_OFFSET ( 0x00000200U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_OFFSET ( 0x00000204U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_OFFSET ( 0x00000208U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_OFFSET ( 0x0000020cU )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_OFFSET ( 0x00000210U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_OFFSET ( 0x00000214U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_OFFSET ( 0x00000218U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_OFFSET ( 0x0000021cU )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_OFFSET ( 0x00000220U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_OFFSET ( 0x00000224U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_OFFSET ( 0x00000228U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_OFFSET ( 0x0000022cU )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_OFFSET ( 0x00000230U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_OFFSET ( 0x00000234U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_OFFSET ( 0x00000238U )
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_OFFSET ( 0x0000023cU )
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_OFFSET ( 0x00000250U )
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_OFFSET ( 0x00000254U )
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_OFFSET ( 0x00000260U )
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_OFFSET ( 0x00000264U )
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_OFFSET ( 0x00000268U )
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_OFFSET ( 0x0000026cU )
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_OFFSET ( 0x00000270U )
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_OFFSET ( 0x00000274U )
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_OFFSET ( 0x00000280U )
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_OFFSET ( 0x00000284U )
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_OFFSET ( 0x00000288U )
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_OFFSET ( 0x00000290U )
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_OFFSET ( 0x00000294U )
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_OFFSET ( 0x00000298U )
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_OFFSET ( 0x000002b0U )
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_OFFSET ( 0x000002b4U )
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_OFFSET ( 0x000002b8U )
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_OFFSET ( 0x000002bcU )
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_OFFSET ( 0x000002c0U )
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_OFFSET ( 0x000002c4U )
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_OFFSET ( 0x000002c8U )
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_OFFSET ( 0x000002ccU )
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_OFFSET ( 0x000002d0U )
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_OFFSET ( 0x00000700U )
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_OFFSET ( 0x00000704U )
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_OFFSET ( 0x00000708U )
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_OFFSET ( 0x0000070cU )
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_OFFSET ( 0x00000710U )
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_OFFSET ( 0x00000714U )
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_OFFSET ( 0x00000718U )
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_OFFSET ( 0x0000071cU )
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_OFFSET ( 0x00000720U )
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_OFFSET ( 0x00000728U )
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_OFFSET ( 0x0000072cU )
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_OFFSET ( 0x00000730U )
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_OFFSET ( 0x00000734U )
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_OFFSET ( 0x00000738U )
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_OFFSET ( 0x0000073cU )
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_OFFSET ( 0x00000740U )
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_OFFSET ( 0x00000744U )
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_OFFSET ( 0x00000748U )
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_OFFSET ( 0x0000074cU )
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_OFFSET ( 0x00000750U )
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_OFFSET ( 0x0000080cU )
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_OFFSET ( 0x00000810U )
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_OFFSET ( 0x00000814U )
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_OFFSET ( 0x0000081cU )
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_OFFSET ( 0x0000088cU )
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_OFFSET ( 0x00000890U )
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_OFFSET ( 0x00000894U )
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_OFFSET ( 0x00000898U )
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_OFFSET ( 0x0000089cU )
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_OFFSET ( 0x000008a4U )
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_OFFSET ( 0x000008a8U )
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_OFFSET ( 0x000008b4U )
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_OFFSET ( 0x000008b8U )
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_OFFSET ( 0x000008bcU )
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_OFFSET ( 0x000008c0U )
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_OFFSET ( 0x000008c4U )
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_OFFSET ( 0x000008c8U )
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_OFFSET ( 0x000008ccU )
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_OFFSET ( 0x000008d0U )
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_OFFSET ( 0x000008d4U )
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_OFFSET ( 0x000008d8U )
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_OFFSET ( 0x000008e0U )
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_OFFSET ( 0x000008e8U )
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_OFFSET ( 0x000008f0U )
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_OFFSET ( 0x000008f4U )
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_OFFSET ( 0x000008f8U )
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_OFFSET ( 0x000008fcU )
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_OFFSET ( 0x00000940U )
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_OFFSET ( 0x00000944U )
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_OFFSET ( 0x00000948U )
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_OFFSET ( 0x0000094cU )
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_OFFSET ( 0x00000b10U )
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_OFFSET ( 0x00000b1cU )
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_OFFSET ( 0x00000b40U )
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_OFFSET ( 0x00000b48U )
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_OFFSET ( 0x00000b4cU )
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_OFFSET ( 0x00000b80U )
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_OFFSET ( 0x00000b84U )
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_OFFSET ( 0x00000b88U )
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_OFFSET ( 0x00000b8cU )
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_OFFSET ( 0x00000b90U )
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_OFFSET ( 0x00000c7cU )
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_OFFSET ( 0x00000c80U )
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_OFFSET ( 0x00000c88U )
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_OFFSET ( 0x00000c8cU )
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_OFFSET ( 0x00000cacU )
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_OFFSET ( 0x00100010U )
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_OFFSET ( 0x00100014U )
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_OFFSET ( 0x00100018U )
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_OFFSET ( 0x0010001cU )
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_OFFSET ( 0x00100020U )
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_OFFSET ( 0x00100024U )
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_OFFSET ( 0x00100030U )
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_OFFSET ( 0x0010007cU )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_OFFSET ( 0x00300000U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_OFFSET ( 0x00300004U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_OFFSET ( 0x00300008U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_OFFSET ( 0x0030000cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_OFFSET ( 0x00300010U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_OFFSET ( 0x00300014U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_OFFSET ( 0x00300018U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_OFFSET ( 0x00300100U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_OFFSET ( 0x00300104U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_OFFSET ( 0x00300108U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_OFFSET ( 0x0030010cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_OFFSET ( 0x00300110U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_OFFSET ( 0x00300114U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_OFFSET ( 0x00300200U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_OFFSET ( 0x00300204U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_OFFSET ( 0x00300208U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_OFFSET ( 0x0030020cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_OFFSET ( 0x00300210U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_OFFSET ( 0x00300214U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_OFFSET ( 0x00300218U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_OFFSET ( 0x00300300U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_OFFSET ( 0x00300304U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_OFFSET ( 0x00300308U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_OFFSET ( 0x0030030cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_OFFSET ( 0x00300310U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_OFFSET ( 0x00300314U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_OFFSET ( 0x00300400U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_OFFSET ( 0x00300404U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_OFFSET ( 0x00300408U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_OFFSET ( 0x0030040cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_OFFSET ( 0x00300410U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_OFFSET ( 0x00300414U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_OFFSET ( 0x00300418U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_OFFSET ( 0x00300500U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_OFFSET ( 0x00300504U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_OFFSET ( 0x00300508U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_OFFSET ( 0x0030050cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_OFFSET ( 0x00300510U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_OFFSET ( 0x00300514U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_OFFSET ( 0x00300600U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_OFFSET ( 0x00300604U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_OFFSET ( 0x00300608U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_OFFSET ( 0x0030060cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_OFFSET ( 0x00300610U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_OFFSET ( 0x00300614U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_OFFSET ( 0x00300618U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_OFFSET ( 0x00300700U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_OFFSET ( 0x00300704U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_OFFSET ( 0x00300708U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_OFFSET ( 0x0030070cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_OFFSET ( 0x00300710U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_OFFSET ( 0x00300714U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_OFFSET ( 0x00300800U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_OFFSET ( 0x00300804U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_OFFSET ( 0x00300808U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_OFFSET ( 0x0030080cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_OFFSET ( 0x00300810U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_OFFSET ( 0x00300814U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_OFFSET ( 0x00300818U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_OFFSET ( 0x00300900U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_OFFSET ( 0x00300904U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_OFFSET ( 0x00300908U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_OFFSET ( 0x0030090cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_OFFSET ( 0x00300910U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_OFFSET ( 0x00300914U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_OFFSET ( 0x00300a00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_OFFSET ( 0x00300a04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_OFFSET ( 0x00300a08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_OFFSET ( 0x00300a0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_OFFSET ( 0x00300a10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_OFFSET ( 0x00300a14U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_OFFSET ( 0x00300a18U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_OFFSET ( 0x00300b00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_OFFSET ( 0x00300b04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_OFFSET ( 0x00300b08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_OFFSET ( 0x00300b0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_OFFSET ( 0x00300b10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_OFFSET ( 0x00300b14U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_OFFSET ( 0x00300c00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_OFFSET ( 0x00300c04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_OFFSET ( 0x00300c08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_OFFSET ( 0x00300c0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_OFFSET ( 0x00300c10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_OFFSET ( 0x00300c14U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_OFFSET ( 0x00300c18U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_OFFSET ( 0x00300d00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_OFFSET ( 0x00300d04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_OFFSET ( 0x00300d08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_OFFSET ( 0x00300d0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_OFFSET ( 0x00300d10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_OFFSET ( 0x00300d14U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_OFFSET ( 0x00300e00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_OFFSET ( 0x00300e04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_OFFSET ( 0x00300e08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_OFFSET ( 0x00300e0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_OFFSET ( 0x00300e10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_OFFSET ( 0x00300e14U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_OFFSET ( 0x00300e18U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_OFFSET ( 0x00300f00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_OFFSET ( 0x00300f04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_OFFSET ( 0x00300f08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_OFFSET ( 0x00300f0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_OFFSET ( 0x00300f10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_OFFSET ( 0x00300f14U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_OFFSET ( 0x00301000U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_OFFSET ( 0x00301004U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_OFFSET ( 0x00301008U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_OFFSET ( 0x0030100cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_OFFSET ( 0x00301010U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_OFFSET ( 0x00301014U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_OFFSET ( 0x00301018U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_OFFSET ( 0x00301100U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_OFFSET ( 0x00301104U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_OFFSET ( 0x00301108U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_OFFSET ( 0x0030110cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_OFFSET ( 0x00301110U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_OFFSET ( 0x00301114U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_OFFSET ( 0x00301200U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_OFFSET ( 0x00301204U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_OFFSET ( 0x00301208U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_OFFSET ( 0x0030120cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_OFFSET ( 0x00301210U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_OFFSET ( 0x00301214U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_OFFSET ( 0x00301218U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_OFFSET ( 0x00301300U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_OFFSET ( 0x00301304U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_OFFSET ( 0x00301308U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_OFFSET ( 0x0030130cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_OFFSET ( 0x00301310U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_OFFSET ( 0x00301314U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_OFFSET ( 0x00301400U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_OFFSET ( 0x00301404U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_OFFSET ( 0x00301408U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_OFFSET ( 0x0030140cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_OFFSET ( 0x00301410U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_OFFSET ( 0x00301414U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_OFFSET ( 0x00301418U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_OFFSET ( 0x00301500U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_OFFSET ( 0x00301504U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_OFFSET ( 0x00301508U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_OFFSET ( 0x0030150cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_OFFSET ( 0x00301510U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_OFFSET ( 0x00301514U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_OFFSET ( 0x00301600U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_OFFSET ( 0x00301604U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_OFFSET ( 0x00301608U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_OFFSET ( 0x0030160cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_OFFSET ( 0x00301610U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_OFFSET ( 0x00301614U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_OFFSET ( 0x00301618U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_OFFSET ( 0x00301700U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_OFFSET ( 0x00301704U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_OFFSET ( 0x00301708U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_OFFSET ( 0x0030170cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_OFFSET ( 0x00301710U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_OFFSET ( 0x00301714U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_OFFSET ( 0x00301800U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_OFFSET ( 0x00301804U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_OFFSET ( 0x00301808U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_OFFSET ( 0x0030180cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_OFFSET ( 0x00301810U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_OFFSET ( 0x00301814U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_OFFSET ( 0x00301818U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_OFFSET ( 0x00301900U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_OFFSET ( 0x00301904U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_OFFSET ( 0x00301908U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_OFFSET ( 0x0030190cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_OFFSET ( 0x00301910U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_OFFSET ( 0x00301914U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_OFFSET ( 0x00301a00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_OFFSET ( 0x00301a04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_OFFSET ( 0x00301a08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_OFFSET ( 0x00301a0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_OFFSET ( 0x00301a10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_OFFSET ( 0x00301a14U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_OFFSET ( 0x00301a18U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_OFFSET ( 0x00301b00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_OFFSET ( 0x00301b04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_OFFSET ( 0x00301b08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_OFFSET ( 0x00301b0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_OFFSET ( 0x00301b10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_OFFSET ( 0x00301b14U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_OFFSET ( 0x00301c00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_OFFSET ( 0x00301c04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_OFFSET ( 0x00301c08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_OFFSET ( 0x00301c0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_OFFSET ( 0x00301c10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_OFFSET ( 0x00301c14U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_OFFSET ( 0x00301c18U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_OFFSET ( 0x00301d00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_OFFSET ( 0x00301d04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_OFFSET ( 0x00301d08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_OFFSET ( 0x00301d0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_OFFSET ( 0x00301d10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_OFFSET ( 0x00301d14U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_OFFSET ( 0x00301e00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_OFFSET ( 0x00301e04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_OFFSET ( 0x00301e08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_OFFSET ( 0x00301e0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_OFFSET ( 0x00301e10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_OFFSET ( 0x00301e14U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_OFFSET ( 0x00301e18U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_OFFSET ( 0x00301f00U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_OFFSET ( 0x00301f04U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_OFFSET ( 0x00301f08U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_OFFSET ( 0x00301f0cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_OFFSET ( 0x00301f10U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_OFFSET ( 0x00301f14U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_OFFSET ( 0x00302100U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_OFFSET ( 0x00302104U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_OFFSET ( 0x00302108U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_OFFSET ( 0x0030210cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_OFFSET ( 0x00302110U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_OFFSET ( 0x00302114U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_OFFSET ( 0x00302300U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_OFFSET ( 0x00302304U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_OFFSET ( 0x00302308U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_OFFSET ( 0x0030230cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_OFFSET ( 0x00302310U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_OFFSET ( 0x00302314U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_OFFSET ( 0x00302500U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_OFFSET ( 0x00302504U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_OFFSET ( 0x00302508U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_OFFSET ( 0x0030250cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_OFFSET ( 0x00302510U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_OFFSET ( 0x00302514U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_OFFSET ( 0x00302700U )
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_OFFSET ( 0x00302704U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_OFFSET ( 0x00302708U )
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_OFFSET ( 0x0030270cU )
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_OFFSET ( 0x00302710U )
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_OFFSET ( 0x00302714U )
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_OFFSET ( 0x00380000U )
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_OFFSET ( 0x00380004U )
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_OFFSET ( 0x00380008U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_OFFSET ( 0x00380010U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_OFFSET ( 0x00380014U )
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_OFFSET ( 0x00380018U )
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_OFFSET ( 0x0038001cU )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_OFFSET ( 0x00380020U )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_OFFSET ( 0x00380024U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_OFFSET ( 0x00380028U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_OFFSET ( 0x0038002cU )
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_OFFSET ( 0x00380030U )
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_OFFSET ( 0x00380034U )
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_OFFSET ( 0x00380038U )
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_OFFSET ( 0x0038003cU )
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_OFFSET ( 0x00380080U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_OFFSET ( 0x00380084U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_OFFSET ( 0x00380088U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_OFFSET ( 0x0038008cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_OFFSET ( 0x00380090U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_OFFSET ( 0x00380094U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_OFFSET ( 0x00380098U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_OFFSET ( 0x0038009cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_OFFSET ( 0x003800a0U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_OFFSET ( 0x003800a4U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_OFFSET ( 0x003800a8U )
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_OFFSET ( 0x00380100U )
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_OFFSET ( 0x00380104U )
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_OFFSET ( 0x00380108U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_OFFSET ( 0x00380110U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_OFFSET ( 0x00380114U )
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_OFFSET ( 0x00380118U )
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_OFFSET ( 0x0038011cU )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_OFFSET ( 0x00380120U )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_OFFSET ( 0x00380124U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_OFFSET ( 0x00380128U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_OFFSET ( 0x0038012cU )
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_OFFSET ( 0x00380130U )
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_OFFSET ( 0x00380134U )
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_OFFSET ( 0x00380138U )
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_OFFSET ( 0x0038013cU )
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_OFFSET ( 0x00380180U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_OFFSET ( 0x00380184U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_OFFSET ( 0x00380188U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_OFFSET ( 0x0038018cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_OFFSET ( 0x00380190U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_OFFSET ( 0x00380194U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_OFFSET ( 0x00380198U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_OFFSET ( 0x0038019cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_OFFSET ( 0x003801a0U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_OFFSET ( 0x003801a4U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_OFFSET ( 0x003801a8U )
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_OFFSET ( 0x00380200U )
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_OFFSET ( 0x00380204U )
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_OFFSET ( 0x00380208U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_OFFSET ( 0x00380210U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_OFFSET ( 0x00380214U )
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_OFFSET ( 0x00380218U )
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_OFFSET ( 0x0038021cU )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_OFFSET ( 0x00380220U )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_OFFSET ( 0x00380224U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_OFFSET ( 0x00380228U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_OFFSET ( 0x0038022cU )
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_OFFSET ( 0x00380230U )
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_OFFSET ( 0x00380234U )
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_OFFSET ( 0x00380238U )
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_OFFSET ( 0x0038023cU )
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_OFFSET ( 0x00380280U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_OFFSET ( 0x00380284U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_OFFSET ( 0x00380288U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_OFFSET ( 0x0038028cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_OFFSET ( 0x00380290U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_OFFSET ( 0x00380294U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_OFFSET ( 0x00380298U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_OFFSET ( 0x0038029cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_OFFSET ( 0x003802a0U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_OFFSET ( 0x003802a4U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_OFFSET ( 0x003802a8U )
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_OFFSET ( 0x00380300U )
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_OFFSET ( 0x00380304U )
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_OFFSET ( 0x00380308U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_OFFSET ( 0x00380310U )
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_OFFSET ( 0x00380314U )
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_OFFSET ( 0x00380318U )
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_OFFSET ( 0x0038031cU )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_OFFSET ( 0x00380320U )
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_OFFSET ( 0x00380324U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_OFFSET ( 0x00380328U )
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_OFFSET ( 0x0038032cU )
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_OFFSET ( 0x00380330U )
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_OFFSET ( 0x00380334U )
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_OFFSET ( 0x00380338U )
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_OFFSET ( 0x0038033cU )
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_OFFSET ( 0x00380380U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_OFFSET ( 0x00380384U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_OFFSET ( 0x00380388U )
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_OFFSET ( 0x0038038cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_OFFSET ( 0x00380390U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_OFFSET ( 0x00380394U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_OFFSET ( 0x00380398U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_OFFSET ( 0x0038039cU )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_OFFSET ( 0x003803a0U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_OFFSET ( 0x003803a4U )
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_OFFSET ( 0x003803a8U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_STAT_CMD_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_BAR0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_BAR0_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_BAR1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_BAR1_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_BAR2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_BAR2_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_BAR3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_BAR3_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_BAR4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_BAR4_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_BAR5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_BAR5_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_OFFSET ) ))
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PM_CAP_ID_NXT_PTR_OFFSET ) ))
#define PCIE_CTL_PM_CAP_CON_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PM_CAP_CON_STAT_OFFSET ) ))
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_OFFSET ) ))
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_OFFSET ) ))
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_OFFSET ) ))
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_OFFSET ) ))
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_OFFSET ) ))
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_OFFSET ) ))
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_OFFSET ) ))
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET ) ))
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET ) ))
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_OFFSET ) ))
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_OFFSET ) ))
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_OFFSET ) ))
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_SPCIE_CAP_LINK_CTRL3_OFFSET ) ))
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_OFFSET ) ))
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_CTRL_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_CTRL_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_STAT_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_OFFSET ) ))
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_OFFSET ) ))
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_OFFSET ) ))
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_OFFSET ) ))
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_OFFSET ) ))
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_CTRL_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_STAT_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_OFFSET ) ))
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ_EN_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ4_FC_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_CTRL1_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_CTRL2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_OFFSET ) ))
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_OFFSET ) ))
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_OFFSET ) ))
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_OFFSET ) ))
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_OFFSET ) ))
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_OFFSET ) ))
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_OFFSET ) ))
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_OFFSET ) ))
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_OFFSET ) ))
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_UTILITY_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_OFFSET ) ))
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_OFFSET ) ))
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_OFFSET ) ))
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_OFFSET ) ))
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_OFFSET ) ))
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_ADR (( ( DLNK_PCIE_DWC_DBI_USP_BASE ) + ( PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DEVICE_ID_VENDOR_ID_REG register description at address offset 0x0
  *
  * Register default value:        0x0DD68086
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/DEVICE_ID_VENDOR_ID_REG
  * Device ID , RCRB next offset pointer and Vendor ID Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_VENDOR_ID : 16;
    ///< Vendor ID. The Vendor ID register identifies the manufacturer of the
    ///< Function. Valid vendor identifiers are allocated by the PCI-SIG to
    ///< ensure uniqueness. It is not permitted to populate this register with
    ///< a value of FFFFh, which is an invalid value for Vendor ID.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x8086"
    uint32_t PCI_TYPE0_DEVICE_ID : 16;
    ///< - DEVICE_ID [31:16]  - The Device ID register identifies the particular
    ///< Function for PCIe Type0 and Type1 configuration header. This identifier
    ///< is allocated by the vendor. Databook.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0xDD6"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_device_id_vendor_id_reg_t;

#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_DEFAULT (0x0dd68086U)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_WR_MASK (0x00000000U)


///< Vendor ID. The Vendor ID register identifies the manufacturer of the
///< Function. Valid vendor identifiers are allocated by the PCI-SIG to
///< ensure uniqueness. It is not permitted to populate this register with
///< a value of FFFFh, which is an invalid value for Vendor ID.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_VENDOR_ID_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_VENDOR_ID_BF_WID (16)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_VENDOR_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_VENDOR_ID_BF_DEF (0x00008086)

///< - DEVICE_ID [31:16]  - The Device ID register identifies the particular
///< Function for PCIe Type0 and Type1 configuration header. This identifier
///< is allocated by the vendor. Databook.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_DEVICE_ID_BF_OFF (16)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_DEVICE_ID_BF_WID (16)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_DEVICE_ID_BF_MSK (0xFFFF0000)
#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_PCI_TYPE0_DEVICE_ID_BF_DEF (0x0DD60000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_STATUS_COMMAND_REG register description at address offset 0x4
  *
  * Register default value:        0x00100000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/STATUS_COMMAND_REG
  * Status and Command Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_IO_EN : 1;
    ///< IO Space Enable. Controls a Function's response to I/O Space accesses.
    ///< - When this bit is set, the Function is enabled to decode the address
    ///< and further process I/O Space accesses.  - When this bit is clear,
    ///< all received I/O accesses are caused to be handled as Unsupported
    ///< Requests. For a Function that does not support I/O Space accesses,
    ///< the controller hardwires this bit to 0b.   Note: The access attributes
    ///< of this field are as follows:  - Wire: !has_io_bar ? RO : RW   - Dbi:
    ///< !has_io_bar ? RO : RW
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t PCI_TYPE0_MEM_SPACE_EN : 1;
    ///< Memory Space Enable. Controls a Function's response to Memory Space
    ///< accesses.  - When this bit is set, the Function is enabled to decode
    ///< the address and further process Memory Space accesses.  - When this
    ///< bit is clear, all received Memory Space accesses are caused to be
    ///< handled as Unsupported Requests. For a Function does not support Memory
    ///< Space accesses, the controller hardwires this bit to 0b.   Note: The
    ///< access attributes of this field are as follows:  - Wire: !has_mem_bar
    ///< ? RO : RW   - Dbi: !has_mem_bar ? RO : RW
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t PCI_TYPE0_BUS_MASTER_EN : 1;
    ///< Bus Master Enable. Controls the ability of a Function to issue Memory
    ///< and I/O Read/Write requests.  - When this bit is set, the Function
    ///< is allowed to issue Memory or I/O Requests.  - When this bit is clear,
    ///< the Function is not allowed to issue any Memory or I/O Requests. Requests
    ///< other than Memory or I/O Requests are not controlled by this bit.
    ///< Note: MSI/MSI-X interrupt Messages are in-band memory writes, setting
    ///< the Bus Master Enable bit to 0b disables MSI/MSI-X interrupt Messages
    ///< as well.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t PCI_TYPE0_SPECIAL_CYCLE_OPERATION : 1;
    ///< Special Cycle Enable. This bit was originally described in the PCI
    ///< Local Bus Specification. Its functionality does not apply to PCI Express.
    ///< The controller hardwires this bit to 0b.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t PCI_TYPE_MWI_ENABLE : 1;
    ///< Memory Write and Invalidate. This bit was originally described in
    ///< the PCI Local Bus Specification and the PCI-to-PCI Bridge architecture
    ///< specification. Its functionality does not apply to PCI Express, the
    ///< controller hardwires this bit to 0b.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t PCI_TYPE_VGA_PALETTE_SNOOP : 1;
    ///< VGA Palette Snoop. This bit was originally described in the PCI Local
    ///< Bus Specification and the PCI-to-PCI Bridge architecture specification.
    ///< Its functionality does not apply to PCI Express, the controller hardwires
    ///< this bit to 0b.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint32_t PCI_TYPE0_PARITY_ERR_EN : 1;
    ///< Parity Error Response. This bit controls the logging of poisoned TLPs
    ///< in the Master Data Parity Error bit in the Status register.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t PCI_TYPE_IDSEL_STEPPING : 1;
    ///< IDSEL Stepping/Wait Cycle Control. This bit was originally described
    ///< in the PCI Local Bus Specification. Its functionality does not apply
    ///< to PCI Express. The controller hardwires this bit to 0b.
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
    uint32_t PCI_TYPE0_SERREN : 1;
    ///< SERR# Enable. When set, this bit enables reporting upstream of Non-fatal
    ///< and Fatal errors detected by the Function.  Note: The errors are reported
    ///< if enabled either through this bit or through the PCI Express specific
    ///< bits in the Device Control register.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
    uint32_t PCI_TYPE0_INT_EN : 1;
    ///< Interrupt Disable. Controls the ability of a Function to generate
    ///< INTx emulation interrupts.   When set, Functions are prevented from
    ///< asserting INTx interrupts.  Note:   Any INTx emulation interrupts
    ///< already asserted by the Function must be de-asserted when this bit
    ///< is Set. INTx interrupts use virtual wires that must, if asserted,
    ///< be de-asserted using the appropriate Deassert_INTx message(s) when
    ///< this bit is set.   Only the INTx virtual wire interrupt(s) associated
    ///< with the Function(s) for which this bit is set are affected.   For
    ///< functions that generate INTx interrupts, this bit is required. For
    ///< functions that do not generate INTx interrupts, this bit is optional.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t PCI_TYPE_RESERV : 5;
    ///< Reserved.
    ///< AccessType="RO" BitOffset="11" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
    uint32_t INT_STATUS : 1;
    ///< Emulation interrupt pending. When set, indicates that an INTx emulation
    ///< interrupt is pending internally in the Function. Setting the Interrupt
    ///< Disable bit has no effect on the state of this bit. For Functions
    ///< that do not generate INTx interrupts, the controller hardwires this
    ///< bit to 0b.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t CAP_LIST : 1;
    ///< Capabilities List. Indicates the presence of an Extended Capability
    ///< list item. Since all PCI Express device Functions are required to
    ///< implement the PCI Express Capability structure, the controller hardwires
    ///< this bit to 1b.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x1"
    uint32_t FAST_66MHZ_CAP : 1;
    ///< 66MHz Capable. This bit was originally described in the PCI Local
    ///< Bus Specification. Its functionality does not apply to PCI Express.
    ///< The controller hardwires this bit to 0b.
    ///< AccessType="RO" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t FAST_B2B_CAP : 1;
    ///< Fast Back to Back Transaction Capable. This bit was originally described
    ///< in the PCI Local Bus Specification. Its functionality does not apply
    ///< to PCI Express. The controller hardwires this bit to 0b.
    ///< AccessType="RO" BitOffset="23" ResetValue="0x0"
    uint32_t MASTER_DPE : 1;
    ///< Master Data Parity Error. This bit is set by a Function if the Parity
    ///< Error Response bit in the Command register is 1b and either of the
    ///< following two conditions occurs:  - Function receives a Poisoned Completion
    ///< - Function transmits a Poisoned Request If the Parity Error Response
    ///< bit is 0b, this bit is never set.
    ///< AccessType="RW/1C/V" BitOffset="24" ResetValue="0x0"
    uint32_t DEV_SEL_TIMING : 2;
    ///< DEVSEL Timing. This field was originally described in the PCI Local
    ///< Bus Specification. Its functionality does not apply to PCI Express.
    ///< The controller hardwires this field to 00b.
    ///< AccessType="RO" BitOffset="25" ResetValue="0x0"
    uint32_t SIGNALED_TARGET_ABORT : 1;
    ///< Signaled Target Abort.
    ///< AccessType="RW/1C/V" BitOffset="27" ResetValue="0x0"
    uint32_t RCVD_TARGET_ABORT : 1;
    ///< Received Target Abort.
    ///< AccessType="RW/1C/V" BitOffset="28" ResetValue="0x0"
    uint32_t RCVD_MASTER_ABORT : 1;
    ///< Received Master Abort.
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t SIGNALED_SYS_ERR : 1;
    ///< Signaled System Error.
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t DETECTED_PARITY_ERR : 1;
    ///< Detected Parity Error.
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_stat_cmd_reg_t;

#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DEFAULT (0x00100000U)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RD_MASK (0xffb8fdffU)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_WR_MASK (0xf9000546U)


///< IO Space Enable. Controls a Function's response to I/O Space accesses.
///< - When this bit is set, the Function is enabled to decode the address
///< and further process I/O Space accesses.  - When this bit is clear,
///< all received I/O accesses are caused to be handled as Unsupported
///< Requests. For a Function that does not support I/O Space accesses,
///< the controller hardwires this bit to 0b.   Note: The access attributes
///< of this field are as follows:  - Wire: !has_io_bar ? RO : RW   - Dbi:
///< !has_io_bar ? RO : RW
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_IO_EN_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_IO_EN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_IO_EN_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_IO_EN_BF_DEF (0x00000000)

///< Memory Space Enable. Controls a Function's response to Memory Space
///< accesses.  - When this bit is set, the Function is enabled to decode
///< the address and further process Memory Space accesses.  - When this
///< bit is clear, all received Memory Space accesses are caused to be
///< handled as Unsupported Requests. For a Function does not support Memory
///< Space accesses, the controller hardwires this bit to 0b.   Note: The
///< access attributes of this field are as follows:  - Wire: !has_mem_bar
///< ? RO : RW   - Dbi: !has_mem_bar ? RO : RW
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_MEM_SPACE_EN_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_MEM_SPACE_EN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_MEM_SPACE_EN_BF_MSK (0x00000002)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_MEM_SPACE_EN_BF_DEF (0x00000000)

///< Bus Master Enable. Controls the ability of a Function to issue Memory
///< and I/O Read/Write requests.  - When this bit is set, the Function
///< is allowed to issue Memory or I/O Requests.  - When this bit is clear,
///< the Function is not allowed to issue any Memory or I/O Requests. Requests
///< other than Memory or I/O Requests are not controlled by this bit.
///< Note: MSI/MSI-X interrupt Messages are in-band memory writes, setting
///< the Bus Master Enable bit to 0b disables MSI/MSI-X interrupt Messages
///< as well.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_BUS_MASTER_EN_BF_OFF ( 2)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_BUS_MASTER_EN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_BUS_MASTER_EN_BF_MSK (0x00000004)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_BUS_MASTER_EN_BF_DEF (0x00000000)

///< Special Cycle Enable. This bit was originally described in the PCI
///< Local Bus Specification. Its functionality does not apply to PCI Express.
///< The controller hardwires this bit to 0b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SPECIAL_CYCLE_OPERATION_BF_OFF ( 3)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SPECIAL_CYCLE_OPERATION_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SPECIAL_CYCLE_OPERATION_BF_MSK (0x00000008)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SPECIAL_CYCLE_OPERATION_BF_DEF (0x00000000)

///< Memory Write and Invalidate. This bit was originally described in
///< the PCI Local Bus Specification and the PCI-to-PCI Bridge architecture
///< specification. Its functionality does not apply to PCI Express, the
///< controller hardwires this bit to 0b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_MWI_EN_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_MWI_EN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_MWI_EN_BF_MSK (0x00000010)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_MWI_EN_BF_DEF (0x00000000)

///< VGA Palette Snoop. This bit was originally described in the PCI Local
///< Bus Specification and the PCI-to-PCI Bridge architecture specification.
///< Its functionality does not apply to PCI Express, the controller hardwires
///< this bit to 0b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_VGA_PALETTE_SNOOP_BF_OFF ( 5)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_VGA_PALETTE_SNOOP_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_VGA_PALETTE_SNOOP_BF_MSK (0x00000020)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_VGA_PALETTE_SNOOP_BF_DEF (0x00000000)

///< Parity Error Response. This bit controls the logging of poisoned TLPs
///< in the Master Data Parity Error bit in the Status register.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_PARITY_ERR_EN_BF_OFF ( 6)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_PARITY_ERR_EN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_PARITY_ERR_EN_BF_MSK (0x00000040)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_PARITY_ERR_EN_BF_DEF (0x00000000)

///< IDSEL Stepping/Wait Cycle Control. This bit was originally described
///< in the PCI Local Bus Specification. Its functionality does not apply
///< to PCI Express. The controller hardwires this bit to 0b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_IDSEL_STEPPING_BF_OFF ( 7)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_IDSEL_STEPPING_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_IDSEL_STEPPING_BF_MSK (0x00000080)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_IDSEL_STEPPING_BF_DEF (0x00000000)

///< SERR# Enable. When set, this bit enables reporting upstream of Non-fatal
///< and Fatal errors detected by the Function.  Note: The errors are reported
///< if enabled either through this bit or through the PCI Express specific
///< bits in the Device Control register.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SERREN_BF_OFF ( 8)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SERREN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SERREN_BF_MSK (0x00000100)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_SERREN_BF_DEF (0x00000000)

///< Interrupt Disable. Controls the ability of a Function to generate
///< INTx emulation interrupts.   When set, Functions are prevented from
///< asserting INTx interrupts.  Note:   Any INTx emulation interrupts
///< already asserted by the Function must be de-asserted when this bit
///< is Set. INTx interrupts use virtual wires that must, if asserted,
///< be de-asserted using the appropriate Deassert_INTx message(s) when
///< this bit is set.   Only the INTx virtual wire interrupt(s) associated
///< with the Function(s) for which this bit is set are affected.   For
///< functions that generate INTx interrupts, this bit is required. For
///< functions that do not generate INTx interrupts, this bit is optional.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_INT_EN_BF_OFF (10)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_INT_EN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_INT_EN_BF_MSK (0x00000400)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE0_INT_EN_BF_DEF (0x00000000)

///< Reserved.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_RESERV_BF_OFF (11)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_RESERV_BF_WID ( 5)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_RESERV_BF_MSK (0x0000F800)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_PCI_TYPE_RESERV_BF_DEF (0x00000000)

///< Emulation interrupt pending. When set, indicates that an INTx emulation
///< interrupt is pending internally in the Function. Setting the Interrupt
///< Disable bit has no effect on the state of this bit. For Functions
///< that do not generate INTx interrupts, the controller hardwires this
///< bit to 0b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_INT_STAT_BF_OFF (19)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_INT_STAT_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_INT_STAT_BF_MSK (0x00080000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_INT_STAT_BF_DEF (0x00000000)

///< Capabilities List. Indicates the presence of an Extended Capability
///< list item. Since all PCI Express device Functions are required to
///< implement the PCI Express Capability structure, the controller hardwires
///< this bit to 1b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_CAP_LIST_BF_OFF (20)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_CAP_LIST_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_CAP_LIST_BF_MSK (0x00100000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_CAP_LIST_BF_DEF (0x00100000)

///< 66MHz Capable. This bit was originally described in the PCI Local
///< Bus Specification. Its functionality does not apply to PCI Express.
///< The controller hardwires this bit to 0b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_66MHZ_CAP_BF_OFF (21)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_66MHZ_CAP_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_66MHZ_CAP_BF_MSK (0x00200000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_66MHZ_CAP_BF_DEF (0x00000000)

///< Fast Back to Back Transaction Capable. This bit was originally described
///< in the PCI Local Bus Specification. Its functionality does not apply
///< to PCI Express. The controller hardwires this bit to 0b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_B2B_CAP_BF_OFF (23)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_B2B_CAP_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_B2B_CAP_BF_MSK (0x00800000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_FAST_B2B_CAP_BF_DEF (0x00000000)

///< Master Data Parity Error. This bit is set by a Function if the Parity
///< Error Response bit in the Command register is 1b and either of the
///< following two conditions occurs:  - Function receives a Poisoned Completion
///< - Function transmits a Poisoned Request If the Parity Error Response
///< bit is 0b, this bit is never set.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_MASTER_DPE_BF_OFF (24)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_MASTER_DPE_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_MASTER_DPE_BF_MSK (0x01000000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_MASTER_DPE_BF_DEF (0x00000000)

///< DEVSEL Timing. This field was originally described in the PCI Local
///< Bus Specification. Its functionality does not apply to PCI Express.
///< The controller hardwires this field to 00b.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DEV_SEL_TIMING_BF_OFF (25)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DEV_SEL_TIMING_BF_WID ( 2)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DEV_SEL_TIMING_BF_MSK (0x06000000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DEV_SEL_TIMING_BF_DEF (0x00000000)

///< Signaled Target Abort.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_TARGET_ABORT_BF_OFF (27)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_TARGET_ABORT_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_TARGET_ABORT_BF_MSK (0x08000000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_TARGET_ABORT_BF_DEF (0x00000000)

///< Received Target Abort.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_TARGET_ABORT_BF_OFF (28)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_TARGET_ABORT_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_TARGET_ABORT_BF_MSK (0x10000000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_TARGET_ABORT_BF_DEF (0x00000000)

///< Received Master Abort.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_MASTER_ABORT_BF_OFF (29)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_MASTER_ABORT_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_MASTER_ABORT_BF_MSK (0x20000000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_RCVD_MASTER_ABORT_BF_DEF (0x00000000)

///< Signaled System Error.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_SYS_ERR_BF_OFF (30)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_SYS_ERR_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_SYS_ERR_BF_MSK (0x40000000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_SIGNALED_SYS_ERR_BF_DEF (0x00000000)

///< Detected Parity Error.
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DETECTED_PARITY_ERR_BF_OFF (31)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DETECTED_PARITY_ERR_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DETECTED_PARITY_ERR_BF_MSK (0x80000000)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_DETECTED_PARITY_ERR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_CLASS_CODE_REVISION_ID register description at address offset 0x8
  *
  * Register default value:        0x02800001
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/CLASS_CODE_REVISION_ID
  * Class Code and Revision ID Register.
  */

typedef union {
  struct {
    uint32_t REVISION_ID : 8;
    ///< Revision ID. The value in this register specifies a Function specific
    ///< revision identifier. The value is chosen by the vendor. Zero is an
    ///< acceptable value. The Revision ID should be viewed as a vendor defined
    ///< extension to the Device ID.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x1"
    uint32_t PROGRAM_INTERFACE : 8;
    ///< Programming Interface. This field identifies a specific register-level
    ///< programming interface (if any) so that device independent software
    ///< can interact with the Function. Encodings for interface are provided
    ///< in the PCI Code and ID Assignment Specification. All unspecified encodings
    ///< are Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t SUBCLASS_CODE : 8;
    ///< Sub-Class Code. Specifies a base class sub-class, which identifies
    ///< more specifically the operation of the Function. Encodings for sub-class
    ///< are provided in the PCI Code and ID Assignment Specification. All
    ///< unspecified encodings are Reserved.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x80"
    uint32_t BASE_CLASS_CODE : 8;
    ///< Base Class Code. A code that broadly classifies the type of operation
    ///< the Function performs. Encodings for base class, are provided in the
    ///< PCI Code and ID Assignment Specification. All unspecified encodings
    ///< are Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x2"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_class_code_revision_id_reg_t;

#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_DEFAULT (0x02800001U)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_WR_MASK (0x00000000U)


///< Revision ID. The value in this register specifies a Function specific
///< revision identifier. The value is chosen by the vendor. Zero is an
///< acceptable value. The Revision ID should be viewed as a vendor defined
///< extension to the Device ID.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_REVISION_ID_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_REVISION_ID_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_REVISION_ID_BF_MSK (0x000000FF)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_REVISION_ID_BF_DEF (0x00000001)

///< Programming Interface. This field identifies a specific register-level
///< programming interface (if any) so that device independent software
///< can interact with the Function. Encodings for interface are provided
///< in the PCI Code and ID Assignment Specification. All unspecified encodings
///< are Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_BF_OFF ( 8)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_BF_MSK (0x0000FF00)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_BF_DEF (0x00000000)

///< Sub-Class Code. Specifies a base class sub-class, which identifies
///< more specifically the operation of the Function. Encodings for sub-class
///< are provided in the PCI Code and ID Assignment Specification. All
///< unspecified encodings are Reserved.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_BF_OFF (16)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_BF_MSK (0x00FF0000)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_BF_DEF (0x00800000)

///< Base Class Code. A code that broadly classifies the type of operation
///< the Function performs. Encodings for base class, are provided in the
///< PCI Code and ID Assignment Specification. All unspecified encodings
///< are Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_BF_OFF (24)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_BF_MSK (0xFF000000)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_BF_DEF (0x02000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG register description at address offset 0xc
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG
  * BIST, Header Type, Latency Timer, and Cache Line Size Register.
  */

typedef union {
  struct {
    uint32_t CACHE_LINE_SIZE : 8;
    ///< Cache Line Size. The Cache Line Size register is programmed by the
    ///< system firmware or the operating system to system cache line size.
    ///< However, legacy conventional PCI software may not always be able to
    ///< program this register correctly especially in the case of Hot-Plug
    ///< devices. This read-write register is implemented for legacy compatibility
    ///< purposes but has no effect on any PCI Express device behavior.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LATENCY_MASTER_TIMER : 8;
    ///< Latency Timer. The Latency Timer was originally described in the PCI
    ///< Local Bus Specification and the PCI-to-PCI Bridge Architecture Specification.
    ///< Its functionality does not apply to PCI Express. The controller hardwires
    ///< this register to 00h.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t HEADER_TYPE : 7;
    ///< Header Layout. This field identifies the layout of the second part
    ///< of the predefined header. The controller uses 000 0000b encoding.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t MULTI_FUNC : 1;
    ///< Multi-Function Device. Except where stated otherwise, it is recommended
    ///< that this bit be set if there are multiple Functions, and clear if
    ///< there is only one Function.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="23" ResetValue="0x0"
    uint32_t BIST : 8;
    ///< BIST. This register is used for control and status of BIST. For Functions
    ///< that do not support BIST the controller hardwires the register to
    ///< 00h. A Function whose BIST is invoked must not prevent normal operation
    ///< of the PCI Express Link. Bit descriptions:  - [31]: BIST Capable.
    ///< When Set, this bit indicates that the Function supports BIST. When
    ///< Clear, the Function does not support BIST.  - [30]: Start BIST. If
    ///< BIST Capable is Set, Set this bit to invoke BIST. The Function resets
    ///< the bit when BIST is complete. Software is permitted to fail the device
    ///< if this bit is not Clear (BIST is not complete) 2 seconds after it
    ///< had been Set. Writing this bit to 0b has no effect. This bit must
    ///< be hardwired to 0b if BIST Capable is Clear.  - [29:28]: Reserved.
    ///< - [27:24]: Completion Code. This field encodes the status of the most
    ///< recent test. A value of 0000b means that the Function has passed its
    ///< test. Non-zero values mean the Function failed. Function-specific
    ///< failure codes can be encoded in the non-zero values. This field's
    ///< value is only meaningful when BIST Capable is Set and Start BIST is
    ///< Clear. This field must be hardwired to 0000b if BIST Capable is clear.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_bist_header_type_latency_cache_line_size_reg_t;

#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_DEFAULT (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_WR_MASK (0x000000ffU)


///< Cache Line Size. The Cache Line Size register is programmed by the
///< system firmware or the operating system to system cache line size.
///< However, legacy conventional PCI software may not always be able to
///< program this register correctly especially in the case of Hot-Plug
///< devices. This read-write register is implemented for legacy compatibility
///< purposes but has no effect on any PCI Express device behavior.
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_CACHE_LINE_SIZE_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_CACHE_LINE_SIZE_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_CACHE_LINE_SIZE_BF_MSK (0x000000FF)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_CACHE_LINE_SIZE_BF_DEF (0x00000000)

///< Latency Timer. The Latency Timer was originally described in the PCI
///< Local Bus Specification and the PCI-to-PCI Bridge Architecture Specification.
///< Its functionality does not apply to PCI Express. The controller hardwires
///< this register to 00h.
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_LATENCY_MASTER_TIMER_BF_OFF ( 8)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_LATENCY_MASTER_TIMER_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_LATENCY_MASTER_TIMER_BF_MSK (0x0000FF00)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_LATENCY_MASTER_TIMER_BF_DEF (0x00000000)

///< Header Layout. This field identifies the layout of the second part
///< of the predefined header. The controller uses 000 0000b encoding.
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_HEADER_TYPE_BF_OFF (16)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_HEADER_TYPE_BF_WID ( 7)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_HEADER_TYPE_BF_MSK (0x007F0000)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_HEADER_TYPE_BF_DEF (0x00000000)

///< Multi-Function Device. Except where stated otherwise, it is recommended
///< that this bit be set if there are multiple Functions, and clear if
///< there is only one Function.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_MULTI_FUNC_BF_OFF (23)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_MULTI_FUNC_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_MULTI_FUNC_BF_MSK (0x00800000)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_MULTI_FUNC_BF_DEF (0x00000000)

///< BIST. This register is used for control and status of BIST. For Functions
///< that do not support BIST the controller hardwires the register to
///< 00h. A Function whose BIST is invoked must not prevent normal operation
///< of the PCI Express Link. Bit descriptions:  - [31]: BIST Capable.
///< When Set, this bit indicates that the Function supports BIST. When
///< Clear, the Function does not support BIST.  - [30]: Start BIST. If
///< BIST Capable is Set, Set this bit to invoke BIST. The Function resets
///< the bit when BIST is complete. Software is permitted to fail the device
///< if this bit is not Clear (BIST is not complete) 2 seconds after it
///< had been Set. Writing this bit to 0b has no effect. This bit must
///< be hardwired to 0b if BIST Capable is Clear.  - [29:28]: Reserved.
///< - [27:24]: Completion Code. This field encodes the status of the most
///< recent test. A value of 0000b means that the Function has passed its
///< test. Non-zero values mean the Function failed. Function-specific
///< failure codes can be encoded in the non-zero values. This field's
///< value is only meaningful when BIST Capable is Set and Start BIST is
///< Clear. This field must be hardwired to 0000b if BIST Capable is clear.
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_BIST_BF_OFF (24)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_BIST_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_BIST_BF_MSK (0xFF000000)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_BIST_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_BAR0_REG register description at address offset 0x10
  *
  * Register default value:        0x00000004
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/BAR0_REG
  * BAR0 Register.
  */

typedef union {
  struct {
    uint32_t BAR0_MEM_IO : 1;
    ///< - BAR0 Memory Space Indicator.  - This bit is used to determine whether
    ///< the register maps into Memory or I/O Space. Base Address registers
    ///< that map to Memory Space must return a 0b.  - Base Address registers
    ///< that map to I/O Space must return a 1b.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
    ///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t BAR0_TYPE : 2;
    ///< -  BAR0 Type.  - Memory Space: Base Address registers that map into
    ///< Memory Space can be 32 bits or 64 bits wide (to support mapping into
    ///< a 64-bit address space). The encodings defined in Values: apply.
    ///< - IO Space: Bit 1 is reserved and must return 0b on reads. Bits[31:2]
    ///< are used to map the function into IO space. The encodings defined
    ///< in Values: do not apply.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x2"
    uint32_t BAR0_PREFETCH : 1;
    ///< - BAR0 Prefetchable.  Memory Space: Set to one if data is prefetchable.
    ///< A Function is permitted to mark a range as prefetchable. If there
    ///< are no side effects on reads, the function returns all bytes on reads
    ///< regardless of the byte enables, and host bridges can merge processor
    ///< writes into this range without causing errors. Bit must me clear otherwise.
    ///< IO Space: Not applicable.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t BAR0_START : 28;
    ///< - BAR0_START. BAR0 Base Address.  - Memory Space: Base Address.  -
    ///< IO Space: bits[31:2] are used to map the function into IO space/Base
    ///< Address.   Note: The access attributes of this field are as follows:
    ///< - Wire: R(Sticky)/W(Sticky) if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky)
    ///< if enabled else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_bar0_reg_t;

#define PCIE_CTL_TYPE0_HDR_BAR0_DEFAULT (0x00000004U)
#define PCIE_CTL_TYPE0_HDR_BAR0_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_BAR0_WR_MASK (0xfffffff0U)


///< - BAR0 Memory Space Indicator.  - This bit is used to determine whether
///< the register maps into Memory or I/O Space. Base Address registers
///< that map to Memory Space must return a 0b.  - Base Address registers
///< that map to I/O Space must return a 1b.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR0_MEM_IO_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_BAR0_MEM_IO_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR0_MEM_IO_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_BAR0_MEM_IO_BF_DEF (0x00000000)

///< -  BAR0 Type.  - Memory Space: Base Address registers that map into
///< Memory Space can be 32 bits or 64 bits wide (to support mapping into
///< a 64-bit address space). The encodings defined in Values: apply.
///< - IO Space: Bit 1 is reserved and must return 0b on reads. Bits[31:2]
///< are used to map the function into IO space. The encodings defined
///< in Values: do not apply.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR0_TYPE_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR0_TYPE_BF_WID ( 2)
#define PCIE_CTL_TYPE0_HDR_BAR0_TYPE_BF_MSK (0x00000006)
#define PCIE_CTL_TYPE0_HDR_BAR0_TYPE_BF_DEF (0x00000004)

///< - BAR0 Prefetchable.  Memory Space: Set to one if data is prefetchable.
///< A Function is permitted to mark a range as prefetchable. If there
///< are no side effects on reads, the function returns all bytes on reads
///< regardless of the byte enables, and host bridges can merge processor
///< writes into this range without causing errors. Bit must me clear otherwise.
///< IO Space: Not applicable.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR0_PREFETCH_BF_OFF ( 3)
#define PCIE_CTL_TYPE0_HDR_BAR0_PREFETCH_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR0_PREFETCH_BF_MSK (0x00000008)
#define PCIE_CTL_TYPE0_HDR_BAR0_PREFETCH_BF_DEF (0x00000000)

///< - BAR0_START. BAR0 Base Address.  - Memory Space: Base Address.  -
///< IO Space: bits[31:2] are used to map the function into IO space/Base
///< Address.   Note: The access attributes of this field are as follows:
///< - Wire: R(Sticky)/W(Sticky) if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky)
///< if enabled else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR0_START_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_BAR0_START_BF_WID (28)
#define PCIE_CTL_TYPE0_HDR_BAR0_START_BF_MSK (0xFFFFFFF0)
#define PCIE_CTL_TYPE0_HDR_BAR0_START_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_BAR1_REG register description at address offset 0x14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/BAR1_REG
  * BAR1 Register.
  */

typedef union {
  struct {
    uint32_t BAR1_MEM_IO : 1;
    ///< - BAR1 Memory Space Indicator.  - This bit is used to determine whether
    ///< the register maps into Memory or I/O Space. Base Address registers
    ///< that map to Memory Space must return a 0b.  - Base Address registers
    ///< that map to I/O Space must return a 1b.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
    ///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t BAR1_TYPE : 2;
    ///< - BAR1 Type.  - Memory Space: Base Address registers that map into
    ///< Memory Space can be 32 bits or 64 bits wide (to support mapping into
    ///< a 64-bit address space). The encodings defined in Values: apply.
    ///< - IO Space: Bit 1 is reserved and must return 0b on reads. Bits[31:2]
    ///< are used to map the function into IO space. The encodings defined
    ///< in Values: do not apply.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t BAR1_PREFETCH : 1;
    ///< - BAR1 Prefetchable.  Memory Space: Set to one if data is prefetchable.
    ///< A Function is permitted to mark a range as prefetchable. If there
    ///< are no side effects on reads, the function returns all bytes on reads
    ///< regardless of the byte enables, and host bridges can merge processor
    ///< writes into this range without causing errors. Bit must me clear otherwise.
    ///< IO Space: Not applicable.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x0"
    uint32_t BAR1_START : 28;
    ///< - BAR1 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
    ///< are used to map the function into IO space/Base Address.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
    ///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
    ///< else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_bar1_reg_t;

#define PCIE_CTL_TYPE0_HDR_BAR1_DEFAULT (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_BAR1_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_BAR1_WR_MASK (0xffffffffU)


///< - BAR1 Memory Space Indicator.  - This bit is used to determine whether
///< the register maps into Memory or I/O Space. Base Address registers
///< that map to Memory Space must return a 0b.  - Base Address registers
///< that map to I/O Space must return a 1b.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR1_MEM_IO_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_BAR1_MEM_IO_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR1_MEM_IO_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_BAR1_MEM_IO_BF_DEF (0x00000000)

///< - BAR1 Type.  - Memory Space: Base Address registers that map into
///< Memory Space can be 32 bits or 64 bits wide (to support mapping into
///< a 64-bit address space). The encodings defined in Values: apply.
///< - IO Space: Bit 1 is reserved and must return 0b on reads. Bits[31:2]
///< are used to map the function into IO space. The encodings defined
///< in Values: do not apply.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR1_TYPE_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR1_TYPE_BF_WID ( 2)
#define PCIE_CTL_TYPE0_HDR_BAR1_TYPE_BF_MSK (0x00000006)
#define PCIE_CTL_TYPE0_HDR_BAR1_TYPE_BF_DEF (0x00000000)

///< - BAR1 Prefetchable.  Memory Space: Set to one if data is prefetchable.
///< A Function is permitted to mark a range as prefetchable. If there
///< are no side effects on reads, the function returns all bytes on reads
///< regardless of the byte enables, and host bridges can merge processor
///< writes into this range without causing errors. Bit must me clear otherwise.
///< IO Space: Not applicable.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR1_PREFETCH_BF_OFF ( 3)
#define PCIE_CTL_TYPE0_HDR_BAR1_PREFETCH_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR1_PREFETCH_BF_MSK (0x00000008)
#define PCIE_CTL_TYPE0_HDR_BAR1_PREFETCH_BF_DEF (0x00000000)

///< - BAR1 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
///< are used to map the function into IO space/Base Address.   Note: The
///< access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
///< else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR1_START_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_BAR1_START_BF_WID (28)
#define PCIE_CTL_TYPE0_HDR_BAR1_START_BF_MSK (0xFFFFFFF0)
#define PCIE_CTL_TYPE0_HDR_BAR1_START_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_BAR2_REG register description at address offset 0x18
  *
  * Register default value:        0x00000004
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/BAR2_REG
  * BAR2 Register.
  */

typedef union {
  struct {
    uint32_t BAR2_MEM_IO : 1;
    ///< BAR2 Memory Space Indicator. This bit is used to determine whether
    ///< the register maps into Memory or I/O Space. Base Address registers
    ///< that map to Memory Space must return a 0b. Base Address registers
    ///< that map to I/O Space must return a 1b.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
    ///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t BAR2_TYPE : 2;
    ///< BAR2 Type.  - Memory Space: Base Address registers that map into Memory
    ///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
    ///< address space). The encodings defined in Values: apply.  - IO Space:
    ///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
    ///< to map the function into IO space. The encodings defined in Values:
    ///< do not apply.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
    ///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x2"
    uint32_t BAR2_PREFETCH : 1;
    ///< BAR2 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
    ///< A Function is permitted to mark a range as prefetchable. If there
    ///< are no side effects on reads, the function returns all bytes on reads
    ///< regardless of the byte enables, and host bridges can merge processor
    ///< writes into this range without causing errors. Bit must me clear otherwise.
    ///< - IO Space: Not applicable   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t BAR2_START : 28;
    ///< BAR2 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
    ///< are used to map the function into IO space/Base. Address.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
    ///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
    ///< else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_bar2_reg_t;

#define PCIE_CTL_TYPE0_HDR_BAR2_DEFAULT (0x00000004U)
#define PCIE_CTL_TYPE0_HDR_BAR2_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_BAR2_WR_MASK (0xfffffff0U)


///< BAR2 Memory Space Indicator. This bit is used to determine whether
///< the register maps into Memory or I/O Space. Base Address registers
///< that map to Memory Space must return a 0b. Base Address registers
///< that map to I/O Space must return a 1b.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR2_MEM_IO_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_BAR2_MEM_IO_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR2_MEM_IO_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_BAR2_MEM_IO_BF_DEF (0x00000000)

///< BAR2 Type.  - Memory Space: Base Address registers that map into Memory
///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
///< address space). The encodings defined in Values: apply.  - IO Space:
///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
///< to map the function into IO space. The encodings defined in Values:
///< do not apply.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR2_TYPE_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR2_TYPE_BF_WID ( 2)
#define PCIE_CTL_TYPE0_HDR_BAR2_TYPE_BF_MSK (0x00000006)
#define PCIE_CTL_TYPE0_HDR_BAR2_TYPE_BF_DEF (0x00000004)

///< BAR2 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
///< A Function is permitted to mark a range as prefetchable. If there
///< are no side effects on reads, the function returns all bytes on reads
///< regardless of the byte enables, and host bridges can merge processor
///< writes into this range without causing errors. Bit must me clear otherwise.
///< - IO Space: Not applicable   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR2_PREFETCH_BF_OFF ( 3)
#define PCIE_CTL_TYPE0_HDR_BAR2_PREFETCH_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR2_PREFETCH_BF_MSK (0x00000008)
#define PCIE_CTL_TYPE0_HDR_BAR2_PREFETCH_BF_DEF (0x00000000)

///< BAR2 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
///< are used to map the function into IO space/Base. Address.   Note:
///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
///< else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR2_START_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_BAR2_START_BF_WID (28)
#define PCIE_CTL_TYPE0_HDR_BAR2_START_BF_MSK (0xFFFFFFF0)
#define PCIE_CTL_TYPE0_HDR_BAR2_START_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_BAR3_REG register description at address offset 0x1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/BAR3_REG
  * BAR3 Register.
  */

typedef union {
  struct {
    uint32_t BAR3_MEM_IO : 1;
    ///< BAR3 Memory Space Indicator. This bit is used to determine whether
    ///< the register maps into Memory or I/O Space. Base Address registers
    ///< that map to Memory Space must return a 0b. Base Address registers
    ///< that map to I/O Space must return a 1b.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
    ///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t BAR3_TYPE : 2;
    ///< BAR3 Type.  - Memory Space: Base Address registers that map into Memory
    ///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
    ///< address space). The encodings defined in Values: apply.  - IO Space:
    ///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
    ///< to map the function into IO space. The encodings defined in Values:
    ///< do not apply.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
    ///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t BAR3_PREFETCH : 1;
    ///< BAR3 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
    ///< A Function is permitted to mark a range as prefetchable. If there
    ///< are no side effects on reads, the function returns all bytes on reads
    ///< regardless of the byte enables, and host bridges can merge processor
    ///< writes into this range without causing errors. Bit must me clear otherwise.
    ///< - IO Space: Not applicable   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x0"
    uint32_t BAR3_START : 28;
    ///< BAR3 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
    ///< are used to map the function into IO space/Base. Address.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
    ///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
    ///< else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_bar3_reg_t;

#define PCIE_CTL_TYPE0_HDR_BAR3_DEFAULT (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_BAR3_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_BAR3_WR_MASK (0xffffffffU)


///< BAR3 Memory Space Indicator. This bit is used to determine whether
///< the register maps into Memory or I/O Space. Base Address registers
///< that map to Memory Space must return a 0b. Base Address registers
///< that map to I/O Space must return a 1b.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR3_MEM_IO_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_BAR3_MEM_IO_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR3_MEM_IO_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_BAR3_MEM_IO_BF_DEF (0x00000000)

///< BAR3 Type.  - Memory Space: Base Address registers that map into Memory
///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
///< address space). The encodings defined in Values: apply.  - IO Space:
///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
///< to map the function into IO space. The encodings defined in Values:
///< do not apply.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR3_TYPE_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR3_TYPE_BF_WID ( 2)
#define PCIE_CTL_TYPE0_HDR_BAR3_TYPE_BF_MSK (0x00000006)
#define PCIE_CTL_TYPE0_HDR_BAR3_TYPE_BF_DEF (0x00000000)

///< BAR3 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
///< A Function is permitted to mark a range as prefetchable. If there
///< are no side effects on reads, the function returns all bytes on reads
///< regardless of the byte enables, and host bridges can merge processor
///< writes into this range without causing errors. Bit must me clear otherwise.
///< - IO Space: Not applicable   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR3_PREFETCH_BF_OFF ( 3)
#define PCIE_CTL_TYPE0_HDR_BAR3_PREFETCH_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR3_PREFETCH_BF_MSK (0x00000008)
#define PCIE_CTL_TYPE0_HDR_BAR3_PREFETCH_BF_DEF (0x00000000)

///< BAR3 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
///< are used to map the function into IO space/Base. Address.   Note:
///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
///< else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR3_START_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_BAR3_START_BF_WID (28)
#define PCIE_CTL_TYPE0_HDR_BAR3_START_BF_MSK (0xFFFFFFF0)
#define PCIE_CTL_TYPE0_HDR_BAR3_START_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_BAR4_REG register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/BAR4_REG
  * BAR4 Register.
  */

typedef union {
  struct {
    uint32_t BAR4_MEM_IO : 1;
    ///< BAR4 Memory Space Indicator. This bit is used to determine whether
    ///< the register maps into Memory or I/O Space. Base Address registers
    ///< that map to Memory Space must return a 0b. Base Address registers
    ///< that map to I/O Space must return a 1b.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
    ///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t BAR4_TYPE : 2;
    ///< BAR4 Type.  - Memory Space: Base Address registers that map into Memory
    ///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
    ///< address space). The encodings defined in Values: apply.  - IO Space:
    ///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
    ///< to map the function into IO space. The encodings defined in Values:
    ///< do not apply.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
    ///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t BAR4_PREFETCH : 1;
    ///< BAR4 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
    ///< A Function is permitted to mark a range as prefetchable. If there
    ///< are no side effects on reads, the function returns all bytes on reads
    ///< regardless of the byte enables, and host bridges can merge processor
    ///< writes into this range without causing errors. Bit must me clear otherwise.
    ///< - IO Space: Not applicable   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t BAR4_START : 28;
    ///< BAR4 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
    ///< are used to map the function into IO space/Base. Address.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
    ///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
    ///< else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_bar4_reg_t;

#define PCIE_CTL_TYPE0_HDR_BAR4_DEFAULT (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_BAR4_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_BAR4_WR_MASK (0xfffffff0U)


///< BAR4 Memory Space Indicator. This bit is used to determine whether
///< the register maps into Memory or I/O Space. Base Address registers
///< that map to Memory Space must return a 0b. Base Address registers
///< that map to I/O Space must return a 1b.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR4_MEM_IO_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_BAR4_MEM_IO_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR4_MEM_IO_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_BAR4_MEM_IO_BF_DEF (0x00000000)

///< BAR4 Type.  - Memory Space: Base Address registers that map into Memory
///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
///< address space). The encodings defined in Values: apply.  - IO Space:
///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
///< to map the function into IO space. The encodings defined in Values:
///< do not apply.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR4_TYPE_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR4_TYPE_BF_WID ( 2)
#define PCIE_CTL_TYPE0_HDR_BAR4_TYPE_BF_MSK (0x00000006)
#define PCIE_CTL_TYPE0_HDR_BAR4_TYPE_BF_DEF (0x00000000)

///< BAR4 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
///< A Function is permitted to mark a range as prefetchable. If there
///< are no side effects on reads, the function returns all bytes on reads
///< regardless of the byte enables, and host bridges can merge processor
///< writes into this range without causing errors. Bit must me clear otherwise.
///< - IO Space: Not applicable   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR4_PREFETCH_BF_OFF ( 3)
#define PCIE_CTL_TYPE0_HDR_BAR4_PREFETCH_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR4_PREFETCH_BF_MSK (0x00000008)
#define PCIE_CTL_TYPE0_HDR_BAR4_PREFETCH_BF_DEF (0x00000000)

///< BAR4 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
///< are used to map the function into IO space/Base. Address.   Note:
///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
///< else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR4_START_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_BAR4_START_BF_WID (28)
#define PCIE_CTL_TYPE0_HDR_BAR4_START_BF_MSK (0xFFFFFFF0)
#define PCIE_CTL_TYPE0_HDR_BAR4_START_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_BAR5_REG register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/BAR5_REG
  * BAR5 Register.
  */

typedef union {
  struct {
    uint32_t BAR5_MEM_IO : 1;
    ///< BAR5 Memory Space Indicator. This bit is used to determine whether
    ///< the register maps into Memory or I/O Space. Base Address registers
    ///< that map to Memory Space must return a 0b. Base Address registers
    ///< that map to I/O Space must return a 1b.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
    ///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t BAR5_TYPE : 2;
    ///< BAR5 Type.  - Memory Space: Base Address registers that map into Memory
    ///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
    ///< address space). The encodings defined in Values: apply.  - IO Space:
    ///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
    ///< to map the function into IO space. The encodings defined in Values:
    ///< do not apply.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
    ///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t BAR5_PREFETCH : 1;
    ///< BAR5 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
    ///< A Function is permitted to mark a range as prefetchable. If there
    ///< are no side effects on reads, the function returns all bytes on reads
    ///< regardless of the byte enables, and host bridges can merge processor
    ///< writes into this range without causing errors. Bit must me clear otherwise.
    ///< - IO Space: Not applicable   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
    ///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
    ///< else RO(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t BAR5_START : 28;
    ///< BAR5 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
    ///< are used to map the function into IO space/Base. Address.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
    ///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
    ///< else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_bar5_reg_t;

#define PCIE_CTL_TYPE0_HDR_BAR5_DEFAULT (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_BAR5_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_BAR5_WR_MASK (0xfffffff0U)


///< BAR5 Memory Space Indicator. This bit is used to determine whether
///< the register maps into Memory or I/O Space. Base Address registers
///< that map to Memory Space must return a 0b. Base Address registers
///< that map to I/O Space must return a 1b.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED
///< == 1) then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR5_MEM_IO_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_BAR5_MEM_IO_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR5_MEM_IO_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_BAR5_MEM_IO_BF_DEF (0x00000000)

///< BAR5 Type.  - Memory Space: Base Address registers that map into Memory
///< Space can be 32 bits or 64 bits wide (to support mapping into a 64-bit
///< address space). The encodings defined in Values: apply.  - IO Space:
///< Bit 1 is reserved and must return 0b on reads. Bits[31:2] are used
///< to map the function into IO space. The encodings defined in Values:
///< do not apply.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1) then (if [DBI_RO_WR_EN
///< == 1] then R(Sticky)/W(Sticky) else R(Sticky)) else RO(Sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR5_TYPE_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR5_TYPE_BF_WID ( 2)
#define PCIE_CTL_TYPE0_HDR_BAR5_TYPE_BF_MSK (0x00000006)
#define PCIE_CTL_TYPE0_HDR_BAR5_TYPE_BF_DEF (0x00000000)

///< BAR5 Prefetchable.  - Memory Space: Set to one if data is prefetchable.
///< A Function is permitted to mark a range as prefetchable. If there
///< are no side effects on reads, the function returns all bytes on reads
///< regardless of the byte enables, and host bridges can merge processor
///< writes into this range without causing errors. Bit must me clear otherwise.
///< - IO Space: Not applicable   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (BAR_ENABLED == 1)
///< then (if [DBI_RO_WR_EN == 1] then R(Sticky)/W(Sticky) else R(Sticky))
///< else RO(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR5_PREFETCH_BF_OFF ( 3)
#define PCIE_CTL_TYPE0_HDR_BAR5_PREFETCH_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_BAR5_PREFETCH_BF_MSK (0x00000008)
#define PCIE_CTL_TYPE0_HDR_BAR5_PREFETCH_BF_DEF (0x00000000)

///< BAR5 Base Address.  - Memory Space: Base Address.  - IO Space: bits[31:2]
///< are used to map the function into IO space/Base. Address.   Note:
///< The access attributes of this field are as follows:  - Wire: R(Sticky)/W(Sticky)
///< if enabled else R(Sticky)   - Dbi: R(Sticky)/W(Sticky) if enabled
///< else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_BAR5_START_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_BAR5_START_BF_WID (28)
#define PCIE_CTL_TYPE0_HDR_BAR5_START_BF_MSK (0xFFFFFFF0)
#define PCIE_CTL_TYPE0_HDR_BAR5_START_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_CARDBUS_CIS_PTR_REG register description at address offset 0x28
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/CARDBUS_CIS_PTR_REG
  * CardBus CIS Pointer Register.
  */

typedef union {
  struct {
    uint32_t CARDBUS_CIS_POINTER : 32;
    ///< CardBus CIS Pointer. Its functionality does not apply to PCI Express.
    ///< It must be hardwired to 0000 0000h.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_cardbus_cis_ptr_reg_t;

#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_DEFAULT (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_WR_MASK (0x00000000U)


///< CardBus CIS Pointer. Its functionality does not apply to PCI Express.
///< It must be hardwired to 0000 0000h.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_CARDBUS_CIS_PTR_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_CARDBUS_CIS_PTR_BF_WID (32)
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_CARDBUS_CIS_PTR_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_CARDBUS_CIS_PTR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG register description at address offset 0x2c
  *
  * Register default value:        0x0DD68086
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG
  * Subsystem ID and Subsystem Vendor ID Register.
  */

typedef union {
  struct {
    uint32_t SUBSYS_VENDOR_ID : 16;
    ///< Subsystem Vendor ID. Subsystem Vendor IDs can be obtained from the
    ///< PCI SIG and are used to identify the vendor of the add-in card or
    ///< subsystem. Values for the Subsystem ID are vendor-specific.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x8086"
    uint32_t SUBSYS_DEV_ID : 16;
    ///< Subsystem ID.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0xDD6"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_subsys_id_subsys_vendor_id_reg_t;

#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_DEFAULT (0x0dd68086U)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_RD_MASK (0xffffffffU)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_WR_MASK (0x00000000U)


///< Subsystem Vendor ID. Subsystem Vendor IDs can be obtained from the
///< PCI SIG and are used to identify the vendor of the add-in card or
///< subsystem. Values for the Subsystem ID are vendor-specific.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_VENDOR_ID_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_VENDOR_ID_BF_WID (16)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_VENDOR_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_VENDOR_ID_BF_DEF (0x00008086)

///< Subsystem ID.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_DEV_ID_BF_OFF (16)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_DEV_ID_BF_WID (16)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_DEV_ID_BF_MSK (0xFFFF0000)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_SUBSYS_DEV_ID_BF_DEF (0x0DD60000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_EXP_ROM_BASE_ADDR_REG register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/EXP_ROM_BASE_ADDR_REG
  * Expansion ROM BAR Register.
  */

typedef union {
  struct {
    uint32_t ROM_BAR_ENABLE : 1;
    ///< Expansion ROM Enable. This bit controls whether or not the Function
    ///< accepts accesses to its expansion ROM. The Memory Space Enable bit
    ///< in the Command register has precedence over the Expansion ROM Enable
    ///< bit. A Function must claim accesses to its expansion ROM only if both
    ///< the Memory Space Enable bit and the Expansion ROM Enable bit are set.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else R   -
    ///< Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else
    ///< R
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t ROM_BAR_VALIDATION_STATUS : 3;
    ///< Expansion ROM Validation Status. When this field is non-zero, it indicates
    ///< the status of hardware validation of the Expansion ROM contents.
    ///< - If the Function does not support validation, this field must be
    ///< hardwired to 000b.  - It is optional whether an implementation is
    ///< capable of returning Validation Status values 011b, 101b, 110b, or
    ///< 111b.   Note: The access attributes of this field are as follows:
    ///< - Wire: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else
    ///< R   - Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1 && DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ROM_BAR_VALIDATION_DETAILS : 4;
    ///< Expansion ROM Validation Details. The field contains optional, implementation-specific
    ///< details associated with Expansion ROM Validation.  - If validation
    ///< is in progress (Expansion ROM Validation Status is 001b), non-zero
    ///< values of this field represent implementation-specific indications
    ///< of the phase of the validation progress (for example, 50% complete).
    ///< The value 0000b indicates that no validation progress information
    ///< is provided.  - If validation is completed (Expansion ROM Validation
    ///< Status 010b to 111b inclusive), non-zero values in this field represent
    ///< additional implementation-specific information. The value 0000b indicates
    ///< that no information is provided.  - When validation is supported and
    ///< this field is not implemented, this field must be hardwired to 0000b.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else R   -
    ///< Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1 &&  DBI_RO_WR_EN
    ///< == 1 ) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t EXP_ROM_BASE_ADDRESS : 21;
    ///< Expansion ROM Base Address. Upper 21 bits of the Expansion ROM base
    ///< address. The number of bits (out of these 21) that a Function actually
    ///< implements depends on how much address space the Function requires.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else R   -
    ///< Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else
    ///< R
    ///< AccessType="RW/V" BitOffset="11" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_exp_rom_base_addr_reg_t;

#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_DEFAULT (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_RD_MASK (0xfffff8ffU)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_WR_MASK (0xfffff8ffU)


///< Expansion ROM Enable. This bit controls whether or not the Function
///< accepts accesses to its expansion ROM. The Memory Space Enable bit
///< in the Command register has precedence over the Expansion ROM Enable
///< bit. A Function must claim accesses to its expansion ROM only if both
///< the Memory Space Enable bit and the Expansion ROM Enable bit are set.
///< Note: The access attributes of this field are as follows:  - Wire:
///< if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else R   -
///< Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else
///< R
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_EN_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_EN_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_EN_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_EN_BF_DEF (0x00000000)

///< Expansion ROM Validation Status. When this field is non-zero, it indicates
///< the status of hardware validation of the Expansion ROM contents.
///< - If the Function does not support validation, this field must be
///< hardwired to 000b.  - It is optional whether an implementation is
///< capable of returning Validation Status values 011b, 101b, 110b, or
///< 111b.   Note: The access attributes of this field are as follows:
///< - Wire: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else
///< R   - Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1 && DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_STAT_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_STAT_BF_WID ( 3)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_STAT_BF_MSK (0x0000000E)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_STAT_BF_DEF (0x00000000)

///< Expansion ROM Validation Details. The field contains optional, implementation-specific
///< details associated with Expansion ROM Validation.  - If validation
///< is in progress (Expansion ROM Validation Status is 001b), non-zero
///< values of this field represent implementation-specific indications
///< of the phase of the validation progress (for example, 50% complete).
///< The value 0000b indicates that no validation progress information
///< is provided.  - If validation is completed (Expansion ROM Validation
///< Status 010b to 111b inclusive), non-zero values in this field represent
///< additional implementation-specific information. The value 0000b indicates
///< that no information is provided.  - When validation is supported and
///< this field is not implemented, this field must be hardwired to 0000b.
///< Note: The access attributes of this field are as follows:  - Wire:
///< if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else R   -
///< Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1 &&  DBI_RO_WR_EN
///< == 1 ) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_DETAILS_BF_OFF ( 4)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_DETAILS_BF_WID ( 4)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_DETAILS_BF_MSK (0x000000F0)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ROM_BAR_VALIDATION_DETAILS_BF_DEF (0x00000000)

///< Expansion ROM Base Address. Upper 21 bits of the Expansion ROM base
///< address. The number of bits (out of these 21) that a Function actually
///< implements depends on how much address space the Function requires.
///< Note: The access attributes of this field are as follows:  - Wire:
///< if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else R   -
///< Dbi: if (EXP_ROM_BAR_MASK_REG.ROM_BAR_ENABLED == 1) then R/W else
///< R
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_EXP_ROM_BASE_BF_OFF (11)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_EXP_ROM_BASE_BF_WID (21)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_EXP_ROM_BASE_BF_MSK (0xFFFFF800)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_EXP_ROM_BASE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_PCI_CAP_PTR_REG register description at address offset 0x34
  *
  * Register default value:        0x00000040
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/PCI_CAP_PTR_REG
  * Capabilities Pointer Register.
  */

typedef union {
  struct {
    uint32_t CAP_POINTER : 8;
    ///< Capabilities Pointer. This register points to a valid capability structure.
    ///< Either this structure is the PCI Express Capability structure, or
    ///< a subsequent list item points to the PCI Express Capability structure.
    ///< The bottom two bits are reserved, the controller sets it to 00b. Software
    ///< must mask these bits off before using this register as a pointer in
    ///< Configuration Space to the first entry of a linked list of new capabilities.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x40"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_pci_cap_ptr_reg_t;

#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_DEFAULT (0x00000040U)
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_RD_MASK (0x000000ffU)
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_WR_MASK (0x00000000U)


///< Capabilities Pointer. This register points to a valid capability structure.
///< Either this structure is the PCI Express Capability structure, or
///< a subsequent list item points to the PCI Express Capability structure.
///< The bottom two bits are reserved, the controller sets it to 00b. Software
///< must mask these bits off before using this register as a pointer in
///< Configuration Space to the first entry of a linked list of new capabilities.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_CAP_PTR_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_CAP_PTR_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_CAP_PTR_BF_MSK (0x000000FF)
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_CAP_PTR_BF_DEF (0x00000040)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG register description at address offset 0x3c
  *
  * Register default value:        0x000001FF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR/MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG
  * Max_Lat, Min_Gnt, Interrupt Pin, and Interrupt Line Register.
  */

typedef union {
  struct {
    uint32_t INT_LINE : 8;
    ///< Interrupt Line. The Interrupt Line register communicates interrupt
    ///< line routing information. The register must be implemented by any
    ///< Function that uses an interrupt pin. Values in this register are programmed
    ///< by system software and are system architecture specific. The Function
    ///< itself does not use this value; rather the value in this register
    ///< is used by device drivers and operating systems.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFF"
    uint32_t INT_PIN : 8;
    ///< Interrupt Pin. The Interrupt Pin register identifies the legacy interrupt
    ///< Message(s) the Function uses. All encodings other than the defined
    ///< encodings are reserved. PCI Express defines one legacy interrupt Message
    ///< for a single Function device and up to four legacy interrupt Messages
    ///< for a multi-Function device. For a single Function device, only INTA
    ///< may be used.  Any Function on a multi-Function device can use any
    ///< of the INTx Messages. If a device implements a single legacy interrupt
    ///< Message, it must be INTA; if it implements two legacy interrupt Messages,
    ///< they must be INTA and INTB; and so forth. For a multi-Function device,
    ///< all Functions may use the same INTx Message or each may have its own
    ///< (up to a maximum of four Functions) or any combination thereof. A
    ///< single Function can never generate an interrupt request on more than
    ///< one INTx Message.  Note: The access attributes of this field are as
    ///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x1"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_max_latency_min_grant_intr_pin_intr_line_reg_t;

#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_DEFAULT (0x000001ffU)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_RD_MASK (0x0000ffffU)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_WR_MASK (0x000000ffU)


///< Interrupt Line. The Interrupt Line register communicates interrupt
///< line routing information. The register must be implemented by any
///< Function that uses an interrupt pin. Values in this register are programmed
///< by system software and are system architecture specific. The Function
///< itself does not use this value; rather the value in this register
///< is used by device drivers and operating systems.
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_LINE_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_LINE_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_LINE_BF_MSK (0x000000FF)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_LINE_BF_DEF (0x000000FF)

///< Interrupt Pin. The Interrupt Pin register identifies the legacy interrupt
///< Message(s) the Function uses. All encodings other than the defined
///< encodings are reserved. PCI Express defines one legacy interrupt Message
///< for a single Function device and up to four legacy interrupt Messages
///< for a multi-Function device. For a single Function device, only INTA
///< may be used.  Any Function on a multi-Function device can use any
///< of the INTx Messages. If a device implements a single legacy interrupt
///< Message, it must be INTA; if it implements two legacy interrupt Messages,
///< they must be INTA and INTB; and so forth. For a multi-Function device,
///< all Functions may use the same INTx Message or each may have its own
///< (up to a maximum of four Functions) or any combination thereof. A
///< single Function can never generate an interrupt request on more than
///< one INTx Message.  Note: The access attributes of this field are as
///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R  Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_PIN_BF_OFF ( 8)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_PIN_BF_WID ( 8)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_PIN_BF_MSK (0x0000FF00)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_INT_PIN_BF_DEF (0x00000100)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PM_CAP_CAP_ID_NXT_PTR_REG register description at address offset 0x40
  *
  * Register default value:        0xDFC35001
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PM_CAP/CAP_ID_NXT_PTR_REG
  * Power Management Capabilities Register.
  */

typedef union {
  struct {
    uint32_t PM_CAP_ID : 8;
    ///< Capability ID. This field returns 01h to indicate that this is the
    ///< PCI Power Management Capability. Each function may have only one item
    ///< in its capability list with Capability ID set to 01h.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x1"
    uint32_t PM_NEXT_POINTER : 8;
    ///< Next Capability Pointer. This field provides an offset into the function's
    ///< configuration space pointing to the location of next item in the capabilities
    ///< list. If there are no additional items in the capabilities list, this
    ///< field is set to 00h.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x50"
    uint32_t PM_SPEC_VER : 3;
    ///< Version. This field provides the Power Management specification version.
    ///< The controller hardwires this field to 011b for functions compliant
    ///< to PCI Express Base Specification, Revision 4.0, Version 1.0>.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x3"
    uint32_t PME_CLK : 1;
    ///< PME Clock. Does not apply to PCI Express, the controller hardwires
    ///< it to 0b.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t DSI : 1;
    ///< Device Specific Initialization. The DSI bit indicates whether special
    ///< initialization of this function is required.  When set, indicates
    ///< that the function requires a device specific initialization sequence
    ///< following a transition to the D0uninitialized state.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="21" ResetValue="0x0"
    uint32_t AUX_CURR : 3;
    ///< Aux_Current. This 3 bit field reports the Vaux auxiliary current requirements
    ///< for the function.  If this function implements the Power Management
    ///< Data Register, the controller hardwires this field to 000b.  If PME_Support
    ///< is 0 xxxxb (PME assertion from D3cold is not supported) and the Aux
    ///< Power PM Enable feature is not implemented, the controller hardwires
    ///< this field to 000b.  For functions where PME_Support is 1 xxxxb (PME
    ///< assertion from D3cold is supported), and which do not implement the
    ///< Power Management Data Register, the encodings defined in Values: apply:
    ///< For encoding 000b, when the add-in card is self powered (e.g., it
    ///< contains a battery), it is recommended that the Power Budgeting Extended
    ///< Capability be used to report the thermal requirements of the add-in
    ///< card. Note: Additional Aux power is permitted to be allocated using
    ///< the firmware based mechanism (see the Request D3 Cold Aux Power Limit
    ///< _DSM call as defined in [Firmware]). Additional Aux power is also
    ///< permitted to be allocated by selecting a PM Sub State in the Power
    ///< Limit mechanism (see Section 7.8.1.3)   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="22" ResetValue="0x7"
    uint32_t D1_SUPPORT : 1;
    ///< D1_Support. If this bit is set, this function supports the D1 Power
    ///< Management state. Functions that do not support D1 must always return
    ///< a value of 0b for this bit.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="25" ResetValue="0x1"
    uint32_t D2_SUPPORT : 1;
    ///< D2_Support. If this bit is set, this function supports the D2 Power
    ///< Management state. Functions that do not support D2 must always return
    ///< a value of 0b for this bit.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="26" ResetValue="0x1"
    uint32_t PME_SUPPORT : 5;
    ///< PME_Support. This 5-bit field indicates the power states in which
    ///< the function may generate a PME and/or forward PME messages. A value
    ///< of 0b for any bit indicates that the function is not capable of asserting
    ///< PME while in that power state.  - bit(27) X XXX1b - PME can be generated
    ///< from D0  - bit(28) X XX1Xb - PME can be generated from D1  - bit(29)
    ///< X X1XXb - PME can be generated from D2  - bit(30) X 1XXXb - PME can
    ///< be generated from D3hot  - bit(31) 1 XXXXb - PME can be generated
    ///< from D3cold Bit 31 (PME can be asserted from D3cold) represents a
    ///< special case. Functions that set this bit require some sort of auxiliary
    ///< power source. Implementation specific mechanisms are recommended to
    ///< validate that the power source is available before setting this bit.
    ///< Each bit that corresponds to a supported D-state must be set for PCI-PCI
    ///< Bridge structures representing Ports on Root Complexes/Switches to
    ///< indicate that the Bridge will forward PME Messages. Bit 31 must only
    ///< be set if the Port is still able to forward PME Messages when main
    ///< power is not available.  The read value from this field is the write
    ///< value && (sys_aux_pwr_det, 1'b1, D2_SUPPORT, D1_SUPPORT, 1'b1), where
    ///< D1_SUPPORT and D2_SUPPORT are fields in this register.  The reset
    ///< value PME_SUPPORT_n && (sys_aux_pwr_det, 1'b1, D2_SUPPORT, D1_SUPPORT,
    ///< 1'b1), where PME_SUPPORT_n is a configuration parameter.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
    ///< is sticky.
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x1B"
  } ;
  uint32_t value;
} pcie_ctl_pm_cap_id_nxt_ptr_reg_t;

#define PCIE_CTL_PM_CAP_ID_NXT_PTR_DEFAULT (0xdfc35001U)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_RD_MASK (0xffefffffU)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_WR_MASK (0x00000000U)


///< Capability ID. This field returns 01h to indicate that this is the
///< PCI Power Management Capability. Each function may have only one item
///< in its capability list with Capability ID set to 01h.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_CAP_ID_BF_WID ( 8)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_CAP_ID_BF_MSK (0x000000FF)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_CAP_ID_BF_DEF (0x00000001)

///< Next Capability Pointer. This field provides an offset into the function's
///< configuration space pointing to the location of next item in the capabilities
///< list. If there are no additional items in the capabilities list, this
///< field is set to 00h.   Note: The access attributes of this field are
///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_NEXT_PTR_BF_OFF ( 8)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_NEXT_PTR_BF_WID ( 8)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_NEXT_PTR_BF_MSK (0x0000FF00)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_NEXT_PTR_BF_DEF (0x00005000)

///< Version. This field provides the Power Management specification version.
///< The controller hardwires this field to 011b for functions compliant
///< to PCI Express Base Specification, Revision 4.0, Version 1.0>.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
///< field is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_SPEC_VER_BF_OFF (16)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_SPEC_VER_BF_WID ( 3)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_SPEC_VER_BF_MSK (0x00070000)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PM_SPEC_VER_BF_DEF (0x00030000)

///< PME Clock. Does not apply to PCI Express, the controller hardwires
///< it to 0b.   Note: This register field is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_CLK_BF_OFF (19)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_CLK_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_CLK_BF_MSK (0x00080000)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_CLK_BF_DEF (0x00000000)

///< Device Specific Initialization. The DSI bit indicates whether special
///< initialization of this function is required.  When set, indicates
///< that the function requires a device specific initialization sequence
///< following a transition to the D0uninitialized state.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
///< is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_DSI_BF_OFF (21)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_DSI_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_DSI_BF_MSK (0x00200000)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_DSI_BF_DEF (0x00000000)

///< Aux_Current. This 3 bit field reports the Vaux auxiliary current requirements
///< for the function.  If this function implements the Power Management
///< Data Register, the controller hardwires this field to 000b.  If PME_Support
///< is 0 xxxxb (PME assertion from D3cold is not supported) and the Aux
///< Power PM Enable feature is not implemented, the controller hardwires
///< this field to 000b.  For functions where PME_Support is 1 xxxxb (PME
///< assertion from D3cold is supported), and which do not implement the
///< Power Management Data Register, the encodings defined in Values: apply:
///< For encoding 000b, when the add-in card is self powered (e.g., it
///< contains a battery), it is recommended that the Power Budgeting Extended
///< Capability be used to report the thermal requirements of the add-in
///< card. Note: Additional Aux power is permitted to be allocated using
///< the firmware based mechanism (see the Request D3 Cold Aux Power Limit
///< _DSM call as defined in [Firmware]). Additional Aux power is also
///< permitted to be allocated by selecting a PM Sub State in the Power
///< Limit mechanism (see Section 7.8.1.3)   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_AUX_CURR_BF_OFF (22)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_AUX_CURR_BF_WID ( 3)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_AUX_CURR_BF_MSK (0x01C00000)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_AUX_CURR_BF_DEF (0x01C00000)

///< D1_Support. If this bit is set, this function supports the D1 Power
///< Management state. Functions that do not support D1 must always return
///< a value of 0b for this bit.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D1_SUPPORT_BF_OFF (25)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D1_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D1_SUPPORT_BF_MSK (0x02000000)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D1_SUPPORT_BF_DEF (0x02000000)

///< D2_Support. If this bit is set, this function supports the D2 Power
///< Management state. Functions that do not support D2 must always return
///< a value of 0b for this bit.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D2_SUPPORT_BF_OFF (26)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D2_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D2_SUPPORT_BF_MSK (0x04000000)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_D2_SUPPORT_BF_DEF (0x04000000)

///< PME_Support. This 5-bit field indicates the power states in which
///< the function may generate a PME and/or forward PME messages. A value
///< of 0b for any bit indicates that the function is not capable of asserting
///< PME while in that power state.  - bit(27) X XXX1b - PME can be generated
///< from D0  - bit(28) X XX1Xb - PME can be generated from D1  - bit(29)
///< X X1XXb - PME can be generated from D2  - bit(30) X 1XXXb - PME can
///< be generated from D3hot  - bit(31) 1 XXXXb - PME can be generated
///< from D3cold Bit 31 (PME can be asserted from D3cold) represents a
///< special case. Functions that set this bit require some sort of auxiliary
///< power source. Implementation specific mechanisms are recommended to
///< validate that the power source is available before setting this bit.
///< Each bit that corresponds to a supported D-state must be set for PCI-PCI
///< Bridge structures representing Ports on Root Complexes/Switches to
///< indicate that the Bridge will forward PME Messages. Bit 31 must only
///< be set if the Port is still able to forward PME Messages when main
///< power is not available.  The read value from this field is the write
///< value && (sys_aux_pwr_det, 1'b1, D2_SUPPORT, D1_SUPPORT, 1'b1), where
///< D1_SUPPORT and D2_SUPPORT are fields in this register.  The reset
///< value PME_SUPPORT_n && (sys_aux_pwr_det, 1'b1, D2_SUPPORT, D1_SUPPORT,
///< 1'b1), where PME_SUPPORT_n is a configuration parameter.   Note: The
///< access attributes of this field are as follows:  - Wire: R   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
///< is sticky.
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_SUPPORT_BF_OFF (27)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_SUPPORT_BF_WID ( 5)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_SUPPORT_BF_MSK (0xF8000000)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_PME_SUPPORT_BF_DEF (0xD8000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PM_CAP_CON_STATUS_REG register description at address offset 0x44
  *
  * Register default value:        0x00000008
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PM_CAP/CON_STATUS_REG
  * Power Management Control and Status Register.
  */

typedef union {
  struct {
    uint32_t POWER_STATE : 2;
    ///< PowerState. This 2-bit field is used both to determine the current
    ///< power state of a function and to set the function into a new power
    ///< state. You can write to this register; however, the read-back value
    ///< is the actual power state, not the write value. If you attempt to
    ///< write an unsupported, optional state to this field, the write operation
    ///< completes normally; however, the data is discarded and no state change
    ///< occurs.  Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t NO_SOFT_RST : 1;
    ///< No_Soft_Reset. This bit indicates the state of the function after
    ///< writing the PowerState field to transition the function from D3hot
    ///< to D0. This bit MUST @FLIT be Set.  - When set, this transition preserves
    ///< internal function state. The function is in D0Active and no additional
    ///< software intervention is required.  - When clear, this transition
    ///< results in undefined internal function state. Regardless of this bit,
    ///< functions that transition from D3hot to D0 by Fundamental Reset must
    ///< return to D0Uninitialized with only PME context preserved if PME is
    ///< supported and enabled.   If a VF implements the Power Management Capability,
    ///< the VF's value of this field must be identical to the associated PF's
    ///< value.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x1"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
    uint32_t PME_ENABLE : 1;
    ///< PME_En.  - When set, the function is permitted to generate a PME.
    ///< - When clear, the function is not permitted to generate a PME. If
    ///< PME_Support is 1 xxxxb (PME generation from D3cold) or the function
    ///< consumes Aux power and Aux power is available this bit is RWS and
    ///< the bit is not modified by Conventional Reset or FLR.  If PME_Support
    ///< is 0 xxxxb, this field is not sticky (RW) and defaults to 0b in response
    ///< to a Conventional Reset or an FLR.  If PME_Support is 0 0000b, the
    ///< controller hardwires this bit to 0b.   Note: This register field is
    ///< sticky.
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x0"
    uint32_t DATA_SELECT : 4;
    ///< Data_Select. This 4-bit field is used to select which data is to be
    ///< reported through the Power Management Data Register and Data_Scale
    ///< field. If the Power Management Data field is not implemented, this
    ///< field must be hardwired to zero. The default of this field is zero.
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t DATA_SCALE : 2;
    ///< Data_Scale. This field indicates the scaling factor to be used when
    ///< interpreting the value of the Data field. The value and meaning of
    ///< this field varies depending on which data value has been selected
    ///< by the Data_Select field. This field is a required component of the
    ///< Power Management Data Register (offset 7) and must be implemented
    ///< if the Power Management Data Register is implemented. If the Power
    ///< Management Data Registeris not implemented, this field must be hardwired
    ///< to zero.  For more information, see 7.5.2.3 section of PCI Express
    ///< Base Specification.
    ///< AccessType="RO" BitOffset="13" ResetValue="0x0"
    uint32_t PME_STATUS : 1;
    ///< PME_Status. This bit is set when the function normally generates a
    ///< PME signal. The value of this bit is not affected by the value of
    ///< the PME_En bit. If PME_Support bit 31 of the Power Management Capabilities
    ///< register is clear, this bit is permitted to be hardwired to 0b. Functions
    ///< that consume Aux power must preserve the value of this sticky register
    ///< when Aux power is available. In such functions, this register value
    ///< is not modified by Conventional Reset or FLR.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="15" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
    uint32_t B2_B3_SUPPORT : 1;
    ///< B2B3 Support for D3hot. If this field is set, B2B3 support for D3hot
    ///< is available.
    ///< AccessType="RO" BitOffset="22" ResetValue="0x0"
    uint32_t BUS_PWR_CLK_CON_EN : 1;
    ///< Bus Power/Clock Control Enable. If this field is set, Bus Power/Clock
    ///< Control is Enable.
    ///< AccessType="RO" BitOffset="23" ResetValue="0x0"
    uint32_t DATA_REG_ADD_INFO : 8;
    ///< Data. This field is used to report the state dependent data requested
    ///< by the Data_Select field. The value of this field is scaled by the
    ///< value reported by the Data_Scale field.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_pm_cap_con_stat_reg_t;

#define PCIE_CTL_PM_CAP_CON_STAT_DEFAULT (0x00000008U)
#define PCIE_CTL_PM_CAP_CON_STAT_RD_MASK (0xffc0ff0bU)
#define PCIE_CTL_PM_CAP_CON_STAT_WR_MASK (0x00008103U)


///< PowerState. This 2-bit field is used both to determine the current
///< power state of a function and to set the function into a new power
///< state. You can write to this register; however, the read-back value
///< is the actual power state, not the write value. If you attempt to
///< write an unsupported, optional state to this field, the write operation
///< completes normally; however, the data is discarded and no state change
///< occurs.  Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_PM_CAP_CON_STAT_PWR_STATE_BF_OFF ( 0)
#define PCIE_CTL_PM_CAP_CON_STAT_PWR_STATE_BF_WID ( 2)
#define PCIE_CTL_PM_CAP_CON_STAT_PWR_STATE_BF_MSK (0x00000003)
#define PCIE_CTL_PM_CAP_CON_STAT_PWR_STATE_BF_DEF (0x00000000)

///< No_Soft_Reset. This bit indicates the state of the function after
///< writing the PowerState field to transition the function from D3hot
///< to D0. This bit MUST @FLIT be Set.  - When set, this transition preserves
///< internal function state. The function is in D0Active and no additional
///< software intervention is required.  - When clear, this transition
///< results in undefined internal function state. Regardless of this bit,
///< functions that transition from D3hot to D0 by Fundamental Reset must
///< return to D0Uninitialized with only PME context preserved if PME is
///< supported and enabled.   If a VF implements the Power Management Capability,
///< the VF's value of this field must be identical to the associated PF's
///< value.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_PM_CAP_CON_STAT_NO_SOFT_RST_BF_OFF ( 3)
#define PCIE_CTL_PM_CAP_CON_STAT_NO_SOFT_RST_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_CON_STAT_NO_SOFT_RST_BF_MSK (0x00000008)
#define PCIE_CTL_PM_CAP_CON_STAT_NO_SOFT_RST_BF_DEF (0x00000008)

///< PME_En.  - When set, the function is permitted to generate a PME.
///< - When clear, the function is not permitted to generate a PME. If
///< PME_Support is 1 xxxxb (PME generation from D3cold) or the function
///< consumes Aux power and Aux power is available this bit is RWS and
///< the bit is not modified by Conventional Reset or FLR.  If PME_Support
///< is 0 xxxxb, this field is not sticky (RW) and defaults to 0b in response
///< to a Conventional Reset or an FLR.  If PME_Support is 0 0000b, the
///< controller hardwires this bit to 0b.   Note: This register field is
///< sticky.
#define PCIE_CTL_PM_CAP_CON_STAT_PME_EN_BF_OFF ( 8)
#define PCIE_CTL_PM_CAP_CON_STAT_PME_EN_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_CON_STAT_PME_EN_BF_MSK (0x00000100)
#define PCIE_CTL_PM_CAP_CON_STAT_PME_EN_BF_DEF (0x00000000)

///< Data_Select. This 4-bit field is used to select which data is to be
///< reported through the Power Management Data Register and Data_Scale
///< field. If the Power Management Data field is not implemented, this
///< field must be hardwired to zero. The default of this field is zero.
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SEL_BF_OFF ( 9)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SEL_BF_WID ( 4)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SEL_BF_MSK (0x00001E00)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SEL_BF_DEF (0x00000000)

///< Data_Scale. This field indicates the scaling factor to be used when
///< interpreting the value of the Data field. The value and meaning of
///< this field varies depending on which data value has been selected
///< by the Data_Select field. This field is a required component of the
///< Power Management Data Register (offset 7) and must be implemented
///< if the Power Management Data Register is implemented. If the Power
///< Management Data Registeris not implemented, this field must be hardwired
///< to zero.  For more information, see 7.5.2.3 section of PCI Express
///< Base Specification.
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SCALE_BF_OFF (13)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SCALE_BF_WID ( 2)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SCALE_BF_MSK (0x00006000)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_SCALE_BF_DEF (0x00000000)

///< PME_Status. This bit is set when the function normally generates a
///< PME signal. The value of this bit is not affected by the value of
///< the PME_En bit. If PME_Support bit 31 of the Power Management Capabilities
///< register is clear, this bit is permitted to be hardwired to 0b. Functions
///< that consume Aux power must preserve the value of this sticky register
///< when Aux power is available. In such functions, this register value
///< is not modified by Conventional Reset or FLR.   Note: This register
///< field is sticky.
#define PCIE_CTL_PM_CAP_CON_STAT_PME_STAT_BF_OFF (15)
#define PCIE_CTL_PM_CAP_CON_STAT_PME_STAT_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_CON_STAT_PME_STAT_BF_MSK (0x00008000)
#define PCIE_CTL_PM_CAP_CON_STAT_PME_STAT_BF_DEF (0x00000000)

///< B2B3 Support for D3hot. If this field is set, B2B3 support for D3hot
///< is available.
#define PCIE_CTL_PM_CAP_CON_STAT_B2_B3_SUPPORT_BF_OFF (22)
#define PCIE_CTL_PM_CAP_CON_STAT_B2_B3_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_CON_STAT_B2_B3_SUPPORT_BF_MSK (0x00400000)
#define PCIE_CTL_PM_CAP_CON_STAT_B2_B3_SUPPORT_BF_DEF (0x00000000)

///< Bus Power/Clock Control Enable. If this field is set, Bus Power/Clock
///< Control is Enable.
#define PCIE_CTL_PM_CAP_CON_STAT_BUS_PWR_CLK_CON_EN_BF_OFF (23)
#define PCIE_CTL_PM_CAP_CON_STAT_BUS_PWR_CLK_CON_EN_BF_WID ( 1)
#define PCIE_CTL_PM_CAP_CON_STAT_BUS_PWR_CLK_CON_EN_BF_MSK (0x00800000)
#define PCIE_CTL_PM_CAP_CON_STAT_BUS_PWR_CLK_CON_EN_BF_DEF (0x00000000)

///< Data. This field is used to report the state dependent data requested
///< by the Data_Select field. The value of this field is scaled by the
///< value reported by the Data_Scale field.
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_ADD_INFO_BF_OFF (24)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_ADD_INFO_BF_WID ( 8)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_ADD_INFO_BF_MSK (0xFF000000)
#define PCIE_CTL_PM_CAP_CON_STAT_DATA_ADD_INFO_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_REG register description at address offset 0x50
  *
  * Register default value:        0x01887005
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSI_CAP/PCI_MSI_CAP_ID_NEXT_CTRL_REG
  * MSI Capability Header and Message Control Register.
  */

typedef union {
  struct {
    uint32_t PCI_MSI_CAP_ID : 8;
    ///< Capability ID. Indicates the MSI Capability structure. This field
    ///< returns a Capability ID of 05h indicating that this is an MSI Capability
    ///< structure.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x5"
    uint32_t PCI_MSI_CAP_NEXT_OFFSET : 8;
    ///< Next Capability Pointer. This field contains the offset to the next
    ///< PCI Capability structure or 00h if no other items exist in the linked
    ///< list of Capabilities.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
    ///< then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x70"
    uint32_t PCI_MSI_ENABLE : 1;
    ///< MSI Enable.  - If set and the MSI-X Enable bit in the MSI-X Message
    ///< Control register is clear, the function is permitted to use MSI to
    ///< request service and is prohibited from using INTx interrupts. System
    ///< configuration software sets this bit to enable MSI. A device driver
    ///< is prohibited from writing this bit to mask a function's service request.
    ///< For more information on control of INTx interrupts, see section 7.5.1.1
    ///< of PCI Express Base Specification.  - If clear, the function is prohibited
    ///< from using MSI to request service.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t PCI_MSI_MULTIPLE_MSG_CAP : 3;
    ///< Multiple Message Capable. System software reads this field to determine
    ///< the number of requested vectors. The number of requested vectors must
    ///< be aligned to a power of two (if a function requires three vectors,
    ///< it requests four by initializing this field to 010b). All encodings
    ///< other than the defined encodings are reserved.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="17" ResetValue="0x4"
    uint32_t PCI_MSI_MULTIPLE_MSG_EN : 3;
    ///< Multiple Message Enable. Software writes to this field to indicate
    ///< the number of allocated vectors (equal to or less than the number
    ///< of requested vectors). The number of allocated vectors is aligned
    ///< to a power of two. If a function requests four vectors (indicated
    ///< by a Multiple Message Capable encoding of 010b), system software can
    ///< allocate either four, two, or one vector by writing a 010b, 001b,
    ///< or 000b to this field, respectively. When MSI is enabled, a function
    ///< will be allocated at least 1 vector. All encodings other than the
    ///< defined encodings are reserved.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t PCI_MSI_64_BIT_ADDR_CAP : 1;
    ///< 64-bit Address Capable. This bit must be set if the function is a
    ///< PCI Express Endpoint,as indicated by the value in the Device/Port
    ///< Type field  This bit MUST@FLIT be Set    Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="23" ResetValue="0x1"
    uint32_t PCI_PVM_SUPPORT : 1;
    ///< Per-Vector Masking Capable.  - If set, the function supports MSI Per-Vector
    ///< Masking.  - If clear, the function does not support MSI Per-Vector
    ///< Masking. This bit must be set if the function is a PF or VF within
    ///< an SR-IOV Device.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x1"
    uint32_t PCI_MSI_EXT_DATA_CAP : 1;
    ///< Extended Message Data Capable.  - If set, the function is capable
    ///< of providing Extended Message Data.  - If clear, the function does
    ///< not support providing Extended Message Data.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="25" ResetValue="0x0"
    uint32_t PCI_MSI_EXT_DATA_EN : 1;
    ///< Extended Message Data Enable.  - If set, the function is enabled to
    ///< provide Extended Message Data.  - If clear, the function is not enabled
    ///< to provide Extended Message Data.   Note: The access attributes of
    ///< this field are as follows:  - Wire: PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_MSI_EXT_DATA_CAP
    ///< ? RW : RO   - Dbi: PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_MSI_EXT_DATA_CAP
    ///< ? RW : RO
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_msi_cap_pci_msi_cap_id_next_ctrl_reg_t;

#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_DEFAULT (0x01887005U)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_RD_MASK (0x07ffffffU)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_WR_MASK (0x04710000U)


///< Capability ID. Indicates the MSI Capability structure. This field
///< returns a Capability ID of 05h indicating that this is an MSI Capability
///< structure.
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_ID_BF_WID ( 8)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_ID_BF_MSK (0x000000FF)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_ID_BF_DEF (0x00000005)

///< Next Capability Pointer. This field contains the offset to the next
///< PCI Capability structure or 00h if no other items exist in the linked
///< list of Capabilities.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
///< then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_NEXT_OFFSET_BF_OFF ( 8)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_NEXT_OFFSET_BF_WID ( 8)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_NEXT_OFFSET_BF_MSK (0x0000FF00)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_CAP_NEXT_OFFSET_BF_DEF (0x00007000)

///< MSI Enable.  - If set and the MSI-X Enable bit in the MSI-X Message
///< Control register is clear, the function is permitted to use MSI to
///< request service and is prohibited from using INTx interrupts. System
///< configuration software sets this bit to enable MSI. A device driver
///< is prohibited from writing this bit to mask a function's service request.
///< For more information on control of INTx interrupts, see section 7.5.1.1
///< of PCI Express Base Specification.  - If clear, the function is prohibited
///< from using MSI to request service.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EN_BF_OFF (16)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EN_BF_WID ( 1)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EN_BF_MSK (0x00010000)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EN_BF_DEF (0x00000000)

///< Multiple Message Capable. System software reads this field to determine
///< the number of requested vectors. The number of requested vectors must
///< be aligned to a power of two (if a function requires three vectors,
///< it requests four by initializing this field to 010b). All encodings
///< other than the defined encodings are reserved.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
///< is sticky.
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_CAP_BF_OFF (17)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_CAP_BF_WID ( 3)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_CAP_BF_MSK (0x000E0000)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_CAP_BF_DEF (0x00080000)

///< Multiple Message Enable. Software writes to this field to indicate
///< the number of allocated vectors (equal to or less than the number
///< of requested vectors). The number of allocated vectors is aligned
///< to a power of two. If a function requests four vectors (indicated
///< by a Multiple Message Capable encoding of 010b), system software can
///< allocate either four, two, or one vector by writing a 010b, 001b,
///< or 000b to this field, respectively. When MSI is enabled, a function
///< will be allocated at least 1 vector. All encodings other than the
///< defined encodings are reserved.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_EN_BF_OFF (20)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_EN_BF_WID ( 3)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_EN_BF_MSK (0x00700000)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_MULTIPLE_MSG_EN_BF_DEF (0x00000000)

///< 64-bit Address Capable. This bit must be set if the function is a
///< PCI Express Endpoint,as indicated by the value in the Device/Port
///< Type field  This bit MUST@FLIT be Set    Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_64_BIT_ADDR_CAP_BF_OFF (23)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_64_BIT_ADDR_CAP_BF_WID ( 1)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_64_BIT_ADDR_CAP_BF_MSK (0x00800000)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_64_BIT_ADDR_CAP_BF_DEF (0x00800000)

///< Per-Vector Masking Capable.  - If set, the function supports MSI Per-Vector
///< Masking.  - If clear, the function does not support MSI Per-Vector
///< Masking. This bit must be set if the function is a PF or VF within
///< an SR-IOV Device.
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_PVM_SUPPORT_BF_OFF (24)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_PVM_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_PVM_SUPPORT_BF_MSK (0x01000000)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_PVM_SUPPORT_BF_DEF (0x01000000)

///< Extended Message Data Capable.  - If set, the function is capable
///< of providing Extended Message Data.  - If clear, the function does
///< not support providing Extended Message Data.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_CAP_BF_OFF (25)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_CAP_BF_WID ( 1)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_CAP_BF_MSK (0x02000000)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_CAP_BF_DEF (0x00000000)

///< Extended Message Data Enable.  - If set, the function is enabled to
///< provide Extended Message Data.  - If clear, the function is not enabled
///< to provide Extended Message Data.   Note: The access attributes of
///< this field are as follows:  - Wire: PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_MSI_EXT_DATA_CAP
///< ? RW : RO   - Dbi: PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_MSI_EXT_DATA_CAP
///< ? RW : RO
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_EN_BF_OFF (26)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_EN_BF_WID ( 1)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_EN_BF_MSK (0x04000000)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_PCI_MSI_EXT_DATA_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSI_CAP_MSI_CAP_OFF_04H_REG register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSI_CAP/MSI_CAP_OFF_04H_REG
  * Message Address Register for MSI (Offset 04h).
  */

typedef union {
  struct {
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t PCI_MSI_CAP_OFF_04H : 30;
    ///< Message Address - System-specified message address. If the Message
    ///< Enable bit (bit 16 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG register) is
    ///< set, the contents of this field specify the DWORD-aligned address
    ///< (Address[31:02]) for the MSI transaction. Address[1:0] are set to
    ///< 00b.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_msi_cap_msi_cap_off_04h_reg_t;

#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_DEFAULT (0x00000000U)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_RD_MASK (0xfffffffcU)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_WR_MASK (0xfffffffcU)


///< Message Address - System-specified message address. If the Message
///< Enable bit (bit 16 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG register) is
///< set, the contents of this field specify the DWORD-aligned address
///< (Address[31:02]) for the MSI transaction. Address[1:0] are set to
///< 00b.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_PCI_MSI_CAP_OFF_04H_BF_OFF ( 2)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_PCI_MSI_CAP_OFF_04H_BF_WID (30)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_PCI_MSI_CAP_OFF_04H_BF_MSK (0xFFFFFFFC)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_PCI_MSI_CAP_OFF_04H_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSI_CAP_MSI_CAP_OFF_08H_REG register description at address offset 0x58
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSI_CAP/MSI_CAP_OFF_08H_REG
  * Message Address Register for MSI (Offset 08h).
  */

typedef union {
  struct {
    uint32_t PCI_MSI_CAP_OFF_08H : 16;
    ///< For a function that supports a 32-bit message address, this field
    ///< contains Message Data (System-specified message data). If the Message
    ///< Enable bit (bit 16 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) is set, the
    ///< function sends a DWORD Memory Write transaction using Message Data
    ///< for the lower 16 bits. All 4 Byte Enables are set. The Multiple Message
    ///< Enable field (bits 22:20 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) defines
    ///< the number of low order message data bits the function is permitted
    ///< to modify to generate its system software allocated vectors. For example,
    ///< a Multiple Message Enable encoding of 010b indicates the function
    ///< has been allocated four vectors and is permitted to modify message
    ///< data bits 1 and 0 (a function modifies the lower message data bits
    ///< to generate the allocated number of vectors). If the Multiple Message
    ///< Enable field is 000b, the Function is not permitted to modify the
    ///< message data.  For a function that supports a 64-bit message address,
    ///< it contains lower 16 bits of the Message Upper Address.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PCI_MSI_CAP_OFF_0AH : 16;
    ///< For a function that supports a 32-bit message address, this field
    ///< contains Extended Message Data (System-specified message data). For
    ///< the MSI Capability structures without per-vector masking, it must
    ///< be implemented if the Extended Message Data Capable bit is set; otherwise,
    ///< it is outside the MSI Capability structure and undefined. For the
    ///< MSI Capability structures with Per-vector Masking, it must be implemented
    ///< if the Extended Message Data Capable bit is set; otherwise, it is
    ///< RsvdP. If the Extended Message Data Enable bit (bit 26 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG)
    ///< is set, the DWORD Memory Write transaction uses Extended Message Data
    ///< for the upper 16 bits; otherwise, it uses 0000h for the upper 16 bits.
    ///< For a function that supports a 64-bit message address, it contains
    ///< upper 16 bits of the Message Upper Address.   Note: The access attributes
    ///< of this field are as follows:  - Wire: PCI_MSI_64_BIT_ADDR_CAP ||
    ///< `DEFAULT_EXT_MSI_DATA_CAPABLE ? R/W : R   - Dbi: PCI_MSI_64_BIT_ADDR_CAP
    ///< || `DEFAULT_EXT_MSI_DATA_CAPABLE ? R/W : R
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_msi_cap_msi_cap_off_08h_reg_t;

#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_DEFAULT (0x00000000U)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_RD_MASK (0xffffffffU)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_WR_MASK (0xffffffffU)


///< For a function that supports a 32-bit message address, this field
///< contains Message Data (System-specified message data). If the Message
///< Enable bit (bit 16 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) is set, the
///< function sends a DWORD Memory Write transaction using Message Data
///< for the lower 16 bits. All 4 Byte Enables are set. The Multiple Message
///< Enable field (bits 22:20 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) defines
///< the number of low order message data bits the function is permitted
///< to modify to generate its system software allocated vectors. For example,
///< a Multiple Message Enable encoding of 010b indicates the function
///< has been allocated four vectors and is permitted to modify message
///< data bits 1 and 0 (a function modifies the lower message data bits
///< to generate the allocated number of vectors). If the Multiple Message
///< Enable field is 000b, the Function is not permitted to modify the
///< message data.  For a function that supports a 64-bit message address,
///< it contains lower 16 bits of the Message Upper Address.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_08H_BF_OFF ( 0)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_08H_BF_WID (16)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_08H_BF_MSK (0x0000FFFF)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_08H_BF_DEF (0x00000000)

///< For a function that supports a 32-bit message address, this field
///< contains Extended Message Data (System-specified message data). For
///< the MSI Capability structures without per-vector masking, it must
///< be implemented if the Extended Message Data Capable bit is set; otherwise,
///< it is outside the MSI Capability structure and undefined. For the
///< MSI Capability structures with Per-vector Masking, it must be implemented
///< if the Extended Message Data Capable bit is set; otherwise, it is
///< RsvdP. If the Extended Message Data Enable bit (bit 26 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG)
///< is set, the DWORD Memory Write transaction uses Extended Message Data
///< for the upper 16 bits; otherwise, it uses 0000h for the upper 16 bits.
///< For a function that supports a 64-bit message address, it contains
///< upper 16 bits of the Message Upper Address.   Note: The access attributes
///< of this field are as follows:  - Wire: PCI_MSI_64_BIT_ADDR_CAP ||
///< `DEFAULT_EXT_MSI_DATA_CAPABLE ? R/W : R   - Dbi: PCI_MSI_64_BIT_ADDR_CAP
///< || `DEFAULT_EXT_MSI_DATA_CAPABLE ? R/W : R
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_0AH_BF_OFF (16)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_0AH_BF_WID (16)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_0AH_BF_MSK (0xFFFF0000)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_PCI_MSI_CAP_OFF_0AH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSI_CAP_MSI_CAP_OFF_0CH_REG register description at address offset 0x5c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSI_CAP/MSI_CAP_OFF_0CH_REG
  * Message Address Register for MSI (Offset 0Ch).
  */

typedef union {
  struct {
    uint32_t PCI_MSI_CAP_OFF_0CH : 16;
    ///< For a function that supports a 32-bit message address, this field
    ///< contains the lower Mask Bits when the Per Vector Masking Capable bit
    ///< (PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_PVM_SUPPORT) is set.  For a function
    ///< that supports a 64-bit message address, this field contains Message
    ///< Data (System-specified message data). If the Message Enable bit (bit
    ///< 16 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) is set, the function sends
    ///< a DWORD Memory Write transaction using Message Data for the lower
    ///< 16 bits. All 4 Byte Enables are set. The Multiple Message Enable field
    ///< (bits 22:20 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) defines the number
    ///< of low order message data bits the function is permitted to modify
    ///< to generate its system software allocated vectors. For example, a
    ///< Multiple Message Enable encoding of 010b indicates the function has
    ///< been allocated four vectors and is permitted to modify message data
    ///< bits 1 and 0 (a function modifies the lower message data bits to generate
    ///< the allocated number of vectors). If the Multiple Message Enable field
    ///< is 000b, the Function is not permitted to modify the message data.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< PCI_MSI_64_BIT_ADDR_CAP || MSI_PVM_EN ? R/W : R   - Dbi: PCI_MSI_64_BIT_ADDR_CAP
    ///< || MSI_PVM_EN ? R/W : R
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PCI_MSI_CAP_OFF_0EH : 16;
    ///< For a function that supports a 32-bit message address, this field
    ///< contains the upper Mask Bits when the Per Vector Masking Capable bit
    ///< (PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_PVM_SUPPORT) is set.  For a function
    ///< that supports a 64-bit message address, this field contains Message
    ///< Data (System-specified message data).   Note: The access attributes
    ///< of this field are as follows:  - Wire: (!MSI_64_EN && MSI_PVM_EN_VALUE)
    ///< ? RW: MSI_64_EN && DEFAULT_EXT_MSI_DATA_CAPABLE ? RW : RO   - Dbi:
    ///< (!MSI_64_EN && MSI_PVM_EN_VALUE) ? RW: MSI_64_EN && DEFAULT_EXT_MSI_DATA_CAPABLE
    ///< ? RW : RO
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_msi_cap_msi_cap_off_0ch_reg_t;

#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_DEFAULT (0x00000000U)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_RD_MASK (0xffffffffU)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_WR_MASK (0xffffffffU)


///< For a function that supports a 32-bit message address, this field
///< contains the lower Mask Bits when the Per Vector Masking Capable bit
///< (PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_PVM_SUPPORT) is set.  For a function
///< that supports a 64-bit message address, this field contains Message
///< Data (System-specified message data). If the Message Enable bit (bit
///< 16 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) is set, the function sends
///< a DWORD Memory Write transaction using Message Data for the lower
///< 16 bits. All 4 Byte Enables are set. The Multiple Message Enable field
///< (bits 22:20 of the PCI_MSI_CAP_ID_NEXT_CTRL_REG) defines the number
///< of low order message data bits the function is permitted to modify
///< to generate its system software allocated vectors. For example, a
///< Multiple Message Enable encoding of 010b indicates the function has
///< been allocated four vectors and is permitted to modify message data
///< bits 1 and 0 (a function modifies the lower message data bits to generate
///< the allocated number of vectors). If the Multiple Message Enable field
///< is 000b, the Function is not permitted to modify the message data.
///< Note: The access attributes of this field are as follows:  - Wire:
///< PCI_MSI_64_BIT_ADDR_CAP || MSI_PVM_EN ? R/W : R   - Dbi: PCI_MSI_64_BIT_ADDR_CAP
///< || MSI_PVM_EN ? R/W : R
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0CH_BF_OFF ( 0)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0CH_BF_WID (16)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0CH_BF_MSK (0x0000FFFF)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0CH_BF_DEF (0x00000000)

///< For a function that supports a 32-bit message address, this field
///< contains the upper Mask Bits when the Per Vector Masking Capable bit
///< (PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_PVM_SUPPORT) is set.  For a function
///< that supports a 64-bit message address, this field contains Message
///< Data (System-specified message data).   Note: The access attributes
///< of this field are as follows:  - Wire: (!MSI_64_EN && MSI_PVM_EN_VALUE)
///< ? RW: MSI_64_EN && DEFAULT_EXT_MSI_DATA_CAPABLE ? RW : RO   - Dbi:
///< (!MSI_64_EN && MSI_PVM_EN_VALUE) ? RW: MSI_64_EN && DEFAULT_EXT_MSI_DATA_CAPABLE
///< ? RW : RO
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0EH_BF_OFF (16)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0EH_BF_WID (16)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0EH_BF_MSK (0xFFFF0000)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_PCI_MSI_CAP_OFF_0EH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSI_CAP_MSI_CAP_OFF_10H_REG register description at address offset 0x60
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSI_CAP/MSI_CAP_OFF_10H_REG
  * Message Address Register for MSI (Offset 10h).
  */

typedef union {
  struct {
    uint32_t PCI_MSI_CAP_OFF_10H : 32;
    ///< Used for MSI when the Per Vector Masking Capable bit (PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_PVM_SUPPORT)
    ///< is set. For 32-bit contains Pending Bits. For 64-bit, contains Mask
    ///< Bits.   Note: The access attributes of this field are as follows:
    ///< - Wire: PCI_MSI_64_BIT_ADDR_CAP && MSI_PVM_EN ? R/W : R   - Dbi: PCI_MSI_64_BIT_ADDR_CAP
    ///< && MSI_PVM_EN ? R/W : R
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_msi_cap_msi_cap_off_10h_reg_t;

#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_DEFAULT (0x00000000U)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_RD_MASK (0xffffffffU)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_WR_MASK (0xffffffffU)


///< Used for MSI when the Per Vector Masking Capable bit (PCI_MSI_CAP_ID_NEXT_CTRL_REG.PCI_PVM_SUPPORT)
///< is set. For 32-bit contains Pending Bits. For 64-bit, contains Mask
///< Bits.   Note: The access attributes of this field are as follows:
///< - Wire: PCI_MSI_64_BIT_ADDR_CAP && MSI_PVM_EN ? R/W : R   - Dbi: PCI_MSI_64_BIT_ADDR_CAP
///< && MSI_PVM_EN ? R/W : R
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_PCI_MSI_CAP_OFF_10H_BF_OFF ( 0)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_PCI_MSI_CAP_OFF_10H_BF_WID (32)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_PCI_MSI_CAP_OFF_10H_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_PCI_MSI_CAP_OFF_10H_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSI_CAP_MSI_CAP_OFF_14H_REG register description at address offset 0x64
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSI_CAP/MSI_CAP_OFF_14H_REG
  * Message Address Register for MSI (Offset 14h).
  */

typedef union {
  struct {
    uint32_t PCI_MSI_CAP_OFF_14H : 32;
    ///< Pending Bits. For each pending bit that is set, the function has a
    ///< pending associated message.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_msi_cap_msi_cap_off_14h_reg_t;

#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_DEFAULT (0x00000000U)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_RD_MASK (0xffffffffU)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_WR_MASK (0x00000000U)


///< Pending Bits. For each pending bit that is set, the function has a
///< pending associated message.
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_PCI_MSI_CAP_OFF_14H_BF_OFF ( 0)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_PCI_MSI_CAP_OFF_14H_BF_WID (32)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_PCI_MSI_CAP_OFF_14H_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_PCI_MSI_CAP_OFF_14H_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG register description at address offset 0x70
  *
  * Register default value:        0x0002B010
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG
  * PCI Express Capabilities, ID, Next Pointer Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_ID : 8;
    ///< Capability ID. Indicates the PCI Express Capability structure. This
    ///< field must return a Capability ID of 10h indicating that this is a
    ///< PCI Express Capability structure.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x10"
    uint32_t PCIE_CAP_NEXT_PTR : 8;
    ///< Next Capability Pointer. This field contains the offset to the next
    ///< PCI Capability structure or 00h if no other items exist in the linked
    ///< list of Capabilities.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
    ///< then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0xB0"
    uint32_t PCIE_CAP_REG : 4;
    ///< Capability Version. Indicates PCI-SIG defined PCI Express Capability
    ///< structure version number. A version of the specification that changes
    ///< the PCI Express Capability structure in a way that is not otherwise
    ///< identifiable (for example, through a new Capability field) is permitted
    ///< to increment this field. All such changes to the PCI Express Capability
    ///< structure must be software-compatible. Software must check for Capability
    ///< Version numbers that are greater than or equal to the highest number
    ///< defined when the software is written, as functions reporting any such
    ///< Capability Version numbers will contain a PCI Express Capability structure
    ///< that is compatible with that piece of software. The controller hardwires
    ///< this field to 2h for functions compliant to PCI Express Base Specification,
    ///< Revision 4.0, Version 1.0.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x2"
    uint32_t PCIE_DEV_PORT_TYPE : 4;
    ///< Device/Port Type. Indicates the specific type of this PCI Express
    ///< function.  Note: Different functions in a Multi-Function Device can
    ///< generally be of different types. Defined encodings for functions that
    ///< implement a Type 00h PCI Configuration Space header are: Defined encodings
    ///< for functions that implement a Type 01h PCI Configuration Space header
    ///< are: All other encodings are Reserved.  Note: Different Endpoint types
    ///< have notably different requirements in Section 1.3.2 of PCI Express
    ///< Base Specification regarding I/O resources, Extended Configuration
    ///< Space, and other capabilities.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t PCIE_SLOT_IMP : 1;
    ///< Slot Implemented. When set, this bit indicates that the Link associated
    ///< with this Port is connected to a slot (as compared to being connected
    ///< to a system-integrated device or being disabled). This bit is valid
    ///< for Downstream Ports. This bit is undefined for Upstream Ports.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
    uint32_t PCIE_INT_MSG_NUM : 5;
    ///< PCIE Interrupt Message Number. Interrupt Message Number. This field
    ///< indicates which MSI/MSI-X vector is used for the interrupt message
    ///< generated in association with any of the status bits of this Capability
    ///< structure.  For MSI, the value in this field indicates the offset
    ///< between the base Message Data and the interrupt message that is generated.
    ///< Hardware is required to update this field so that it is correct if
    ///< the number of MSI Messages assigned to the Function changes when software
    ///< writes to the Multiple Message Enable field in the MSI Message Control
    ///< register.  For MSI-X, the value in this field indicates which MSI-X
    ///< Table entry is used to generate the interrupt message. The entry must
    ///< be one of the first 32 entries even if the Function implements more
    ///< than 32 entries. For a given MSI-X implementation, the entry must
    ///< remain constant.  If both MSI and MSI-X are implemented, they are
    ///< permitted to use different vectors, though software is permitted to
    ///< enable only one mechanism at a time. If MSI-X is enabled, the value
    ///< in this field must indicate the vector for MSI-X. If MSI is enabled
    ///< or neither is enabled, the value in this field must indicate the vector
    ///< for MSI. If software enables both MSI and MSI-X at the same time,
    ///< the value in this field is undefined.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="25" ResetValue="0x0"
    uint32_t RSVD : 1;
    ///< Reserved.
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_t;

#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_DEFAULT (0x0002b010U)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_RD_MASK (0x7fffffffU)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_WR_MASK (0x00000000U)


///< Capability ID. Indicates the PCI Express Capability structure. This
///< field must return a Capability ID of 10h indicating that this is a
///< PCI Express Capability structure.
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_ID_BF_WID ( 8)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_ID_BF_MSK (0x000000FF)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_ID_BF_DEF (0x00000010)

///< Next Capability Pointer. This field contains the offset to the next
///< PCI Capability structure or 00h if no other items exist in the linked
///< list of Capabilities.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
///< then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_NEXT_PTR_BF_OFF ( 8)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_NEXT_PTR_BF_WID ( 8)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_NEXT_PTR_BF_MSK (0x0000FF00)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_NEXT_PTR_BF_DEF (0x0000B000)

///< Capability Version. Indicates PCI-SIG defined PCI Express Capability
///< structure version number. A version of the specification that changes
///< the PCI Express Capability structure in a way that is not otherwise
///< identifiable (for example, through a new Capability field) is permitted
///< to increment this field. All such changes to the PCI Express Capability
///< structure must be software-compatible. Software must check for Capability
///< Version numbers that are greater than or equal to the highest number
///< defined when the software is written, as functions reporting any such
///< Capability Version numbers will contain a PCI Express Capability structure
///< that is compatible with that piece of software. The controller hardwires
///< this field to 2h for functions compliant to PCI Express Base Specification,
///< Revision 4.0, Version 1.0.   Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_BF_OFF (16)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_BF_MSK (0x000F0000)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_CAP_BF_DEF (0x00020000)

///< Device/Port Type. Indicates the specific type of this PCI Express
///< function.  Note: Different functions in a Multi-Function Device can
///< generally be of different types. Defined encodings for functions that
///< implement a Type 00h PCI Configuration Space header are: Defined encodings
///< for functions that implement a Type 01h PCI Configuration Space header
///< are: All other encodings are Reserved.  Note: Different Endpoint types
///< have notably different requirements in Section 1.3.2 of PCI Express
///< Base Specification regarding I/O resources, Extended Configuration
///< Space, and other capabilities.
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_DEV_PORT_TYPE_BF_OFF (20)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_DEV_PORT_TYPE_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_DEV_PORT_TYPE_BF_MSK (0x00F00000)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_DEV_PORT_TYPE_BF_DEF (0x00000000)

///< Slot Implemented. When set, this bit indicates that the Link associated
///< with this Port is connected to a slot (as compared to being connected
///< to a system-integrated device or being disabled). This bit is valid
///< for Downstream Ports. This bit is undefined for Upstream Ports.
///< Note: The access attributes of this field are as follows:  - Wire:
///< HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_SLOT_IMP_BF_OFF (24)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_SLOT_IMP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_SLOT_IMP_BF_MSK (0x01000000)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_SLOT_IMP_BF_DEF (0x00000000)

///< PCIE Interrupt Message Number. Interrupt Message Number. This field
///< indicates which MSI/MSI-X vector is used for the interrupt message
///< generated in association with any of the status bits of this Capability
///< structure.  For MSI, the value in this field indicates the offset
///< between the base Message Data and the interrupt message that is generated.
///< Hardware is required to update this field so that it is correct if
///< the number of MSI Messages assigned to the Function changes when software
///< writes to the Multiple Message Enable field in the MSI Message Control
///< register.  For MSI-X, the value in this field indicates which MSI-X
///< Table entry is used to generate the interrupt message. The entry must
///< be one of the first 32 entries even if the Function implements more
///< than 32 entries. For a given MSI-X implementation, the entry must
///< remain constant.  If both MSI and MSI-X are implemented, they are
///< permitted to use different vectors, though software is permitted to
///< enable only one mechanism at a time. If MSI-X is enabled, the value
///< in this field must indicate the vector for MSI-X. If MSI is enabled
///< or neither is enabled, the value in this field must indicate the vector
///< for MSI. If software enables both MSI and MSI-X at the same time,
///< the value in this field is undefined.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_INT_MSG_NUM_BF_OFF (25)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_INT_MSG_NUM_BF_WID ( 5)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_INT_MSG_NUM_BF_MSK (0x3E000000)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_PCIE_INT_MSG_NUM_BF_DEF (0x00000000)

///< Reserved.
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_RSVD_BF_OFF (30)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_RSVD_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_RSVD_BF_MSK (0x40000000)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_RSVD_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_DEVICE_CAPABILITIES_REG register description at address offset 0x74
  *
  * Register default value:        0x00008FE1
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/DEVICE_CAPABILITIES_REG
  * Device Capabilities Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_MAX_PAYLOAD_SIZE : 3;
    ///< Max_Payload_Size Supported. This field indicates the maximum payload
    ///< size that the function can support for TLPs. This field MUST @FLIT
    ///< indicate a minimum of 512 bytes.   If the Rx_MPS_Fixed bit is Set,
    ///< the Function's Rx_MPS_Limit is fixed with the value indicated by this
    ///< (Max_Payload_Size Supported) field. Otherwise, the Rx_MPS_Limit is
    ///< determined by the Max_Payload_Size field (the  MPS setting ) in one
    ///< or more Functions. See section 2.2.2 for important details regarding
    ///< Multi-Function Devices Defined encodings are: The functions of a Multi-Function
    ///< Device are permitted to report different values for this field.  Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x1"
    uint32_t PCIE_CAP_PHANTOM_FUNC_SUPPORT : 2;
    ///< Phantom Functions Supported  This field indicates the support for
    ///< use of unclaimed Function numbers to extend the number of outstanding
    ///< transactions allowed by logically combining unclaimed Function numbers
    ///< (called Phantom Functions) with the Tag identifier.  For a PF with
    ///< its VF Enable bit Set, the use of Phantom Function numbers is not
    ///< permitted and this field must return 0b when read.  For VFs, this
    ///< field is not supported and must be hardwired to 0b.  For every Function
    ///< in an ARI Device, this field must be hardwired to 0b.  The remainder
    ///< of this field description applies only to non-ARI Multi-Function Devices.
    ///< This field indicates the number of most significant bits of the Function
    ///< Number portion of Requester ID that are logically combined with the
    ///< Tag identifier.  Note: Phantom Function support for the Function must
    ///< be enabled by the PCIE_CAP_PHANTOM_FUNC_EN field in the DEVICE_CONTROL_DEVICE_STATUS
    ///< register before the Function is permitted to use the Function Number
    ///< field in the Requester ID for Phantom Functions.  For more information
    ///< on Tag Extension descriptions, see Section 2.2.6.2 of the PCI Express
    ///< Base Specification.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t PCIE_CAP_EXT_TAG_SUPP : 1;
    ///< Extended Tag Field Supported  This field, in combination with the
    ///< PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT field of the DEVICE_CAPABILITIES2_REG
    ///< register and DEV3_CAP_14B_TAG_REQUEST_SUPP field of the DEVICE_CAPABILITIES3_REG
    ///< register indicates the maximum supported size of the Tag field as
    ///< a Requester. This field must be set if the PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT
    ///< field or the DEV3_CAP_14B_TAG_REQUEST_SUPP is set.  Note: 8-bit Tag
    ///< field generation must be enabled by the PCIE_CAP_EXT_TAG_EN field
    ///< in the DEVICE_CONTROL_DEVICE_STATUS register of the Requester Function
    ///< before 8-bit Tags can be generated by the Requester.  For more information
    ///< on interactions with enabling the use of 10-Bit or 14-Bit Tags, see
    ///< section 2.2.6.2 of the PCI Express Base Specification.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x1"
    uint32_t PCIE_CAP_EP_L0S_ACCPT_LATENCY : 3;
    ///< Endpoint L0s Acceptable Latency. This field indicates the acceptable
    ///< total latency that an Endpoint can withstand due to the transition
    ///< from L0s state to the L0 state. It is essentially an indirect measure
    ///< of the Endpoint's internal buffering.  Power management software uses
    ///< the reported L0s Acceptable Latency number to compare against the
    ///< L0s exit latencies reported by all components comprising the data
    ///< path from this Endpoint to the Root Complex Root Port to determine
    ///< whether ASPM L0s entry can be used with no loss of performance. For
    ///< functions other than Endpoints, this field is Reserved and the controller
    ///< hardwires it to 000b.  Note: The access attributes of this field are
    ///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x7"
    uint32_t PCIE_CAP_EP_L1_ACCPT_LATENCY : 3;
    ///< Endpoint L1 Acceptable Latency. This field indicates the acceptable
    ///< latency that an Endpoint can withstand due to the transition from
    ///< L1 state to the L0 state. It is essentially an indirect measure of
    ///< the Endpoint's internal buffering. Power management software uses
    ///< the reported L1 Acceptable Latency number to compare against the L1
    ///< Exit Latencies reported (see below) by all components comprising the
    ///< data path from this Endpoint to the Root Complex Root Port to determine
    ///< whether ASPM L1 entry can be used with no loss of performance. For
    ///< functions other than Endpoints, this field is Reserved and the controller
    ///< hardwires it to 000b.  Note: The access attributes of this field are
    ///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W (Sticky) else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="9" ResetValue="0x7"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t PCIE_CAP_ROLE_BASED_ERR_REPORT : 1;
    ///< Role-Based Error Reporting. When set, this bit indicates that the
    ///< function implements the functionality originally defined in the Error
    ///< Reporting ECN for PCI Express Base Specification, Revision 1.0a, and
    ///< later incorporated into PCI Express Base Specification, Revision 1.1.
    ///< This bit must be set by all functions conforming to the ECN, PCI Express
    ///< Base Specification, Revision 1.1., or subsequent PCI Express Base
    ///< Specification revisions.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
    ///< then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="15" ResetValue="0x1"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
    uint32_t PCIE_CAP_CAP_SLOT_PWR_LMT_VALUE : 8;
    ///< Captured Slot Power Limit Value Applicable for Upstream Ports only.
    ///< In combination with the PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE value, specifies
    ///< the upper limit on power available to the adapter. Power limit (in
    ///< Watts) is calculated by multiplying the value in this field by the
    ///< value in the PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE field except when the
    ///< PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE field equals 00b (1.0x) and the Captured
    ///< Slot Power Limit Value exceeds 0xEF, then alternative encodings are
    ///< used. This value is set by the Set_Slot_Power_Limit Message or hardwired
    ///< to 00h. For VFs, the field value when read is undefined. For more
    ///< information, see section 6.9 and 7.5.3.9 of the PCI Express Base Specification.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE : 2;
    ///< Captured Slot Power Limit Scale Applicable to Upstream Ports only.
    ///< Specifies the scale used for the SET_SLOT_PWR_LIMIT_VAL parameter.
    ///< This value is set by the Set_Slot_Power_Limit Message or hardwired
    ///< to 00b. For VFs, the field value when read is undefined. For more
    ///< information, see section 6.9 of the PCI Express Base Specification.
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint32_t PCIE_CAP_FLR_CAP : 1;
    ///< Function Level Reset Capability This field applies to Endpoints only.
    ///< For all other Function types the controller hardwires this field to
    ///< 0b. For PFs and VFs, the feature is mandatory and this field must
    ///< be set. For more information on Function Level Reset mechanism, see
    ///< section 6.6.2 of the PCI Express Base Specification.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="28" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
    uint32_t PCIE_CAP_TEE_IO_SUPPORTED : 1;
    ///< Indicates that the Function implements the TEE-IO functionality as
    ///< described by the TEE Device Interface Security Protocol (TDISP). Function0
    ///< represents the whole port capabilitiy and all other Functions should
    ///< be set to the same value as Function0.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_device_capabilities_reg_t;

#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_DEFAULT (0x00008fe1U)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_RD_MASK (0x5ffc8fffU)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_WR_MASK (0x00000000U)


///< Max_Payload_Size Supported. This field indicates the maximum payload
///< size that the function can support for TLPs. This field MUST @FLIT
///< indicate a minimum of 512 bytes.   If the Rx_MPS_Fixed bit is Set,
///< the Function's Rx_MPS_Limit is fixed with the value indicated by this
///< (Max_Payload_Size Supported) field. Otherwise, the Rx_MPS_Limit is
///< determined by the Max_Payload_Size field (the  MPS setting ) in one
///< or more Functions. See section 2.2.2 for important details regarding
///< Multi-Function Devices Defined encodings are: The functions of a Multi-Function
///< Device are permitted to report different values for this field.  Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
///< field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_MAX_PAYLOAD_SIZE_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_MAX_PAYLOAD_SIZE_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_MAX_PAYLOAD_SIZE_BF_MSK (0x00000007)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_MAX_PAYLOAD_SIZE_BF_DEF (0x00000001)

///< Phantom Functions Supported  This field indicates the support for
///< use of unclaimed Function numbers to extend the number of outstanding
///< transactions allowed by logically combining unclaimed Function numbers
///< (called Phantom Functions) with the Tag identifier.  For a PF with
///< its VF Enable bit Set, the use of Phantom Function numbers is not
///< permitted and this field must return 0b when read.  For VFs, this
///< field is not supported and must be hardwired to 0b.  For every Function
///< in an ARI Device, this field must be hardwired to 0b.  The remainder
///< of this field description applies only to non-ARI Multi-Function Devices.
///< This field indicates the number of most significant bits of the Function
///< Number portion of Requester ID that are logically combined with the
///< Tag identifier.  Note: Phantom Function support for the Function must
///< be enabled by the PCIE_CAP_PHANTOM_FUNC_EN field in the DEVICE_CONTROL_DEVICE_STATUS
///< register before the Function is permitted to use the Function Number
///< field in the Requester ID for Phantom Functions.  For more information
///< on Tag Extension descriptions, see Section 2.2.6.2 of the PCI Express
///< Base Specification.   Note: The access attributes of this field are
///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_PHANTOM_FUNC_SUPPORT_BF_OFF ( 3)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_PHANTOM_FUNC_SUPPORT_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_PHANTOM_FUNC_SUPPORT_BF_MSK (0x00000018)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_PHANTOM_FUNC_SUPPORT_BF_DEF (0x00000000)

///< Extended Tag Field Supported  This field, in combination with the
///< PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT field of the DEVICE_CAPABILITIES2_REG
///< register and DEV3_CAP_14B_TAG_REQUEST_SUPP field of the DEVICE_CAPABILITIES3_REG
///< register indicates the maximum supported size of the Tag field as
///< a Requester. This field must be set if the PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT
///< field or the DEV3_CAP_14B_TAG_REQUEST_SUPP is set.  Note: 8-bit Tag
///< field generation must be enabled by the PCIE_CAP_EXT_TAG_EN field
///< in the DEVICE_CONTROL_DEVICE_STATUS register of the Requester Function
///< before 8-bit Tags can be generated by the Requester.  For more information
///< on interactions with enabling the use of 10-Bit or 14-Bit Tags, see
///< section 2.2.6.2 of the PCI Express Base Specification.   Note: The
///< access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
///< field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EXT_TAG_SUPP_BF_OFF ( 5)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EXT_TAG_SUPP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EXT_TAG_SUPP_BF_MSK (0x00000020)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EXT_TAG_SUPP_BF_DEF (0x00000020)

///< Endpoint L0s Acceptable Latency. This field indicates the acceptable
///< total latency that an Endpoint can withstand due to the transition
///< from L0s state to the L0 state. It is essentially an indirect measure
///< of the Endpoint's internal buffering.  Power management software uses
///< the reported L0s Acceptable Latency number to compare against the
///< L0s exit latencies reported by all components comprising the data
///< path from this Endpoint to the Root Complex Root Port to determine
///< whether ASPM L0s entry can be used with no loss of performance. For
///< functions other than Endpoints, this field is Reserved and the controller
///< hardwires it to 000b.  Note: The access attributes of this field are
///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L0S_ACCPT_LATENCY_BF_OFF ( 6)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L0S_ACCPT_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L0S_ACCPT_LATENCY_BF_MSK (0x000001C0)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L0S_ACCPT_LATENCY_BF_DEF (0x000001C0)

///< Endpoint L1 Acceptable Latency. This field indicates the acceptable
///< latency that an Endpoint can withstand due to the transition from
///< L1 state to the L0 state. It is essentially an indirect measure of
///< the Endpoint's internal buffering. Power management software uses
///< the reported L1 Acceptable Latency number to compare against the L1
///< Exit Latencies reported (see below) by all components comprising the
///< data path from this Endpoint to the Root Complex Root Port to determine
///< whether ASPM L1 entry can be used with no loss of performance. For
///< functions other than Endpoints, this field is Reserved and the controller
///< hardwires it to 000b.  Note: The access attributes of this field are
///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W (Sticky) else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L1_ACCPT_LATENCY_BF_OFF ( 9)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L1_ACCPT_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L1_ACCPT_LATENCY_BF_MSK (0x00000E00)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_EP_L1_ACCPT_LATENCY_BF_DEF (0x00000E00)

///< Role-Based Error Reporting. When set, this bit indicates that the
///< function implements the functionality originally defined in the Error
///< Reporting ECN for PCI Express Base Specification, Revision 1.0a, and
///< later incorporated into PCI Express Base Specification, Revision 1.1.
///< This bit must be set by all functions conforming to the ECN, PCI Express
///< Base Specification, Revision 1.1., or subsequent PCI Express Base
///< Specification revisions.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
///< then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_ROLE_BASED_ERR_RPT_BF_OFF (15)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_ROLE_BASED_ERR_RPT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_ROLE_BASED_ERR_RPT_BF_MSK (0x00008000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_ROLE_BASED_ERR_RPT_BF_DEF (0x00008000)

///< Captured Slot Power Limit Value Applicable for Upstream Ports only.
///< In combination with the PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE value, specifies
///< the upper limit on power available to the adapter. Power limit (in
///< Watts) is calculated by multiplying the value in this field by the
///< value in the PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE field except when the
///< PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE field equals 00b (1.0x) and the Captured
///< Slot Power Limit Value exceeds 0xEF, then alternative encodings are
///< used. This value is set by the Set_Slot_Power_Limit Message or hardwired
///< to 00h. For VFs, the field value when read is undefined. For more
///< information, see section 6.9 and 7.5.3.9 of the PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_VAL_BF_OFF (18)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_VAL_BF_WID ( 8)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_VAL_BF_MSK (0x03FC0000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_VAL_BF_DEF (0x00000000)

///< Captured Slot Power Limit Scale Applicable to Upstream Ports only.
///< Specifies the scale used for the SET_SLOT_PWR_LIMIT_VAL parameter.
///< This value is set by the Set_Slot_Power_Limit Message or hardwired
///< to 00b. For VFs, the field value when read is undefined. For more
///< information, see section 6.9 of the PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_SCALE_BF_OFF (26)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_SCALE_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_SCALE_BF_MSK (0x0C000000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_SLOT_PWR_LMT_SCALE_BF_DEF (0x00000000)

///< Function Level Reset Capability This field applies to Endpoints only.
///< For all other Function types the controller hardwires this field to
///< 0b. For PFs and VFs, the feature is mandatory and this field must
///< be set. For more information on Function Level Reset mechanism, see
///< section 6.6.2 of the PCI Express Base Specification.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_FLR_CAP_BF_OFF (28)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_FLR_CAP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_FLR_CAP_BF_MSK (0x10000000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_FLR_CAP_BF_DEF (0x00000000)

///< Indicates that the Function implements the TEE-IO functionality as
///< described by the TEE Device Interface Security Protocol (TDISP). Function0
///< represents the whole port capabilitiy and all other Functions should
///< be set to the same value as Function0.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_TEE_IO_SUPPORTED_BF_OFF (30)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_TEE_IO_SUPPORTED_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_TEE_IO_SUPPORTED_BF_MSK (0x40000000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_PCIE_CAP_TEE_IO_SUPPORTED_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_DEVICE_CONTROL_DEVICE_STATUS register description at address offset 0x78
  *
  * Register default value:        0x00102110
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/DEVICE_CONTROL_DEVICE_STATUS
  * Device Control and Device Status Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_CORR_ERR_REPORT_EN : 1;
    ///< Correctable Error Reporting Enable  This field, in conjunction with
    ///< other field, controls sending ERR_COR Messages.  For a Multi-Function
    ///< device, this field controls error reporting for each function from
    ///< point-of-view of the respective Function.  For a Root Port, the reporting
    ///< of correctable errors is internal to the root. No external ERR_COR
    ///< Message is generated.  An RCiEP that is not associated with a Root
    ///< Complex Event Collector is permitted to hardwire this field to 0b.
    ///< For PFs and VFs, see #sect-sr-iov-error-handling for details on error
    ///< handling.  For more information, see section 6.2.5, 6.2.6, and 6.2.10.2
    ///< of the PCI Express Base Specification.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PCIE_CAP_NON_FATAL_ERR_REPORT_EN : 1;
    ///< Non-Fatal Error Reporting Enable  This field, in conjunction with
    ///< other field, controls sending ERR_NONFATAL Messages. For a Multi-Function
    ///< Device, this field controls error reporting for each function from
    ///< point-of-view of the respective Function.  For a Root Port, the reporting
    ///< of Non-fatal errors is internal to the root. No external ERR_NONFATAL
    ///< Message is generated.  An RCiEP that is not associated with a Root
    ///< Complex Event Collector is permitted to hardwire this field to 0b.
    ///< For PFs and VFs, see #sect-sr-iov-error-handling for details on error
    ///< handling.  For more information, see section 6.2.5 and 6.2.6 of the
    ///< PCI Express Base Specification.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t PCIE_CAP_FATAL_ERR_REPORT_EN : 1;
    ///< Fatal Error Reporting Enable  This field, in conjunction with other
    ///< field, controls sending ERR_FATAL Messages. For a Multi-Function device,
    ///< this field controls error reporting for each function from point-of-view
    ///< of the respective Function.  For a Root Port, the reporting of Fatal
    ///< errors is internal to the root. No external ERR_FATAL Message is generated.
    ///< An RCiEP that is not associated with a Root Complex Event Collector
    ///< is permitted to hardwire this field to 0b.  For PFs and VFs, see #sect-sr-iov-error-handling
    ///< for details on error handling.  For more information, see section
    ///< 6.2.5 and 6.2.6 of the PCI Express Base Specification.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t PCIE_CAP_UNSUPPORT_REQ_REP_EN : 1;
    ///< Unsupported Request Reporting Enable. This bit, in conjunction with
    ///< other bits, controls the signaling of Unsupported Request Errors by
    ///< sending error Messages (for more details, see section 6.2.5 and section
    ///< 6.2.6 of PCI Express Base Specification). For a Multi-Function Device,
    ///< this bit controls error reporting for each Function from point-of-view
    ///< of the respective Function.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t PCIE_CAP_EN_REL_ORDER : 1;
    ///< Enable Relaxed Ordering. If this bit is set, the function is permitted
    ///< to set the Relaxed Ordering bit in the Attributes field of transactions
    ///< it initiates that do not require strong write ordering (for more details,
    ///< see section 2.2.6.4 and section 2.4 of PCI Express Base Specification).
    ///< For a function that never sets the Relaxed Ordering attribute in transactions
    ///< it initiates as a Requester, the controller hardwires this bit to
    ///< 0b.   Note: The access attributes of this field are as follows:  -
    ///< Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t PCIE_CAP_MAX_PAYLOAD_SIZE_CS : 3;
    ///< Max_Payload_Size. For specified cases, this field determines the maximum
    ///< TLP payload size (the MPS setting) for the Function. Values permitted
    ///< to be programmed are indicated by the Max_Payload_Size Supported field.
    ///< As a Receiver, if the Rx_MPS_Fixed bit is Set, the Rx_MPS_Limit is
    ///< fixed with the value indicated by the Max_Payload_Size Supported field.
    ///< Otherwise, the Rx_MPS_Limit is determined by the MPS setting in one
    ///< or more Functions. See Section 2.2.2 for important details regarding
    ///< Multi Function Devices.  As a Transmitter, the Function must not generate
    ///< TLPs with payloads exceeding the MPS setting, with the exception of
    ///< Functions in a Multi-Function Device , or Functions with implemention-specific
    ///< mechanisms capable of supporting different MPS settings for different
    ///< targets. See Section 2.2.2 for important details. Defined encodings
    ///< for this field are: For Functions that support only the 128-byte max
    ///< payload size, the controller hardwires this field to 000b.  System
    ///< software is not required to program the same value for this field
    ///< for all the Functions of a Multi-Function device (for more details,
    ///< see section 2.2.2 of PCI Express Base Specification).  For ARI Devices,
    ///< Max_Payload_Size is determined solely by the setting in Function0.
    ///< The settings in the other Functions always return whatever value software
    ///< programmed for each, but otherwise are ignored by the component.
    ///< On an update to the Max Payload Size field, system software must ensure
    ///< that no traffic which could be impacted by the change to Max Payload
    ///< Size is active. Traffic that is impacted by the change to Max Payload
    ///< Size can only happen after the register update is completed.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t PCIE_CAP_EXT_TAG_EN : 1;
    ///< Extended Tag Field Enable  This field, in combination with the PCIE_CAP_10BITS_TAG_REQ_EN
    ///< field of DEVICE_CONTROL2_DEVICE_STATUS2_REG register and the DEV3_CAP_14B_TAG_REQUEST_EN
    ///< field of DEVICE_CONTROL3_REG register, determines how many Tag field
    ///< bits a Requester is permitted to use. When the PCIE_CAP_10BITS_TAG_REQ_EN
    ///< field and the DEV3_CAP_14B_TAG_REQUEST_EN field are both clear, the
    ///< Values apply.  If software changes the value of the this field while
    ///< the Function has outstanding Non-Posted Requests, the result is undefined.
    ///< For Functions that do not implement this capability, the controller
    ///< hardwires this field to 0b.  For more information, see section 2.2.6.2
    ///< of the PCI Express Base Specification for required behavior when one
    ///< or both of these larger-Tag Requester Enable fields are set.   Note:
    ///< The access attributes of this field are as follows:  - Wire: DEVICE_CAPABILITIES_REG.PCIE_CAP_EXT_TAG_SUPP
    ///< ? RW : RO    - Dbi: DEVICE_CAPABILITIES_REG.PCIE_CAP_EXT_TAG_SUPP
    ///< ? RW : RO
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x1"
    uint32_t PCIE_CAP_PHANTOM_FUNC_EN : 1;
    ///< Phantom Functions Enable  This field, in combination with the PCIE_CAP_10BITS_TAG_REQ_EN
    ///< field of the DEVICE_CONTROL2_DEVICE_STATUS2_REG register and the DEV3_CAP_14B_TAG_REQUEST_EN
    ///< field of the DEVICE_CONTROL3_REG register, determines how many Tag
    ///< field bits a Requester is permitted to use. When the PCIE_CAP_10BITS_TAG_REQ_EN
    ///< field is clear the Values apply.  Behavior is undefined when this
    ///< bit is Set in Functions with enabled Shadow Functions.  Software should
    ///< not change the value of this field while the Function has outstanding
    ///< Non-Posted Requests; otherwise, the result is undefined.  For functions
    ///< that do not implement this capability, the controller hardwires this
    ///< field to 0b.  For more information, see section 2.2.6.2 of the PCI
    ///< Express Base Specification.   Note: The access attributes of this
    ///< field are as follows:  - Wire: DEVICE_CAPABILITIES_REG.PCIE_CAP_PHANTOM_FUNC_SUPPORT
    ///< ? RW : RO    - Dbi: DEVICE_CAPABILITIES_REG.PCIE_CAP_PHANTOM_FUNC_SUPPORT
    ///< ? RW : RO
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t PCIE_CAP_AUX_POWER_PM_EN : 1;
    ///< Aux Power PM Enable. This bit is derived by sampling the sys_aux_pwr_det
    ///< input. When set this bit, enables a function to draw Aux power independent
    ///< of PME Aux power. Functions that require Aux power on legacy operating
    ///< systems should continue to indicate PME Aux power requirements. Aux
    ///< power is allocated as requested in the Aux_Current field of the Power
    ///< Management Capabilities register (PMC), independent of the PME_En
    ///< bit in the Power Management Control/Status register (PMCSR). For Multi-Function
    ///< devices, a component is allowed to draw Aux power if at least one
    ///< of the functions has this bit set. Note: Functions that consume Aux
    ///< power must preserve the value of this sticky register when Aux power
    ///< is available. In such functions, this bit is not modified by Conventional
    ///< Reset.  For functions that do not implement this capability, the controller
    ///< hardwires this bit to 0b.  Additional Aux power is permitted to be
    ///< allocated using the firmware based mechanism (see the Request D3cold
    ///< Aux Power Limit _DSM call as defined in [Firmware])  Additional Aux
    ///< power is also permitted to be allocated by selecting a PM Sub State
    ///< in the Power Limit mechanism.   Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="10" ResetValue="0x0"
    uint32_t PCIE_CAP_EN_NO_SNOOP : 1;
    ///< Enable No Snoop. If this bit is set, the function is permitted to
    ///< Set the No Snoop bit in the Requester Attributes of transactions it
    ///< initiates that do not require hardware enforced cache coherency (see
    ///< section 2.2.6.5 in PCI Express Base Specification). Note: Setting
    ///< this bit to 1b should not cause a function to set the No Snoop attribute
    ///< on all transactions that it initiates. Even when this bit is set,
    ///< a function is only permitted to set the No Snoop attribute on a transaction
    ///< when it can guarantee that the address of the transaction is not stored
    ///< in any cache in the system.  The controller hardwires this bit 0b
    ///< if a function would never set the No Snoop attribute in transactions
    ///< it initiates.   Note: The access attributes of this field are as follows:
    ///< - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="11" ResetValue="0x0"
    uint32_t PCIE_CAP_MAX_READ_REQ_SIZE : 3;
    ///< Max_Read_Request_Size. This field sets the maximum Read Request size
    ///< for the function as a Requester. The function must not generate Read
    ///< Requests with a size exceeding the set value. For functions that do
    ///< not generate Read Requests larger than 128 bytes and functions that
    ///< do not generate Read Requests on their own behalf, the controller
    ///< implements this field as Read Only (RO) with a value of 000b.  Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="12" ResetValue="0x2"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
    uint32_t PCIE_CAP_CORR_ERR_DETECTED : 1;
    ///< Correctable Error Detected. This bit indicates status of correctable
    ///< errors detected. Errors are logged in this register regardless of
    ///< whether error reporting is enabled or not in the Device Control register.
    ///< For a Multi-Function device, each function indicates status of errors
    ///< as perceived by the respective function.  For functions supporting
    ///< Advanced Error Handling, errors are logged in this register regardless
    ///< of the settings of the Correctable Error Mask register.
    ///< AccessType="RW/1C/V" BitOffset="16" ResetValue="0x0"
    uint32_t PCIE_CAP_NON_FATAL_ERR_DETECTED : 1;
    ///< Non-Fatal Error Detected. This bit indicates status of Non-fatal errors
    ///< detected. Errors are logged in this register regardless of whether
    ///< error reporting is enabled or not in the Device Control register.
    ///< For a Multi-Function device, each function indicates status of errors
    ///< as perceived by the respective Function.  For functions supporting
    ///< Advanced Error Handling, errors are logged in this register regardless
    ///< of the settings of the Uncorrectable Error Mask register.
    ///< AccessType="RW/1C/V" BitOffset="17" ResetValue="0x0"
    uint32_t PCIE_CAP_FATAL_ERR_DETECTED : 1;
    ///< Fatal Error Detected. This bit indicates status of Fatal errors detected.
    ///< Errors are logged in this register regardless of whether error reporting
    ///< is enabled or not in the Device Control register. For a Multi-Function
    ///< device, each function indicates status of errors as perceived by the
    ///< respective Function.  For Functions supporting Advanced Error Handling,
    ///< errors are logged in this register regardless of the settings of the
    ///< Uncorrectable Error Mask register.
    ///< AccessType="RW/1C/V" BitOffset="18" ResetValue="0x0"
    uint32_t PCIE_CAP_UNSUPPORTED_REQ_DETECTED : 1;
    ///< Unsupported Request Detected. This bit indicates that the function
    ///< received an Unsupported Request. Errors are logged in this register
    ///< regardless of whether error reporting is enabled or not in the Device
    ///< Control register. For a Multi-Function Device, each function indicates
    ///< status of errors as perceived by the respective function.
    ///< AccessType="RW/1C/V" BitOffset="19" ResetValue="0x0"
    uint32_t PCIE_CAP_AUX_POWER_DETECTED : 1;
    ///< AUX Power Detected Functions that require Aux power report this field
    ///< as set if Aux power is detected by the Function.  This field is derived
    ///< by sampling the sys_aux_pwr_det input.  For VFs, this field is not
    ///< supported and must be hardwired to 0b.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x1"
    uint32_t PCIE_CAP_TRANS_PENDING : 1;
    ///< Transactions Pending.  Endpoints:  When set, this bit indicates that
    ///< the function has issued Non-Posted Requests that have not been completed.
    ///< A Function reports this bit cleared only when all outstanding Non-Posted
    ///< Requests have completed or have been terminated by the Completion
    ///< Timeout mechanism. This bit must also be cleared upon the completion
    ///< of an FLR.  Root and Switch Ports: The controller hardwires this bit
    ///< to 0b.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_device_ctrl_device_stat_reg_t;

#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_DEFAULT (0x00102110U)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_RD_MASK (0x003f7fffU)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_WR_MASK (0x000f75ffU)


///< Correctable Error Reporting Enable  This field, in conjunction with
///< other field, controls sending ERR_COR Messages.  For a Multi-Function
///< device, this field controls error reporting for each function from
///< point-of-view of the respective Function.  For a Root Port, the reporting
///< of correctable errors is internal to the root. No external ERR_COR
///< Message is generated.  An RCiEP that is not associated with a Root
///< Complex Event Collector is permitted to hardwire this field to 0b.
///< For PFs and VFs, see #sect-sr-iov-error-handling for details on error
///< handling.  For more information, see section 6.2.5, 6.2.6, and 6.2.10.2
///< of the PCI Express Base Specification.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_RPT_EN_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_RPT_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_RPT_EN_BF_MSK (0x00000001)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_RPT_EN_BF_DEF (0x00000000)

///< Non-Fatal Error Reporting Enable  This field, in conjunction with
///< other field, controls sending ERR_NONFATAL Messages. For a Multi-Function
///< Device, this field controls error reporting for each function from
///< point-of-view of the respective Function.  For a Root Port, the reporting
///< of Non-fatal errors is internal to the root. No external ERR_NONFATAL
///< Message is generated.  An RCiEP that is not associated with a Root
///< Complex Event Collector is permitted to hardwire this field to 0b.
///< For PFs and VFs, see #sect-sr-iov-error-handling for details on error
///< handling.  For more information, see section 6.2.5 and 6.2.6 of the
///< PCI Express Base Specification.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_RPT_EN_BF_OFF ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_RPT_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_RPT_EN_BF_MSK (0x00000002)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_RPT_EN_BF_DEF (0x00000000)

///< Fatal Error Reporting Enable  This field, in conjunction with other
///< field, controls sending ERR_FATAL Messages. For a Multi-Function device,
///< this field controls error reporting for each function from point-of-view
///< of the respective Function.  For a Root Port, the reporting of Fatal
///< errors is internal to the root. No external ERR_FATAL Message is generated.
///< An RCiEP that is not associated with a Root Complex Event Collector
///< is permitted to hardwire this field to 0b.  For PFs and VFs, see #sect-sr-iov-error-handling
///< for details on error handling.  For more information, see section
///< 6.2.5 and 6.2.6 of the PCI Express Base Specification.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_RPT_EN_BF_OFF ( 2)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_RPT_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_RPT_EN_BF_MSK (0x00000004)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_RPT_EN_BF_DEF (0x00000000)

///< Unsupported Request Reporting Enable. This bit, in conjunction with
///< other bits, controls the signaling of Unsupported Request Errors by
///< sending error Messages (for more details, see section 6.2.5 and section
///< 6.2.6 of PCI Express Base Specification). For a Multi-Function Device,
///< this bit controls error reporting for each Function from point-of-view
///< of the respective Function.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORT_REQ_REP_EN_BF_OFF ( 3)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORT_REQ_REP_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORT_REQ_REP_EN_BF_MSK (0x00000008)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORT_REQ_REP_EN_BF_DEF (0x00000000)

///< Enable Relaxed Ordering. If this bit is set, the function is permitted
///< to set the Relaxed Ordering bit in the Attributes field of transactions
///< it initiates that do not require strong write ordering (for more details,
///< see section 2.2.6.4 and section 2.4 of PCI Express Base Specification).
///< For a function that never sets the Relaxed Ordering attribute in transactions
///< it initiates as a Requester, the controller hardwires this bit to
///< 0b.   Note: The access attributes of this field are as follows:  -
///< Wire: R/W   - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_REL_ORDER_BF_OFF ( 4)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_REL_ORDER_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_REL_ORDER_BF_MSK (0x00000010)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_REL_ORDER_BF_DEF (0x00000010)

///< Max_Payload_Size. For specified cases, this field determines the maximum
///< TLP payload size (the MPS setting) for the Function. Values permitted
///< to be programmed are indicated by the Max_Payload_Size Supported field.
///< As a Receiver, if the Rx_MPS_Fixed bit is Set, the Rx_MPS_Limit is
///< fixed with the value indicated by the Max_Payload_Size Supported field.
///< Otherwise, the Rx_MPS_Limit is determined by the MPS setting in one
///< or more Functions. See Section 2.2.2 for important details regarding
///< Multi Function Devices.  As a Transmitter, the Function must not generate
///< TLPs with payloads exceeding the MPS setting, with the exception of
///< Functions in a Multi-Function Device , or Functions with implemention-specific
///< mechanisms capable of supporting different MPS settings for different
///< targets. See Section 2.2.2 for important details. Defined encodings
///< for this field are: For Functions that support only the 128-byte max
///< payload size, the controller hardwires this field to 000b.  System
///< software is not required to program the same value for this field
///< for all the Functions of a Multi-Function device (for more details,
///< see section 2.2.2 of PCI Express Base Specification).  For ARI Devices,
///< Max_Payload_Size is determined solely by the setting in Function0.
///< The settings in the other Functions always return whatever value software
///< programmed for each, but otherwise are ignored by the component.
///< On an update to the Max Payload Size field, system software must ensure
///< that no traffic which could be impacted by the change to Max Payload
///< Size is active. Traffic that is impacted by the change to Max Payload
///< Size can only happen after the register update is completed.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_BF_OFF ( 5)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_BF_MSK (0x000000E0)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_BF_DEF (0x00000000)

///< Extended Tag Field Enable  This field, in combination with the PCIE_CAP_10BITS_TAG_REQ_EN
///< field of DEVICE_CONTROL2_DEVICE_STATUS2_REG register and the DEV3_CAP_14B_TAG_REQUEST_EN
///< field of DEVICE_CONTROL3_REG register, determines how many Tag field
///< bits a Requester is permitted to use. When the PCIE_CAP_10BITS_TAG_REQ_EN
///< field and the DEV3_CAP_14B_TAG_REQUEST_EN field are both clear, the
///< Values apply.  If software changes the value of the this field while
///< the Function has outstanding Non-Posted Requests, the result is undefined.
///< For Functions that do not implement this capability, the controller
///< hardwires this field to 0b.  For more information, see section 2.2.6.2
///< of the PCI Express Base Specification for required behavior when one
///< or both of these larger-Tag Requester Enable fields are set.   Note:
///< The access attributes of this field are as follows:  - Wire: DEVICE_CAPABILITIES_REG.PCIE_CAP_EXT_TAG_SUPP
///< ? RW : RO    - Dbi: DEVICE_CAPABILITIES_REG.PCIE_CAP_EXT_TAG_SUPP
///< ? RW : RO
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EXT_TAG_EN_BF_OFF ( 8)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EXT_TAG_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EXT_TAG_EN_BF_MSK (0x00000100)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EXT_TAG_EN_BF_DEF (0x00000100)

///< Phantom Functions Enable  This field, in combination with the PCIE_CAP_10BITS_TAG_REQ_EN
///< field of the DEVICE_CONTROL2_DEVICE_STATUS2_REG register and the DEV3_CAP_14B_TAG_REQUEST_EN
///< field of the DEVICE_CONTROL3_REG register, determines how many Tag
///< field bits a Requester is permitted to use. When the PCIE_CAP_10BITS_TAG_REQ_EN
///< field is clear the Values apply.  Behavior is undefined when this
///< bit is Set in Functions with enabled Shadow Functions.  Software should
///< not change the value of this field while the Function has outstanding
///< Non-Posted Requests; otherwise, the result is undefined.  For functions
///< that do not implement this capability, the controller hardwires this
///< field to 0b.  For more information, see section 2.2.6.2 of the PCI
///< Express Base Specification.   Note: The access attributes of this
///< field are as follows:  - Wire: DEVICE_CAPABILITIES_REG.PCIE_CAP_PHANTOM_FUNC_SUPPORT
///< ? RW : RO    - Dbi: DEVICE_CAPABILITIES_REG.PCIE_CAP_PHANTOM_FUNC_SUPPORT
///< ? RW : RO
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_PHANTOM_FUNC_EN_BF_OFF ( 9)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_PHANTOM_FUNC_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_PHANTOM_FUNC_EN_BF_MSK (0x00000200)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_PHANTOM_FUNC_EN_BF_DEF (0x00000000)

///< Aux Power PM Enable. This bit is derived by sampling the sys_aux_pwr_det
///< input. When set this bit, enables a function to draw Aux power independent
///< of PME Aux power. Functions that require Aux power on legacy operating
///< systems should continue to indicate PME Aux power requirements. Aux
///< power is allocated as requested in the Aux_Current field of the Power
///< Management Capabilities register (PMC), independent of the PME_En
///< bit in the Power Management Control/Status register (PMCSR). For Multi-Function
///< devices, a component is allowed to draw Aux power if at least one
///< of the functions has this bit set. Note: Functions that consume Aux
///< power must preserve the value of this sticky register when Aux power
///< is available. In such functions, this bit is not modified by Conventional
///< Reset.  For functions that do not implement this capability, the controller
///< hardwires this bit to 0b.  Additional Aux power is permitted to be
///< allocated using the firmware based mechanism (see the Request D3cold
///< Aux Power Limit _DSM call as defined in [Firmware])  Additional Aux
///< power is also permitted to be allocated by selecting a PM Sub State
///< in the Power Limit mechanism.   Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_PM_EN_BF_OFF (10)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_PM_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_PM_EN_BF_MSK (0x00000400)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_PM_EN_BF_DEF (0x00000000)

///< Enable No Snoop. If this bit is set, the function is permitted to
///< Set the No Snoop bit in the Requester Attributes of transactions it
///< initiates that do not require hardware enforced cache coherency (see
///< section 2.2.6.5 in PCI Express Base Specification). Note: Setting
///< this bit to 1b should not cause a function to set the No Snoop attribute
///< on all transactions that it initiates. Even when this bit is set,
///< a function is only permitted to set the No Snoop attribute on a transaction
///< when it can guarantee that the address of the transaction is not stored
///< in any cache in the system.  The controller hardwires this bit 0b
///< if a function would never set the No Snoop attribute in transactions
///< it initiates.   Note: The access attributes of this field are as follows:
///< - Wire: R   - Dbi: R
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_NO_SNOOP_BF_OFF (11)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_NO_SNOOP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_NO_SNOOP_BF_MSK (0x00000800)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_EN_NO_SNOOP_BF_DEF (0x00000000)

///< Max_Read_Request_Size. This field sets the maximum Read Request size
///< for the function as a Requester. The function must not generate Read
///< Requests with a size exceeding the set value. For functions that do
///< not generate Read Requests larger than 128 bytes and functions that
///< do not generate Read Requests on their own behalf, the controller
///< implements this field as Read Only (RO) with a value of 000b.  Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_READ_REQ_SIZE_BF_OFF (12)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_READ_REQ_SIZE_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_READ_REQ_SIZE_BF_MSK (0x00007000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_MAX_READ_REQ_SIZE_BF_DEF (0x00002000)

///< Correctable Error Detected. This bit indicates status of correctable
///< errors detected. Errors are logged in this register regardless of
///< whether error reporting is enabled or not in the Device Control register.
///< For a Multi-Function device, each function indicates status of errors
///< as perceived by the respective function.  For functions supporting
///< Advanced Error Handling, errors are logged in this register regardless
///< of the settings of the Correctable Error Mask register.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_DETECTED_BF_OFF (16)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_DETECTED_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_DETECTED_BF_MSK (0x00010000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_CORR_ERR_DETECTED_BF_DEF (0x00000000)

///< Non-Fatal Error Detected. This bit indicates status of Non-fatal errors
///< detected. Errors are logged in this register regardless of whether
///< error reporting is enabled or not in the Device Control register.
///< For a Multi-Function device, each function indicates status of errors
///< as perceived by the respective Function.  For functions supporting
///< Advanced Error Handling, errors are logged in this register regardless
///< of the settings of the Uncorrectable Error Mask register.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_DETECTED_BF_OFF (17)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_DETECTED_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_DETECTED_BF_MSK (0x00020000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_NON_FATAL_ERR_DETECTED_BF_DEF (0x00000000)

///< Fatal Error Detected. This bit indicates status of Fatal errors detected.
///< Errors are logged in this register regardless of whether error reporting
///< is enabled or not in the Device Control register. For a Multi-Function
///< device, each function indicates status of errors as perceived by the
///< respective Function.  For Functions supporting Advanced Error Handling,
///< errors are logged in this register regardless of the settings of the
///< Uncorrectable Error Mask register.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_DETECTED_BF_OFF (18)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_DETECTED_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_DETECTED_BF_MSK (0x00040000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_FATAL_ERR_DETECTED_BF_DEF (0x00000000)

///< Unsupported Request Detected. This bit indicates that the function
///< received an Unsupported Request. Errors are logged in this register
///< regardless of whether error reporting is enabled or not in the Device
///< Control register. For a Multi-Function Device, each function indicates
///< status of errors as perceived by the respective function.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORTED_REQ_DETECTED_BF_OFF (19)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORTED_REQ_DETECTED_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORTED_REQ_DETECTED_BF_MSK (0x00080000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_UNSUPPORTED_REQ_DETECTED_BF_DEF (0x00000000)

///< AUX Power Detected Functions that require Aux power report this field
///< as set if Aux power is detected by the Function.  This field is derived
///< by sampling the sys_aux_pwr_det input.  For VFs, this field is not
///< supported and must be hardwired to 0b.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_DETECTED_BF_OFF (20)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_DETECTED_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_DETECTED_BF_MSK (0x00100000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_AUX_PWR_DETECTED_BF_DEF (0x00100000)

///< Transactions Pending.  Endpoints:  When set, this bit indicates that
///< the function has issued Non-Posted Requests that have not been completed.
///< A Function reports this bit cleared only when all outstanding Non-Posted
///< Requests have completed or have been terminated by the Completion
///< Timeout mechanism. This bit must also be cleared upon the completion
///< of an FLR.  Root and Switch Ports: The controller hardwires this bit
///< to 0b.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_TRANS_PENDING_BF_OFF (21)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_TRANS_PENDING_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_TRANS_PENDING_BF_MSK (0x00200000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_PCIE_CAP_TRANS_PENDING_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_LINK_CAPABILITIES_REG register description at address offset 0x7c
  *
  * Register default value:        0x00437C25
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/LINK_CAPABILITIES_REG
  * Link Capabilities Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_MAX_LINK_SPEED : 4;
    ///< Max Link Speed. This field indicates the maximum Link speed of the
    ///< associated Port. The encoded value specifies a bit location in the
    ///< Supported Link Speeds Vector (in the Link Capabilities 2 register)
    ///< that corresponds to the maximum Link speed. All encodings other than
    ///< the defined encodings are reserved.  Multi-Function Devices associated
    ///< with an Upstream Port must report the same value in this field for
    ///< all functions.   Note: The access attributes of this field are as
    ///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x5"
    uint32_t PCIE_CAP_MAX_LINK_WIDTH : 6;
    ///< Maximum Link Width. This field indicates the maximum Link width (xN
    ///< - corresponding to N Lanes) implemented by the component. This value
    ///< is permitted to exceed the number of Lanes routed to the slot (Downstream
    ///< Port), adapter connector (Upstream Port), or in the case of component-to-component
    ///< connections, the actual wired connection width. All encodings other
    ///< than the defined encodings are reserved. Multi-Function devices associated
    ///< with an Upstream Port must report the same value in this field for
    ///< all functions.   Note: The access attributes of this field are as
    ///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x2"
    uint32_t PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT : 2;
    ///< Active State Power Management (ASPM) Support. This field indicates
    ///< the level of ASPM supported on the given PCI Express Link. For more
    ///< information on ASPM support requirements, see section 5.4.1 of PCI
    ///< Express Base Specification. Multi-Function devices associated with
    ///< an Upstream Port must report the same value in this field for all
    ///< functions.  Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="10" ResetValue="0x3"
    uint32_t PCIE_CAP_L0S_EXIT_LATENCY : 3;
    ///< L0s Exit Latency. This field indicates the L0s exit latency for the
    ///< given PCI Express Link. The value reported indicates the length of
    ///< time this Port requires to complete transition from L0s to L0. If
    ///< L0s is not supported, the value is undefined; however, see the Implementation
    ///< Note  Potential Issues With Legacy Software When L0s is Not Supported
    ///< in section 5.4.1.1 of PCI Express Base Specification for the recommended
    ///< value.  Note: Exit latencies may be influenced by PCI Express reference
    ///< clock configuration depending upon whether a component uses a common
    ///< or separate reference clock.  Multi-Function Devices associated with
    ///< an Upstream Port must report the same value in this field for all
    ///< functions.  There are two each of these register fields, this one
    ///< and a shadow one at the same address. The Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG)
    ///< of the Link Control Register (LINK_CONTROL_LINK_STATUS_REG) determines
    ///< which one is used by the controller and which one is accessed by a
    ///< read request. Common Clock operation is enabled in the controller
    ///< when you set the Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of
    ///< the Link Control Register (LINK_CONTROL_LINK_STATUS_REG). The assertion
    ///< of CS2 (that is, assert the dbi_cs2 input, or the CS2 address bit
    ///< for the AXI bridge) is required to write to the shadow field at this
    ///< location.  Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x7"
    uint32_t PCIE_CAP_L1_EXIT_LATENCY : 3;
    ///< L1 Exit Latency. This field indicates the L1 exit latency for the
    ///< given PCI Express Link. The value reported indicates the length of
    ///< time this Port requires to complete transition from ASPM L1 to L0.
    ///< If ASPM L1 is not supported, the value is undefined.  Note: Exit latencies
    ///< may be influenced by PCI Express reference clock configuration depending
    ///< upon whether a component uses a common or separate reference clock.
    ///< Multi-Function Devices associated with an Upstream Port must report
    ///< the same value in this field for all functions.  There are two each
    ///< of these register fields, this one and a shadow one at the same address.
    ///< The Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control
    ///< Register (LINK_CONTROL_LINK_STATUS_REG) determines which one is used
    ///< by the controller and which one is accessed by a read request. Common
    ///< Clock operation is enabled in the controller when you set the Common
    ///< Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control Register
    ///< (LINK_CONTROL_LINK_STATUS_REG). The assertion of CS2 (that is, assert
    ///< the dbi_cs2 input, or the CS2 address bit for the AXI bridge) is required
    ///< to write to the shadow field at this location.  Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x6"
    uint32_t PCIE_CAP_CLOCK_POWER_MAN : 1;
    ///< Clock Power Management. For Upstream Ports, a value of 1b in this
    ///< bit indicates that the component tolerates the removal of any reference
    ///< clock(s) through the  clock request  (CLKREQ#) mechanism when the
    ///< Link is in the L1 and L2/L3 Ready Link states. A value of 0b indicates
    ///< the component does not have this capability and that reference clock(s)
    ///< must not be removed in these Link states.  L1 PM Substates defines
    ///< other semantics for the CLKREQ# signal, which are managed independently
    ///< of Clock Power Management.  This Capability is applicable only in
    ///< form factors that support  clock request  (CLKREQ#) capability.  For
    ///< a Multi-Function device associated with an Upstream Port, each Function
    ///< indicates its capability independently. Power Management configuration
    ///< software must only permit reference clock removal if all functions
    ///< of the Multi-Function device indicate a 1b in this bit. For ARI Devices,
    ///< all Functions must indicate the same value in this bit.  Note:  The
    ///< controller does not support this feature with PIPE 4.2 configuration
    ///< if L1 Substate is not enabled.  For Downstream Ports, the controller
    ///< hardwires this bit to 0b.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
    ///< then R/W(sticky) else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
    uint32_t PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP : 1;
    ///< Surprise Down Error Reporting Capable. For a Downstream Port, this
    ///< bit must be set if the component supports the optional capability
    ///< of detecting and reporting a Surprise Down error condition.  For Upstream
    ///< Ports and components that do not support this optional capability,
    ///< the controller hardwires this bit to 0b.   Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="19" ResetValue="0x0"
    uint32_t PCIE_CAP_DLL_ACTIVE_REP_CAP : 1;
    ///< Data Link Layer Link Active Reporting Capable. For a Downstream Port,
    ///< the controller hardwires this bit to 1b if the component supports
    ///< the optional capability of reporting the DL_Active state of the Data
    ///< Link Control and Management State Machine. For a hot-plug capable
    ///< Downstream Port (as indicated by the Hot-Plug Capable bit of the Slot
    ///< Capabilities register) or a Downstream Port that supports Link speeds
    ///< greater than 5.0 GT/s, the controller hardwires this bit to 1b.  For
    ///< Upstream Ports and components that do not support this optional capability,
    ///< the controller hardwires this bit to 0b.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_BW_NOT_CAP : 1;
    ///< Link Bandwidth Notification Capability. A value of 1b indicates support
    ///< for the Link Bandwidth Notification status and interrupt mechanisms.
    ///< This capability is required for all Root Ports and Switch Downstream
    ///< Ports supporting Links wider than x1 and/or multiple Link speeds.
    ///< This field is not applicable and is Reserved for Endpoints, PCI Express
    ///< to PCI/PCI-X bridges, and Upstream Ports of Switches.  For functions
    ///< that do not implement the Link Bandwidth Notification Capability the
    ///< controller hardwires this bit to 0b.   Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="21" ResetValue="0x0"
    uint32_t PCIE_CAP_ASPM_OPT_COMPLIANCE : 1;
    ///< ASPM Optionality Compliance. This field must be set to 1b in all functions.
    ///< Components implemented against certain earlier versions of this specification
    ///< will have this bit set to 0b.  Software is permitted to use the value
    ///< of this bit to help determine whether to enable ASPM or whether to
    ///< run ASPM compliance tests.   Note: The access attributes of this field
    ///< are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R
    ///< AccessType="RO" BitOffset="22" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t PCIE_CAP_PORT_NUM : 8;
    ///< Port Number. This field indicates the PCI Express Port number for
    ///< the given PCI Express Link. Multi-Function Devices associated with
    ///< an Upstream Port must report the same value in this field for all
    ///< functions.   Note: The access attributes of this field are as follows:
    ///< - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_link_capabilities_reg_t;

#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_DEFAULT (0x00437c25U)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_RD_MASK (0xff7fffffU)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_WR_MASK (0x00000000U)


///< Max Link Speed. This field indicates the maximum Link speed of the
///< associated Port. The encoded value specifies a bit location in the
///< Supported Link Speeds Vector (in the Link Capabilities 2 register)
///< that corresponds to the maximum Link speed. All encodings other than
///< the defined encodings are reserved.  Multi-Function Devices associated
///< with an Upstream Port must report the same value in this field for
///< all functions.   Note: The access attributes of this field are as
///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_MSK (0x0000000F)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_DEF (0x00000005)

///< Maximum Link Width. This field indicates the maximum Link width (xN
///< - corresponding to N Lanes) implemented by the component. This value
///< is permitted to exceed the number of Lanes routed to the slot (Downstream
///< Port), adapter connector (Upstream Port), or in the case of component-to-component
///< connections, the actual wired connection width. All encodings other
///< than the defined encodings are reserved. Multi-Function devices associated
///< with an Upstream Port must report the same value in this field for
///< all functions.   Note: The access attributes of this field are as
///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_OFF ( 4)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_WID ( 6)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_MSK (0x000003F0)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_DEF (0x00000020)

///< Active State Power Management (ASPM) Support. This field indicates
///< the level of ASPM supported on the given PCI Express Link. For more
///< information on ASPM support requirements, see section 5.4.1 of PCI
///< Express Base Specification. Multi-Function devices associated with
///< an Upstream Port must report the same value in this field for all
///< functions.  Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_OFF (10)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_MSK (0x00000C00)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_DEF (0x00000C00)

///< L0s Exit Latency. This field indicates the L0s exit latency for the
///< given PCI Express Link. The value reported indicates the length of
///< time this Port requires to complete transition from L0s to L0. If
///< L0s is not supported, the value is undefined; however, see the Implementation
///< Note  Potential Issues With Legacy Software When L0s is Not Supported
///< in section 5.4.1.1 of PCI Express Base Specification for the recommended
///< value.  Note: Exit latencies may be influenced by PCI Express reference
///< clock configuration depending upon whether a component uses a common
///< or separate reference clock.  Multi-Function Devices associated with
///< an Upstream Port must report the same value in this field for all
///< functions.  There are two each of these register fields, this one
///< and a shadow one at the same address. The Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG)
///< of the Link Control Register (LINK_CONTROL_LINK_STATUS_REG) determines
///< which one is used by the controller and which one is accessed by a
///< read request. Common Clock operation is enabled in the controller
///< when you set the Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of
///< the Link Control Register (LINK_CONTROL_LINK_STATUS_REG). The assertion
///< of CS2 (that is, assert the dbi_cs2 input, or the CS2 address bit
///< for the AXI bridge) is required to write to the shadow field at this
///< location.  Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L0S_EXIT_LATENCY_BF_OFF (12)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L0S_EXIT_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L0S_EXIT_LATENCY_BF_MSK (0x00007000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L0S_EXIT_LATENCY_BF_DEF (0x00007000)

///< L1 Exit Latency. This field indicates the L1 exit latency for the
///< given PCI Express Link. The value reported indicates the length of
///< time this Port requires to complete transition from ASPM L1 to L0.
///< If ASPM L1 is not supported, the value is undefined.  Note: Exit latencies
///< may be influenced by PCI Express reference clock configuration depending
///< upon whether a component uses a common or separate reference clock.
///< Multi-Function Devices associated with an Upstream Port must report
///< the same value in this field for all functions.  There are two each
///< of these register fields, this one and a shadow one at the same address.
///< The Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control
///< Register (LINK_CONTROL_LINK_STATUS_REG) determines which one is used
///< by the controller and which one is accessed by a read request. Common
///< Clock operation is enabled in the controller when you set the Common
///< Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control Register
///< (LINK_CONTROL_LINK_STATUS_REG). The assertion of CS2 (that is, assert
///< the dbi_cs2 input, or the CS2 address bit for the AXI bridge) is required
///< to write to the shadow field at this location.  Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L1_EXIT_LATENCY_BF_OFF (15)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L1_EXIT_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L1_EXIT_LATENCY_BF_MSK (0x00038000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_L1_EXIT_LATENCY_BF_DEF (0x00030000)

///< Clock Power Management. For Upstream Ports, a value of 1b in this
///< bit indicates that the component tolerates the removal of any reference
///< clock(s) through the  clock request  (CLKREQ#) mechanism when the
///< Link is in the L1 and L2/L3 Ready Link states. A value of 0b indicates
///< the component does not have this capability and that reference clock(s)
///< must not be removed in these Link states.  L1 PM Substates defines
///< other semantics for the CLKREQ# signal, which are managed independently
///< of Clock Power Management.  This Capability is applicable only in
///< form factors that support  clock request  (CLKREQ#) capability.  For
///< a Multi-Function device associated with an Upstream Port, each Function
///< indicates its capability independently. Power Management configuration
///< software must only permit reference clock removal if all functions
///< of the Multi-Function device indicate a 1b in this bit. For ARI Devices,
///< all Functions must indicate the same value in this bit.  Note:  The
///< controller does not support this feature with PIPE 4.2 configuration
///< if L1 Substate is not enabled.  For Downstream Ports, the controller
///< hardwires this bit to 0b.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
///< then R/W(sticky) else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_OFF (18)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_MSK (0x00040000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_DEF (0x00000000)

///< Surprise Down Error Reporting Capable. For a Downstream Port, this
///< bit must be set if the component supports the optional capability
///< of detecting and reporting a Surprise Down error condition.  For Upstream
///< Ports and components that do not support this optional capability,
///< the controller hardwires this bit to 0b.   Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_OFF (19)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_MSK (0x00080000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_DEF (0x00000000)

///< Data Link Layer Link Active Reporting Capable. For a Downstream Port,
///< the controller hardwires this bit to 1b if the component supports
///< the optional capability of reporting the DL_Active state of the Data
///< Link Control and Management State Machine. For a hot-plug capable
///< Downstream Port (as indicated by the Hot-Plug Capable bit of the Slot
///< Capabilities register) or a Downstream Port that supports Link speeds
///< greater than 5.0 GT/s, the controller hardwires this bit to 1b.  For
///< Upstream Ports and components that do not support this optional capability,
///< the controller hardwires this bit to 0b.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_OFF (20)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_MSK (0x00100000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_DEF (0x00000000)

///< Link Bandwidth Notification Capability. A value of 1b indicates support
///< for the Link Bandwidth Notification status and interrupt mechanisms.
///< This capability is required for all Root Ports and Switch Downstream
///< Ports supporting Links wider than x1 and/or multiple Link speeds.
///< This field is not applicable and is Reserved for Endpoints, PCI Express
///< to PCI/PCI-X bridges, and Upstream Ports of Switches.  For functions
///< that do not implement the Link Bandwidth Notification Capability the
///< controller hardwires this bit to 0b.   Note: This register field is
///< sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_OFF (21)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_MSK (0x00200000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_DEF (0x00000000)

///< ASPM Optionality Compliance. This field must be set to 1b in all functions.
///< Components implemented against certain earlier versions of this specification
///< will have this bit set to 0b.  Software is permitted to use the value
///< of this bit to help determine whether to enable ASPM or whether to
///< run ASPM compliance tests.   Note: The access attributes of this field
///< are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_OFF (22)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_MSK (0x00400000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_DEF (0x00400000)

///< Port Number. This field indicates the PCI Express Port number for
///< the given PCI Express Link. Multi-Function Devices associated with
///< an Upstream Port must report the same value in this field for all
///< functions.   Note: The access attributes of this field are as follows:
///< - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_OFF (24)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_WID ( 8)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_MSK (0xFF000000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_LINK_CONTROL_LINK_STATUS_REG register description at address offset 0x80
  *
  * Register default value:        0x10110000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/LINK_CONTROL_LINK_STATUS_REG
  * Link Control and Link Status Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_ACTIVE_STATE_LINK_PM_CONTROL : 2;
    ///< ASPM Control/Active State Power Management Control  This field controls
    ///< the level of ASPM enabled on the given PCI Express Link.  For requirements
    ///< on when and how to enable ASPM, see section 5.4.1.3 of the PCI Express
    ///< Base Specification.  Note:  L0s Entry Enabled  enables the Transmitter
    ///< to enter L0s. If L0s is supported, the Receiver must be capable of
    ///< entering L0s even when the Transmitter is disabled from entering L0s
    ///< (00b or 10b).  In Flit Mode, L0s is not supported, bit 0 of this field
    ///< is ignored and has no effect (that is, encodings 0x1 and 0x0 are equivalent
    ///< as are encodings 0x3 and 0x2).  ASPM L1 must be enabled by software
    ///< in the Upstream component on a Link prior to enabling ASPM L1 in the
    ///< Downstream component on that Link. When disabling ASPM L1, software
    ///< must disable ASPM L1 in the Downstream component on a Link prior to
    ///< disabling ASPM L1 in the Upstream component on that Link. ASPM L1
    ///< must only be enabled on the Downstream component if both components
    ///< on a Link support ASPM L1.  For Multi-Function Devices (including
    ///< ARI Devices), it is recommended that software program the same value
    ///< for this field in all Functions. For non-ARI Multi-Function Devices,
    ///< only capabilities enabled in all Functions are enabled for the component
    ///< as a whole.  For ARI Devices, ASPM Control is determined solely by
    ///< the setting in Function0, regardless of Function 0's D-state. The
    ///< settings in the other Functions always return whatever value software
    ///< programmed for each, but otherwise are ignored by the component. Software
    ///< must not enable L0s in either direction on a given Link unless components
    ///< on both sides of the Link each support L0s; otherwise, the result
    ///< is undefined.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t PCIE_CAP_RCB : 1;
    ///< Read Completion Boundary (RCB).   Root Ports: Indicates the RCB value
    ///< for the Root Port. Refer to section 2.3.1.1 of PCI Express Base Specification
    ///< for the definition of the parameter RCB. The controller hardwires
    ///< this bit for a Root Port and returns its RCB support capabilities.
    ///< Endpoints and Bridges: Optionally set by configuration software to
    ///< indicate the RCB value of the Root Port Upstream from the Endpoint
    ///< or Bridge. Refer to Section 2.3.1.1 of PCI Express Base Specification
    ///< for the definition of the parameter RCB is same as Root Port. Configuration
    ///< software must only set this bit if the Root Port Upstream from the
    ///< Endpoint or Bridge reports an RCB value of 128 bytes (a value of 1b
    ///< in the Read Completion Boundary bit). For functions that do not implement
    ///< this feature, the controller hardwires this bit to 0b.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_DISABLE : 1;
    ///< Link Disable. This bit disables the Link by directing the LTSSM to
    ///< the Disabled state when set; this bit is Reserved on Endpoints, PCI
    ///< Express to PCI/PCI-X bridges, and Upstream Ports of Switches.  Writes
    ///< to this bit are immediately reflected in the value read from the bit,
    ///< regardless of actual Link state.  After clearing this bit, software
    ///< must honor timing requirements defined in Section 6.6.1 with respect
    ///< to the first Configuration Read following a Conventional Reset.  In
    ///< a DSP that supports crosslink, the controller gates the write value
    ///< with the CROSS_LINK_EN field in PORT_LINK_CTRL_OFF.   Note: The access
    ///< attributes of this field are as follows:  - Wire: CX_CROSSLINK_ENABLE=1
    ///< && PORT_LINK_CTRL_OFF.CROSS_LINK_EN=1||CX_CROSSLINK_ENABLE=0 && dsp=1
    ///< ? RW : RO   - Dbi: CX_CROSSLINK_ENABLE=1 && PORT_LINK_CTRL_OFF.CROSS_LINK_EN=1||CX_CROSSLINK_ENABLE=0
    ///< && dsp=1? RW : RO
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint32_t PCIE_CAP_RETRAIN_LINK : 1;
    ///< Retrain Link. A write of 1b to this bit initiates Link retraining
    ///< by directing the Physical Layer LTSSM to the Recovery state. If the
    ///< LTSSM is already in Recovery or Configuration, re-entering Recovery
    ///< is permitted but not required. If the Port is in DPC when a write
    ///< of 1b to this bit occurs, the result is undefined. Reads of this bit
    ///< always return 0b.  It is permitted to write 1b to this bit while simultaneously
    ///< writing modified values to other fields in this register. If the LTSSM
    ///< is not already in Recovery or Configuration, the resulting Link training
    ///< must use the modified values. If the LTSSM is already in Recovery
    ///< or Configuration, the modified values are not required to affect the
    ///< Link training that's already in progress.  This bit is not applicable
    ///< and is Reserved for Endpoints, PCI Express to PCI/PCI-X bridges, and
    ///< Upstream Ports of Switches.  This bit always returns 0b when read.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< see description   - Dbi: see description
    ///< AccessType="RW/V" BitOffset="5" ResetValue="0x0"
    uint32_t PCIE_CAP_COMMON_CLK_CONFIG : 1;
    ///< Common Clock Configuration. When set, this bit indicates that this
    ///< component and the component at the opposite end of this Link are operating
    ///< with a distributed common reference clock.  A value of 0b indicates
    ///< that this component and the component at the opposite end of this
    ///< Link are operating with asynchronous reference clock.  For non-ARI
    ///< Multi-Function Devices, software must program the same value for this
    ///< bit in all Functions. If not all Functions are Set, then the component
    ///< must as a whole assume that its reference clock is not common with
    ///< the Upstream component.  For ARI Devices, Common Clock Configuration
    ///< is determined solely by the setting in Function 0. The settings in
    ///< the other Functions always return whatever value software programmed
    ///< for each, but otherwise are ignored by the component.  Components
    ///< utilize this common clock configuration information to report the
    ///< correct L0s and L1 Exit Latencies.  After changing the value in this
    ///< bit in both components on a Link, software must trigger the Link to
    ///< retrain by writing a 1b to the Retrain Link bit of the Downstream
    ///< Port.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t PCIE_CAP_EXTENDED_SYNCH : 1;
    ///< Extended Synch  This mode provides external devices (for example,
    ///< logic analyzers) monitoring the Link time to achieve bit and Symbol
    ///< lock before the Link enters the L0 state and resumes communication.
    ///< For Multi-Function devices if any function has this field set, then
    ///< the component must transmit the additional Ordered Sets when exiting
    ///< L0s or when in Recovery.  In Flit Mode, this field is ignored and
    ///< has no effect since L0s is not supported.  For more information, see
    ///< section 4.2.4.5 and 4.2.6.4.1 of the PCI Express Base Specification.
    ///< AccessType="RW/V" BitOffset="7" ResetValue="0x0"
    uint32_t PCIE_CAP_EN_CLK_POWER_MAN : 1;
    ///< Enable Clock Power Management. Applicable only for Upstream Ports
    ///< and with form factors that support a  Clock Request  (CLKREQ#) mechanism,
    ///< this bit operates as follows: For a non-ARI Multi-Function Device,
    ///< power-management-configuration software must only Set this bit if
    ///< all Functions of the Multi-Function Device indicate a 1b in the Clock
    ///< Power Management bit of the Link Capabilities register. The component
    ///< is permitted to use the CLKREQ# signal to power manage Link clock
    ///< only if this bit is Set for all Functions.  For ARI Devices, Clock
    ///< Power Management is enabled solely by the setting in Function 0. The
    ///< settings in the other Functions always return whatever value software
    ///< programmed for each, but otherwise are ignored by the component. The
    ///< CLKREQ# signal may also be controlled through the L1 PM Substates
    ///< mechanism. Such control is not affected by the setting of this bit.
    ///< For Downstream Ports and components that do not support Clock Power
    ///< Management (as indicated by a 0b value in the Clock Power Management
    ///< bit of the Link Capabilities register), the controller hardwires this
    ///< bit to 0b.  The write value is gated with the PCIE_CAP_CLOCK_POWER_MAN
    ///< field in LINK_CAPABILITIES_REG.  Note: The access attributes of this
    ///< field are as follows:  - Wire: LINK_CAPABILITIES_REG.PCIE_CAP_CLOCK_POWER_MAN
    ///< ? RWS : ROS   - Dbi: LINK_CAPABILITIES_REG.PCIE_CAP_CLOCK_POWER_MAN
    ///< ? RWS : ROS  Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x0"
    uint32_t PCIE_CAP_HW_AUTO_WIDTH_DISABLE : 1;
    ///< Hardware Autonomous Width Disable. When set, this bit disables hardware
    ///< from changing the Link width for reasons other than attempting to
    ///< correct unreliable Link operation by reducing Link width.  For a Multi-Function
    ///< Device associated with an Upstream Port, the bit in Function 0 is
    ///< of type RW, and only Function 0 controls the component's Link behavior.
    ///< In all other Functions of that device, this bit is of type RsvdP.
    ///< For components that do not implement the ability autonomously to change
    ///< Link width, the ciontroller hardwires this bit to 0b.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_BW_MAN_INT_EN : 1;
    ///< Link Bandwidth Management Interrupt Enable. When set, this bit enables
    ///< the generation of an interrupt to indicate that the Link Bandwidth
    ///< Management Status bit has been set. The write value is gated with
    ///< the PCIE_CAP_LINK_BW_NOT_CAP field in LINK_CAPABILITIES_REG.  This
    ///< bit is not applicable and is Reserved for Endpoints, PCI Express-to-PCI/PCI-X
    ///< bridges, and Upstream Ports of Switches.  For functions that do not
    ///< implement the Link Bandwidth Notification Capability, the controller
    ///< hardwires this bit to 0b.   Note: The access attributes of this field
    ///< are as follows:  - Wire: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
    ///< ? RW : RO    - Dbi: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
    ///< ? RW : RO
    ///< AccessType="RW/V" BitOffset="10" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_AUTO_BW_INT_EN : 1;
    ///< Link Autonomous Bandwidth Management Interrupt Enable. When set, this
    ///< bit enables the generation of an interrupt to indicate that the Link
    ///< Autonomous Bandwidth Status bit has been set. The write value is gated
    ///< with the PCIE_CAP_LINK_BW_NOT_CAP field in LINK_CAPABILITIES_REG.
    ///< This bit is not applicable and is Reserved for Endpoints, PCI Express-to-PCI/PCI-X
    ///< bridges, and Upstream Ports of Switches.  For functions that do not
    ///< implement the Link Bandwidth Notification Capability, the controller
    ///< hardwires this bit to 0b.   Note: The access attributes of this field
    ///< are as follows:  - Wire: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
    ///< ? RW : RO   - Dbi: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
    ///< ? RW : RO
    ///< AccessType="RW/V" BitOffset="11" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t PCIE_CAP_DRS_SIGNALING_CONTROL : 2;
    ///< DRS Signaling Control. Indicates the mechanism used to report reception
    ///< of a DRS message. Must be implemented for Downstream Ports with the
    ///< DRS Supported bit Set in the Link Capabilities 2 Register. Encodings
    ///< are:  If DRS Supported is set, receiving a DRS Message will set DRS
    ///< Message Received in the Link Status 2 Register but will otherwise
    ///< have no effect  If the DRS Message Received bit in the Link Status
    ///< 2 Register transitions from 0 to 1, and either MSI or MSI-X is enabled,
    ///< an MSI or MSI-X interrupt is generated using the vector in Interrupt
    ///< Message Number (section 7.5.3.2)  If the DRS Message Received bit
    ///< in the Link Status 2 Register transitions from 0 to 1, the Port must
    ///< send an FRS Message Upstream with the FRS Reason field set to DRS
    ///< Message Received.  Behavior is undefined if this field is set to 10b
    ///< and the FRS Supported bit in the Device Capabilities 2 Register is
    ///< Clear.  Behavior is undefined if this field is set to 11b. For Downstream
    ///< Ports with the DRS Supported bit clear in the Link Capabilities 2
    ///< register, the controller hardwires this field to 00b. This field is
    ///< Reserved for Upstream Ports.
    ///< AccessType="RO" BitOffset="14" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_SPEED : 4;
    ///< Current Link Speed. This field indicates the negotiated Link speed
    ///< of the given PCI Express Link. The encoded value specifies a bit location
    ///< in the Supported Link Speeds Vector (in the Link Capabilities 2 register)
    ///< that corresponds to the current Link speed. All encodings other than
    ///< the defined encodings are reserved. The value in this field is undefined
    ///< when the Link is not up.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x1"
    uint32_t PCIE_CAP_NEGO_LINK_WIDTH : 6;
    ///< Negotiated Link Width. This field indicates the negotiated width of
    ///< the given PCI Express Link.This includes the Link Width determined
    ///< during initial link training as well changes that occur afer initial
    ///< link training (e.g., L0p). All encodings other than the defined encodings
    ///< are reserved. The value in this field is undefined when the Link is
    ///< not up.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t PCIE_CAP_LINK_TRAINING : 1;
    ///< Link Training. This read-only bit indicates that the Physical Layer
    ///< LTSSM is in the Configuration or Recovery state, or that 1b was written
    ///< to the Retrain Link bit but Link training has not yet begun. Hardware
    ///< clears this bit when the LTSSM exits the Configuration/Recovery state.
    ///< This bit is not applicable and Reserved for Endpoints, PCI Express
    ///< to PCI/PCI-X bridges, and Upstream Ports of Switches, and the controller
    ///< hardwires it to 0b.   Note: The access attributes of this field are
    ///< as follows:  - Wire: RSVDP   - Dbi: R
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint32_t PCIE_CAP_SLOT_CLK_CONFIG : 1;
    ///< Slot Clock Configuration. This bit indicates that the component uses
    ///< the same physical reference clock that the platform provides on the
    ///< connector. If the device uses an independent clock irrespective of
    ///< the presence of a reference clock on the connector, this bit must
    ///< be clear.  For a Multi-Function Device, each Function must report
    ///< the same value for this bit.   Note: The access attributes of this
    ///< field are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN ==
    ///< 1) then R/W else R
    ///< AccessType="RO" BitOffset="28" ResetValue="0x1"
    uint32_t PCIE_CAP_DLL_ACTIVE : 1;
    ///< Data Link Layer Link Active. This bit indicates the status of the
    ///< Data Link Control and Management State Machine. It returns a 1b to
    ///< indicate the DL_Active state, 0b otherwise.  This bit must be implemented
    ///< if the Data Link Layer Link Active Reporting Capable bit is 1b. Otherwise,
    ///< the controller hardwires it to 0b.
    ///< AccessType="RO" BitOffset="29" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_BW_MAN_STATUS : 1;
    ///< Link Bandwidth Management Status. This bit is set by hardware to indicate
    ///< that either of the following has occurred without the Port transitioning
    ///< through DL_Down status:   A Link retraining has completed following
    ///< a write of 1b to the Retrain Link bit.  Note: This bit is set following
    ///< any write of 1b to the Retrain Link bit, including when the Link is
    ///< in the process of retraining for some other reason.   Hardware has
    ///< changed Link speed or width to attempt to correct unreliable Link
    ///< operation, either through an LTSSM timeout or a higher level process.
    ///< This bit must be set if the Physical Layer reports a speed or width
    ///< change was initiated by the Downstream component that was not indicated
    ///< as an autonomous change. This bit is not applicable and is Reserved
    ///< for Endpoints, PCI Express-to-PCI/PCI-X bridges, and Upstream Ports
    ///< of Switches.  For functions that do not implement the Link Bandwidth
    ///< Notification Capability, the controller hardwires this bit to 0b.
    ///< The default value of this bit is 0b.  The write value is gated with
    ///< the PCIE_CAP_LINK_BW_NOT_CAP field in LINK_CAPABILITIES_REG.   Note:
    ///< The access attributes of this field are as follows:  - Wire: RSVDP
    ///< - Dbi: R
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_AUTO_BW_STATUS : 1;
    ///< Link Autonomous Bandwidth Status. This bit is set by hardware to indicate
    ///< that hardware has autonomously changed Link speed or width, without
    ///< the Port transitioning through DL_Down status, for reasons other than
    ///< to attempt to correct unreliable Link operation.  This bit must be
    ///< set if the Physical Layer reports a speed or width change was initiated
    ///< by the Downstream component that was indicated as an autonomous change.
    ///< The write value is gated with the PCIE_CAP_LINK_BW_NOT_CAP field in
    ///< LINK_CAPABILITIES_REG.  This bit is not applicable and is Reserved
    ///< for Endpoints, PCI Express-to-PCI/PCI-X bridges, and Upstream Ports
    ///< of Switches.  For functions that do not implement the Link Bandwidth
    ///< Notification Capability, the controller hardwires this bit to 0b.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< RSVDP   - Dbi: R
    ///< AccessType="RO" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_link_ctrl_link_stat_reg_t;

#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_DEFAULT (0x10110000U)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_RD_MASK (0xfbffcffbU)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_WR_MASK (0x00000ffbU)


///< ASPM Control/Active State Power Management Control  This field controls
///< the level of ASPM enabled on the given PCI Express Link.  For requirements
///< on when and how to enable ASPM, see section 5.4.1.3 of the PCI Express
///< Base Specification.  Note:  L0s Entry Enabled  enables the Transmitter
///< to enter L0s. If L0s is supported, the Receiver must be capable of
///< entering L0s even when the Transmitter is disabled from entering L0s
///< (00b or 10b).  In Flit Mode, L0s is not supported, bit 0 of this field
///< is ignored and has no effect (that is, encodings 0x1 and 0x0 are equivalent
///< as are encodings 0x3 and 0x2).  ASPM L1 must be enabled by software
///< in the Upstream component on a Link prior to enabling ASPM L1 in the
///< Downstream component on that Link. When disabling ASPM L1, software
///< must disable ASPM L1 in the Downstream component on a Link prior to
///< disabling ASPM L1 in the Upstream component on that Link. ASPM L1
///< must only be enabled on the Downstream component if both components
///< on a Link support ASPM L1.  For Multi-Function Devices (including
///< ARI Devices), it is recommended that software program the same value
///< for this field in all Functions. For non-ARI Multi-Function Devices,
///< only capabilities enabled in all Functions are enabled for the component
///< as a whole.  For ARI Devices, ASPM Control is determined solely by
///< the setting in Function0, regardless of Function 0's D-state. The
///< settings in the other Functions always return whatever value software
///< programmed for each, but otherwise are ignored by the component. Software
///< must not enable L0s in either direction on a given Link unless components
///< on both sides of the Link each support L0s; otherwise, the result
///< is undefined.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_ACTIVE_STATE_LINK_PM_CTRL_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_ACTIVE_STATE_LINK_PM_CTRL_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_ACTIVE_STATE_LINK_PM_CTRL_BF_MSK (0x00000003)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_ACTIVE_STATE_LINK_PM_CTRL_BF_DEF (0x00000000)

///< Read Completion Boundary (RCB).   Root Ports: Indicates the RCB value
///< for the Root Port. Refer to section 2.3.1.1 of PCI Express Base Specification
///< for the definition of the parameter RCB. The controller hardwires
///< this bit for a Root Port and returns its RCB support capabilities.
///< Endpoints and Bridges: Optionally set by configuration software to
///< indicate the RCB value of the Root Port Upstream from the Endpoint
///< or Bridge. Refer to Section 2.3.1.1 of PCI Express Base Specification
///< for the definition of the parameter RCB is same as Root Port. Configuration
///< software must only set this bit if the Root Port Upstream from the
///< Endpoint or Bridge reports an RCB value of 128 bytes (a value of 1b
///< in the Read Completion Boundary bit). For functions that do not implement
///< this feature, the controller hardwires this bit to 0b.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RCB_BF_OFF ( 3)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RCB_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RCB_BF_MSK (0x00000008)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RCB_BF_DEF (0x00000000)

///< Link Disable. This bit disables the Link by directing the LTSSM to
///< the Disabled state when set; this bit is Reserved on Endpoints, PCI
///< Express to PCI/PCI-X bridges, and Upstream Ports of Switches.  Writes
///< to this bit are immediately reflected in the value read from the bit,
///< regardless of actual Link state.  After clearing this bit, software
///< must honor timing requirements defined in Section 6.6.1 with respect
///< to the first Configuration Read following a Conventional Reset.  In
///< a DSP that supports crosslink, the controller gates the write value
///< with the CROSS_LINK_EN field in PORT_LINK_CTRL_OFF.   Note: The access
///< attributes of this field are as follows:  - Wire: CX_CROSSLINK_ENABLE=1
///< && PORT_LINK_CTRL_OFF.CROSS_LINK_EN=1||CX_CROSSLINK_ENABLE=0 && dsp=1
///< ? RW : RO   - Dbi: CX_CROSSLINK_ENABLE=1 && PORT_LINK_CTRL_OFF.CROSS_LINK_EN=1||CX_CROSSLINK_ENABLE=0
///< && dsp=1? RW : RO
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_DIS_BF_OFF ( 4)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_DIS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_DIS_BF_MSK (0x00000010)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_DIS_BF_DEF (0x00000000)

///< Retrain Link. A write of 1b to this bit initiates Link retraining
///< by directing the Physical Layer LTSSM to the Recovery state. If the
///< LTSSM is already in Recovery or Configuration, re-entering Recovery
///< is permitted but not required. If the Port is in DPC when a write
///< of 1b to this bit occurs, the result is undefined. Reads of this bit
///< always return 0b.  It is permitted to write 1b to this bit while simultaneously
///< writing modified values to other fields in this register. If the LTSSM
///< is not already in Recovery or Configuration, the resulting Link training
///< must use the modified values. If the LTSSM is already in Recovery
///< or Configuration, the modified values are not required to affect the
///< Link training that's already in progress.  This bit is not applicable
///< and is Reserved for Endpoints, PCI Express to PCI/PCI-X bridges, and
///< Upstream Ports of Switches.  This bit always returns 0b when read.
///< Note: The access attributes of this field are as follows:  - Wire:
///< see description   - Dbi: see description
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RETRAIN_LINK_BF_OFF ( 5)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RETRAIN_LINK_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RETRAIN_LINK_BF_MSK (0x00000020)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_RETRAIN_LINK_BF_DEF (0x00000000)

///< Common Clock Configuration. When set, this bit indicates that this
///< component and the component at the opposite end of this Link are operating
///< with a distributed common reference clock.  A value of 0b indicates
///< that this component and the component at the opposite end of this
///< Link are operating with asynchronous reference clock.  For non-ARI
///< Multi-Function Devices, software must program the same value for this
///< bit in all Functions. If not all Functions are Set, then the component
///< must as a whole assume that its reference clock is not common with
///< the Upstream component.  For ARI Devices, Common Clock Configuration
///< is determined solely by the setting in Function 0. The settings in
///< the other Functions always return whatever value software programmed
///< for each, but otherwise are ignored by the component.  Components
///< utilize this common clock configuration information to report the
///< correct L0s and L1 Exit Latencies.  After changing the value in this
///< bit in both components on a Link, software must trigger the Link to
///< retrain by writing a 1b to the Retrain Link bit of the Downstream
///< Port.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_CLK_CFG_BF_OFF ( 6)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_CLK_CFG_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_CLK_CFG_BF_MSK (0x00000040)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_CLK_CFG_BF_DEF (0x00000000)

///< Extended Synch  This mode provides external devices (for example,
///< logic analyzers) monitoring the Link time to achieve bit and Symbol
///< lock before the Link enters the L0 state and resumes communication.
///< For Multi-Function devices if any function has this field set, then
///< the component must transmit the additional Ordered Sets when exiting
///< L0s or when in Recovery.  In Flit Mode, this field is ignored and
///< has no effect since L0s is not supported.  For more information, see
///< section 4.2.4.5 and 4.2.6.4.1 of the PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EXTENDED_SYNCH_BF_OFF ( 7)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EXTENDED_SYNCH_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EXTENDED_SYNCH_BF_MSK (0x00000080)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EXTENDED_SYNCH_BF_DEF (0x00000000)

///< Enable Clock Power Management. Applicable only for Upstream Ports
///< and with form factors that support a  Clock Request  (CLKREQ#) mechanism,
///< this bit operates as follows: For a non-ARI Multi-Function Device,
///< power-management-configuration software must only Set this bit if
///< all Functions of the Multi-Function Device indicate a 1b in the Clock
///< Power Management bit of the Link Capabilities register. The component
///< is permitted to use the CLKREQ# signal to power manage Link clock
///< only if this bit is Set for all Functions.  For ARI Devices, Clock
///< Power Management is enabled solely by the setting in Function 0. The
///< settings in the other Functions always return whatever value software
///< programmed for each, but otherwise are ignored by the component. The
///< CLKREQ# signal may also be controlled through the L1 PM Substates
///< mechanism. Such control is not affected by the setting of this bit.
///< For Downstream Ports and components that do not support Clock Power
///< Management (as indicated by a 0b value in the Clock Power Management
///< bit of the Link Capabilities register), the controller hardwires this
///< bit to 0b.  The write value is gated with the PCIE_CAP_CLOCK_POWER_MAN
///< field in LINK_CAPABILITIES_REG.  Note: The access attributes of this
///< field are as follows:  - Wire: LINK_CAPABILITIES_REG.PCIE_CAP_CLOCK_POWER_MAN
///< ? RWS : ROS   - Dbi: LINK_CAPABILITIES_REG.PCIE_CAP_CLOCK_POWER_MAN
///< ? RWS : ROS  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EN_CLK_PWR_MAN_BF_OFF ( 8)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EN_CLK_PWR_MAN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EN_CLK_PWR_MAN_BF_MSK (0x00000100)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_EN_CLK_PWR_MAN_BF_DEF (0x00000000)

///< Hardware Autonomous Width Disable. When set, this bit disables hardware
///< from changing the Link width for reasons other than attempting to
///< correct unreliable Link operation by reducing Link width.  For a Multi-Function
///< Device associated with an Upstream Port, the bit in Function 0 is
///< of type RW, and only Function 0 controls the component's Link behavior.
///< In all other Functions of that device, this bit is of type RsvdP.
///< For components that do not implement the ability autonomously to change
///< Link width, the ciontroller hardwires this bit to 0b.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_HW_AUTO_WIDTH_DIS_BF_OFF ( 9)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_HW_AUTO_WIDTH_DIS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_HW_AUTO_WIDTH_DIS_BF_MSK (0x00000200)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_HW_AUTO_WIDTH_DIS_BF_DEF (0x00000000)

///< Link Bandwidth Management Interrupt Enable. When set, this bit enables
///< the generation of an interrupt to indicate that the Link Bandwidth
///< Management Status bit has been set. The write value is gated with
///< the PCIE_CAP_LINK_BW_NOT_CAP field in LINK_CAPABILITIES_REG.  This
///< bit is not applicable and is Reserved for Endpoints, PCI Express-to-PCI/PCI-X
///< bridges, and Upstream Ports of Switches.  For functions that do not
///< implement the Link Bandwidth Notification Capability, the controller
///< hardwires this bit to 0b.   Note: The access attributes of this field
///< are as follows:  - Wire: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
///< ? RW : RO    - Dbi: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
///< ? RW : RO
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_INT_EN_BF_OFF (10)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_INT_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_INT_EN_BF_MSK (0x00000400)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_INT_EN_BF_DEF (0x00000000)

///< Link Autonomous Bandwidth Management Interrupt Enable. When set, this
///< bit enables the generation of an interrupt to indicate that the Link
///< Autonomous Bandwidth Status bit has been set. The write value is gated
///< with the PCIE_CAP_LINK_BW_NOT_CAP field in LINK_CAPABILITIES_REG.
///< This bit is not applicable and is Reserved for Endpoints, PCI Express-to-PCI/PCI-X
///< bridges, and Upstream Ports of Switches.  For functions that do not
///< implement the Link Bandwidth Notification Capability, the controller
///< hardwires this bit to 0b.   Note: The access attributes of this field
///< are as follows:  - Wire: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
///< ? RW : RO   - Dbi: LINK_CAPABILITIES_REG.PCIE_CAP_LINK_BW_NOT_CAP
///< ? RW : RO
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_INT_EN_BF_OFF (11)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_INT_EN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_INT_EN_BF_MSK (0x00000800)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_INT_EN_BF_DEF (0x00000000)

///< DRS Signaling Control. Indicates the mechanism used to report reception
///< of a DRS message. Must be implemented for Downstream Ports with the
///< DRS Supported bit Set in the Link Capabilities 2 Register. Encodings
///< are:  If DRS Supported is set, receiving a DRS Message will set DRS
///< Message Received in the Link Status 2 Register but will otherwise
///< have no effect  If the DRS Message Received bit in the Link Status
///< 2 Register transitions from 0 to 1, and either MSI or MSI-X is enabled,
///< an MSI or MSI-X interrupt is generated using the vector in Interrupt
///< Message Number (section 7.5.3.2)  If the DRS Message Received bit
///< in the Link Status 2 Register transitions from 0 to 1, the Port must
///< send an FRS Message Upstream with the FRS Reason field set to DRS
///< Message Received.  Behavior is undefined if this field is set to 10b
///< and the FRS Supported bit in the Device Capabilities 2 Register is
///< Clear.  Behavior is undefined if this field is set to 11b. For Downstream
///< Ports with the DRS Supported bit clear in the Link Capabilities 2
///< register, the controller hardwires this field to 00b. This field is
///< Reserved for Upstream Ports.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DRS_SIGNALING_CTRL_BF_OFF (14)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DRS_SIGNALING_CTRL_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DRS_SIGNALING_CTRL_BF_MSK (0x0000C000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DRS_SIGNALING_CTRL_BF_DEF (0x00000000)

///< Current Link Speed. This field indicates the negotiated Link speed
///< of the given PCI Express Link. The encoded value specifies a bit location
///< in the Supported Link Speeds Vector (in the Link Capabilities 2 register)
///< that corresponds to the current Link speed. All encodings other than
///< the defined encodings are reserved. The value in this field is undefined
///< when the Link is not up.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_SPEED_BF_OFF (16)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_SPEED_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_SPEED_BF_MSK (0x000F0000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_SPEED_BF_DEF (0x00010000)

///< Negotiated Link Width. This field indicates the negotiated width of
///< the given PCI Express Link.This includes the Link Width determined
///< during initial link training as well changes that occur afer initial
///< link training (e.g., L0p). All encodings other than the defined encodings
///< are reserved. The value in this field is undefined when the Link is
///< not up.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_NEGO_LINK_WIDTH_BF_OFF (20)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_NEGO_LINK_WIDTH_BF_WID ( 6)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_NEGO_LINK_WIDTH_BF_MSK (0x03F00000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_NEGO_LINK_WIDTH_BF_DEF (0x00100000)

///< Link Training. This read-only bit indicates that the Physical Layer
///< LTSSM is in the Configuration or Recovery state, or that 1b was written
///< to the Retrain Link bit but Link training has not yet begun. Hardware
///< clears this bit when the LTSSM exits the Configuration/Recovery state.
///< This bit is not applicable and Reserved for Endpoints, PCI Express
///< to PCI/PCI-X bridges, and Upstream Ports of Switches, and the controller
///< hardwires it to 0b.   Note: The access attributes of this field are
///< as follows:  - Wire: RSVDP   - Dbi: R
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_TRAINING_BF_OFF (27)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_TRAINING_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_TRAINING_BF_MSK (0x08000000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_TRAINING_BF_DEF (0x00000000)

///< Slot Clock Configuration. This bit indicates that the component uses
///< the same physical reference clock that the platform provides on the
///< connector. If the device uses an independent clock irrespective of
///< the presence of a reference clock on the connector, this bit must
///< be clear.  For a Multi-Function Device, each Function must report
///< the same value for this bit.   Note: The access attributes of this
///< field are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN ==
///< 1) then R/W else R
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_SLOT_CLK_CFG_BF_OFF (28)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_SLOT_CLK_CFG_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_SLOT_CLK_CFG_BF_MSK (0x10000000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_SLOT_CLK_CFG_BF_DEF (0x10000000)

///< Data Link Layer Link Active. This bit indicates the status of the
///< Data Link Control and Management State Machine. It returns a 1b to
///< indicate the DL_Active state, 0b otherwise.  This bit must be implemented
///< if the Data Link Layer Link Active Reporting Capable bit is 1b. Otherwise,
///< the controller hardwires it to 0b.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DLL_ACTIVE_BF_OFF (29)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DLL_ACTIVE_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DLL_ACTIVE_BF_MSK (0x20000000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_DLL_ACTIVE_BF_DEF (0x00000000)

///< Link Bandwidth Management Status. This bit is set by hardware to indicate
///< that either of the following has occurred without the Port transitioning
///< through DL_Down status:   A Link retraining has completed following
///< a write of 1b to the Retrain Link bit.  Note: This bit is set following
///< any write of 1b to the Retrain Link bit, including when the Link is
///< in the process of retraining for some other reason.   Hardware has
///< changed Link speed or width to attempt to correct unreliable Link
///< operation, either through an LTSSM timeout or a higher level process.
///< This bit must be set if the Physical Layer reports a speed or width
///< change was initiated by the Downstream component that was not indicated
///< as an autonomous change. This bit is not applicable and is Reserved
///< for Endpoints, PCI Express-to-PCI/PCI-X bridges, and Upstream Ports
///< of Switches.  For functions that do not implement the Link Bandwidth
///< Notification Capability, the controller hardwires this bit to 0b.
///< The default value of this bit is 0b.  The write value is gated with
///< the PCIE_CAP_LINK_BW_NOT_CAP field in LINK_CAPABILITIES_REG.   Note:
///< The access attributes of this field are as follows:  - Wire: RSVDP
///< - Dbi: R
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_STAT_BF_OFF (30)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_STAT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_STAT_BF_MSK (0x40000000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_BW_MAN_STAT_BF_DEF (0x00000000)

///< Link Autonomous Bandwidth Status. This bit is set by hardware to indicate
///< that hardware has autonomously changed Link speed or width, without
///< the Port transitioning through DL_Down status, for reasons other than
///< to attempt to correct unreliable Link operation.  This bit must be
///< set if the Physical Layer reports a speed or width change was initiated
///< by the Downstream component that was indicated as an autonomous change.
///< The write value is gated with the PCIE_CAP_LINK_BW_NOT_CAP field in
///< LINK_CAPABILITIES_REG.  This bit is not applicable and is Reserved
///< for Endpoints, PCI Express-to-PCI/PCI-X bridges, and Upstream Ports
///< of Switches.  For functions that do not implement the Link Bandwidth
///< Notification Capability, the controller hardwires this bit to 0b.
///< Note: The access attributes of this field are as follows:  - Wire:
///< RSVDP   - Dbi: R
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_STAT_BF_OFF (31)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_STAT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_STAT_BF_MSK (0x80000000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_PCIE_CAP_LINK_AUTO_BW_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_DEVICE_CAPABILITIES2_REG register description at address offset 0x94
  *
  * Register default value:        0x00B10010
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/DEVICE_CAPABILITIES2_REG
  * Device Capabilities 2 Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_CPL_TIMEOUT_RANGE : 4;
    ///< Completion Timeout Ranges Supported  This field indicates device Function
    ///< support for the optional Completion Timeout programmability mechanism.
    ///< This mechanism allows system software to modify the Completion Timeout
    ///< value. This field is applicable only to Root Ports, Endpoints that
    ///< issue Requests on their own behalf, and PCI Express to PCI/PCI-X Bridges
    ///< that take ownership of Requests issued on PCI Express. For all other
    ///< Functions this field is reserved and must be hardwired to 0000b.
    ///< Four time value ranges are defined (A, B, C, D), each with two selectable
    ///< sub-ranges (for which the time ranges are defined in the description
    ///< of the Completion Timeout Value field in the Device Control 2 register):
    ///< The value in this field indicates the timeout value ranges supported.
    ///< For VFs, this field value must be identical to the associated PF's
    ///< field value.  Undefined encodings: Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t PCIE_CAP_CPL_TIMEOUT_DISABLE_SUPPORT : 1;
    ///< Completion Timeout Disable Supported  The Completion Timeout Disable
    ///< mechanism is required for Endpoints that issue Requests on their own
    ///< behalf and PCI Express to PCI/PCI-X Bridges that take ownership of
    ///< Requests issued on PCI Express.  For VFs, this field value must be
    ///< identical to the associated PF's field value.  This mechanism is optional
    ///< for Root Ports.  For all other Functions this field is reserved and
    ///< the controller hardwires this field to 0b.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x1"
    uint32_t PCIE_CAP_ARI_FORWARD_SUPPORT : 1;
    ///< ARI Forwarding Supported. Applicable only to Switch Downstream Ports
    ///< and Root Ports; must be 0b for other Function types. This bit must
    ///< be set to 1b if a Switch Downstream Port or Root Port supports this
    ///< optional capability. For more information, see section 6.13 of PCI
    ///< Express Base Specification.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint32_t PCIE_CAP_ATOMIC_ROUTING_SUPP : 1;
    ///< AtomicOp Routing Supported. Applicable only to Switch Upstream Ports,
    ///< Switch Downstream Ports, and Root Ports; must be 0b for other Function
    ///< types. This bit must be set to 1b if the Port supports this optional
    ///< capability. For more information, see section 6.15 of PCI Express
    ///< Base Specification.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t PCIE_CAP_32_ATOMIC_CPL_SUPP : 1;
    ///< 32-bit AtomicOp Completer Supported  Applicable to Functions with
    ///< Memory Space BARs as well as all Root Ports; must be 0b otherwise.
    ///< Includes FetchAdd, Swap, and CAS AtomicOps. This field must be set
    ///< to 1b if the Function supports this optional capability.  For VFs,
    ///< this field value must be identical to the associated PF's field value.
    ///< For more information on additional RC requirements, see section 6.15.3.1
    ///< of the PCI Express Base Specification.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(Sticky) else R(Sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
    uint32_t PCIE_CAP_64_ATOMIC_CPL_SUPP : 1;
    ///< 64-bit AtomicOp Completer Supported Applicable to Functions with Memory
    ///< Space BARs as well as all Root Ports; must be 0b otherwise. Includes
    ///< FetchAdd, Swap, and CAS AtomicOps. This bit must be set to 1b if the
    ///< Function supports this optional capability.  For VFs, this field value
    ///< must be identical to the associated PF's field value.  For more information
    ///< on additional RC requirements, see section 6.15.3.1 of PCI Express
    ///< Base Specification.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W(Sticky) else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t PCIE_CAP_128_CAS_CPL_SUPP : 1;
    ///< 128-bit CAS Completer Supported Applicable to Functions with Memory
    ///< Space BARs as well as all Root Ports; must be 0b otherwise. This field
    ///< must be set to 1b if the Function supports this optional capability.
    ///< For VFs, this field value must be identical to the associated PF's
    ///< field value.  For more information, see section 6.15 of the PCI Express
    ///< Base Specification.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W(Sticky) else R(Sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t PCIE_CAP_NO_RO_EN_PR2PR_PAR : 1;
    ///< No RO-enabled PR-PR Passing. If this bit is set, the routing element
    ///< never carries out the passing permitted by Table 2-39 of PCI Express
    ///< Base Specification entry A2b that is associated with the Relaxed Ordering
    ///< Attribute field being Set. This bit applies only for Switches and
    ///< RCs that support peer-to-peer traffic between Root Ports. This bit
    ///< applies only to Posted Requests being forwarded through the Switch
    ///< or RC and does not apply to traffic originating or terminating within
    ///< the Switch or RC itself. All Ports on a Switch or RC must report the
    ///< same value for this bit. For all other functions, this bit must be
    ///< 0b.
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t PCIE_CAP2_LN_SYS_CLS : 2;
    ///< LN System CLS. Applicable only to Root Ports and RCRBs; must be 00b
    ///< for all other Function types. This field indicates if the Root Port
    ///< or RCRB supports LN protocol as an LN Completer, and if so, what cacheline
    ///< size is in effect. All encodings other than the defined encodings
    ///< are reserved.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t PCIE_CAP2_10_BIT_TAG_COMP_SUPPORT : 1;
    ///< 10-Bit Tag Completer Supported  For VFs, this field value must be
    ///< identical to the associated PF's field value.  For more information,
    ///< see section 2.2.6.2. of the PCI Express Base Specification.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT : 1;
    ///< 10-Bit Tag Requester Supported  This field must not be set if the
    ///< PCIE_CAP2_10_BIT_TAG_COMP_SUPPORT field is clear.  Note: 10-Bit Tag
    ///< field generation must be enabled by the PCIE_CAP_10BITS_TAG_REQ_EN
    ///< field in the DEVICE_CONTROL2_DEVICE_STATUS2_REG register of the Requester
    ///< Function before 10-Bit Tags can be generated by the Requester.  For
    ///< VFs, this bit value must equal the VF 10-Bit Tag Requester Supported
    ///< bit value in the SR-IOV Capabilities register.  For more information,
    ///< see section 2.2.6.2. of the PCI Express Base Specification.
    ///< AccessType="RO" BitOffset="17" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
    uint32_t PCIE_CAP2_CFG_EXTND_FMT_SUPPORT : 1;
    ///< Extended Fmt Field Supported  If Set, the Function supports the 3-bit
    ///< definition of the Fmt field when operating in Non-Flit Mode. If Clear,
    ///< the Function supports a 2-bit definition of the Fmt field.  Must be
    ///< set for Functions that support End-End TLP Prefixes (NFM) or OHC-E
    ///< (FM). All Functions in an Upstream Port must have the same value for
    ///< this field. Each Downstream Port of a component may have a different
    ///< value for this field.  MUST@FLIT be Set.  For more information, see
    ///< section 2.2 of the PCI Express Base Specification.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x1"
    uint32_t PCIE_CAP2_CFG_END2END_TLP_PRFX_SUPPORT : 1;
    ///< End-End TLP Prefix Supported. Indicates whether End-End TLP Prefix
    ///< support (NFM) / OHC-E (FM) is offered by a Function. Values are: All
    ///< Ports of a Switch must have the same value for this bit.  Note: The
    ///< access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="21" ResetValue="0x1"
    uint32_t PCIE_CAP2_CFG_MAX_END2END_TLP_PRFXS : 2;
    ///< Max End-End TLP Prefixes. Indicates the maximum number of End-End
    ///< TLP Prefixes supported by this Function (NFM) or the maximum size
    ///< of OHC-E supported (FM). For more information,  see Section 2.2.10.2
    ///< of PCI Express Base Specification. If End-End TLP Prefix Supported
    ///< is clear, this field is RsvdP.  Different Root Ports that have the
    ///< End-End TLP Prefix Supported bit set are permitted to report different
    ///< values for this field.  For Switches where End-End TLP Prefix Supported
    ///< is set, this field must be 00b indicating support for up to four End-End
    ///< TLP Prefixes.  Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="22" ResetValue="0x2"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t PCIE_CAP_DMWR_CPL_SUPP : 1;
    ///< Deferrable Memory Write (DMWr) Completer Supported. Applicable to
    ///< Functions with Memory Space BARs as well as all Root Ports; This bit
    ///< must be Set if the Function can serve as a DMWr Completer. For more
    ///< information, see Section 6.30 of PCI Express Base Specification.
    ///< AccessType="RO" BitOffset="28" ResetValue="0x0"
    uint32_t PCIE_CAP_DMWR_LEN_SUPP : 2;
    ///< Deferrable Memory Write (DMWr) Lengths Supported. Applicable to Functions
    ///< with either the DMWr Routing Supported bit Set or the DMWR Completer
    ///< Supported bit Set (or both). This field indicates the largest DMWr
    ///< TLP that this Function can receive. When applicable, all Functions
    ///< in a Multi-Function Device associated with an Upstream Port must report
    ///< the same value in this field. This field is RsvdP if both DMWr Completer
    ///< Supported and DMWr Routing Supported are Clear. For more information,
    ///< see Section 6.30 of PCI Express Base Specification.
    ///< AccessType="RO" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_device_capabilities2_reg_t;

#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_DEFAULT (0x00b10010U)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_RD_MASK (0x70f3c7ffU)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_WR_MASK (0x00000000U)


///< Completion Timeout Ranges Supported  This field indicates device Function
///< support for the optional Completion Timeout programmability mechanism.
///< This mechanism allows system software to modify the Completion Timeout
///< value. This field is applicable only to Root Ports, Endpoints that
///< issue Requests on their own behalf, and PCI Express to PCI/PCI-X Bridges
///< that take ownership of Requests issued on PCI Express. For all other
///< Functions this field is reserved and must be hardwired to 0000b.
///< Four time value ranges are defined (A, B, C, D), each with two selectable
///< sub-ranges (for which the time ranges are defined in the description
///< of the Completion Timeout Value field in the Device Control 2 register):
///< The value in this field indicates the timeout value ranges supported.
///< For VFs, this field value must be identical to the associated PF's
///< field value.  Undefined encodings: Reserved
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_RANGE_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_RANGE_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_RANGE_BF_MSK (0x0000000F)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_RANGE_BF_DEF (0x00000000)

///< Completion Timeout Disable Supported  The Completion Timeout Disable
///< mechanism is required for Endpoints that issue Requests on their own
///< behalf and PCI Express to PCI/PCI-X Bridges that take ownership of
///< Requests issued on PCI Express.  For VFs, this field value must be
///< identical to the associated PF's field value.  This mechanism is optional
///< for Root Ports.  For all other Functions this field is reserved and
///< the controller hardwires this field to 0b.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_DIS_SUPPORT_BF_OFF ( 4)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_DIS_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_DIS_SUPPORT_BF_MSK (0x00000010)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_CPL_TIMEOUT_DIS_SUPPORT_BF_DEF (0x00000010)

///< ARI Forwarding Supported. Applicable only to Switch Downstream Ports
///< and Root Ports; must be 0b for other Function types. This bit must
///< be set to 1b if a Switch Downstream Port or Root Port supports this
///< optional capability. For more information, see section 6.13 of PCI
///< Express Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ARI_FORWARD_SUPPORT_BF_OFF ( 5)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ARI_FORWARD_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ARI_FORWARD_SUPPORT_BF_MSK (0x00000020)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ARI_FORWARD_SUPPORT_BF_DEF (0x00000000)

///< AtomicOp Routing Supported. Applicable only to Switch Upstream Ports,
///< Switch Downstream Ports, and Root Ports; must be 0b for other Function
///< types. This bit must be set to 1b if the Port supports this optional
///< capability. For more information, see section 6.15 of PCI Express
///< Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ATOMIC_ROUTING_SUPP_BF_OFF ( 6)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ATOMIC_ROUTING_SUPP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ATOMIC_ROUTING_SUPP_BF_MSK (0x00000040)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_ATOMIC_ROUTING_SUPP_BF_DEF (0x00000000)

///< 32-bit AtomicOp Completer Supported  Applicable to Functions with
///< Memory Space BARs as well as all Root Ports; must be 0b otherwise.
///< Includes FetchAdd, Swap, and CAS AtomicOps. This field must be set
///< to 1b if the Function supports this optional capability.  For VFs,
///< this field value must be identical to the associated PF's field value.
///< For more information on additional RC requirements, see section 6.15.3.1
///< of the PCI Express Base Specification.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(Sticky) else R(Sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_32_ATOMIC_CPL_SUPP_BF_OFF ( 7)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_32_ATOMIC_CPL_SUPP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_32_ATOMIC_CPL_SUPP_BF_MSK (0x00000080)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_32_ATOMIC_CPL_SUPP_BF_DEF (0x00000000)

///< 64-bit AtomicOp Completer Supported Applicable to Functions with Memory
///< Space BARs as well as all Root Ports; must be 0b otherwise. Includes
///< FetchAdd, Swap, and CAS AtomicOps. This bit must be set to 1b if the
///< Function supports this optional capability.  For VFs, this field value
///< must be identical to the associated PF's field value.  For more information
///< on additional RC requirements, see section 6.15.3.1 of PCI Express
///< Base Specification.   Note: The access attributes of this field are
///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W(Sticky) else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_64_ATOMIC_CPL_SUPP_BF_OFF ( 8)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_64_ATOMIC_CPL_SUPP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_64_ATOMIC_CPL_SUPP_BF_MSK (0x00000100)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_64_ATOMIC_CPL_SUPP_BF_DEF (0x00000000)

///< 128-bit CAS Completer Supported Applicable to Functions with Memory
///< Space BARs as well as all Root Ports; must be 0b otherwise. This field
///< must be set to 1b if the Function supports this optional capability.
///< For VFs, this field value must be identical to the associated PF's
///< field value.  For more information, see section 6.15 of the PCI Express
///< Base Specification.   Note: The access attributes of this field are
///< as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W(Sticky) else R(Sticky)  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_128_CAS_CPL_SUPP_BF_OFF ( 9)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_128_CAS_CPL_SUPP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_128_CAS_CPL_SUPP_BF_MSK (0x00000200)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_128_CAS_CPL_SUPP_BF_DEF (0x00000000)

///< No RO-enabled PR-PR Passing. If this bit is set, the routing element
///< never carries out the passing permitted by Table 2-39 of PCI Express
///< Base Specification entry A2b that is associated with the Relaxed Ordering
///< Attribute field being Set. This bit applies only for Switches and
///< RCs that support peer-to-peer traffic between Root Ports. This bit
///< applies only to Posted Requests being forwarded through the Switch
///< or RC and does not apply to traffic originating or terminating within
///< the Switch or RC itself. All Ports on a Switch or RC must report the
///< same value for this bit. For all other functions, this bit must be
///< 0b.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_NO_RO_EN_PR2PR_PAR_BF_OFF (10)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_NO_RO_EN_PR2PR_PAR_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_NO_RO_EN_PR2PR_PAR_BF_MSK (0x00000400)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_NO_RO_EN_PR2PR_PAR_BF_DEF (0x00000000)

///< LN System CLS. Applicable only to Root Ports and RCRBs; must be 00b
///< for all other Function types. This field indicates if the Root Port
///< or RCRB supports LN protocol as an LN Completer, and if so, what cacheline
///< size is in effect. All encodings other than the defined encodings
///< are reserved.   Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_LN_SYS_CLS_BF_OFF (14)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_LN_SYS_CLS_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_LN_SYS_CLS_BF_MSK (0x0000C000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_LN_SYS_CLS_BF_DEF (0x00000000)

///< 10-Bit Tag Completer Supported  For VFs, this field value must be
///< identical to the associated PF's field value.  For more information,
///< see section 2.2.6.2. of the PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_SUPPORT_BF_OFF (16)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_SUPPORT_BF_MSK (0x00010000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_SUPPORT_BF_DEF (0x00010000)

///< 10-Bit Tag Requester Supported  This field must not be set if the
///< PCIE_CAP2_10_BIT_TAG_COMP_SUPPORT field is clear.  Note: 10-Bit Tag
///< field generation must be enabled by the PCIE_CAP_10BITS_TAG_REQ_EN
///< field in the DEVICE_CONTROL2_DEVICE_STATUS2_REG register of the Requester
///< Function before 10-Bit Tags can be generated by the Requester.  For
///< VFs, this bit value must equal the VF 10-Bit Tag Requester Supported
///< bit value in the SR-IOV Capabilities register.  For more information,
///< see section 2.2.6.2. of the PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT_BF_OFF (17)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT_BF_MSK (0x00020000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT_BF_DEF (0x00000000)

///< Extended Fmt Field Supported  If Set, the Function supports the 3-bit
///< definition of the Fmt field when operating in Non-Flit Mode. If Clear,
///< the Function supports a 2-bit definition of the Fmt field.  Must be
///< set for Functions that support End-End TLP Prefixes (NFM) or OHC-E
///< (FM). All Functions in an Upstream Port must have the same value for
///< this field. Each Downstream Port of a component may have a different
///< value for this field.  MUST@FLIT be Set.  For more information, see
///< section 2.2 of the PCI Express Base Specification.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_EXTND_FMT_SUPPORT_BF_OFF (20)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_EXTND_FMT_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_EXTND_FMT_SUPPORT_BF_MSK (0x00100000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_EXTND_FMT_SUPPORT_BF_DEF (0x00100000)

///< End-End TLP Prefix Supported. Indicates whether End-End TLP Prefix
///< support (NFM) / OHC-E (FM) is offered by a Function. Values are: All
///< Ports of a Switch must have the same value for this bit.  Note: The
///< access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register
///< field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_END2END_TLP_PRFX_SUPPORT_BF_OFF (21)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_END2END_TLP_PRFX_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_END2END_TLP_PRFX_SUPPORT_BF_MSK (0x00200000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_END2END_TLP_PRFX_SUPPORT_BF_DEF (0x00200000)

///< Max End-End TLP Prefixes. Indicates the maximum number of End-End
///< TLP Prefixes supported by this Function (NFM) or the maximum size
///< of OHC-E supported (FM). For more information,  see Section 2.2.10.2
///< of PCI Express Base Specification. If End-End TLP Prefix Supported
///< is clear, this field is RsvdP.  Different Root Ports that have the
///< End-End TLP Prefix Supported bit set are permitted to report different
///< values for this field.  For Switches where End-End TLP Prefix Supported
///< is set, this field must be 00b indicating support for up to four End-End
///< TLP Prefixes.  Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_MAX_END2END_TLP_PRFXS_BF_OFF (22)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_MAX_END2END_TLP_PRFXS_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_MAX_END2END_TLP_PRFXS_BF_MSK (0x00C00000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP2_CFG_MAX_END2END_TLP_PRFXS_BF_DEF (0x00800000)

///< Deferrable Memory Write (DMWr) Completer Supported. Applicable to
///< Functions with Memory Space BARs as well as all Root Ports; This bit
///< must be Set if the Function can serve as a DMWr Completer. For more
///< information, see Section 6.30 of PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_CPL_SUPP_BF_OFF (28)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_CPL_SUPP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_CPL_SUPP_BF_MSK (0x10000000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_CPL_SUPP_BF_DEF (0x00000000)

///< Deferrable Memory Write (DMWr) Lengths Supported. Applicable to Functions
///< with either the DMWr Routing Supported bit Set or the DMWR Completer
///< Supported bit Set (or both). This field indicates the largest DMWr
///< TLP that this Function can receive. When applicable, all Functions
///< in a Multi-Function Device associated with an Upstream Port must report
///< the same value in this field. This field is RsvdP if both DMWr Completer
///< Supported and DMWr Routing Supported are Clear. For more information,
///< see Section 6.30 of PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_LEN_SUPP_BF_OFF (29)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_LEN_SUPP_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_LEN_SUPP_BF_MSK (0x60000000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_PCIE_CAP_DMWR_LEN_SUPP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_DEVICE_CONTROL2_DEVICE_STATUS2_REG register description at address offset 0x98
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/DEVICE_CONTROL2_DEVICE_STATUS2_REG
  * Device Control 2 and Status 2 Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_CPL_TIMEOUT_VALUE : 4;
    ///< Completion Timeout Value In device Functions that support Completion
    ///< Timeout programmability, this field allows system software to modify
    ///< the Completion Timeout value.  This field is applicable to Root Ports,
    ///< Endpoints that issue Requests on their own behalf, and PCI Express
    ///< to PCI/PCI-X Bridges that take ownership of Requests issued on PCI
    ///< Express. For VFs, the associated PF's value applies, and this field
    ///< must be RsvdP . For all other Functions, this field is Reserved and
    ///< controller hardwires it to 0000b.  A Function that does not support
    ///< this optional capability must hardwire this field to 0000b and MUST@FLIT
    ///< implement a timeout value in the range 40 ms to 50 ms. A function
    ///< that does not support Flit Mode must to implement a timeout value
    ///< in the range 50 us to 50 ms. Functions that support Completion Timeout
    ///< programmability must support the values given below corresponding
    ///< to the programmability ranges indicated in the Completion Timeout
    ///< Ranges Supported field.  For Functions that do not support Flit Mode,
    ///< it is strongly recommended that the Completion Timeout mechanism not
    ///< expire in less than 10 ms.  Software is permitted to change the value
    ///< in this field at any time. For Requests already pending when the Completion
    ///< Timeout Value is changed, hardware is permitted to use either the
    ///< new or the old value for the outstanding Requests, and is permitted
    ///< to base the start time for each Request either on when this value
    ///< was changed or on when each request was issued.  Undefined encodings:
    ///< Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t PCIE_CAP_CPL_TIMEOUT_DISABLE : 1;
    ///< Completion Timeout Disable For non-VFs, this field is required for
    ///< all Functions that support the Completion Timeout Disable Capability.
    ///< For VFs, the associated PF's value applies, and this field must be
    ///< reserved. Otherwise, Functions that do not support this optional capability
    ///< are permitted to hardwire this bit to 0b. Software is permitted to
    ///< set or clear this field at any time. If there are outstanding Requests
    ///< when the field is cleared, it is permitted but not required for hardware
    ///< to apply the completion timeout mechanism to the outstanding Requests.
    ///< If this is done, it is permitted to base the start time for each Request
    ///< on either the time this field was cleared or the time each Request
    ///< was issued.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t PCIE_CAP_ARI_FORWARD_SUPPORT_CS : 1;
    ///< ARI Forwarding Enable. When set, the Downstream Port disables its
    ///< traditional Device Number field being 0 enforcement when turning a
    ///< Type 1 Configuration Request into a Type 0 Configuration Request,
    ///< permitting access to Extended Functions in an ARI Device immediately
    ///< below the Port. For more information, see Section 6.13 of PCI Express
    ///< Base Specification.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t PCIE_CTRL2_CFG_END2END_TLP_PFX_BLCK : 1;
    ///< End-End TLP Prefix Blocking. Controls whether the routing function
    ///< is permitted to forward TLPs containing an End-End TLP Prefix (NFM)/OHC-E
    ///< (FM). This bit affects TLPs that exit the Switch/Root Complex using
    ///< the associated Port. It does not affect TLPs forwarded internally
    ///< within the Switch/Root Complex. It does not affect TLPs that enter
    ///< through the associated Port, that originate in the associated Port
    ///< or originate in a Root Complex Integrated Device integrated with the
    ///< associated Port. Blocked TLPs are reported by the TLP Prefix Blocked
    ///< Error.  This bit is hardwired to 1b in Root Ports that support End-End
    ///< TLP Prefixes/OHC-E but do not support forwarding of End-End TLP Prefixes/OHC-E.
    ///< This bit is applicable to Root Ports and Switch Ports where the End-End
    ///< TLP Prefix Supported bit is set. This bit is not applicable and is
    ///< RsvdP in all other cases.
    ///< AccessType="RO" BitOffset="15" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_device_ctrl2_device_stat2_reg_t;

#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_DEFAULT (0x00000000U)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_RD_MASK (0x0000803fU)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_WR_MASK (0x00000010U)


///< Completion Timeout Value In device Functions that support Completion
///< Timeout programmability, this field allows system software to modify
///< the Completion Timeout value.  This field is applicable to Root Ports,
///< Endpoints that issue Requests on their own behalf, and PCI Express
///< to PCI/PCI-X Bridges that take ownership of Requests issued on PCI
///< Express. For VFs, the associated PF's value applies, and this field
///< must be RsvdP . For all other Functions, this field is Reserved and
///< controller hardwires it to 0000b.  A Function that does not support
///< this optional capability must hardwire this field to 0000b and MUST@FLIT
///< implement a timeout value in the range 40 ms to 50 ms. A function
///< that does not support Flit Mode must to implement a timeout value
///< in the range 50 us to 50 ms. Functions that support Completion Timeout
///< programmability must support the values given below corresponding
///< to the programmability ranges indicated in the Completion Timeout
///< Ranges Supported field.  For Functions that do not support Flit Mode,
///< it is strongly recommended that the Completion Timeout mechanism not
///< expire in less than 10 ms.  Software is permitted to change the value
///< in this field at any time. For Requests already pending when the Completion
///< Timeout Value is changed, hardware is permitted to use either the
///< new or the old value for the outstanding Requests, and is permitted
///< to base the start time for each Request either on when this value
///< was changed or on when each request was issued.  Undefined encodings:
///< Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_VAL_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_VAL_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_VAL_BF_MSK (0x0000000F)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_VAL_BF_DEF (0x00000000)

///< Completion Timeout Disable For non-VFs, this field is required for
///< all Functions that support the Completion Timeout Disable Capability.
///< For VFs, the associated PF's value applies, and this field must be
///< reserved. Otherwise, Functions that do not support this optional capability
///< are permitted to hardwire this bit to 0b. Software is permitted to
///< set or clear this field at any time. If there are outstanding Requests
///< when the field is cleared, it is permitted but not required for hardware
///< to apply the completion timeout mechanism to the outstanding Requests.
///< If this is done, it is permitted to base the start time for each Request
///< on either the time this field was cleared or the time each Request
///< was issued.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_DIS_BF_OFF ( 4)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_DIS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_DIS_BF_MSK (0x00000010)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_CPL_TIMEOUT_DIS_BF_DEF (0x00000000)

///< ARI Forwarding Enable. When set, the Downstream Port disables its
///< traditional Device Number field being 0 enforcement when turning a
///< Type 1 Configuration Request into a Type 0 Configuration Request,
///< permitting access to Extended Functions in an ARI Device immediately
///< below the Port. For more information, see Section 6.13 of PCI Express
///< Base Specification.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_ARI_FORWARD_SUPPORT_CS_BF_OFF ( 5)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_ARI_FORWARD_SUPPORT_CS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_ARI_FORWARD_SUPPORT_CS_BF_MSK (0x00000020)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CAP_ARI_FORWARD_SUPPORT_CS_BF_DEF (0x00000000)

///< End-End TLP Prefix Blocking. Controls whether the routing function
///< is permitted to forward TLPs containing an End-End TLP Prefix (NFM)/OHC-E
///< (FM). This bit affects TLPs that exit the Switch/Root Complex using
///< the associated Port. It does not affect TLPs forwarded internally
///< within the Switch/Root Complex. It does not affect TLPs that enter
///< through the associated Port, that originate in the associated Port
///< or originate in a Root Complex Integrated Device integrated with the
///< associated Port. Blocked TLPs are reported by the TLP Prefix Blocked
///< Error.  This bit is hardwired to 1b in Root Ports that support End-End
///< TLP Prefixes/OHC-E but do not support forwarding of End-End TLP Prefixes/OHC-E.
///< This bit is applicable to Root Ports and Switch Ports where the End-End
///< TLP Prefix Supported bit is set. This bit is not applicable and is
///< RsvdP in all other cases.
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CTRL2_CFG_END2END_TLP_PFX_BLCK_BF_OFF (15)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CTRL2_CFG_END2END_TLP_PFX_BLCK_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CTRL2_CFG_END2END_TLP_PFX_BLCK_BF_MSK (0x00008000)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_PCIE_CTRL2_CFG_END2END_TLP_PFX_BLCK_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_LINK_CAPABILITIES2_REG register description at address offset 0x9c
  *
  * Register default value:        0x0180003E
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/LINK_CAPABILITIES2_REG
  * Link Capabilities 2 Register.
  */

typedef union {
  struct {
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR : 7;
    ///< Supported Link Speeds Vector This field indicates the supported Link
    ///< speeds of the associated Port. For each bit, a value of 1b indicates
    ///< that the corresponding Link speed is supported; otherwise, the Link
    ///< speed is not supported.  Multi-Function Devices associated with an
    ///< Upstream Port must report the same value in this field for all Functions.
    ///< This field has a default of (PCIE_CAP_MAX_LINK_SPEED == 0110) ? 0111111
    ///< :(PCIE_CAP_MAX_LINK_SPEED == 0101) ? 0011111 : (PCIE_CAP_MAX_LINK_SPEED
    ///< == 0100) ? 0001111 : (PCIE_CAP_MAX_LINK_SPEED == 0011) ? 0000111 :
    ///< (PCIE_CAP_MAX_LINK_SPEED == 0010) ? 0000011 : 0000001 where PCIE_CAP_MAX_LINK_SPEED
    ///< is a field in the LINK_CAPABILITIES_REG register.  For more information,
    ///< see section 8.2.1 of the  PCI Express Base Specification.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x1F"
    uint32_t PCIE_CAP_CROSS_LINK_SUPPORT : 1;
    ///< Crosslink Supported. When set to 1b, this bit indicates that the associated
    ///< Port supports crosslinks (for more details, see section 4.2.6.3.1
    ///< of PCI Express Base Specification). When set to 0b on a Port that
    ///< supports Link speeds of 8.0 GT/s or higher, this bit indicates that
    ///< the associated Port does not support crosslinks. When set to 0b on
    ///< a Port that only supports Link speeds of 2.5 GT/s or 5.0 GT/s, this
    ///< bit provides no information regarding the Port's level of crosslink
    ///< support. It is recommended that this bit be Set in any Port that supports
    ///< crosslinks even though doing so is only required for Ports that also
    ///< support operating at 8.0 GT/s or higher Link speeds.  Note: Software
    ///< should use this bit when referencing fields whose definition depends
    ///< on whether or not the Port supports crosslinks (for more details,
    ///< see section 7.7.3.4 of PCI Express Base Specification).  Multi-Function
    ///< Devices associated with an Upstream Port must report the same value
    ///< in this field for all Functions.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t PCIE_CAP_LWR_SKP_OS_GEN_SUP : 7;
    ///< Lower SKP OS Generation Supported Speeds Vector If this field is non-Zero,
    ///< it indicates that the port, when operating at the indicated speed
    ///< supports SRIS and also supports software control of the SKP Ordered
    ///< Set transmission scheduling rate.  Multi-Function Devices associated
    ///< with an Upstream Port must report the same value in this field for
    ///< all Functions. Behavior is undefined if a bit is set to '1' in this
    ///< field and the corresponding bit is not set to '1' in the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR
    ///< field.  This field has a default of (PCIE_CAP_MAX_LINK_SPEED == 0110)
    ///< ? 0111111 :(PCIE_CAP_MAX_LINK_SPEED == 0101) ? 0011111 : (PCIE_CAP_MAX_LINK_SPEED
    ///< == 0100) ? 0001111 : (PCIE_CAP_MAX_LINK_SPEED == 0011) ? 0000111 :
    ///< (PCIE_CAP_MAX_LINK_SPEED == 0010) ? 0000011 : 0000001 where PCIE_CAP_MAX_LINK_SPEED
    ///< is a field in the LINK_CAPABILITIES_REG register.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t PCIE_CAP_LWR_SKP_OS_RCV_SUP : 7;
    ///< Lower SKP OS Reception Supported Speeds Vector If this field is non-Zero,
    ///< it indicates that the port, when operating at the indicated speed
    ///< supports SRIS and also supports receiving SKP OS at the rate defined
    ///< for SRNS while running in SRIS.  Multi-Function Devices associated
    ///< with an Upstream Port must report the same value in this field for
    ///< all Functions. Behavior is undefined if a bit is set to '1' in this
    ///< field and the corresponding bit is not set to '1' in the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR
    ///< field.  This field has a default of (PCIE_CAP_MAX_LINK_SPEED == 0110)
    ///< ? 0111111 :(PCIE_CAP_MAX_LINK_SPEED == 0101) ? 0011111 : (PCIE_CAP_MAX_LINK_SPEED
    ///< == 0100) ? 0001111 : (PCIE_CAP_MAX_LINK_SPEED == 0011) ? 0000111 :
    ///< (PCIE_CAP_MAX_LINK_SPEED == 0010) ? 0000011 : 0000001 where PCIE_CAP_MAX_LINK_SPEED
    ///< is a field in the LINK_CAPABILITIES_REG register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t PCIE_CAP_RETIMER_PRE_DET_SUPPORT : 1;
    ///< Retimer Presence Detect Supported When set to 1b, this field indicates
    ///< that the associated Port supports detection and reporting of Retimer
    ///< presence.  This bit MUST@FLIT be Set.  This bit must be set to 1b
    ///< in a Port when the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR of the LINK_CAPABILITIES2_REG
    ///< register indicates support for a Link speed of 16.0 GT/s or higher.
    ///< It is permitted to be set to 1b regardless of the supported Link speeds.
    ///< Multi-Function Devices associated with an Upstream Port must report
    ///< the same value in this field for all Functions.   Note: The access
    ///< attributes of this field are as follows:  - Wire: HWINIT   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< AccessType="RO" BitOffset="23" ResetValue="0x1"
    uint32_t PCIE_CAP_TWO_RETIMERS_PRE_DET_SUPPORT : 1;
    ///< Two Retimers Presence Detect Supported When set to 1b, this bit indicates
    ///< that the associated Port supports detection and reporting of two Retimers
    ///< presence.  This bit MUST@FLIT be Set.  This bit must be set to 1b
    ///< in a Port when the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR of the LINK_CAPABILITIES2_REG
    ///< register indicates support for a Link speed of 16.0 GT/s or higher.
    ///< It is permitted to be set to 1b regardless of the supported Link speeds
    ///< if the PCIE_CAP_RETIMER_PRE_DET_SUPPORT field is also set to 1b.
    ///< Multi-Function Devices associated with an Upstream Port must report
    ///< the same value in this field for all Functions.   Note: The access
    ///< attributes of this field are as follows:  - Wire: HWINIT   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< AccessType="RW/V" BitOffset="24" ResetValue="0x1"
    uint32_t  : 7;
    ///< Reserved
    ///< AccessType="RO" BitOffset="25" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_link_capabilities2_reg_t;

#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_DEFAULT (0x0180003eU)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_RD_MASK (0x01fffffeU)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_WR_MASK (0x01000000U)


///< Supported Link Speeds Vector This field indicates the supported Link
///< speeds of the associated Port. For each bit, a value of 1b indicates
///< that the corresponding Link speed is supported; otherwise, the Link
///< speed is not supported.  Multi-Function Devices associated with an
///< Upstream Port must report the same value in this field for all Functions.
///< This field has a default of (PCIE_CAP_MAX_LINK_SPEED == 0110) ? 0111111
///< :(PCIE_CAP_MAX_LINK_SPEED == 0101) ? 0011111 : (PCIE_CAP_MAX_LINK_SPEED
///< == 0100) ? 0001111 : (PCIE_CAP_MAX_LINK_SPEED == 0011) ? 0000111 :
///< (PCIE_CAP_MAX_LINK_SPEED == 0010) ? 0000011 : 0000001 where PCIE_CAP_MAX_LINK_SPEED
///< is a field in the LINK_CAPABILITIES_REG register.  For more information,
///< see section 8.2.1 of the  PCI Express Base Specification.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_BF_OFF ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_BF_WID ( 7)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_BF_MSK (0x000000FE)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_BF_DEF (0x0000003E)

///< Crosslink Supported. When set to 1b, this bit indicates that the associated
///< Port supports crosslinks (for more details, see section 4.2.6.3.1
///< of PCI Express Base Specification). When set to 0b on a Port that
///< supports Link speeds of 8.0 GT/s or higher, this bit indicates that
///< the associated Port does not support crosslinks. When set to 0b on
///< a Port that only supports Link speeds of 2.5 GT/s or 5.0 GT/s, this
///< bit provides no information regarding the Port's level of crosslink
///< support. It is recommended that this bit be Set in any Port that supports
///< crosslinks even though doing so is only required for Ports that also
///< support operating at 8.0 GT/s or higher Link speeds.  Note: Software
///< should use this bit when referencing fields whose definition depends
///< on whether or not the Port supports crosslinks (for more details,
///< see section 7.7.3.4 of PCI Express Base Specification).  Multi-Function
///< Devices associated with an Upstream Port must report the same value
///< in this field for all Functions.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_CROSS_LINK_SUPPORT_BF_OFF ( 8)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_CROSS_LINK_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_CROSS_LINK_SUPPORT_BF_MSK (0x00000100)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_CROSS_LINK_SUPPORT_BF_DEF (0x00000000)

///< Lower SKP OS Generation Supported Speeds Vector If this field is non-Zero,
///< it indicates that the port, when operating at the indicated speed
///< supports SRIS and also supports software control of the SKP Ordered
///< Set transmission scheduling rate.  Multi-Function Devices associated
///< with an Upstream Port must report the same value in this field for
///< all Functions. Behavior is undefined if a bit is set to '1' in this
///< field and the corresponding bit is not set to '1' in the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR
///< field.  This field has a default of (PCIE_CAP_MAX_LINK_SPEED == 0110)
///< ? 0111111 :(PCIE_CAP_MAX_LINK_SPEED == 0101) ? 0011111 : (PCIE_CAP_MAX_LINK_SPEED
///< == 0100) ? 0001111 : (PCIE_CAP_MAX_LINK_SPEED == 0011) ? 0000111 :
///< (PCIE_CAP_MAX_LINK_SPEED == 0010) ? 0000011 : 0000001 where PCIE_CAP_MAX_LINK_SPEED
///< is a field in the LINK_CAPABILITIES_REG register.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_GEN_SUP_BF_OFF ( 9)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_GEN_SUP_BF_WID ( 7)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_GEN_SUP_BF_MSK (0x0000FE00)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_GEN_SUP_BF_DEF (0x00000000)

///< Lower SKP OS Reception Supported Speeds Vector If this field is non-Zero,
///< it indicates that the port, when operating at the indicated speed
///< supports SRIS and also supports receiving SKP OS at the rate defined
///< for SRNS while running in SRIS.  Multi-Function Devices associated
///< with an Upstream Port must report the same value in this field for
///< all Functions. Behavior is undefined if a bit is set to '1' in this
///< field and the corresponding bit is not set to '1' in the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR
///< field.  This field has a default of (PCIE_CAP_MAX_LINK_SPEED == 0110)
///< ? 0111111 :(PCIE_CAP_MAX_LINK_SPEED == 0101) ? 0011111 : (PCIE_CAP_MAX_LINK_SPEED
///< == 0100) ? 0001111 : (PCIE_CAP_MAX_LINK_SPEED == 0011) ? 0000111 :
///< (PCIE_CAP_MAX_LINK_SPEED == 0010) ? 0000011 : 0000001 where PCIE_CAP_MAX_LINK_SPEED
///< is a field in the LINK_CAPABILITIES_REG register.
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_RCV_SUP_BF_OFF (16)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_RCV_SUP_BF_WID ( 7)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_RCV_SUP_BF_MSK (0x007F0000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_LWR_SKP_OS_RCV_SUP_BF_DEF (0x00000000)

///< Retimer Presence Detect Supported When set to 1b, this field indicates
///< that the associated Port supports detection and reporting of Retimer
///< presence.  This bit MUST@FLIT be Set.  This bit must be set to 1b
///< in a Port when the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR of the LINK_CAPABILITIES2_REG
///< register indicates support for a Link speed of 16.0 GT/s or higher.
///< It is permitted to be set to 1b regardless of the supported Link speeds.
///< Multi-Function Devices associated with an Upstream Port must report
///< the same value in this field for all Functions.   Note: The access
///< attributes of this field are as follows:  - Wire: HWINIT   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_RETIMER_PRE_DET_SUPPORT_BF_OFF (23)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_RETIMER_PRE_DET_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_RETIMER_PRE_DET_SUPPORT_BF_MSK (0x00800000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_RETIMER_PRE_DET_SUPPORT_BF_DEF (0x00800000)

///< Two Retimers Presence Detect Supported When set to 1b, this bit indicates
///< that the associated Port supports detection and reporting of two Retimers
///< presence.  This bit MUST@FLIT be Set.  This bit must be set to 1b
///< in a Port when the PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR of the LINK_CAPABILITIES2_REG
///< register indicates support for a Link speed of 16.0 GT/s or higher.
///< It is permitted to be set to 1b regardless of the supported Link speeds
///< if the PCIE_CAP_RETIMER_PRE_DET_SUPPORT field is also set to 1b.
///< Multi-Function Devices associated with an Upstream Port must report
///< the same value in this field for all Functions.   Note: The access
///< attributes of this field are as follows:  - Wire: HWINIT   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_TWO_RETIMERS_PRE_DET_SUPPORT_BF_OFF (24)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_TWO_RETIMERS_PRE_DET_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_TWO_RETIMERS_PRE_DET_SUPPORT_BF_MSK (0x01000000)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_PCIE_CAP_TWO_RETIMERS_PRE_DET_SUPPORT_BF_DEF (0x01000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_LINK_CONTROL2_LINK_STATUS2_REG register description at address offset 0xa0
  *
  * Register default value:        0x01010005
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP/LINK_CONTROL2_LINK_STATUS2_REG
  * Link Control 2 and Status 2 Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_TARGET_LINK_SPEED : 4;
    ///< Target Link Speed. For Downstream Ports, this field sets an upper
    ///< limit on Link operational speed by restricting the values advertised
    ///< by the Upstream component in its training sequences. The encoded value
    ///< specifies a bit location in the Supported Link Speeds Vector (in the
    ///< Link Capabilities 2 register) that corresponds to the desired target
    ///< Link speed. All encodings other than the defined encodings are reserved.
    ///< If a value is written to this field that does not correspond to a
    ///< supported speed (as indicated by the Supported Link Speeds Vector),
    ///< the result is undefined.  If either of the Enter Compliance or Enter
    ///< Modified Compliance bits are implemented, then this field must also
    ///< be implemented.  The default value of this field is the highest Link
    ///< speed supported by the component (as reported in the Max Link Speed
    ///< field of the Link Capabilities register) unless the corresponding
    ///< platform/form factor requires a different default value.  For both
    ///< Upstream and Downstream Ports, this field is used to set the target
    ///< compliance mode speed when software is using the Enter Compliance
    ///< bit to force a Link into compliance mode.  For Upstream Ports, if
    ///< the Enter Compliance bit is Clear, this field is permitted to have
    ///< no effect.  For a Multi-Function Device associated with an Upstream
    ///< Port, the field in Function 0 is of type RWS, and only Function 0
    ///< controls the component's Link behavior. In all other Functions of
    ///< that device, this field is of type RsvdP.  Components that support
    ///< only the 2.5 GT/s speed are permitted to hardwire this field to 0000b.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x5"
    uint32_t PCIE_CAP_ENTER_COMPLIANCE : 1;
    ///< Enter Compliance. Software is permitted to force a Link to enter Compliance
    ///< mode (at the speed indicated in the Target Link Speed field and the
    ///< de-emphasis/preset level indicated by the Compliance Preset/De-emphasis
    ///< bit) by setting this bit to 1b in both components on a Link and then
    ///< initiating a hot reset on the Link.  Default value of this bit following
    ///< Fundamental Reset is 0b.  For a Multi-Function Device associated with
    ///< an Upstream Port, the bit in Function 0 is of type RWS, and only Function
    ///< 0 controls the component's Link behavior. In all other Functions of
    ///< that device, this bit is of type RsvdP.  Components that support only
    ///< the 2.5 GT/s speed are permitted to hardwire this bit to 0b.  This
    ///< bit is intended for debug, compliance testing purposes only. System
    ///< firmware and software is allowed to modify this bit only during debug
    ///< or compliance testing. In all other cases, the system must ensure
    ///< that this bit is set to the default value.  After the software requests
    ///< entering Polling.Compliance by setting this Enter Compliance bit,
    ///< software should request exiting from Polling.Compliance by clearing
    ///< this Enter Compliance bit only after controller sends out Compliance
    ///< Pattern.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field
    ///< is sticky.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint32_t PCIE_CAP_HW_AUTO_SPEED_DISABLE : 1;
    ///< Hardware Autonomous Speed Disable. When set, this bit disables hardware
    ///< from changing the Link speed for device-specific reasons other than
    ///< attempting to correct unreliable Link operation by reducing Link speed.
    ///< Initial transition to the highest supported common link speed is not
    ///< blocked by this bit.  For a Multi-Function Device associated with
    ///< an Upstream Port, the bit in Function 0 is of type RWS, and only Function
    ///< 0 controls the component's Link behavior. In all other Functions of
    ///< that device, this bit is of type RsvdP.  Functions that do not implement
    ///< the associated mechanism are permitted to hardwire this bit to 0b.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t PCIE_CAP_SEL_DEEMPHASIS : 1;
    ///< Selectable De-emphasis. When the Link is operating at 5.0 GT/s speed,
    ///< this bit is used to control the transmit de-emphasis of the link in
    ///< specific situations. For more information, see section 4.2.6 of PCI
    ///< Express Base Specification. When the Link is not operating at 5.0
    ///< GT/s speed, the setting of this bit has no effect. Components that
    ///< support only the 2.5 GT/s speed are permitted to hardwire this bit
    ///< to 0b.  This bit is not applicable and Reserved for Endpoints, PCI
    ///< Express to PCI/PCI-X bridges, and Upstream Ports of Switches.  Note:
    ///< This register field is sticky.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t PCIE_CAP_TX_MARGIN : 3;
    ///< Transmit Margin, This field controls the value of the non-deemphasized
    ///< voltage level at the Transmitter pins. This field is reset to 000b
    ///< on entry to the LTSSM Polling.Configuration substate (see Chapter
    ///< 4 of PCI Express Base Specification for details of how the Transmitter
    ///< voltage level is determined in various states).  - 001b-111b: As defined
    ///< in Section 8.3.4 not all encodings are required to be implemented.
    ///< For a Multi-Function Device associated with an Upstream Port, the
    ///< field in Function 0 is of type RWS, and only Function 0 controls the
    ///< component's Link behavior. In all other Functions of that device,
    ///< this field is of type RsvdP.  For components that support only the
    ///< 2.5 GT/s speed, the controller hardwires this bit to 000b.  This field
    ///< is intended for debug, compliance testing purposes only. System firmware
    ///< and software is allowed to modify this field only during debug or
    ///< compliance testing. In all other cases, the system must ensure that
    ///< this field is set to the default value.  Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="7" ResetValue="0x0"
    uint32_t PCIE_CAP_ENTER_MODIFIED_COMPLIANCE : 1;
    ///< Enter Modified Compliance. When this bit is set to 1b, the device
    ///< transmits Modified Compliance Pattern if the LTSSM enters Polling.Compliance
    ///< substate. Components that support only the 2.5 GT/s speed are permitted
    ///< to hardwire this bit to 0b.  For a Multi-Function Device associated
    ///< with an Upstream Port, the bit in Function 0 is of type RWS, and only
    ///< Function 0 controls the component's Link behavior. In all other Functions
    ///< of that device, this bit is of type RsvdP.  This bit is intended for
    ///< debug, compliance testing purposes only. System firmware and software
    ///< is allowed to modify this bit only during debug or compliance testing.
    ///< In all other cases, the system must ensure that this bit is set to
    ///< the default value.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t PCIE_CAP_COMPLIANCE_SOS : 1;
    ///< Compliance SOS. When set to 1b, the LTSSM is required to send SKP
    ///< Ordered Sets between sequences when sending the Compliance Pattern
    ///< or Modified Compliance Pattern.  For a Multi-Function Device associated
    ///< with an Upstream Port, the bit in Function 0 is of type RWS, and only
    ///< Function 0 controls the component's Link behavior. In all other Functions
    ///< of that device, this bit is of type RsvdP.  This bit is applicable
    ///< when the Link is operating at 2.5 GT/s or 5.0 GT/s data rates only.
    ///< For components that support only the 2.5 GT/s speed, the controller
    ///< hardwires this bit to 0b.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RW/V" BitOffset="11" ResetValue="0x0"
    uint32_t PCIE_CAP_COMPLIANCE_PRESET : 4;
    ///< Compliance Preset/De-emphasis.  - For 8.0 GT/s and higher Data Rate:
    ///< This field sets the Transmitter Preset in Polling.Compliance state
    ///< if the entry occurred due to the Enter Compliance bit being 1b. The
    ///< encodings are defined in section 4.2.3.2 of PCI Express Base Specification
    ///< . Results are undefined if a reserved preset encoding is used when
    ///< entering Polling.Compliance in this way.  - For 5.0 GT/s Data Rate:
    ///< This field sets the de-emphasis level in Polling.Compliance state
    ///< if the entry occurred due to the Enter Compliance bit being 1b.  -
    ///< When the Link is operating at 2.5 GT/s, the setting of this field
    ///< has no effect. Components that support only 2.5 GT/s speed are permitted
    ///< to hardwire this field to 0000b.  - For a Multi-Function Device associated
    ///< with an Upstream Port, the field in Function 0 is of type RWS, and
    ///< only Function 0 controls the component's Link behavior. In all other
    ///< Functions of that device, this field is of type RsvdP.  - This field
    ///< is intended for debug and compliance testing purposes. System firmware
    ///< and software is allowed to modify this field only during debug or
    ///< compliance testing. In all other cases, the system must ensure that
    ///< this field is set to the default value. Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="12" ResetValue="0x0"
    uint32_t PCIE_CAP_CURR_DEEMPHASIS : 1;
    ///< Current De-emphasis Level When the Link is operating at 5.0 GT/s speed,
    ///< this field reflects the level of de-emphasis.  The value in this field
    ///< is undefined when the Link is not operating at 5.0 GT/s speed.  For
    ///< VFs, the associated PF's value applies, and this field must be reserved.
    ///< Otherwise, components that support only the 2.5 GT/s speed are permitted
    ///< to hardwire this field to 0b.  For components that support speeds
    ///< greater than 2.5 GT/s, Multi-Function Devices associated with an Upstream
    ///< Port must report the same value in this field for all Functions of
    ///< the Port.  In C-PCIe mode, its contents are derived by sampling the
    ///< PIPE.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x1"
    uint32_t PCIE_CAP_EQ_CPL : 1;
    ///< Equalization 8.0 GT/s Complete. When set to 1b, this bit indicates
    ///< that the Transmitter Equalization procedure at the 8.0 GT/s data rate
    ///< has completed. Details of the Transmitter Equalization process and
    ///< when this bit needs to be set to 1b is provided in section 4.2.6.4.2
    ///< of PCI Express Base Specification.  For Multi-Function Upstream Port,
    ///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
    ///< For components that only support speeds below 8.0 GT/s, the controller
    ///< hardwires this bit to 0b.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t PCIE_CAP_EQ_CPL_P1 : 1;
    ///< Equalization 8.0 GT/s Phase 1 Successful. When set to 1b, this bit
    ///< indicates that Phase 1 of the 8.0 GT/s Transmitter Equalization procedure
    ///< has successfully completed. Details of the Transmitter Equalization
    ///< process and when this bit needs to be set to 1b is provided in section
    ///< 4.2.6.4.2 of PCI Express Base Specification.  For Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions. For components that only support speeds below 8.0 GT/s,
    ///< the controller hardwires this bit to 0b.   Note: This register field
    ///< is sticky.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t PCIE_CAP_EQ_CPL_P2 : 1;
    ///< Equalization 8.0 GT/s Phase 2 Successful. When set to 1b, this bit
    ///< indicates that Phase 2 of the 8.0 GT/s Transmitter Equalization procedure
    ///< has successfully completed. Details of the Transmitter Equalization
    ///< process and when this bit needs to be set to 1b is provided in section
    ///< 4.2.6.4.2 of PCI Express Base Specification.  For Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions. For components that only support speeds below 8.0 GT/s,
    ///< the controller hardwires this bit to 0b.   Note: This register field
    ///< is sticky.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t PCIE_CAP_EQ_CPL_P3 : 1;
    ///< EEqualization 8.0 GT/s Phase 3 Successful. When set to 1b, this bit
    ///< indicates that Phase 3 of the 8.0 GT/s Transmitter Equalization procedure
    ///< has successfully completed. Details of the Transmitter Equalization
    ///< process and when this bit needs to be set to 1b is provided in section
    ///< 4.2.6.4.2 of PCI Express Base Specification.  For Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions. For components that only support speeds below 8.0 GT/s,
    ///< the controller hardwires this bit to 0b.   Note: This register field
    ///< is sticky.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_EQ_REQ : 1;
    ///< Link Equalization Request 8.0 GT/s. This bit is set by hardware to
    ///< request the 8.0 GT/s Link equalization process to be performed on
    ///< the Link. For more information, see sections 4.2.3 and 4.2.6.4.2 of
    ///< PCI Express Base Specification.  For Multi-Function Upstream Port,
    ///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
    ///< For components that only support speeds below 8.0 GT/s, the controller
    ///< hardwires this bit to 0b.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="21" ResetValue="0x0"
    uint32_t PCIE_CAP_RETIMER_PRE_DET : 1;
    ///< Retimer Presence Detected  This field is required for Ports that have
    ///< the PCIE_CAP_RETIMER_PRE_DET_SUPPORT field of the LINK_CAPABILITIES2_REG
    ///< register set to 1b.  For Ports that have the PCIE_CAP_RETIMER_PRE_DET_SUPPORT
    ///< field set to 0b, the controller hardwires this field to 0b.  For Multi-Function
    ///< Devices associated with an Upstream Port, this field must be implemented
    ///< in Function 0 and is reserved in all other Functions.  For more information,
    ///< see section 4.2.6.3.5.1 of the PCI Express Base Specification.   Note:
    ///< This register field is sticky.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint32_t PCIE_CAP_TWO_RETIMERS_PRE_DET : 1;
    ///< Two Retimers Presence Detected. When set to 1b, this bit indicates
    ///< that two Retimers were present during the most recent Link negotiation.
    ///< For more information, see section 4.2.6.3.5.1  of PCI Express Base
    ///< Specification.  This bit is required for Ports that have the Two Retimers
    ///< Presence Detect Supported bit of the Link Capabilities 2 register
    ///< set to 1b.  Ports that have the Two Retimers Presence Detect Supported
    ///< bit set to 0b are permitted to hardwire this bit to 0b.  For Multi-Function
    ///< Devices associated with an Upstream Port, this bit must be implemented
    ///< in Function 0 and RsvdZ in all other Functions.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO/V" BitOffset="23" ResetValue="0x0"
    uint32_t PCIE_CAP_CROSSLINK_RESOLUTION : 2;
    ///< Crosslink Resolution. This field indicates the state of the Crosslink
    ///< negotiation. It must be implemented if Crosslink Supported is Set
    ///< and the Port supports 16.0 GT/s or higher data rate. It is permitted
    ///< to be implemented in all other Ports. If Crosslink Supported is clear,
    ///< the controller hardwires this field to 01b or 10b. Once a value of
    ///< 01b or 10b is returned in this field, that value must continue to
    ///< be returned while the Link is Up.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x1"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_link_ctrl2_link_stat2_reg_t;

#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_DEFAULT (0x01010005U)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_RD_MASK (0x03ffffffU)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_WR_MASK (0x0020ffbfU)


///< Target Link Speed. For Downstream Ports, this field sets an upper
///< limit on Link operational speed by restricting the values advertised
///< by the Upstream component in its training sequences. The encoded value
///< specifies a bit location in the Supported Link Speeds Vector (in the
///< Link Capabilities 2 register) that corresponds to the desired target
///< Link speed. All encodings other than the defined encodings are reserved.
///< If a value is written to this field that does not correspond to a
///< supported speed (as indicated by the Supported Link Speeds Vector),
///< the result is undefined.  If either of the Enter Compliance or Enter
///< Modified Compliance bits are implemented, then this field must also
///< be implemented.  The default value of this field is the highest Link
///< speed supported by the component (as reported in the Max Link Speed
///< field of the Link Capabilities register) unless the corresponding
///< platform/form factor requires a different default value.  For both
///< Upstream and Downstream Ports, this field is used to set the target
///< compliance mode speed when software is using the Enter Compliance
///< bit to force a Link into compliance mode.  For Upstream Ports, if
///< the Enter Compliance bit is Clear, this field is permitted to have
///< no effect.  For a Multi-Function Device associated with an Upstream
///< Port, the field in Function 0 is of type RWS, and only Function 0
///< controls the component's Link behavior. In all other Functions of
///< that device, this field is of type RsvdP.  Components that support
///< only the 2.5 GT/s speed are permitted to hardwire this field to 0000b.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TARGET_LINK_SPEED_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TARGET_LINK_SPEED_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TARGET_LINK_SPEED_BF_MSK (0x0000000F)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TARGET_LINK_SPEED_BF_DEF (0x00000005)

///< Enter Compliance. Software is permitted to force a Link to enter Compliance
///< mode (at the speed indicated in the Target Link Speed field and the
///< de-emphasis/preset level indicated by the Compliance Preset/De-emphasis
///< bit) by setting this bit to 1b in both components on a Link and then
///< initiating a hot reset on the Link.  Default value of this bit following
///< Fundamental Reset is 0b.  For a Multi-Function Device associated with
///< an Upstream Port, the bit in Function 0 is of type RWS, and only Function
///< 0 controls the component's Link behavior. In all other Functions of
///< that device, this bit is of type RsvdP.  Components that support only
///< the 2.5 GT/s speed are permitted to hardwire this bit to 0b.  This
///< bit is intended for debug, compliance testing purposes only. System
///< firmware and software is allowed to modify this bit only during debug
///< or compliance testing. In all other cases, the system must ensure
///< that this bit is set to the default value.  After the software requests
///< entering Polling.Compliance by setting this Enter Compliance bit,
///< software should request exiting from Polling.Compliance by clearing
///< this Enter Compliance bit only after controller sends out Compliance
///< Pattern.   Note: The access attributes of this field are as follows:
///< - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_COMPLIANCE_BF_OFF ( 4)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_COMPLIANCE_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_COMPLIANCE_BF_MSK (0x00000010)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_COMPLIANCE_BF_DEF (0x00000000)

///< Hardware Autonomous Speed Disable. When set, this bit disables hardware
///< from changing the Link speed for device-specific reasons other than
///< attempting to correct unreliable Link operation by reducing Link speed.
///< Initial transition to the highest supported common link speed is not
///< blocked by this bit.  For a Multi-Function Device associated with
///< an Upstream Port, the bit in Function 0 is of type RWS, and only Function
///< 0 controls the component's Link behavior. In all other Functions of
///< that device, this bit is of type RsvdP.  Functions that do not implement
///< the associated mechanism are permitted to hardwire this bit to 0b.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_HW_AUTO_SPEED_DIS_BF_OFF ( 5)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_HW_AUTO_SPEED_DIS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_HW_AUTO_SPEED_DIS_BF_MSK (0x00000020)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_HW_AUTO_SPEED_DIS_BF_DEF (0x00000000)

///< Selectable De-emphasis. When the Link is operating at 5.0 GT/s speed,
///< this bit is used to control the transmit de-emphasis of the link in
///< specific situations. For more information, see section 4.2.6 of PCI
///< Express Base Specification. When the Link is not operating at 5.0
///< GT/s speed, the setting of this bit has no effect. Components that
///< support only the 2.5 GT/s speed are permitted to hardwire this bit
///< to 0b.  This bit is not applicable and Reserved for Endpoints, PCI
///< Express to PCI/PCI-X bridges, and Upstream Ports of Switches.  Note:
///< This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_SEL_DEEMPHASIS_BF_OFF ( 6)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_SEL_DEEMPHASIS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_SEL_DEEMPHASIS_BF_MSK (0x00000040)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_SEL_DEEMPHASIS_BF_DEF (0x00000000)

///< Transmit Margin, This field controls the value of the non-deemphasized
///< voltage level at the Transmitter pins. This field is reset to 000b
///< on entry to the LTSSM Polling.Configuration substate (see Chapter
///< 4 of PCI Express Base Specification for details of how the Transmitter
///< voltage level is determined in various states).  - 001b-111b: As defined
///< in Section 8.3.4 not all encodings are required to be implemented.
///< For a Multi-Function Device associated with an Upstream Port, the
///< field in Function 0 is of type RWS, and only Function 0 controls the
///< component's Link behavior. In all other Functions of that device,
///< this field is of type RsvdP.  For components that support only the
///< 2.5 GT/s speed, the controller hardwires this bit to 000b.  This field
///< is intended for debug, compliance testing purposes only. System firmware
///< and software is allowed to modify this field only during debug or
///< compliance testing. In all other cases, the system must ensure that
///< this field is set to the default value.  Note: The access attributes
///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TX_MARGIN_BF_OFF ( 7)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TX_MARGIN_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TX_MARGIN_BF_MSK (0x00000380)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TX_MARGIN_BF_DEF (0x00000000)

///< Enter Modified Compliance. When this bit is set to 1b, the device
///< transmits Modified Compliance Pattern if the LTSSM enters Polling.Compliance
///< substate. Components that support only the 2.5 GT/s speed are permitted
///< to hardwire this bit to 0b.  For a Multi-Function Device associated
///< with an Upstream Port, the bit in Function 0 is of type RWS, and only
///< Function 0 controls the component's Link behavior. In all other Functions
///< of that device, this bit is of type RsvdP.  This bit is intended for
///< debug, compliance testing purposes only. System firmware and software
///< is allowed to modify this bit only during debug or compliance testing.
///< In all other cases, the system must ensure that this bit is set to
///< the default value.   Note: The access attributes of this field are
///< as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This
///< register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_MODIFIED_COMPLIANCE_BF_OFF (10)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_MODIFIED_COMPLIANCE_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_MODIFIED_COMPLIANCE_BF_MSK (0x00000400)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_ENTER_MODIFIED_COMPLIANCE_BF_DEF (0x00000000)

///< Compliance SOS. When set to 1b, the LTSSM is required to send SKP
///< Ordered Sets between sequences when sending the Compliance Pattern
///< or Modified Compliance Pattern.  For a Multi-Function Device associated
///< with an Upstream Port, the bit in Function 0 is of type RWS, and only
///< Function 0 controls the component's Link behavior. In all other Functions
///< of that device, this bit is of type RsvdP.  This bit is applicable
///< when the Link is operating at 2.5 GT/s or 5.0 GT/s data rates only.
///< For components that support only the 2.5 GT/s speed, the controller
///< hardwires this bit to 0b.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_SOS_BF_OFF (11)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_SOS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_SOS_BF_MSK (0x00000800)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_SOS_BF_DEF (0x00000000)

///< Compliance Preset/De-emphasis.  - For 8.0 GT/s and higher Data Rate:
///< This field sets the Transmitter Preset in Polling.Compliance state
///< if the entry occurred due to the Enter Compliance bit being 1b. The
///< encodings are defined in section 4.2.3.2 of PCI Express Base Specification
///< . Results are undefined if a reserved preset encoding is used when
///< entering Polling.Compliance in this way.  - For 5.0 GT/s Data Rate:
///< This field sets the de-emphasis level in Polling.Compliance state
///< if the entry occurred due to the Enter Compliance bit being 1b.  -
///< When the Link is operating at 2.5 GT/s, the setting of this field
///< has no effect. Components that support only 2.5 GT/s speed are permitted
///< to hardwire this field to 0000b.  - For a Multi-Function Device associated
///< with an Upstream Port, the field in Function 0 is of type RWS, and
///< only Function 0 controls the component's Link behavior. In all other
///< Functions of that device, this field is of type RsvdP.  - This field
///< is intended for debug and compliance testing purposes. System firmware
///< and software is allowed to modify this field only during debug or
///< compliance testing. In all other cases, the system must ensure that
///< this field is set to the default value. Note: The access attributes
///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_PRST_BF_OFF (12)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_PRST_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_PRST_BF_MSK (0x0000F000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_COMPLIANCE_PRST_BF_DEF (0x00000000)

///< Current De-emphasis Level When the Link is operating at 5.0 GT/s speed,
///< this field reflects the level of de-emphasis.  The value in this field
///< is undefined when the Link is not operating at 5.0 GT/s speed.  For
///< VFs, the associated PF's value applies, and this field must be reserved.
///< Otherwise, components that support only the 2.5 GT/s speed are permitted
///< to hardwire this field to 0b.  For components that support speeds
///< greater than 2.5 GT/s, Multi-Function Devices associated with an Upstream
///< Port must report the same value in this field for all Functions of
///< the Port.  In C-PCIe mode, its contents are derived by sampling the
///< PIPE.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CURR_DEEMPHASIS_BF_OFF (16)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CURR_DEEMPHASIS_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CURR_DEEMPHASIS_BF_MSK (0x00010000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CURR_DEEMPHASIS_BF_DEF (0x00010000)

///< Equalization 8.0 GT/s Complete. When set to 1b, this bit indicates
///< that the Transmitter Equalization procedure at the 8.0 GT/s data rate
///< has completed. Details of the Transmitter Equalization process and
///< when this bit needs to be set to 1b is provided in section 4.2.6.4.2
///< of PCI Express Base Specification.  For Multi-Function Upstream Port,
///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
///< For components that only support speeds below 8.0 GT/s, the controller
///< hardwires this bit to 0b.   Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_BF_OFF (17)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_BF_MSK (0x00020000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_BF_DEF (0x00000000)

///< Equalization 8.0 GT/s Phase 1 Successful. When set to 1b, this bit
///< indicates that Phase 1 of the 8.0 GT/s Transmitter Equalization procedure
///< has successfully completed. Details of the Transmitter Equalization
///< process and when this bit needs to be set to 1b is provided in section
///< 4.2.6.4.2 of PCI Express Base Specification.  For Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions. For components that only support speeds below 8.0 GT/s,
///< the controller hardwires this bit to 0b.   Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P1_BF_OFF (18)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P1_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P1_BF_MSK (0x00040000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P1_BF_DEF (0x00000000)

///< Equalization 8.0 GT/s Phase 2 Successful. When set to 1b, this bit
///< indicates that Phase 2 of the 8.0 GT/s Transmitter Equalization procedure
///< has successfully completed. Details of the Transmitter Equalization
///< process and when this bit needs to be set to 1b is provided in section
///< 4.2.6.4.2 of PCI Express Base Specification.  For Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions. For components that only support speeds below 8.0 GT/s,
///< the controller hardwires this bit to 0b.   Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P2_BF_OFF (19)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P2_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P2_BF_MSK (0x00080000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P2_BF_DEF (0x00000000)

///< EEqualization 8.0 GT/s Phase 3 Successful. When set to 1b, this bit
///< indicates that Phase 3 of the 8.0 GT/s Transmitter Equalization procedure
///< has successfully completed. Details of the Transmitter Equalization
///< process and when this bit needs to be set to 1b is provided in section
///< 4.2.6.4.2 of PCI Express Base Specification.  For Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions. For components that only support speeds below 8.0 GT/s,
///< the controller hardwires this bit to 0b.   Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P3_BF_OFF (20)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P3_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P3_BF_MSK (0x00100000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_EQ_CPL_P3_BF_DEF (0x00000000)

///< Link Equalization Request 8.0 GT/s. This bit is set by hardware to
///< request the 8.0 GT/s Link equalization process to be performed on
///< the Link. For more information, see sections 4.2.3 and 4.2.6.4.2 of
///< PCI Express Base Specification.  For Multi-Function Upstream Port,
///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
///< For components that only support speeds below 8.0 GT/s, the controller
///< hardwires this bit to 0b.   Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_LINK_EQ_REQ_BF_OFF (21)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_LINK_EQ_REQ_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_LINK_EQ_REQ_BF_MSK (0x00200000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_LINK_EQ_REQ_BF_DEF (0x00000000)

///< Retimer Presence Detected  This field is required for Ports that have
///< the PCIE_CAP_RETIMER_PRE_DET_SUPPORT field of the LINK_CAPABILITIES2_REG
///< register set to 1b.  For Ports that have the PCIE_CAP_RETIMER_PRE_DET_SUPPORT
///< field set to 0b, the controller hardwires this field to 0b.  For Multi-Function
///< Devices associated with an Upstream Port, this field must be implemented
///< in Function 0 and is reserved in all other Functions.  For more information,
///< see section 4.2.6.3.5.1 of the PCI Express Base Specification.   Note:
///< This register field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_RETIMER_PRE_DET_BF_OFF (22)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_RETIMER_PRE_DET_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_RETIMER_PRE_DET_BF_MSK (0x00400000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_RETIMER_PRE_DET_BF_DEF (0x00000000)

///< Two Retimers Presence Detected. When set to 1b, this bit indicates
///< that two Retimers were present during the most recent Link negotiation.
///< For more information, see section 4.2.6.3.5.1  of PCI Express Base
///< Specification.  This bit is required for Ports that have the Two Retimers
///< Presence Detect Supported bit of the Link Capabilities 2 register
///< set to 1b.  Ports that have the Two Retimers Presence Detect Supported
///< bit set to 0b are permitted to hardwire this bit to 0b.  For Multi-Function
///< Devices associated with an Upstream Port, this bit must be implemented
///< in Function 0 and RsvdZ in all other Functions.   Note: This register
///< field is sticky.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TWO_RETIMERS_PRE_DET_BF_OFF (23)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TWO_RETIMERS_PRE_DET_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TWO_RETIMERS_PRE_DET_BF_MSK (0x00800000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_TWO_RETIMERS_PRE_DET_BF_DEF (0x00000000)

///< Crosslink Resolution. This field indicates the state of the Crosslink
///< negotiation. It must be implemented if Crosslink Supported is Set
///< and the Port supports 16.0 GT/s or higher data rate. It is permitted
///< to be implemented in all other Ports. If Crosslink Supported is clear,
///< the controller hardwires this field to 01b or 10b. Once a value of
///< 01b or 10b is returned in this field, that value must continue to
///< be returned while the Link is Up.
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CROSSLINK_RESOLUTION_BF_OFF (24)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CROSSLINK_RESOLUTION_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CROSSLINK_RESOLUTION_BF_MSK (0x03000000)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_PCIE_CAP_CROSSLINK_RESOLUTION_BF_DEF (0x01000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_REG register description at address offset 0xb0
  *
  * Register default value:        0x00100011
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSIX_CAP/PCI_MSIX_CAP_ID_NEXT_CTRL_REG
  * MSI-X Capability ID, Next Pointer, Control Register.
  */

typedef union {
  struct {
    uint32_t PCI_MSIX_CAP_ID : 8;
    ///< MSI-X Capability ID. This field indicates the MSI-X Capability structure.
    ///< This field must return a Capability ID of 11h indicating that this
    ///< is an MSI-X Capability structure.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x11"
    uint32_t PCI_MSIX_CAP_NEXT_OFFSET : 8;
    ///< MSI-X Next Capability Pointer. This field contains the offset to the
    ///< next PCI Capability structure or 00h if no other items exist in the
    ///< linked list of Capabilities.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t PCI_MSIX_TABLE_SIZE : 11;
    ///< MSI-X Table Size. System software reads this field to determine the
    ///< MSI-X Table Size N, which is encoded as N-1. For example, a returned
    ///< value of 000 0000 0011b indicates a table size of 4.  SRIOV Note:
    ///< All VFs in a single PF have the same value for  MSI-X Table Size
    ///< (PCI_MSIX_TABLE_SIZE field in SHADOW_PCI_MSIX_CAP_ID_NEXT_CTRL_REG).
    ///< To write this common value, you must perform a DBI_CS2 write (that
    ///< is, assert the dbi_cs2 input, or the CS2 address bit for the AXI bridge)
    ///< while accessing the PCI_MSIX_TABLE_SIZE field in the PF PCI_MSIX_CAP_ID_NEXT_CTRL_REG
    ///< register.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x10"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
    uint32_t PCI_MSIX_FUNCTION_MASK : 1;
    ///< Function Mask. If Set, all of the vectors associated with the Function
    ///< are masked, regardless of their per-vector Mask bit values. If Clear,
    ///< each vector's Mask bit determines whether the vector is masked or
    ///< not. Setting or Clearing the MSI-X Function Mask bit has no effect
    ///< on the value of the per-vector Mask bits.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t PCI_MSIX_ENABLE : 1;
    ///< MSI-X Enable. If Set and the MSI Enable bit in the MSI Message Control
    ///< Register for MSI is Clear, the Function is permitted to use MSI-X
    ///< to request service and is prohibited from using INTx interrupts (if
    ///< implemented). System configuration software Sets this bit to enable
    ///< MSI-X. A device driver is prohibited from writing this bit to mask
    ///< a Function's service request. If Clear, the Function is prohibited
    ///< from using MSI-X to request service.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_msix_cap_pci_msix_cap_id_next_ctrl_reg_t;

#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_DEFAULT (0x00100011U)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_RD_MASK (0xc7ffffffU)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_WR_MASK (0xc0000000U)


///< MSI-X Capability ID. This field indicates the MSI-X Capability structure.
///< This field must return a Capability ID of 11h indicating that this
///< is an MSI-X Capability structure.
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_ID_BF_WID ( 8)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_ID_BF_MSK (0x000000FF)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_ID_BF_DEF (0x00000011)

///< MSI-X Next Capability Pointer. This field contains the offset to the
///< next PCI Capability structure or 00h if no other items exist in the
///< linked list of Capabilities.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R  Note: This register field is sticky.
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_NEXT_OFFSET_BF_OFF ( 8)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_NEXT_OFFSET_BF_WID ( 8)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_NEXT_OFFSET_BF_MSK (0x0000FF00)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_CAP_NEXT_OFFSET_BF_DEF (0x00000000)

///< MSI-X Table Size. System software reads this field to determine the
///< MSI-X Table Size N, which is encoded as N-1. For example, a returned
///< value of 000 0000 0011b indicates a table size of 4.  SRIOV Note:
///< All VFs in a single PF have the same value for  MSI-X Table Size
///< (PCI_MSIX_TABLE_SIZE field in SHADOW_PCI_MSIX_CAP_ID_NEXT_CTRL_REG).
///< To write this common value, you must perform a DBI_CS2 write (that
///< is, assert the dbi_cs2 input, or the CS2 address bit for the AXI bridge)
///< while accessing the PCI_MSIX_TABLE_SIZE field in the PF PCI_MSIX_CAP_ID_NEXT_CTRL_REG
///< register.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_TBL_SIZE_BF_OFF (16)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_TBL_SIZE_BF_WID (11)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_TBL_SIZE_BF_MSK (0x07FF0000)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_TBL_SIZE_BF_DEF (0x00100000)

///< Function Mask. If Set, all of the vectors associated with the Function
///< are masked, regardless of their per-vector Mask bit values. If Clear,
///< each vector's Mask bit determines whether the vector is masked or
///< not. Setting or Clearing the MSI-X Function Mask bit has no effect
///< on the value of the per-vector Mask bits.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_FUNCTION_MASK_BF_OFF (30)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_FUNCTION_MASK_BF_WID ( 1)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_FUNCTION_MASK_BF_MSK (0x40000000)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_FUNCTION_MASK_BF_DEF (0x00000000)

///< MSI-X Enable. If Set and the MSI Enable bit in the MSI Message Control
///< Register for MSI is Clear, the Function is permitted to use MSI-X
///< to request service and is prohibited from using INTx interrupts (if
///< implemented). System configuration software Sets this bit to enable
///< MSI-X. A device driver is prohibited from writing this bit to mask
///< a Function's service request. If Clear, the Function is prohibited
///< from using MSI-X to request service.
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_EN_BF_OFF (31)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_EN_BF_WID ( 1)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_EN_BF_MSK (0x80000000)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_PCI_MSIX_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSIX_CAP_MSIX_TABLE_OFFSET_REG register description at address offset 0xb4
  *
  * Register default value:        0x00000005
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSIX_CAP/MSIX_TABLE_OFFSET_REG
  * MSI-X Table Offset and BIR Register.
  */

typedef union {
  struct {
    uint32_t PCI_MSIX_BIR : 3;
    ///< MSI-X Table BAR Indicator Register Field. This field indicates which
    ///< one of a Function's Base Address Registers , located beginning at
    ///< 10h in Configuration Space, or entry in the Enhanced Allocation capability
    ///< with a matching BEI , is used to map the Function's MSI-X Table into
    ///< Memory Space. All encodings other than the defined encodings are reserved.
    ///< For a 64-bit Base Address Register , the Table BIR indicates the lower
    ///< DWORD. For Functions with Type 1 Configuration Space headers, BIR
    ///< values 2 through 5 are also Reserved.  SRIOV Note: All VFs in a single
    ///< PF have the same value for  MSI-X Table BAR Indicator Register  (PCI_MSIX_BIR
    ///< field in SHADOW_MSIX_TABLE_OFFSET_REG). To write this common value,
    ///< you must perform a DBI_CS2 write (that is, assert the dbi_cs2 input,
    ///< or the CS2 address bit for the AXI bridge) while accessing the PCI_MSIX_BIR
    ///< field in the PF MSIX_TABLE_OFFSET_REG register.  Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x5"
    uint32_t PCI_MSIX_TABLE_OFFSET : 29;
    ///< MSI-X Table Offset. Used as an offset from the address contained by
    ///< one of the Function's Base Address Registers to point to the base
    ///< of the MSI-X Table. The lower 3 Table BIR bits are masked off (set
    ///< to zero) by software to form a 32-bit QWORD-aligned offset.  SRIOV
    ///< Note: All VFs in a single PF have the same value for  MSI-X Table
    ///< Offset  (PCI_MSIX_TABLE_OFFSET field in SHADOW_MSIX_TABLE_OFFSET_REG).
    ///< To write this common value, you must perform a DBI_CS2 write (that
    ///< is, assert the dbi_cs2 input, or the CS2 address bit for the AXI bridge)
    ///< while accessing the PCI_MSIX_TABLE_OFFSET field in the PF MSIX_TABLE_OFFSET_REG
    ///< register.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_msix_cap_msix_tbl_offset_reg_t;

#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_DEFAULT (0x00000005U)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_RD_MASK (0xffffffffU)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_WR_MASK (0x00000000U)


///< MSI-X Table BAR Indicator Register Field. This field indicates which
///< one of a Function's Base Address Registers , located beginning at
///< 10h in Configuration Space, or entry in the Enhanced Allocation capability
///< with a matching BEI , is used to map the Function's MSI-X Table into
///< Memory Space. All encodings other than the defined encodings are reserved.
///< For a 64-bit Base Address Register , the Table BIR indicates the lower
///< DWORD. For Functions with Type 1 Configuration Space headers, BIR
///< values 2 through 5 are also Reserved.  SRIOV Note: All VFs in a single
///< PF have the same value for  MSI-X Table BAR Indicator Register  (PCI_MSIX_BIR
///< field in SHADOW_MSIX_TABLE_OFFSET_REG). To write this common value,
///< you must perform a DBI_CS2 write (that is, assert the dbi_cs2 input,
///< or the CS2 address bit for the AXI bridge) while accessing the PCI_MSIX_BIR
///< field in the PF MSIX_TABLE_OFFSET_REG register.  Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
///< is sticky.
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_BIR_BF_OFF ( 0)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_BIR_BF_WID ( 3)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_BIR_BF_MSK (0x00000007)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_BIR_BF_DEF (0x00000005)

///< MSI-X Table Offset. Used as an offset from the address contained by
///< one of the Function's Base Address Registers to point to the base
///< of the MSI-X Table. The lower 3 Table BIR bits are masked off (set
///< to zero) by software to form a 32-bit QWORD-aligned offset.  SRIOV
///< Note: All VFs in a single PF have the same value for  MSI-X Table
///< Offset  (PCI_MSIX_TABLE_OFFSET field in SHADOW_MSIX_TABLE_OFFSET_REG).
///< To write this common value, you must perform a DBI_CS2 write (that
///< is, assert the dbi_cs2 input, or the CS2 address bit for the AXI bridge)
///< while accessing the PCI_MSIX_TABLE_OFFSET field in the PF MSIX_TABLE_OFFSET_REG
///< register.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_TBL_OFFSET_BF_OFF ( 3)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_TBL_OFFSET_BF_WID (29)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_TBL_OFFSET_BF_MSK (0xFFFFFFF8)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_PCI_MSIX_TBL_OFFSET_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MSIX_CAP_MSIX_PBA_OFFSET_REG register description at address offset 0xb8
  *
  * Register default value:        0x00000805
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MSIX_CAP/MSIX_PBA_OFFSET_REG
  * MSI-X PBA Offset and BIR Register.
  */

typedef union {
  struct {
    uint32_t PCI_MSIX_PBA_BIR : 3;
    ///< MSI-X PBA BIR. This field indicates which one of a Function's Base
    ///< Address Registers , located beginning at 10h in Configuration Space,
    ///< or entry in the Enhanced Allocation capability with a matching BEI,
    ///< is used to map the Function's MSI-X PBA into Memory Space. The PBA
    ///< BIR value definitions are identical to those for the Table BIR .
    ///< SRIOV Note: All VFs in a single PF have the same value for  MSI-X
    ///< PBA BIR  (PCI_MSIX_PBA_BIR field in SHADOW_MSIX_PBA_OFFSET_REG). To
    ///< write this common value, you must perform a DBI_CS2 write (that is,
    ///< assert the dbi_cs2 input, or the CS2 address bit for the AXI bridge)
    ///< while accessing the PCI_MSIX_PBA_BIR field in the PF MSIX_PBA_OFFSET_REG
    ///< register.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x5"
    uint32_t PCI_MSIX_PBA_OFFSET : 29;
    ///< MSI-X PBA Offset. Used as an offset from the address contained by
    ///< one of the Function's Base Address Registers to point to the base
    ///< of the MSI-X PBA. The lower 3 PBA BIR bits are masked off (set to
    ///< zero) by software to form a 32-bit QWORD-aligned offset.  SRIOV Note:
    ///< All VFs in a single PF have the same value for  MSI-X PBA Offset
    ///< (PCI_MSIX_PBA_OFFSET field in SHADOW_MSIX_PBA_OFFSET_REG). To write
    ///< this common value, you must perform a DBI_CS2 write (that is, assert
    ///< the dbi_cs2 input, or the CS2 address bit for the AXI bridge) while
    ///< accessing the PCI_MSIX_PBA_OFFSET field in the PF MSIX_PBA_OFFSET_REG
    ///< register.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x100"
  } ;
  uint32_t value;
} pcie_ctl_msix_cap_msix_pba_offset_reg_t;

#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_DEFAULT (0x00000805U)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_RD_MASK (0xffffffffU)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_WR_MASK (0x00000000U)


///< MSI-X PBA BIR. This field indicates which one of a Function's Base
///< Address Registers , located beginning at 10h in Configuration Space,
///< or entry in the Enhanced Allocation capability with a matching BEI,
///< is used to map the Function's MSI-X PBA into Memory Space. The PBA
///< BIR value definitions are identical to those for the Table BIR .
///< SRIOV Note: All VFs in a single PF have the same value for  MSI-X
///< PBA BIR  (PCI_MSIX_PBA_BIR field in SHADOW_MSIX_PBA_OFFSET_REG). To
///< write this common value, you must perform a DBI_CS2 write (that is,
///< assert the dbi_cs2 input, or the CS2 address bit for the AXI bridge)
///< while accessing the PCI_MSIX_PBA_BIR field in the PF MSIX_PBA_OFFSET_REG
///< register.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_BIR_BF_OFF ( 0)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_BIR_BF_WID ( 3)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_BIR_BF_MSK (0x00000007)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_BIR_BF_DEF (0x00000005)

///< MSI-X PBA Offset. Used as an offset from the address contained by
///< one of the Function's Base Address Registers to point to the base
///< of the MSI-X PBA. The lower 3 PBA BIR bits are masked off (set to
///< zero) by software to form a 32-bit QWORD-aligned offset.  SRIOV Note:
///< All VFs in a single PF have the same value for  MSI-X PBA Offset
///< (PCI_MSIX_PBA_OFFSET field in SHADOW_MSIX_PBA_OFFSET_REG). To write
///< this common value, you must perform a DBI_CS2 write (that is, assert
///< the dbi_cs2 input, or the CS2 address bit for the AXI bridge) while
///< accessing the PCI_MSIX_PBA_OFFSET field in the PF MSIX_PBA_OFFSET_REG
///< register.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_OFFSET_BF_OFF ( 3)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_OFFSET_BF_WID (29)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_OFFSET_BF_MSK (0xFFFFFFF8)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_PCI_MSIX_PBA_OFFSET_BF_DEF (0x00000800)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_AER_EXT_CAP_HDR_OFF register description at address offset 0x100
  *
  * Register default value:        0x14820001
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/AER_EXT_CAP_HDR_OFF
  * Advanced Error Reporting Extended Capability Header.
  */

typedef union {
  struct {
    uint32_t CAP_ID : 16;
    ///< AER Extended Capability ID. This field is a PCI-SIG defined ID number
    ///< that indicates the nature and format of the Extended Capability. The
    ///< Extended Capability ID for the Advanced Error Reporting Capability
    ///< is 0001h.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x1"
    uint32_t CAP_VERSION : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present. This
    ///< field must be 2h if the End-End TLP Prefix Supported bit is set and
    ///< must be 1h or 2h otherwise.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x2"
    uint32_t NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Capability structure or 000h if no other items exist in
    ///< the linked list of Capabilities. For Extended Capabilities implemented
    ///< in Configuration Space, this offset is relative to the beginning of
    ///< PCI-compatible Configuration Space and thus must always be either
    ///< 000h (for terminating list of Capabilities) or greater than 0FFh.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x148"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_aer_ext_cap_hdr_off_reg_t;

#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_DEFAULT (0x14820001U)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_WR_MASK (0x00000000U)


///< AER Extended Capability ID. This field is a PCI-SIG defined ID number
///< that indicates the nature and format of the Extended Capability. The
///< Extended Capability ID for the Advanced Error Reporting Capability
///< is 0001h.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_ID_BF_WID (16)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_ID_BF_DEF (0x00000001)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present. This
///< field must be 2h if the End-End TLP Prefix Supported bit is set and
///< must be 1h or 2h otherwise.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_VER_BF_OFF (16)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_VER_BF_WID ( 4)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_VER_BF_MSK (0x000F0000)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_CAP_VER_BF_DEF (0x00020000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Capability structure or 000h if no other items exist in
///< the linked list of Capabilities. For Extended Capabilities implemented
///< in Configuration Space, this offset is relative to the beginning of
///< PCI-compatible Configuration Space and thus must always be either
///< 000h (for terminating list of Capabilities) or greater than 0FFh.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_DEF (0x14800000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_UNCORR_ERR_STATUS_OFF register description at address offset 0x104
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/UNCORR_ERR_STATUS_OFF
  * Uncorrectable Error Status Register.
  */

typedef union {
  struct {
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t DL_PROTOCOL_ERR_STATUS : 1;
    ///< Data Link Protocol Error Status. Status bit for Data Link Protocol
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="4" ResetValue="0x0"
    uint32_t SURPRISE_DOWN_ERR_STATUS : 1;
    ///< Surprise Down Error Status (Optional). Status bit for Surprise Down
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="5" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t POIS_TLP_ERR_STATUS : 1;
    ///< Poisoned TLP Status. Status bit for Poisoned TLP.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="12" ResetValue="0x0"
    uint32_t FC_PROTOCOL_ERR_STATUS : 1;
    ///< Flow Control Protocol Error Status. Status bit for Flow Control Protocol
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="13" ResetValue="0x0"
    uint32_t CMPLT_TIMEOUT_ERR_STATUS : 1;
    ///< Completion Timeout Status. Status for Completion Timeout.   Note:
    ///< This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="14" ResetValue="0x0"
    uint32_t CMPLT_ABORT_ERR_STATUS : 1;
    ///< Completer Abort Status. Status bit for Completer Abort.   Note: This
    ///< register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="15" ResetValue="0x0"
    uint32_t UNEXP_CMPLT_ERR_STATUS : 1;
    ///< Unexpected Completion Status. Status bit for Unexpected Completion.
    ///< Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="16" ResetValue="0x0"
    uint32_t REC_OVERFLOW_ERR_STATUS : 1;
    ///< Receiver Overflow Status. Status bit for Receiver Overflow.   Note:
    ///< This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="17" ResetValue="0x0"
    uint32_t MALF_TLP_ERR_STATUS : 1;
    ///< Malformed TLP Status. This field represents status of Malformed TLP.
    ///< Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="18" ResetValue="0x0"
    uint32_t ECRC_ERR_STATUS : 1;
    ///< ECRC Error Status. This field represents status of ECRC Error.  Note:If
    ///< CX_ECRC_ENABLE=0 the register field always reads 0.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="19" ResetValue="0x0"
    uint32_t UNSUPPORTED_REQ_ERR_STATUS : 1;
    ///< Unsupported Request Error Status. This field represents status of
    ///< Unsupported Request Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="20" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
    uint32_t INTERNAL_ERR_STATUS : 1;
    ///< Uncorrectable Internal Error Status. This field gives status of the
    ///< Uncorrectable Internal Error.  The controller sets this bit when your
    ///< application asserts app_err_bus[9]. It does not set this bit when
    ///< it detects internal uncorrectable internal errors such as parity and
    ///< ECC failures. You should use the outputs from these errors to drive
    ///< the app_err_bus[9] input. For more information, see the  Data Integrity
    ///< (Wire, Datapath, and RAM Protection)  section in the Databook.  This
    ///< register field is reserved for VFs.   Note: This register field is
    ///< sticky.
    ///< AccessType="RW/1C/V" BitOffset="22" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t TLP_PRFX_BLOCKED_ERR_STATUS : 1;
    ///< TLP Prefix Blocked Error Status. Status bit for TLP Prefix Blocked
    ///< Error.  Note: Not supported.   Note: This register field is sticky.
    ///< AccessType="RW/1C" BitOffset="25" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t IDE_CHECK_FAILED_STATUS : 1;
    ///< IDE Check Failed Status (optional). Status bit for IDE Check Failed
    ///< Status.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="28" ResetValue="0x0"
    uint32_t MISROUTED_IDE_TLP_STATUS : 1;
    ///< Misrouted IDE TLP Status (optional). Status bit for Misrouted IDE
    ///< TLP Status.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t PCRC_CHECK_FAILED_STATUS : 1;
    ///< PCRC Check Failed Status (optional). Status bit for PCRC Check Failed
    ///< Status.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_uncorr_err_stat_off_reg_t;

#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_RD_MASK (0x725ff030U)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_WR_MASK (0x725ff030U)


///< Data Link Protocol Error Status. Status bit for Data Link Protocol
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_DL_PROTOCOL_ERR_STAT_BF_OFF ( 4)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_DL_PROTOCOL_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_DL_PROTOCOL_ERR_STAT_BF_MSK (0x00000010)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_DL_PROTOCOL_ERR_STAT_BF_DEF (0x00000000)

///< Surprise Down Error Status (Optional). Status bit for Surprise Down
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_SURPRISE_DOWN_ERR_STAT_BF_OFF ( 5)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_SURPRISE_DOWN_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_SURPRISE_DOWN_ERR_STAT_BF_MSK (0x00000020)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_SURPRISE_DOWN_ERR_STAT_BF_DEF (0x00000000)

///< Poisoned TLP Status. Status bit for Poisoned TLP.   Note: This register
///< field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_POIS_TLP_ERR_STAT_BF_OFF (12)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_POIS_TLP_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_POIS_TLP_ERR_STAT_BF_MSK (0x00001000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_POIS_TLP_ERR_STAT_BF_DEF (0x00000000)

///< Flow Control Protocol Error Status. Status bit for Flow Control Protocol
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_FC_PROTOCOL_ERR_STAT_BF_OFF (13)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_FC_PROTOCOL_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_FC_PROTOCOL_ERR_STAT_BF_MSK (0x00002000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_FC_PROTOCOL_ERR_STAT_BF_DEF (0x00000000)

///< Completion Timeout Status. Status for Completion Timeout.   Note:
///< This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_TIMEOUT_ERR_STAT_BF_OFF (14)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_TIMEOUT_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_TIMEOUT_ERR_STAT_BF_MSK (0x00004000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_TIMEOUT_ERR_STAT_BF_DEF (0x00000000)

///< Completer Abort Status. Status bit for Completer Abort.   Note: This
///< register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_ABORT_ERR_STAT_BF_OFF (15)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_ABORT_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_ABORT_ERR_STAT_BF_MSK (0x00008000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_CMPLT_ABORT_ERR_STAT_BF_DEF (0x00000000)

///< Unexpected Completion Status. Status bit for Unexpected Completion.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNEXP_CMPLT_ERR_STAT_BF_OFF (16)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNEXP_CMPLT_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNEXP_CMPLT_ERR_STAT_BF_MSK (0x00010000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNEXP_CMPLT_ERR_STAT_BF_DEF (0x00000000)

///< Receiver Overflow Status. Status bit for Receiver Overflow.   Note:
///< This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_REC_OVERFLOW_ERR_STAT_BF_OFF (17)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_REC_OVERFLOW_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_REC_OVERFLOW_ERR_STAT_BF_MSK (0x00020000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_REC_OVERFLOW_ERR_STAT_BF_DEF (0x00000000)

///< Malformed TLP Status. This field represents status of Malformed TLP.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MALF_TLP_ERR_STAT_BF_OFF (18)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MALF_TLP_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MALF_TLP_ERR_STAT_BF_MSK (0x00040000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MALF_TLP_ERR_STAT_BF_DEF (0x00000000)

///< ECRC Error Status. This field represents status of ECRC Error.  Note:If
///< CX_ECRC_ENABLE=0 the register field always reads 0.   Note: This register
///< field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_ECRC_ERR_STAT_BF_OFF (19)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_ECRC_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_ECRC_ERR_STAT_BF_MSK (0x00080000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_ECRC_ERR_STAT_BF_DEF (0x00000000)

///< Unsupported Request Error Status. This field represents status of
///< Unsupported Request Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNSUPPORTED_REQ_ERR_STAT_BF_OFF (20)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNSUPPORTED_REQ_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNSUPPORTED_REQ_ERR_STAT_BF_MSK (0x00100000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_UNSUPPORTED_REQ_ERR_STAT_BF_DEF (0x00000000)

///< Uncorrectable Internal Error Status. This field gives status of the
///< Uncorrectable Internal Error.  The controller sets this bit when your
///< application asserts app_err_bus[9]. It does not set this bit when
///< it detects internal uncorrectable internal errors such as parity and
///< ECC failures. You should use the outputs from these errors to drive
///< the app_err_bus[9] input. For more information, see the  Data Integrity
///< (Wire, Datapath, and RAM Protection)  section in the Databook.  This
///< register field is reserved for VFs.   Note: This register field is
///< sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_INTERNAL_ERR_STAT_BF_OFF (22)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_INTERNAL_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_INTERNAL_ERR_STAT_BF_MSK (0x00400000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_INTERNAL_ERR_STAT_BF_DEF (0x00000000)

///< TLP Prefix Blocked Error Status. Status bit for TLP Prefix Blocked
///< Error.  Note: Not supported.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_TLP_PRFX_BLKED_ERR_STAT_BF_OFF (25)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_TLP_PRFX_BLKED_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_TLP_PRFX_BLKED_ERR_STAT_BF_MSK (0x02000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_TLP_PRFX_BLKED_ERR_STAT_BF_DEF (0x00000000)

///< IDE Check Failed Status (optional). Status bit for IDE Check Failed
///< Status.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_IDE_CHECK_FAILED_STAT_BF_OFF (28)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_IDE_CHECK_FAILED_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_IDE_CHECK_FAILED_STAT_BF_MSK (0x10000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_IDE_CHECK_FAILED_STAT_BF_DEF (0x00000000)

///< Misrouted IDE TLP Status (optional). Status bit for Misrouted IDE
///< TLP Status.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MISROUTED_IDE_TLP_STAT_BF_OFF (29)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MISROUTED_IDE_TLP_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MISROUTED_IDE_TLP_STAT_BF_MSK (0x20000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_MISROUTED_IDE_TLP_STAT_BF_DEF (0x00000000)

///< PCRC Check Failed Status (optional). Status bit for PCRC Check Failed
///< Status.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_PCRC_CHECK_FAILED_STAT_BF_OFF (30)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_PCRC_CHECK_FAILED_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_PCRC_CHECK_FAILED_STAT_BF_MSK (0x40000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_PCRC_CHECK_FAILED_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_UNCORR_ERR_MASK_OFF register description at address offset 0x108
  *
  * Register default value:        0x00400000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/UNCORR_ERR_MASK_OFF
  * Uncorrectable Error Mask Register.
  */

typedef union {
  struct {
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t DL_PROTOCOL_ERR_MASK : 1;
    ///< Data Link Protocol Error Mask. This field informs whether Data Link
    ///< Protocol Error is masked or not.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SURPRISE_DOWN_ERR_MASK : 1;
    ///< Surprise Down Error Mask. Mask bit for Surprise Down Error.   Note:
    ///< This register field is sticky.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t POIS_TLP_ERR_MASK : 1;
    ///< Poisoned TLP Error Mask. Mask bit for Poisoned TLP Error.   Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t FC_PROTOCOL_ERR_MASK : 1;
    ///< Flow Control Protocol Error Mask. Mask bit for Flow Control Protocol
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CMPLT_TIMEOUT_ERR_MASK : 1;
    ///< Completion Timeout Error Mask. Mask bit for Completion Timeout Error.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CMPLT_ABORT_ERR_MASK : 1;
    ///< Completer Abort Error Mask (Optional). Mask bit for Completer Abort
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t UNEXP_CMPLT_ERR_MASK : 1;
    ///< Unexpected Completion Mask. Mask bit for Unexpected Completion Error.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t REC_OVERFLOW_ERR_MASK : 1;
    ///< Receiver Overflow Mask (Optional). This field represents Receiver
    ///< Overflow Mask.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t MALF_TLP_ERR_MASK : 1;
    ///< Malformed TLP Mask. Mask bit for Malformed TLP.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t ECRC_ERR_MASK : 1;
    ///< ECRC Error Mask (Optional). Mask bit for ECRC Error.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W (sticky)   -
    ///< Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t UNSUPPORTED_REQ_ERR_MASK : 1;
    ///< Unsupported Request Error Mask. Mask bit for Unsupported Request Error.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
    uint32_t INTERNAL_ERR_MASK : 1;
    ///< Uncorrectable Internal Error Mask (Optional). Mask bit for Uncorrectable
    ///< Internal Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t ATOMIC_EGRESS_BLOCKED_ERR_MASK : 1;
    ///< AtomicOp Egress Block Mask (Optional). Mask bit for AtomicOp Egress
    ///< Block Error.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
    uint32_t TLP_PRFX_BLOCKED_ERR_MASK : 1;
    ///< TLP Prefix Blocked Error Mask. Mask bit for TLP Prefix Blocked Error.
    ///< Note: Not supported.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="25" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t DMWR_EGRESS_BLOCKED_ERR_MASK : 1;
    ///< Deferrable Memory Write Egress Block Mask (Optional). Mask bit for
    ///< Deferrable Memory Write Egress Block Error.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="27" ResetValue="0x0"
    uint32_t IDE_CHECK_FAILED_MASK : 1;
    ///< IDE Check Failed Mask (optional)   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t MISROUTED_IDE_TLP_MASK : 1;
    ///< Misrouted IDE TLP Mask (optional)   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t PCRC_CHECK_FAILED_MASK : 1;
    ///< PCRC Check Failed Mask (optional)   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_uncorr_err_mask_off_reg_t;

#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DEFAULT (0x00400000U)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_RD_MASK (0x7b5ff030U)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_WR_MASK (0x705ff010U)


///< Data Link Protocol Error Mask. This field informs whether Data Link
///< Protocol Error is masked or not.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DL_PROTOCOL_ERR_MASK_BF_OFF ( 4)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DL_PROTOCOL_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DL_PROTOCOL_ERR_MASK_BF_MSK (0x00000010)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DL_PROTOCOL_ERR_MASK_BF_DEF (0x00000000)

///< Surprise Down Error Mask. Mask bit for Surprise Down Error.   Note:
///< This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_SURPRISE_DOWN_ERR_MASK_BF_OFF ( 5)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_SURPRISE_DOWN_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_SURPRISE_DOWN_ERR_MASK_BF_MSK (0x00000020)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_SURPRISE_DOWN_ERR_MASK_BF_DEF (0x00000000)

///< Poisoned TLP Error Mask. Mask bit for Poisoned TLP Error.   Note:
///< This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_POIS_TLP_ERR_MASK_BF_OFF (12)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_POIS_TLP_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_POIS_TLP_ERR_MASK_BF_MSK (0x00001000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_POIS_TLP_ERR_MASK_BF_DEF (0x00000000)

///< Flow Control Protocol Error Mask. Mask bit for Flow Control Protocol
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_FC_PROTOCOL_ERR_MASK_BF_OFF (13)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_FC_PROTOCOL_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_FC_PROTOCOL_ERR_MASK_BF_MSK (0x00002000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_FC_PROTOCOL_ERR_MASK_BF_DEF (0x00000000)

///< Completion Timeout Error Mask. Mask bit for Completion Timeout Error.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_TIMEOUT_ERR_MASK_BF_OFF (14)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_TIMEOUT_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_TIMEOUT_ERR_MASK_BF_MSK (0x00004000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_TIMEOUT_ERR_MASK_BF_DEF (0x00000000)

///< Completer Abort Error Mask (Optional). Mask bit for Completer Abort
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_ABORT_ERR_MASK_BF_OFF (15)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_ABORT_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_ABORT_ERR_MASK_BF_MSK (0x00008000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_CMPLT_ABORT_ERR_MASK_BF_DEF (0x00000000)

///< Unexpected Completion Mask. Mask bit for Unexpected Completion Error.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNEXP_CMPLT_ERR_MASK_BF_OFF (16)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNEXP_CMPLT_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNEXP_CMPLT_ERR_MASK_BF_MSK (0x00010000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNEXP_CMPLT_ERR_MASK_BF_DEF (0x00000000)

///< Receiver Overflow Mask (Optional). This field represents Receiver
///< Overflow Mask.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_REC_OVERFLOW_ERR_MASK_BF_OFF (17)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_REC_OVERFLOW_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_REC_OVERFLOW_ERR_MASK_BF_MSK (0x00020000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_REC_OVERFLOW_ERR_MASK_BF_DEF (0x00000000)

///< Malformed TLP Mask. Mask bit for Malformed TLP.   Note: This register
///< field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MALF_TLP_ERR_MASK_BF_OFF (18)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MALF_TLP_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MALF_TLP_ERR_MASK_BF_MSK (0x00040000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MALF_TLP_ERR_MASK_BF_DEF (0x00000000)

///< ECRC Error Mask (Optional). Mask bit for ECRC Error.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W (sticky)   -
///< Dbi: R/W (sticky)  Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ECRC_ERR_MASK_BF_OFF (19)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ECRC_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ECRC_ERR_MASK_BF_MSK (0x00080000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ECRC_ERR_MASK_BF_DEF (0x00000000)

///< Unsupported Request Error Mask. Mask bit for Unsupported Request Error.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNSUPPORTED_REQ_ERR_MASK_BF_OFF (20)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNSUPPORTED_REQ_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNSUPPORTED_REQ_ERR_MASK_BF_MSK (0x00100000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_UNSUPPORTED_REQ_ERR_MASK_BF_DEF (0x00000000)

///< Uncorrectable Internal Error Mask (Optional). Mask bit for Uncorrectable
///< Internal Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_INTERNAL_ERR_MASK_BF_OFF (22)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_INTERNAL_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_INTERNAL_ERR_MASK_BF_MSK (0x00400000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_INTERNAL_ERR_MASK_BF_DEF (0x00400000)

///< AtomicOp Egress Block Mask (Optional). Mask bit for AtomicOp Egress
///< Block Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ATOMIC_EGRESS_BLKED_ERR_MASK_BF_OFF (24)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ATOMIC_EGRESS_BLKED_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ATOMIC_EGRESS_BLKED_ERR_MASK_BF_MSK (0x01000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ATOMIC_EGRESS_BLKED_ERR_MASK_BF_DEF (0x00000000)

///< TLP Prefix Blocked Error Mask. Mask bit for TLP Prefix Blocked Error.
///< Note: Not supported.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_TLP_PRFX_BLKED_ERR_MASK_BF_OFF (25)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_TLP_PRFX_BLKED_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_TLP_PRFX_BLKED_ERR_MASK_BF_MSK (0x02000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_TLP_PRFX_BLKED_ERR_MASK_BF_DEF (0x00000000)

///< Deferrable Memory Write Egress Block Mask (Optional). Mask bit for
///< Deferrable Memory Write Egress Block Error.   Note: This register
///< field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DMWR_EGRESS_BLKED_ERR_MASK_BF_OFF (27)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DMWR_EGRESS_BLKED_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DMWR_EGRESS_BLKED_ERR_MASK_BF_MSK (0x08000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_DMWR_EGRESS_BLKED_ERR_MASK_BF_DEF (0x00000000)

///< IDE Check Failed Mask (optional)   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_IDE_CHECK_FAILED_MASK_BF_OFF (28)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_IDE_CHECK_FAILED_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_IDE_CHECK_FAILED_MASK_BF_MSK (0x10000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_IDE_CHECK_FAILED_MASK_BF_DEF (0x00000000)

///< Misrouted IDE TLP Mask (optional)   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MISROUTED_IDE_TLP_MASK_BF_OFF (29)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MISROUTED_IDE_TLP_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MISROUTED_IDE_TLP_MASK_BF_MSK (0x20000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_MISROUTED_IDE_TLP_MASK_BF_DEF (0x00000000)

///< PCRC Check Failed Mask (optional)   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_PCRC_CHECK_FAILED_MASK_BF_OFF (30)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_PCRC_CHECK_FAILED_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_PCRC_CHECK_FAILED_MASK_BF_MSK (0x40000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_PCRC_CHECK_FAILED_MASK_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_UNCORR_ERR_SEV_OFF register description at address offset 0x10c
  *
  * Register default value:        0x10462030
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/UNCORR_ERR_SEV_OFF
  * Uncorrectable Error Severity Register.
  */

typedef union {
  struct {
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t DL_PROTOCOL_ERR_SEVERITY : 1;
    ///< Data Link Protocol Error Severity. Severity bit for Data Link Protocol
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t SURPRISE_DOWN_ERR_SVRITY : 1;
    ///< Surprise Down Error Severity (Optional). Severity bit for Surprise
    ///< Down Error.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x1"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t POIS_TLP_ERR_SEVERITY : 1;
    ///< Poisoned TLP Severity. Severity bit for Poisoned TLP.   Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t FC_PROTOCOL_ERR_SEVERITY : 1;
    ///< Flow Control Protocol Error Severity (Optional). Severity bit for
    ///< Flow Control Protocol Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t CMPLT_TIMEOUT_ERR_SEVERITY : 1;
    ///< Completion Timeout Error Severity. Severity bit for Completion Timeout
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CMPLT_ABORT_ERR_SEVERITY : 1;
    ///< Completer Abort Error Severity (Optional). Severity bit for Completer
    ///< Abort Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t UNEXP_CMPLT_ERR_SEVERITY : 1;
    ///< Unexpected Completion Error Severity. Severity bit for Unexpected
    ///< Completion Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t REC_OVERFLOW_ERR_SEVERITY : 1;
    ///< Receiver Overflow Error Severity (Optional). Severity bit for Receiver
    ///< Overflow Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint32_t MALF_TLP_ERR_SEVERITY : 1;
    ///< Malformed TLP Severity. Severity bit for Malformed TLP.   Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint32_t ECRC_ERR_SEVERITY : 1;
    ///< ECRC Error Severity (Optional). Severity bit for ECRC Error.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W (sticky)
    ///< - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t UNSUPPORTED_REQ_ERR_SEVERITY : 1;
    ///< Unsupported Request Error Severity. Severity bit for Unsupported Request
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
    uint32_t INTERNAL_ERR_SEVERITY : 1;
    ///< Uncorrectable Internal Error Severity (Optional). Severity bit for
    ///< Uncorrectable Internal Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x1"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t TLP_PRFX_BLOCKED_ERR_SEVERITY : 1;
    ///< TLP Prefix Blocked Error Severity (Optional). Severity bit for TLP
    ///< Prefix Blocked Error.  Note: Not supported.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="25" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t DMWR_EGRESS_BLOCKED_ERR_SEVERITY : 1;
    ///< Deferrable Memory Write Egress Blocked Severity (Optional). Severity
    ///< bit for Deferrable Memory Write Egress Blocked Error.   Note: This
    ///< register field is sticky.
    ///< AccessType="RO" BitOffset="27" ResetValue="0x0"
    uint32_t IDE_CHECK_FAILED_SEV : 1;
    ///< IDE Check Failed Severity (optional)   Note: This register field is
    ///< sticky.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint32_t MISROUTED_IDE_TLP_SEV : 1;
    ///< Misrouted IDE TLP Severity (optional)   Note: This register field
    ///< is sticky.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t PCRC_CHECK_FAILED_SEV : 1;
    ///< PCRC Check Failed Severity (optional)   Note: This register field
    ///< is sticky.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_uncorr_err_sev_off_reg_t;

#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DEFAULT (0x10462030U)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_RD_MASK (0x7a5ff030U)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_WR_MASK (0x705ff010U)


///< Data Link Protocol Error Severity. Severity bit for Data Link Protocol
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DL_PROTOCOL_ERR_SEVERITY_BF_OFF ( 4)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DL_PROTOCOL_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DL_PROTOCOL_ERR_SEVERITY_BF_MSK (0x00000010)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DL_PROTOCOL_ERR_SEVERITY_BF_DEF (0x00000010)

///< Surprise Down Error Severity (Optional). Severity bit for Surprise
///< Down Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_SURPRISE_DOWN_ERR_SVRITY_BF_OFF ( 5)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_SURPRISE_DOWN_ERR_SVRITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_SURPRISE_DOWN_ERR_SVRITY_BF_MSK (0x00000020)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_SURPRISE_DOWN_ERR_SVRITY_BF_DEF (0x00000020)

///< Poisoned TLP Severity. Severity bit for Poisoned TLP.   Note: This
///< register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_POIS_TLP_ERR_SEVERITY_BF_OFF (12)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_POIS_TLP_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_POIS_TLP_ERR_SEVERITY_BF_MSK (0x00001000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_POIS_TLP_ERR_SEVERITY_BF_DEF (0x00000000)

///< Flow Control Protocol Error Severity (Optional). Severity bit for
///< Flow Control Protocol Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_FC_PROTOCOL_ERR_SEVERITY_BF_OFF (13)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_FC_PROTOCOL_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_FC_PROTOCOL_ERR_SEVERITY_BF_MSK (0x00002000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_FC_PROTOCOL_ERR_SEVERITY_BF_DEF (0x00002000)

///< Completion Timeout Error Severity. Severity bit for Completion Timeout
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_TIMEOUT_ERR_SEVERITY_BF_OFF (14)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_TIMEOUT_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_TIMEOUT_ERR_SEVERITY_BF_MSK (0x00004000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_TIMEOUT_ERR_SEVERITY_BF_DEF (0x00000000)

///< Completer Abort Error Severity (Optional). Severity bit for Completer
///< Abort Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_ABORT_ERR_SEVERITY_BF_OFF (15)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_ABORT_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_ABORT_ERR_SEVERITY_BF_MSK (0x00008000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_CMPLT_ABORT_ERR_SEVERITY_BF_DEF (0x00000000)

///< Unexpected Completion Error Severity. Severity bit for Unexpected
///< Completion Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNEXP_CMPLT_ERR_SEVERITY_BF_OFF (16)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNEXP_CMPLT_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNEXP_CMPLT_ERR_SEVERITY_BF_MSK (0x00010000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNEXP_CMPLT_ERR_SEVERITY_BF_DEF (0x00000000)

///< Receiver Overflow Error Severity (Optional). Severity bit for Receiver
///< Overflow Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_REC_OVERFLOW_ERR_SEVERITY_BF_OFF (17)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_REC_OVERFLOW_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_REC_OVERFLOW_ERR_SEVERITY_BF_MSK (0x00020000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_REC_OVERFLOW_ERR_SEVERITY_BF_DEF (0x00020000)

///< Malformed TLP Severity. Severity bit for Malformed TLP.   Note: This
///< register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MALF_TLP_ERR_SEVERITY_BF_OFF (18)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MALF_TLP_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MALF_TLP_ERR_SEVERITY_BF_MSK (0x00040000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MALF_TLP_ERR_SEVERITY_BF_DEF (0x00040000)

///< ECRC Error Severity (Optional). Severity bit for ECRC Error.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W (sticky)
///< - Dbi: R/W (sticky)  Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_ECRC_ERR_SEVERITY_BF_OFF (19)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_ECRC_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_ECRC_ERR_SEVERITY_BF_MSK (0x00080000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_ECRC_ERR_SEVERITY_BF_DEF (0x00000000)

///< Unsupported Request Error Severity. Severity bit for Unsupported Request
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNSUPPORTED_REQ_ERR_SEVERITY_BF_OFF (20)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNSUPPORTED_REQ_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNSUPPORTED_REQ_ERR_SEVERITY_BF_MSK (0x00100000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_UNSUPPORTED_REQ_ERR_SEVERITY_BF_DEF (0x00000000)

///< Uncorrectable Internal Error Severity (Optional). Severity bit for
///< Uncorrectable Internal Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_INTERNAL_ERR_SEVERITY_BF_OFF (22)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_INTERNAL_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_INTERNAL_ERR_SEVERITY_BF_MSK (0x00400000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_INTERNAL_ERR_SEVERITY_BF_DEF (0x00400000)

///< TLP Prefix Blocked Error Severity (Optional). Severity bit for TLP
///< Prefix Blocked Error.  Note: Not supported.   Note: This register
///< field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_TLP_PRFX_BLKED_ERR_SEVERITY_BF_OFF (25)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_TLP_PRFX_BLKED_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_TLP_PRFX_BLKED_ERR_SEVERITY_BF_MSK (0x02000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_TLP_PRFX_BLKED_ERR_SEVERITY_BF_DEF (0x00000000)

///< Deferrable Memory Write Egress Blocked Severity (Optional). Severity
///< bit for Deferrable Memory Write Egress Blocked Error.   Note: This
///< register field is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DMWR_EGRESS_BLKED_ERR_SEVERITY_BF_OFF (27)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DMWR_EGRESS_BLKED_ERR_SEVERITY_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DMWR_EGRESS_BLKED_ERR_SEVERITY_BF_MSK (0x08000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_DMWR_EGRESS_BLKED_ERR_SEVERITY_BF_DEF (0x00000000)

///< IDE Check Failed Severity (optional)   Note: This register field is
///< sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_IDE_CHECK_FAILED_SEV_BF_OFF (28)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_IDE_CHECK_FAILED_SEV_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_IDE_CHECK_FAILED_SEV_BF_MSK (0x10000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_IDE_CHECK_FAILED_SEV_BF_DEF (0x10000000)

///< Misrouted IDE TLP Severity (optional)   Note: This register field
///< is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MISROUTED_IDE_TLP_SEV_BF_OFF (29)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MISROUTED_IDE_TLP_SEV_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MISROUTED_IDE_TLP_SEV_BF_MSK (0x20000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_MISROUTED_IDE_TLP_SEV_BF_DEF (0x00000000)

///< PCRC Check Failed Severity (optional)   Note: This register field
///< is sticky.
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_PCRC_CHECK_FAILED_SEV_BF_OFF (30)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_PCRC_CHECK_FAILED_SEV_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_PCRC_CHECK_FAILED_SEV_BF_MSK (0x40000000)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_PCRC_CHECK_FAILED_SEV_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_CORR_ERR_STATUS_OFF register description at address offset 0x110
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/CORR_ERR_STATUS_OFF
  * Correctable Error Status Register.
  */

typedef union {
  struct {
    uint32_t RX_ERR_STATUS : 1;
    ///< Receiver Error Status (Optional). This field provides status of Receiver
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
    uint32_t BAD_TLP_STATUS : 1;
    ///< Bad TLP Status. Status bit for Bad TLP.   Note: This register field
    ///< is sticky.
    ///< AccessType="RW/1C/V" BitOffset="6" ResetValue="0x0"
    uint32_t BAD_DLLP_STATUS : 1;
    ///< Bad DLLP Status. Status bit for Bad DLLP.   Note: This register field
    ///< is sticky.
    ///< AccessType="RW/1C/V" BitOffset="7" ResetValue="0x0"
    uint32_t REPLAY_NO_ROLEOVER_STATUS : 1;
    ///< REPLAY_NUM Rollover Status. Status bit for REPLAY_NUM Rollover.
    ///< Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="8" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
    uint32_t RPL_TIMER_TIMEOUT_STATUS : 1;
    ///< Replay Timer Timeout Status. Status bit for Replay Timer Timeout.
    ///< Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="12" ResetValue="0x0"
    uint32_t ADVISORY_NON_FATAL_ERR_STATUS : 1;
    ///< Advisory Non-Fatal Error Status. Status bit for Advisory Non-Fatal
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="13" ResetValue="0x0"
    uint32_t CORRECTED_INT_ERR_STATUS : 1;
    ///< Corrected Internal Error Status (Optional). This field provides status
    ///< of Corrected Internal Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="14" ResetValue="0x0"
    uint32_t HEADER_LOG_OVERFLOW_STATUS : 1;
    ///< Header Log Overflow Error Status (Optional). This field provides status
    ///< of Header Log Overflow Error.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="15" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_corr_err_stat_off_reg_t;

#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RD_MASK (0x0000f1c1U)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_WR_MASK (0x0000f1c1U)


///< Receiver Error Status (Optional). This field provides status of Receiver
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RX_ERR_STAT_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RX_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RX_ERR_STAT_BF_MSK (0x00000001)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RX_ERR_STAT_BF_DEF (0x00000000)

///< Bad TLP Status. Status bit for Bad TLP.   Note: This register field
///< is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_TLP_STAT_BF_OFF ( 6)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_TLP_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_TLP_STAT_BF_MSK (0x00000040)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_TLP_STAT_BF_DEF (0x00000000)

///< Bad DLLP Status. Status bit for Bad DLLP.   Note: This register field
///< is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_DLLP_STAT_BF_OFF ( 7)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_DLLP_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_DLLP_STAT_BF_MSK (0x00000080)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_BAD_DLLP_STAT_BF_DEF (0x00000000)

///< REPLAY_NUM Rollover Status. Status bit for REPLAY_NUM Rollover.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_REPLAY_NO_ROLEOVER_STAT_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_REPLAY_NO_ROLEOVER_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_REPLAY_NO_ROLEOVER_STAT_BF_MSK (0x00000100)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_REPLAY_NO_ROLEOVER_STAT_BF_DEF (0x00000000)

///< Replay Timer Timeout Status. Status bit for Replay Timer Timeout.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RPL_TIMER_TIMEOUT_STAT_BF_OFF (12)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RPL_TIMER_TIMEOUT_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RPL_TIMER_TIMEOUT_STAT_BF_MSK (0x00001000)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_RPL_TIMER_TIMEOUT_STAT_BF_DEF (0x00000000)

///< Advisory Non-Fatal Error Status. Status bit for Advisory Non-Fatal
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_ADVISORY_NON_FATAL_ERR_STAT_BF_OFF (13)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_ADVISORY_NON_FATAL_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_ADVISORY_NON_FATAL_ERR_STAT_BF_MSK (0x00002000)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_ADVISORY_NON_FATAL_ERR_STAT_BF_DEF (0x00000000)

///< Corrected Internal Error Status (Optional). This field provides status
///< of Corrected Internal Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_CORRECTED_INT_ERR_STAT_BF_OFF (14)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_CORRECTED_INT_ERR_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_CORRECTED_INT_ERR_STAT_BF_MSK (0x00004000)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_CORRECTED_INT_ERR_STAT_BF_DEF (0x00000000)

///< Header Log Overflow Error Status (Optional). This field provides status
///< of Header Log Overflow Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_HEADER_LOG_OVERFLOW_STAT_BF_OFF (15)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_HEADER_LOG_OVERFLOW_STAT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_HEADER_LOG_OVERFLOW_STAT_BF_MSK (0x00008000)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_HEADER_LOG_OVERFLOW_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_CORR_ERR_MASK_OFF register description at address offset 0x114
  *
  * Register default value:        0x0000E000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/CORR_ERR_MASK_OFF
  * Correctable Error Mask Register.
  */

typedef union {
  struct {
    uint32_t RX_ERR_MASK : 1;
    ///< Receiver Error Mask (Optional). Masking bit for Receiver Error.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
    uint32_t BAD_TLP_MASK : 1;
    ///< Bad TLP Mask. Masking bit for Bad TLP.   Note: This register field
    ///< is sticky.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t BAD_DLLP_MASK : 1;
    ///< Bad DLLP Mask. Masking bit for Bad DLLP.   Note: This register field
    ///< is sticky.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t REPLAY_NO_ROLEOVER_MASK : 1;
    ///< REPLAY_NUM Rollover Mask. Masking bit for REPLAY_NUM Rollover.   Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
    uint32_t RPL_TIMER_TIMEOUT_MASK : 1;
    ///< Replay Timer Timeout Mask. Masking bit for Replay Timer Timeout.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t ADVISORY_NON_FATAL_ERR_MASK : 1;
    ///< Advisory Non-Fatal Error Mask. Masking bit for Advisory Non-Fatal
    ///< Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t CORRECTED_INT_ERR_MASK : 1;
    ///< Corrected Internal Error Mask (Optional). Masking bit for Corrected
    ///< Internal Error Mask.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint32_t HEADER_LOG_OVERFLOW_MASK : 1;
    ///< Header Log Overflow Error Mask (Optional). Masking bit for Header
    ///< Log Overflow Error.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x1"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_corr_err_mask_off_reg_t;

#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_DEFAULT (0x0000e000U)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RD_MASK (0x0000f1c1U)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_WR_MASK (0x0000f1c1U)


///< Receiver Error Mask (Optional). Masking bit for Receiver Error.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RX_ERR_MASK_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RX_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RX_ERR_MASK_BF_MSK (0x00000001)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RX_ERR_MASK_BF_DEF (0x00000000)

///< Bad TLP Mask. Masking bit for Bad TLP.   Note: This register field
///< is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_TLP_MASK_BF_OFF ( 6)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_TLP_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_TLP_MASK_BF_MSK (0x00000040)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_TLP_MASK_BF_DEF (0x00000000)

///< Bad DLLP Mask. Masking bit for Bad DLLP.   Note: This register field
///< is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_DLLP_MASK_BF_OFF ( 7)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_DLLP_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_DLLP_MASK_BF_MSK (0x00000080)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_BAD_DLLP_MASK_BF_DEF (0x00000000)

///< REPLAY_NUM Rollover Mask. Masking bit for REPLAY_NUM Rollover.   Note:
///< This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_REPLAY_NO_ROLEOVER_MASK_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_REPLAY_NO_ROLEOVER_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_REPLAY_NO_ROLEOVER_MASK_BF_MSK (0x00000100)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_REPLAY_NO_ROLEOVER_MASK_BF_DEF (0x00000000)

///< Replay Timer Timeout Mask. Masking bit for Replay Timer Timeout.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RPL_TIMER_TIMEOUT_MASK_BF_OFF (12)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RPL_TIMER_TIMEOUT_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RPL_TIMER_TIMEOUT_MASK_BF_MSK (0x00001000)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_RPL_TIMER_TIMEOUT_MASK_BF_DEF (0x00000000)

///< Advisory Non-Fatal Error Mask. Masking bit for Advisory Non-Fatal
///< Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_ADVISORY_NON_FATAL_ERR_MASK_BF_OFF (13)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_ADVISORY_NON_FATAL_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_ADVISORY_NON_FATAL_ERR_MASK_BF_MSK (0x00002000)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_ADVISORY_NON_FATAL_ERR_MASK_BF_DEF (0x00002000)

///< Corrected Internal Error Mask (Optional). Masking bit for Corrected
///< Internal Error Mask.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_CORRECTED_INT_ERR_MASK_BF_OFF (14)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_CORRECTED_INT_ERR_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_CORRECTED_INT_ERR_MASK_BF_MSK (0x00004000)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_CORRECTED_INT_ERR_MASK_BF_DEF (0x00004000)

///< Header Log Overflow Error Mask (Optional). Masking bit for Header
///< Log Overflow Error.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_HEADER_LOG_OVERFLOW_MASK_BF_OFF (15)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_HEADER_LOG_OVERFLOW_MASK_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_HEADER_LOG_OVERFLOW_MASK_BF_MSK (0x00008000)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_HEADER_LOG_OVERFLOW_MASK_BF_DEF (0x00008000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_ADV_ERR_CAP_CTRL_OFF register description at address offset 0x118
  *
  * Register default value:        0x000000A0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/ADV_ERR_CAP_CTRL_OFF
  * Advanced Error Capabilities and Control Register.
  */

typedef union {
  struct {
    uint32_t FIRST_ERR_POINTER : 5;
    ///< First Error Pointer. The First Error Pointer is a field that identifies
    ///< the bit position of the first error reported in the Uncorrectable
    ///< Error Status register.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ECRC_GEN_CAP : 1;
    ///< ECRC Generation Capable. If Set, this bit indicates that the Function
    ///< is capable of generating ECRC.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x1"
    uint32_t ECRC_GEN_EN : 1;
    ///< ECRC Generation Enable. When Set, ECRC generation is enabled. Functions
    ///< that do not implement the associated mechanism are permitted to hardwire
    ///< this bit to 0b. Default value of this bit is 0b.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t ECRC_CHECK_CAP : 1;
    ///< ECRC Check Capable. If Set, this bit indicates that the Function is
    ///< capable of checking ECRC.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
    ///< then R/W(sticky) else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="7" ResetValue="0x1"
    uint32_t ECRC_CHECK_EN : 1;
    ///< ECRC Check Enable. When Set, ECRC checking is enabled. Functions that
    ///< do not implement the associated mechanism are permitted to hardwire
    ///< this bit to 0b. Default value of this bit is 0b.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t MULTIPLE_HEADER_CAP : 1;
    ///< Multiple Header Recording Capable. If Set, this bit indicates that
    ///< the Function is capable of recording more than one error header.
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t MULTIPLE_HEADER_EN : 1;
    ///< Multiple Header Recording Enable. When Set, this bit enables the Function
    ///< to record more than one error header. Functions that do not implement
    ///< the associated mechanism are permitted to hardwire this bit to 0b.
    ///< Default value of this bit is 0b.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t TLP_PRFX_LOG_PRESENT : 1;
    ///< TLP Prefix Log Present. If Set and the First Error Pointer is valid,
    ///< indicates that the TLP Prefix Log register contains valid information.
    ///< If Clear or if First Error Pointer is invalid, the TLP Prefix Log
    ///< register is undefined. Default value of this bit is 0. This bit is
    ///< RsvdP if the End-End TLP Prefix Supported bit is Clear.   Note: This
    ///< register field is sticky.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t CTO_PRFX_HDR_LOG_CAP : 1;
    ///< Completion Timeout Prefix/Header Log Capable. If Set, this bit indicates
    ///< that the Function records the prefix/header of Request TLPs that experience
    ///< a Completion Timeout error.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
    uint32_t  : 19;
    ///< Reserved
    ///< AccessType="RO" BitOffset="13" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_adv_err_cap_ctrl_off_reg_t;

#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_DEFAULT (0x000000a0U)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_RD_MASK (0x00001fffU)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_WR_MASK (0x00000140U)


///< First Error Pointer. The First Error Pointer is a field that identifies
///< the bit position of the first error reported in the Uncorrectable
///< Error Status register.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_PTR_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_PTR_BF_WID ( 5)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_PTR_BF_MSK (0x0000001F)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_PTR_BF_DEF (0x00000000)

///< ECRC Generation Capable. If Set, this bit indicates that the Function
///< is capable of generating ECRC.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_CAP_BF_OFF ( 5)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_CAP_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_CAP_BF_MSK (0x00000020)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_CAP_BF_DEF (0x00000020)

///< ECRC Generation Enable. When Set, ECRC generation is enabled. Functions
///< that do not implement the associated mechanism are permitted to hardwire
///< this bit to 0b. Default value of this bit is 0b.   Note: This register
///< field is sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_EN_BF_OFF ( 6)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_EN_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_EN_BF_MSK (0x00000040)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_EN_BF_DEF (0x00000000)

///< ECRC Check Capable. If Set, this bit indicates that the Function is
///< capable of checking ECRC.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1)
///< then R/W(sticky) else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_CAP_BF_OFF ( 7)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_CAP_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_CAP_BF_MSK (0x00000080)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_CAP_BF_DEF (0x00000080)

///< ECRC Check Enable. When Set, ECRC checking is enabled. Functions that
///< do not implement the associated mechanism are permitted to hardwire
///< this bit to 0b. Default value of this bit is 0b.   Note: This register
///< field is sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_EN_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_EN_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_EN_BF_MSK (0x00000100)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_EN_BF_DEF (0x00000000)

///< Multiple Header Recording Capable. If Set, this bit indicates that
///< the Function is capable of recording more than one error header.
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_CAP_BF_OFF ( 9)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_CAP_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_CAP_BF_MSK (0x00000200)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_CAP_BF_DEF (0x00000000)

///< Multiple Header Recording Enable. When Set, this bit enables the Function
///< to record more than one error header. Functions that do not implement
///< the associated mechanism are permitted to hardwire this bit to 0b.
///< Default value of this bit is 0b.   Note: The access attributes of
///< this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_EN_BF_OFF (10)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_EN_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_EN_BF_MSK (0x00000400)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_EN_BF_DEF (0x00000000)

///< TLP Prefix Log Present. If Set and the First Error Pointer is valid,
///< indicates that the TLP Prefix Log register contains valid information.
///< If Clear or if First Error Pointer is invalid, the TLP Prefix Log
///< register is undefined. Default value of this bit is 0. This bit is
///< RsvdP if the End-End TLP Prefix Supported bit is Clear.   Note: This
///< register field is sticky.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_TLP_PRFX_LOG_PRESENT_BF_OFF (11)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_TLP_PRFX_LOG_PRESENT_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_TLP_PRFX_LOG_PRESENT_BF_MSK (0x00000800)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_TLP_PRFX_LOG_PRESENT_BF_DEF (0x00000000)

///< Completion Timeout Prefix/Header Log Capable. If Set, this bit indicates
///< that the Function records the prefix/header of Request TLPs that experience
///< a Completion Timeout error.
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_CTO_PRFX_HDR_LOG_CAP_BF_OFF (12)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_CTO_PRFX_HDR_LOG_CAP_BF_WID ( 1)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_CTO_PRFX_HDR_LOG_CAP_BF_MSK (0x00001000)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_CTO_PRFX_HDR_LOG_CAP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_HDR_LOG_0_OFF register description at address offset 0x11c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/HDR_LOG_0_OFF
  * Header Log Register 0.
  */

typedef union {
  struct {
    uint32_t FIRST_DWORD_FIRST_BYTE : 8;
    ///< Byte 0 of Header log register of First 32-bit Data Word. This field
    ///< represents first byte of First DW of Header. This field maps to:
    ///< HDR_LOG_0_OFF[7:0] = app_hdr_valid? app_hdr_log[31:24] : radm_hdr_log[31:24].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FIRST_DWORD_SECOND_BYTE : 8;
    ///< Byte 1 of Header log register of First 32-bit Data Word. This field
    ///< represents second byte of First DW of Header. This field maps to:
    ///< HDR_LOG_0_OFF[15:8] = app_hdr_valid? app_hdr_log[23:16] : radm_hdr_log[23:16].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t FIRST_DWORD_THIRD_BYTE : 8;
    ///< Byte 2 of Header log register of First 32-bit Data Word. This field
    ///< represents third byte of First DW of Header. This field maps to:
    ///< HDR_LOG_0_OFF[23:16] = app_hdr_valid? app_hdr_log[15:8] : radm_hdr_log[15:8].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t FIRST_DWORD_FOURTH_BYTE : 8;
    ///< Byte 3 of Header log register of First 32-bit Data Word. This field
    ///< represents fourth byte of First DW of Header. This field maps to:
    ///< HDR_LOG_0_OFF[31:24] = app_hdr_valid? app_hdr_log[7:0] : radm_hdr_log[7:0].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_hdr_log_0_off_reg_t;

#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_WR_MASK (0x00000000U)


///< Byte 0 of Header log register of First 32-bit Data Word. This field
///< represents first byte of First DW of Header. This field maps to:
///< HDR_LOG_0_OFF[7:0] = app_hdr_valid? app_hdr_log[31:24] : radm_hdr_log[31:24].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 of Header log register of First 32-bit Data Word. This field
///< represents second byte of First DW of Header. This field maps to:
///< HDR_LOG_0_OFF[15:8] = app_hdr_valid? app_hdr_log[23:16] : radm_hdr_log[23:16].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 of Header log register of First 32-bit Data Word. This field
///< represents third byte of First DW of Header. This field maps to:
///< HDR_LOG_0_OFF[23:16] = app_hdr_valid? app_hdr_log[15:8] : radm_hdr_log[15:8].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 of Header log register of First 32-bit Data Word. This field
///< represents fourth byte of First DW of Header. This field maps to:
///< HDR_LOG_0_OFF[31:24] = app_hdr_valid? app_hdr_log[7:0] : radm_hdr_log[7:0].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_HDR_LOG_1_OFF register description at address offset 0x120
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/HDR_LOG_1_OFF
  * Header Log Register 1.
  */

typedef union {
  struct {
    uint32_t SECOND_DWORD_FIRST_BYTE : 8;
    ///< Byte 0 of Header log register of Second 32-bit Data Word. This field
    ///< represents first byte of Second DW of Header. This field maps to:
    ///< HDR_LOG_1_OFF[7:0] = app_hdr_valid? app_hdr_log[63:56] : radm_hdr_log[63:56].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t SECOND_DWORD_SECOND_BYTE : 8;
    ///< Byte 1 of Header log register of Second 32-bit Data Word. This field
    ///< represents second byte of Second DW of Header. This field maps to:
    ///< HDR_LOG_1_OFF[15:8] = app_hdr_valid? app_hdr_log[55:48] : radm_hdr_log[55:48].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t SECOND_DWORD_THIRD_BYTE : 8;
    ///< Byte 2 of Header log register of Second 32-bit Data Word. This field
    ///< represents third byte of Second DW of Header. This field maps to:
    ///< HDR_LOG_1_OFF[23:16] = app_hdr_valid? app_hdr_log[47:40] : radm_hdr_log[47:40].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t SECOND_DWORD_FOURTH_BYTE : 8;
    ///< Byte 3 of Header log register of Second 32-bit Data Word. This field
    ///< represents fourth byte of Second DW of Header. This field maps to:
    ///< HDR_LOG_1_OFF[31:24] = app_hdr_valid? app_hdr_log[39:32] : radm_hdr_log[39:32].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_hdr_log_1_off_reg_t;

#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_WR_MASK (0x00000000U)


///< Byte 0 of Header log register of Second 32-bit Data Word. This field
///< represents first byte of Second DW of Header. This field maps to:
///< HDR_LOG_1_OFF[7:0] = app_hdr_valid? app_hdr_log[63:56] : radm_hdr_log[63:56].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 of Header log register of Second 32-bit Data Word. This field
///< represents second byte of Second DW of Header. This field maps to:
///< HDR_LOG_1_OFF[15:8] = app_hdr_valid? app_hdr_log[55:48] : radm_hdr_log[55:48].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 of Header log register of Second 32-bit Data Word. This field
///< represents third byte of Second DW of Header. This field maps to:
///< HDR_LOG_1_OFF[23:16] = app_hdr_valid? app_hdr_log[47:40] : radm_hdr_log[47:40].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 of Header log register of Second 32-bit Data Word. This field
///< represents fourth byte of Second DW of Header. This field maps to:
///< HDR_LOG_1_OFF[31:24] = app_hdr_valid? app_hdr_log[39:32] : radm_hdr_log[39:32].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_HDR_LOG_2_OFF register description at address offset 0x124
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/HDR_LOG_2_OFF
  * Header Log Register 2.
  */

typedef union {
  struct {
    uint32_t THIRD_DWORD_FIRST_BYTE : 8;
    ///< Byte 0 of Header log register of Third 32-bit Data Word. This field
    ///< represents first byte of Third DW of Header. This field maps to:
    ///< HDR_LOG_2_OFF[7:0] = app_hdr_valid? app_hdr_log[95:88] : radm_hdr_log[95:88].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t THIRD_DWORD_SECOND_BYTE : 8;
    ///< Byte 1 of Header log register of Third 32-bit Data Word. This field
    ///< represents second byte of Third DW of Header. This field maps to:
    ///< HDR_LOG_2_OFF[15:8] = app_hdr_valid? app_hdr_log[87:80] : radm_hdr_log[87:80].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t THIRD_DWORD_THIRD_BYTE : 8;
    ///< Byte 2 of Header log register of Third 32-bit Data Word. This field
    ///< represents third byte of Third DW of Header. This field maps to:
    ///< HDR_LOG_2_OFF[23:16] = app_hdr_valid? app_hdr_log[79:72] : radm_hdr_log[79:72].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t THIRD_DWORD_FOURTH_BYTE : 8;
    ///< Byte 3 of Header log register of Third 32-bit Data Word. This field
    ///< represents fourth byte of Third DW of Header. This field maps to:
    ///< HDR_LOG_2_OFF[31:24] = app_hdr_valid? app_hdr_log[71:64] : radm_hdr_log[71:64].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_hdr_log_2_off_reg_t;

#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_WR_MASK (0x00000000U)


///< Byte 0 of Header log register of Third 32-bit Data Word. This field
///< represents first byte of Third DW of Header. This field maps to:
///< HDR_LOG_2_OFF[7:0] = app_hdr_valid? app_hdr_log[95:88] : radm_hdr_log[95:88].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 of Header log register of Third 32-bit Data Word. This field
///< represents second byte of Third DW of Header. This field maps to:
///< HDR_LOG_2_OFF[15:8] = app_hdr_valid? app_hdr_log[87:80] : radm_hdr_log[87:80].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 of Header log register of Third 32-bit Data Word. This field
///< represents third byte of Third DW of Header. This field maps to:
///< HDR_LOG_2_OFF[23:16] = app_hdr_valid? app_hdr_log[79:72] : radm_hdr_log[79:72].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 of Header log register of Third 32-bit Data Word. This field
///< represents fourth byte of Third DW of Header. This field maps to:
///< HDR_LOG_2_OFF[31:24] = app_hdr_valid? app_hdr_log[71:64] : radm_hdr_log[71:64].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_HDR_LOG_3_OFF register description at address offset 0x128
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/HDR_LOG_3_OFF
  * Header Log Register 3.
  */

typedef union {
  struct {
    uint32_t FOURTH_DWORD_FIRST_BYTE : 8;
    ///< Byte 0 of Header log register of Fourth 32-bit Data Word. This field
    ///< represents first byte of Fourth DW of Header. This field maps to:
    ///< HDR_LOG_3_OFF[7:0] = app_hdr_valid? app_hdr_log[127:120] : radm_hdr_log[127:120].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FOURTH_DWORD_SECOND_BYTE : 8;
    ///< Byte 1 of Header log register of Fourth 32-bit Data Word. This field
    ///< represents second byte of Fourth DW of Header. This field maps to:
    ///< HDR_LOG_3_OFF[15:8] = app_hdr_valid? app_hdr_log[119:112] : radm_hdr_log[119:112].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t FOURTH_DWORD_THIRD_BYTE : 8;
    ///< Byte 2 of Header log register of Fourth 32-bit Data Word. This field
    ///< represents third byte of Fourth DW of Header. This field maps to:
    ///< HDR_LOG_3_OFF[23:16] = app_hdr_valid? app_hdr_log[111:104] : radm_hdr_log[111:104].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t FOURTH_DWORD_FOURTH_BYTE : 8;
    ///< Byte 3 of Header log register of Fourth 32-bit Data Word. This field
    ///< represents fourth byte of Fourth DW of Header. This field maps to:
    ///< HDR_LOG_3_OFF[31:24] = app_hdr_valid? app_hdr_log[103:96] : radm_hdr_log[103:96].
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_hdr_log_3_off_reg_t;

#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_WR_MASK (0x00000000U)


///< Byte 0 of Header log register of Fourth 32-bit Data Word. This field
///< represents first byte of Fourth DW of Header. This field maps to:
///< HDR_LOG_3_OFF[7:0] = app_hdr_valid? app_hdr_log[127:120] : radm_hdr_log[127:120].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 of Header log register of Fourth 32-bit Data Word. This field
///< represents second byte of Fourth DW of Header. This field maps to:
///< HDR_LOG_3_OFF[15:8] = app_hdr_valid? app_hdr_log[119:112] : radm_hdr_log[119:112].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 of Header log register of Fourth 32-bit Data Word. This field
///< represents third byte of Fourth DW of Header. This field maps to:
///< HDR_LOG_3_OFF[23:16] = app_hdr_valid? app_hdr_log[111:104] : radm_hdr_log[111:104].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 of Header log register of Fourth 32-bit Data Word. This field
///< represents fourth byte of Fourth DW of Header. This field maps to:
///< HDR_LOG_3_OFF[31:24] = app_hdr_valid? app_hdr_log[103:96] : radm_hdr_log[103:96].
///< Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_TLP_PREFIX_LOG_1_OFF register description at address offset 0x138
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/TLP_PREFIX_LOG_1_OFF
  * TLP Prefix Log Register 1.
  */

typedef union {
  struct {
    uint32_t CFG_TLP_PFX_LOG_1_FIRST_BYTE : 8;
    ///< Byte 0 of Error TLP Prefix Log 1. This field contains first byte of
    ///< First DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_1_SECOND_BYTE : 8;
    ///< Byte 1 of Error TLP Prefix Log 1. This field contains second byte
    ///< of First DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_1_THIRD_BYTE : 8;
    ///< Byte 2 of Error TLP Prefix Log 1. This field contains third byte of
    ///< First DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_1_FOURTH_BYTE : 8;
    ///< Byte 3 of Error TLP Prefix Log 1. This field contains fourth byte
    ///< of First DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_tlp_prefix_log_1_off_reg_t;

#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_WR_MASK (0x00000000U)


///< Byte 0 of Error TLP Prefix Log 1. This field contains first byte of
///< First DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 of Error TLP Prefix Log 1. This field contains second byte
///< of First DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 of Error TLP Prefix Log 1. This field contains third byte of
///< First DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 of Error TLP Prefix Log 1. This field contains fourth byte
///< of First DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_TLP_PREFIX_LOG_2_OFF register description at address offset 0x13c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/TLP_PREFIX_LOG_2_OFF
  * TLP Prefix Log Register 2.
  */

typedef union {
  struct {
    uint32_t CFG_TLP_PFX_LOG_2_FIRST_BYTE : 8;
    ///< Byte 0 Error TLP Prefix Log 2. This field contains first byte of Second
    ///< DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_2_SECOND_BYTE : 8;
    ///< Byte 1 Error TLP Prefix Log 2. This field contains second byte of
    ///< Second DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_2_THIRD_BYTE : 8;
    ///< Byte 2 Error TLP Prefix Log 2. This field contains third byte of Second
    ///< DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_2_FOURTH_BYTE : 8;
    ///< Byte 3 Error TLP Prefix Log 2. This field contains fourth byte of
    ///< Second DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_tlp_prefix_log_2_off_reg_t;

#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_WR_MASK (0x00000000U)


///< Byte 0 Error TLP Prefix Log 2. This field contains first byte of Second
///< DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 Error TLP Prefix Log 2. This field contains second byte of
///< Second DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 Error TLP Prefix Log 2. This field contains third byte of Second
///< DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 Error TLP Prefix Log 2. This field contains fourth byte of
///< Second DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_TLP_PREFIX_LOG_3_OFF register description at address offset 0x140
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/TLP_PREFIX_LOG_3_OFF
  * TLP Prefix Log Register 3.
  */

typedef union {
  struct {
    uint32_t CFG_TLP_PFX_LOG_3_FIRST_BYTE : 8;
    ///< Byte 0 Error TLP Prefix Log 3. This field contains first byte of Third
    ///< DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_3_SECOND_BYTE : 8;
    ///< Byte 1 Error TLP Prefix Log 3. This field contains second byte of
    ///< Third DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_3_THIRD_BYTE : 8;
    ///< Byte 2 Error TLP Prefix Log 3. This field contains third byte of Third
    ///< DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_3_FOURTH_BYTE : 8;
    ///< Byte 3 Error TLP Prefix Log 3. This field contains fourth byte of
    ///< Third DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_tlp_prefix_log_3_off_reg_t;

#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_WR_MASK (0x00000000U)


///< Byte 0 Error TLP Prefix Log 3. This field contains first byte of Third
///< DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 Error TLP Prefix Log 3. This field contains second byte of
///< Third DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 Error TLP Prefix Log 3. This field contains third byte of Third
///< DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 Error TLP Prefix Log 3. This field contains fourth byte of
///< Third DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_AER_CAP_TLP_PREFIX_LOG_4_OFF register description at address offset 0x144
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_AER_CAP/TLP_PREFIX_LOG_4_OFF
  * TLP Prefix Log Register 4.
  */

typedef union {
  struct {
    uint32_t CFG_TLP_PFX_LOG_4_FIRST_BYTE : 8;
    ///< Byte 0 Error TLP Prefix Log 4. This field contains first byte of Fourth
    ///< DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_4_SECOND_BYTE : 8;
    ///< Byte 1 Error TLP Prefix Log 4. This field contains second byte of
    ///< Fourth DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_4_THIRD_BYTE : 8;
    ///< Byte 2 Error TLP Prefix Log 4. This field contains third byte of Fourth
    ///< DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_TLP_PFX_LOG_4_FOURTH_BYTE : 8;
    ///< Byte 3 Error TLP Prefix Log 4. This field contains fourth byte of
    ///< Fourth DW of TLP Prefix.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_aer_cap_tlp_prefix_log_4_off_reg_t;

#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_WR_MASK (0x00000000U)


///< Byte 0 Error TLP Prefix Log 4. This field contains first byte of Fourth
///< DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_BF_OFF ( 0)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_BF_MSK (0x000000FF)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_BF_DEF (0x00000000)

///< Byte 1 Error TLP Prefix Log 4. This field contains second byte of
///< Fourth DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_BF_OFF ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_BF_MSK (0x0000FF00)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_BF_DEF (0x00000000)

///< Byte 2 Error TLP Prefix Log 4. This field contains third byte of Fourth
///< DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_BF_OFF (16)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_BF_MSK (0x00FF0000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_BF_DEF (0x00000000)

///< Byte 3 Error TLP Prefix Log 4. This field contains fourth byte of
///< Fourth DW of TLP Prefix.   Note: This register field is sticky.
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_BF_OFF (24)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_BF_WID ( 8)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_BF_MSK (0xFF000000)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_SPCIE_CAP_SPCIE_CAP_HEADER_REG register description at address offset 0x148
  *
  * Register default value:        0x15810019
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_SPCIE_CAP/SPCIE_CAP_HEADER_REG
  * SPCIE Capability Header.
  */

typedef union {
  struct {
    uint32_t EXTENDED_CAP_ID : 16;
    ///< Secondary PCI Express Extended Capability ID. This field is a PCI-SIG
    ///< defined ID number that indicates the nature and format of the Extended
    ///< Capability. PCI Express Extended Capability ID for the Secondary PCI
    ///< Express Extended Capability is 0019h.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x19"
    uint32_t CAP_VERSION : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Extended Capability structure or 000h if no other items
    ///< exist in the linked list of Capabilities.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x158"
  } ;
  uint32_t value;
} pcie_ctl_spcie_cap_spcie_cap_header_reg_t;

#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_DEFAULT (0x15810019U)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_RD_MASK (0xffffffffU)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_WR_MASK (0x00000000U)


///< Secondary PCI Express Extended Capability ID. This field is a PCI-SIG
///< defined ID number that indicates the nature and format of the Extended
///< Capability. PCI Express Extended Capability ID for the Secondary PCI
///< Express Extended Capability is 0019h.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_EXTENDED_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_EXTENDED_CAP_ID_BF_WID (16)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_EXTENDED_CAP_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_EXTENDED_CAP_ID_BF_DEF (0x00000019)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_CAP_VER_BF_OFF (16)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_CAP_VER_BF_WID ( 4)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_CAP_VER_BF_MSK (0x000F0000)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_CAP_VER_BF_DEF (0x00010000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Extended Capability structure or 000h if no other items
///< exist in the linked list of Capabilities.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_NEXT_OFFSET_BF_DEF (0x15800000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_SPCIE_CAP_LINK_CONTROL3_REG register description at address offset 0x14c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_SPCIE_CAP/LINK_CONTROL3_REG
  * Link Control 3 Register.
  */

typedef union {
  struct {
    uint32_t PERFORM_EQ : 1;
    ///< Perform Equalization. This bit is RW for Downstream Ports and for
    ///< Upstream Ports when Crosslink Supported is 1b. This bit is not applicable
    ///< and is RsvdP for Upstream Ports when the Crosslink Supported bit is
    ///< 0b. If the Port does not support 8.0 GT/s, this bit is permitted to
    ///< be hardwired to 0b by the controller. If the Link is in Gen6 rate,
    ///< setting this bit to 1b does not take effect because the Gen6 Base
    ///< Spec says: All equalization procedures at the 64.0 GT/s data rate,
    ///< including re-equalization, must be initiated from the 32.0 GT/s data
    ///< rate only. If you want to perform Gen6 EQ, first you must change the
    ///< Link to Gen5 data rate and then set the Target link Speed to Gen6,
    ///< PERFORM_EQ to 1b and the Retrain Link bit to 1b in the Downstream
    ///< Port.   Note: The access attributes of this field are as follows:
    ///< - Wire: RSVDP   - Dbi: RSVDP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t EQ_REQ_INT_EN : 1;
    ///< Link Equalization Request Interrupt Enable. This bit is RW for Downstream
    ///< Ports and for Upstream Ports when Crosslink Supported is 1b. This
    ///< bit is not applicable and is RsvdP for Upstream Ports when the Crosslink
    ///< Supported bit is 0b. If the Port does not support 8.0 GT/s, this bit
    ///< is permitted to be hardwired to 0b by the controller.   Note: The
    ///< access attributes of this field are as follows:  - Wire: RSVDP   -
    ///< Dbi: RSVDP
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_spcie_cap_link_ctrl3_reg_t;

#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_DEFAULT (0x00000000U)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_RD_MASK (0x00000003U)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_WR_MASK (0x00000000U)


///< Perform Equalization. This bit is RW for Downstream Ports and for
///< Upstream Ports when Crosslink Supported is 1b. This bit is not applicable
///< and is RsvdP for Upstream Ports when the Crosslink Supported bit is
///< 0b. If the Port does not support 8.0 GT/s, this bit is permitted to
///< be hardwired to 0b by the controller. If the Link is in Gen6 rate,
///< setting this bit to 1b does not take effect because the Gen6 Base
///< Spec says: All equalization procedures at the 64.0 GT/s data rate,
///< including re-equalization, must be initiated from the 32.0 GT/s data
///< rate only. If you want to perform Gen6 EQ, first you must change the
///< Link to Gen5 data rate and then set the Target link Speed to Gen6,
///< PERFORM_EQ to 1b and the Retrain Link bit to 1b in the Downstream
///< Port.   Note: The access attributes of this field are as follows:
///< - Wire: RSVDP   - Dbi: RSVDP
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_PERFORM_EQ_BF_OFF ( 0)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_PERFORM_EQ_BF_WID ( 1)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_PERFORM_EQ_BF_MSK (0x00000001)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_PERFORM_EQ_BF_DEF (0x00000000)

///< Link Equalization Request Interrupt Enable. This bit is RW for Downstream
///< Ports and for Upstream Ports when Crosslink Supported is 1b. This
///< bit is not applicable and is RsvdP for Upstream Ports when the Crosslink
///< Supported bit is 0b. If the Port does not support 8.0 GT/s, this bit
///< is permitted to be hardwired to 0b by the controller.   Note: The
///< access attributes of this field are as follows:  - Wire: RSVDP   -
///< Dbi: RSVDP
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_EQ_REQ_INT_EN_BF_OFF ( 1)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_EQ_REQ_INT_EN_BF_WID ( 1)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_EQ_REQ_INT_EN_BF_MSK (0x00000002)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_EQ_REQ_INT_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_SPCIE_CAP_LANE_ERR_STATUS_REG register description at address offset 0x150
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_SPCIE_CAP/LANE_ERR_STATUS_REG
  * Lane Error Status Register.
  */

typedef union {
  struct {
    uint32_t LANE_ERR_STATUS : 2;
    ///< Lane Error Status Bits per Lane. Each bit indicates if the corresponding
    ///< Lane detected a Lane-based error. A value of 1b indicates that a Lane
    ///< based-error was detected on the corresponding Lane Number. For Ports
    ///< that are narrower than 32 Lanes, the unused upper bits [31: Maximum
    ///< Link Width] are RsvdZ. For Ports that do not support 8.0 GT/s and
    ///< do not set these bits based on 8b/10b errors , this field is permitted
    ///< to be hardwired to 0 by the controller.   Note: This register field
    ///< is sticky.
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_spcie_cap_lane_err_stat_reg_t;

#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_DEFAULT (0x00000000U)
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_RD_MASK (0x00000003U)
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_WR_MASK (0x00000003U)


///< Lane Error Status Bits per Lane. Each bit indicates if the corresponding
///< Lane detected a Lane-based error. A value of 1b indicates that a Lane
///< based-error was detected on the corresponding Lane Number. For Ports
///< that are narrower than 32 Lanes, the unused upper bits [31: Maximum
///< Link Width] are RsvdZ. For Ports that do not support 8.0 GT/s and
///< do not set these bits based on 8b/10b errors , this field is permitted
///< to be hardwired to 0 by the controller.   Note: This register field
///< is sticky.
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_LANE_ERR_STAT_BF_OFF ( 0)
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_LANE_ERR_STAT_BF_WID ( 2)
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_LANE_ERR_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_LANE_ERR_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_SPCIE_CAP_SPCIE_CAP_OFF_0CH_REG register description at address offset 0x154
  *
  * Register default value:        0x74007400
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_SPCIE_CAP/SPCIE_CAP_OFF_0CH_REG
  * Lane Equalization Control Register for lanes 1 and 0.
  */

typedef union {
  struct {
    uint32_t DSP_TX_PRESET0 : 4;
    ///< Downstream Port 8.0 GT/s Transmitter Preset 0. Transmitter preset
    ///< 0 value used for 8.0 GT/s equalization by this Port when the Port
    ///< is operating as a Downstream Port. This field is ignored when the
    ///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
    ///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< RSVDP   - Dbi: RSVDP
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t DSP_RX_PRESET_HINT0 : 3;
    ///< Downstream Port 8.0 GT/s Receiver Preset Hint 0. Receiver preset hint
    ///< 0 value that may be used as a suggested setting for 8.0 GT/s receiver
    ///< equalization by this Port when the Port is operating as a Downstream
    ///< Port. This field is ignored when the Port is operating as an Upstream
    ///< Port. For an Upstream Port if Crosslink Supported is 0b, this field
    ///< is RsvdP. Otherwise, this field is HwInit.   Note: The access attributes
    ///< of this field are as follows:  - Wire: RSVDP   - Dbi: RSVDP
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t USP_TX_PRESET0 : 4;
    ///< Upstream Port 8.0 GT/s Transmitter Preset 0.  The write value is gated
    ///< with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
    ///< Field contains the Transmitter preset 0 value sent or received during
    ///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
    ///< port and whether the Crosslink is supported or not, this field representss
    ///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
    ///< When Operating port is Upstream port and Crosslink Supported bit is
    ///< 0, this field is intended for debug and diagnostics. It contains the
    ///< value captured from Lane 0 during Link Equalization.  - Case C: When
    ///< Operating port is Upstream port and Crosslink Supported bit is 1,
    ///< Field is not used or affected by the current Link Equalization. Field
    ///< value will be used if a future crosslink negotiation switches the
    ///< Operating Port Direction so that case A applies. For case A and C,
    ///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x4"
    uint32_t USP_RX_PRESET_HINT0 : 3;
    ///< Upstream Port 8.0 GT/s Receiver Preset Hint 0.  The write value is
    ///< gated with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
    ///< Field contains the Receiver preset hint 0 value sent or received during
    ///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
    ///< port and whether the Crosslink is supported or not, this field representss
    ///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
    ///< When Operating port is Upstream port and Crosslink Supported bit is
    ///< 0, this field is intended for debug and diagnostics. It contains the
    ///< value captured from Lane 0 during Link Equalization.  - Case C: When
    ///< Operating port is Upstream port and Crosslink Supported bit is 1,
    ///< Field is not used or affected by the current Link Equalization. Field
    ///< value will be used if a future crosslink negotiation switches the
    ///< Operating Port Direction so that case A applies. For case A and C,
    ///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x7"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
    uint32_t DSP_TX_PRESET1 : 4;
    ///< Downstream Port 8.0 GT/s Transmitter Preset 1. Transmitter preset
    ///< 1 value used for 8.0 GT/s equalization by this Port when the Port
    ///< is operating as a Downstream Port. This field is ignored when the
    ///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
    ///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< RSVDP   - Dbi: RSVDP
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t DSP_RX_PRESET_HINT1 : 3;
    ///< Downstream Port 8.0 GT/s Receiver Preset Hint 1. Receiver preset hint
    ///< 1 value that may be used as a suggested setting for 8.0 GT/s receiver
    ///< equalization by this Port when the Port is operating as a Downstream
    ///< Port. This field is ignored when the Port is operating as an Upstream
    ///< Port. For an Upstream Port if Crosslink Supported is 0b, this field
    ///< is RsvdP. Otherwise, this field is HwInit.   Note: The access attributes
    ///< of this field are as follows:  - Wire: RSVDP   - Dbi: RSVDP
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t USP_TX_PRESET1 : 4;
    ///< Upstream Port 8.0 GT/s Transmitter Preset 1.  The write value is gated
    ///< with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
    ///< Field contains the Transmitter preset 1 value sent or received during
    ///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
    ///< port and whether the Crosslink is supported or not, this field representss
    ///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
    ///< When Operating port is Upstream port and Crosslink Supported bit is
    ///< 0, this field is intended for debug and diagnostics. It contains the
    ///< value captured from Lane 0 during Link Equalization.  - Case C: When
    ///< Operating port is Upstream port and Crosslink Supported bit is 1,
    ///< Field is not used or affected by the current Link Equalization. Field
    ///< value will be used if a future crosslink negotiation switches the
    ///< Operating Port Direction so that case A applies. For case A and C,
    ///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x4"
    uint32_t USP_RX_PRESET_HINT1 : 3;
    ///< Upstream Port 8.0 GT/s Receiver Preset Hint 1.  The write value is
    ///< gated with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
    ///< Field contains the Receiver preset hint 1 value sent or received during
    ///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
    ///< port and whether the Crosslink is supported or not, this field representss
    ///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
    ///< When Operating port is Upstream port and Crosslink Supported bit is
    ///< 0, this field is intended for debug and diagnostics. It contains the
    ///< value captured from Lane 0 during Link Equalization.  - Case C: When
    ///< Operating port is Upstream port and Crosslink Supported bit is 1,
    ///< Field is not used or affected by the current Link Equalization. Field
    ///< value will be used if a future crosslink negotiation switches the
    ///< Operating Port Direction so that case A applies. For case A and C,
    ///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="28" ResetValue="0x7"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_spcie_cap_spcie_cap_off_0ch_reg_t;

#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DEFAULT (0x74007400U)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_RD_MASK (0x7f7f7f7fU)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_WR_MASK (0x00000000U)


///< Downstream Port 8.0 GT/s Transmitter Preset 0. Transmitter preset
///< 0 value used for 8.0 GT/s equalization by this Port when the Port
///< is operating as a Downstream Port. This field is ignored when the
///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
///< Note: The access attributes of this field are as follows:  - Wire:
///< RSVDP   - Dbi: RSVDP
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST0_BF_OFF ( 0)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST0_BF_WID ( 4)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST0_BF_MSK (0x0000000F)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST0_BF_DEF (0x00000000)

///< Downstream Port 8.0 GT/s Receiver Preset Hint 0. Receiver preset hint
///< 0 value that may be used as a suggested setting for 8.0 GT/s receiver
///< equalization by this Port when the Port is operating as a Downstream
///< Port. This field is ignored when the Port is operating as an Upstream
///< Port. For an Upstream Port if Crosslink Supported is 0b, this field
///< is RsvdP. Otherwise, this field is HwInit.   Note: The access attributes
///< of this field are as follows:  - Wire: RSVDP   - Dbi: RSVDP
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT0_BF_OFF ( 4)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT0_BF_WID ( 3)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT0_BF_MSK (0x00000070)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT0_BF_DEF (0x00000000)

///< Upstream Port 8.0 GT/s Transmitter Preset 0.  The write value is gated
///< with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
///< Field contains the Transmitter preset 0 value sent or received during
///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
///< port and whether the Crosslink is supported or not, this field representss
///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
///< When Operating port is Upstream port and Crosslink Supported bit is
///< 0, this field is intended for debug and diagnostics. It contains the
///< value captured from Lane 0 during Link Equalization.  - Case C: When
///< Operating port is Upstream port and Crosslink Supported bit is 1,
///< Field is not used or affected by the current Link Equalization. Field
///< value will be used if a future crosslink negotiation switches the
///< Operating Port Direction so that case A applies. For case A and C,
///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST0_BF_OFF ( 8)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST0_BF_WID ( 4)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST0_BF_MSK (0x00000F00)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST0_BF_DEF (0x00000400)

///< Upstream Port 8.0 GT/s Receiver Preset Hint 0.  The write value is
///< gated with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
///< Field contains the Receiver preset hint 0 value sent or received during
///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
///< port and whether the Crosslink is supported or not, this field representss
///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
///< When Operating port is Upstream port and Crosslink Supported bit is
///< 0, this field is intended for debug and diagnostics. It contains the
///< value captured from Lane 0 during Link Equalization.  - Case C: When
///< Operating port is Upstream port and Crosslink Supported bit is 1,
///< Field is not used or affected by the current Link Equalization. Field
///< value will be used if a future crosslink negotiation switches the
///< Operating Port Direction so that case A applies. For case A and C,
///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT0_BF_OFF (12)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT0_BF_WID ( 3)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT0_BF_MSK (0x00007000)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT0_BF_DEF (0x00007000)

///< Downstream Port 8.0 GT/s Transmitter Preset 1. Transmitter preset
///< 1 value used for 8.0 GT/s equalization by this Port when the Port
///< is operating as a Downstream Port. This field is ignored when the
///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
///< Note: The access attributes of this field are as follows:  - Wire:
///< RSVDP   - Dbi: RSVDP
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST1_BF_OFF (16)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST1_BF_WID ( 4)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST1_BF_MSK (0x000F0000)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_TX_PRST1_BF_DEF (0x00000000)

///< Downstream Port 8.0 GT/s Receiver Preset Hint 1. Receiver preset hint
///< 1 value that may be used as a suggested setting for 8.0 GT/s receiver
///< equalization by this Port when the Port is operating as a Downstream
///< Port. This field is ignored when the Port is operating as an Upstream
///< Port. For an Upstream Port if Crosslink Supported is 0b, this field
///< is RsvdP. Otherwise, this field is HwInit.   Note: The access attributes
///< of this field are as follows:  - Wire: RSVDP   - Dbi: RSVDP
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT1_BF_OFF (20)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT1_BF_WID ( 3)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT1_BF_MSK (0x00700000)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_DSP_RX_PRST_HINT1_BF_DEF (0x00000000)

///< Upstream Port 8.0 GT/s Transmitter Preset 1.  The write value is gated
///< with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
///< Field contains the Transmitter preset 1 value sent or received during
///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
///< port and whether the Crosslink is supported or not, this field representss
///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
///< When Operating port is Upstream port and Crosslink Supported bit is
///< 0, this field is intended for debug and diagnostics. It contains the
///< value captured from Lane 0 during Link Equalization.  - Case C: When
///< Operating port is Upstream port and Crosslink Supported bit is 1,
///< Field is not used or affected by the current Link Equalization. Field
///< value will be used if a future crosslink negotiation switches the
///< Operating Port Direction so that case A applies. For case A and C,
///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST1_BF_OFF (24)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST1_BF_WID ( 4)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST1_BF_MSK (0x0F000000)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_TX_PRST1_BF_DEF (0x04000000)

///< Upstream Port 8.0 GT/s Receiver Preset Hint 1.  The write value is
///< gated with the PCIE_CAP_CROSS_LINK_SUPPORT field of LINK_CAPABILITIES2_REG.
///< Field contains the Receiver preset hint 1 value sent or received during
///< 8.0 GT/s Link Equalization.  - Case A: When Operating port is Downstream
///< port and whether the Crosslink is supported or not, this field representss
///< the value sent on Lane 0 during 8.0 GT/s equalization.  - Case B:
///< When Operating port is Upstream port and Crosslink Supported bit is
///< 0, this field is intended for debug and diagnostics. It contains the
///< value captured from Lane 0 during Link Equalization.  - Case C: When
///< Operating port is Upstream port and Crosslink Supported bit is 1,
///< Field is not used or affected by the current Link Equalization. Field
///< value will be used if a future crosslink negotiation switches the
///< Operating Port Direction so that case A applies. For case A and C,
///< Field is HwInit. For case B, Field is RO.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT1_BF_OFF (28)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT1_BF_WID ( 3)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT1_BF_MSK (0x70000000)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_USP_RX_PRST_HINT1_BF_DEF (0x70000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_EXT_CAP_HDR_REG register description at address offset 0x158
  *
  * Register default value:        0x17C10026
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_EXT_CAP_HDR_REG
  * Physical Layer 16.0 GT/s Extended Capability Header.
  */

typedef union {
  struct {
    uint32_t EXTENDED_CAP_ID : 16;
    ///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
    ///< ID number that indicates the nature and format of the Extended Capability.
    ///< The Extended Capability ID for the Physical Layer 16.0 GT/s Capability
    ///< is 0026h.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x26"
    uint32_t CAP_VERSION : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present. This
    ///< bit depends on the version of the specification.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
    ///< register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Capability structure or 000h if no other items exist in
    ///< the linked list of Capabilities. For Extended Capabilities implemented
    ///< in Configuration Space, this offset is relative to the beginning of
    ///< PCI-compatible Configuration Space and thus must always be either
    ///< 000h (for terminating list of Capabilities) or greater than 0FFh.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x17C"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_ext_cap_hdr_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_DEFAULT (0x17c10026U)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_RD_MASK (0xffffffffU)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_WR_MASK (0x00000000U)


///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
///< ID number that indicates the nature and format of the Extended Capability.
///< The Extended Capability ID for the Physical Layer 16.0 GT/s Capability
///< is 0026h.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_WID (16)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_DEF (0x00000026)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present. This
///< bit depends on the version of the specification.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
///< register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_CAP_VER_BF_OFF (16)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_CAP_VER_BF_WID ( 4)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_CAP_VER_BF_MSK (0x000F0000)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_CAP_VER_BF_DEF (0x00010000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Capability structure or 000h if no other items exist in
///< the linked list of Capabilities. For Extended Capabilities implemented
///< in Configuration Space, this offset is relative to the beginning of
///< PCI-compatible Configuration Space and thus must always be either
///< 000h (for terminating list of Capabilities) or greater than 0FFh.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_NEXT_OFFSET_BF_DEF (0x17C00000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_CAPABILITY_REG register description at address offset 0x15c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_CAPABILITY_REG
  * 16.0 GT/s Capabilities Register.
  */

typedef union {
  struct {
    uint32_t  : 32;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_capability_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_DEFAULT (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_RD_MASK (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_WR_MASK (0x00000000U)



/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_CONTROL_REG register description at address offset 0x160
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_CONTROL_REG
  * 16.0 GT/s Control Register.
  */

typedef union {
  struct {
    uint32_t  : 32;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_ctrl_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_CTRL_DEFAULT (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_CTRL_RD_MASK (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_CTRL_WR_MASK (0x00000000U)



/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_STATUS_REG register description at address offset 0x164
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_STATUS_REG
  * 16.0 GT/s Status Register.
  */

typedef union {
  struct {
    uint32_t EQ_16G_CPL : 1;
    ///< Equalization 16.0GT/s Complete. For a Multi-Function Upstream Port,
    ///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t EQ_16G_CPL_P1 : 1;
    ///< Equalization 16.0GT/s Phase 1 Successful. For a Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EQ_16G_CPL_P2 : 1;
    ///< Equalization 16.0GT/s Phase 2 Successful. For a Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t EQ_16G_CPL_P3 : 1;
    ///< Equalization 16.0GT/s Phase 3 Successful. For a Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t LINK_EQ_16G_REQ : 1;
    ///< Link Equalization Request 16.0GT/s. For a Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions.   Note: This register field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_stat_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_STAT_DEFAULT (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_RD_MASK (0x0000001fU)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_WR_MASK (0x00000010U)


///< Equalization 16.0GT/s Complete. For a Multi-Function Upstream Port,
///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
///< Note: This register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_BF_OFF ( 0)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_BF_WID ( 1)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_BF_MSK (0x00000001)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_BF_DEF (0x00000000)

///< Equalization 16.0GT/s Phase 1 Successful. For a Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions.   Note: This register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P1_BF_OFF ( 1)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P1_BF_WID ( 1)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P1_BF_MSK (0x00000002)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P1_BF_DEF (0x00000000)

///< Equalization 16.0GT/s Phase 2 Successful. For a Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions.   Note: This register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P2_BF_OFF ( 2)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P2_BF_WID ( 1)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P2_BF_MSK (0x00000004)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P2_BF_DEF (0x00000000)

///< Equalization 16.0GT/s Phase 3 Successful. For a Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions.   Note: This register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P3_BF_OFF ( 3)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P3_BF_WID ( 1)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P3_BF_MSK (0x00000008)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_EQ_16G_CPL_P3_BF_DEF (0x00000000)

///< Link Equalization Request 16.0GT/s. For a Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions.   Note: This register field is sticky.
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_LINK_EQ_16G_REQ_BF_OFF ( 4)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_LINK_EQ_16G_REQ_BF_WID ( 1)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_LINK_EQ_16G_REQ_BF_MSK (0x00000010)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_LINK_EQ_16G_REQ_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_LC_DPAR_STATUS_REG register description at address offset 0x168
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_LC_DPAR_STATUS_REG
  * 16.0 GT/s Local Data Parity Mismatch Status Register.
  */

typedef union {
  struct {
    uint32_t LC_DPAR_STATUS : 2;
    ///< Local Data Parity Mismatch Status. Each bit indicates if the corresponding
    ///< Lane detected a Data Parity mismatch. A value of 1b indicates that
    ///< a mismatch was detected on the corresponding Lane Number. The default
    ///< value of each bit is 0b. For Ports that are narrower than 32 Lanes,
    ///< the unused upper bits [31: MaximumLink Width] are RsvdZ.
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_lc_dpar_stat_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_DEFAULT (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_RD_MASK (0x00000003U)
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_WR_MASK (0x00000003U)


///< Local Data Parity Mismatch Status. Each bit indicates if the corresponding
///< Lane detected a Data Parity mismatch. A value of 1b indicates that
///< a mismatch was detected on the corresponding Lane Number. The default
///< value of each bit is 0b. For Ports that are narrower than 32 Lanes,
///< the unused upper bits [31: MaximumLink Width] are RsvdZ.
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_LC_DPAR_STAT_BF_OFF ( 0)
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_LC_DPAR_STAT_BF_WID ( 2)
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_LC_DPAR_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_LC_DPAR_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STATUS_REG register description at address offset 0x16c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_FIRST_RETIMER_DPAR_STATUS_REG
  * 16.0 GT/s First Retimer Data Parity Mismatch Status Register.
  */

typedef union {
  struct {
    uint32_t FIRST_RETIMER_DPAR_STATUS : 2;
    ///< First Retimer Data Parity Mismatch Status. Each bit indicates if the
    ///< corresponding Lane detected a Data Parity mismatch. A value of 1b
    ///< indicates that a mismatch was detected on the corresponding Lane Number.
    ///< The default value of each bit is 0b. The value of this field is undefined
    ///< when no Retimers are present. For Ports that are narrower than 32
    ///< Lanes, the unused upper bits [31: Maximum Link Width] are RsvdZ.
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_first_retimer_dpar_stat_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_DEFAULT (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_RD_MASK (0x00000003U)
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_WR_MASK (0x00000003U)


///< First Retimer Data Parity Mismatch Status. Each bit indicates if the
///< corresponding Lane detected a Data Parity mismatch. A value of 1b
///< indicates that a mismatch was detected on the corresponding Lane Number.
///< The default value of each bit is 0b. The value of this field is undefined
///< when no Retimers are present. For Ports that are narrower than 32
///< Lanes, the unused upper bits [31: Maximum Link Width] are RsvdZ.
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_FIRST_RETIMER_DPAR_STAT_BF_OFF ( 0)
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_FIRST_RETIMER_DPAR_STAT_BF_WID ( 2)
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_FIRST_RETIMER_DPAR_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_FIRST_RETIMER_DPAR_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STATUS_REG register description at address offset 0x170
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_SECOND_RETIMER_DPAR_STATUS_REG
  * 16.0 GT/s Second Retimer Data Parity Mismatch Status Register.
  */

typedef union {
  struct {
    uint32_t SECOND_RETIMER_DPAR_STATUS : 2;
    ///< Second Retimer Data Parity Mismatch Status. Each bit indicates if
    ///< the corresponding Lane detected a Data Parity mismatch. A value of
    ///< 1b indicates that a mismatch was detected on the corresponding Lane
    ///< Number. The default value of each bit is 0b. The value of this field
    ///< is undefined when no Retimers are present or only one Retimer is present.
    ///< For Ports that are narrower than 32 Lanes, the unused upper bits [31:
    ///< Maximum Link Width] are RsvdZ.
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_second_retimer_dpar_stat_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_DEFAULT (0x00000000U)
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_RD_MASK (0x00000003U)
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_WR_MASK (0x00000003U)


///< Second Retimer Data Parity Mismatch Status. Each bit indicates if
///< the corresponding Lane detected a Data Parity mismatch. A value of
///< 1b indicates that a mismatch was detected on the corresponding Lane
///< Number. The default value of each bit is 0b. The value of this field
///< is undefined when no Retimers are present or only one Retimer is present.
///< For Ports that are narrower than 32 Lanes, the unused upper bits [31:
///< Maximum Link Width] are RsvdZ.
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_SECOND_RETIMER_DPAR_STAT_BF_OFF ( 0)
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_SECOND_RETIMER_DPAR_STAT_BF_WID ( 2)
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_SECOND_RETIMER_DPAR_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_SECOND_RETIMER_DPAR_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL16G_CAP_PL16G_CAP_OFF_20H_REG register description at address offset 0x178
  *
  * Register default value:        0x00004040
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL16G_CAP/PL16G_CAP_OFF_20H_REG
  * 16.0 GT/s Lane Equalization Control Register for Lane 0-3.
  */

typedef union {
  struct {
    uint32_t DSP_16G_TX_PRESET0 : 4;
    ///< Downstream Port 16.0 GT/s Transmitter Preset0. Transmitter Preset
    ///< of Lane 0 used for 16.0 GT/s equalization by this Port when the Port
    ///< is operating as a Downstream Port. This field is ignored when the
    ///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
    ///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< RSVDP   - Dbi: RSVDP
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t USP_16G_TX_PRESET0 : 4;
    ///< Upstream Port 16.0 GT/s Transmitter Preset0.  - Case A: When Operating
    ///< port is Downstream port and whether the Crosslink is supported or
    ///< not, this field represents the value sent on Lane 0 during 16.0 GT/s
    ///< equalization.  - Case B: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 0, this field is intended for debug and
    ///< diagnostics. It contains the value captured from Lane 0 during Link
    ///< Equalization.  - Case C: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 1, Field is not used or affected by the
    ///< current Link Equalization. Field value will be used if a future crosslink
    ///< negotiation switches the Operating Port Direction so that case A applies.
    ///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
    ///< B also has a writable but not readable register internally with following
    ///< access attributes. For case B and C, the writable register's value
    ///< is set to implementation specific 16.0 GT/s Transmitter Preset bits
    ///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
    ///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==01b.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R   -
    ///< Dbi: R
    ///< AccessType="RO" BitOffset="4" ResetValue="0x4"
    uint32_t DSP_16G_TX_PRESET1 : 4;
    ///< Downstream Port 16.0 GT/s Transmitter Preset1. Transmitter Preset
    ///< of Lane 1 used for 16.0 GT/s equalization by this Port when the Port
    ///< is operating as a Downstream Port. This field is ignored when the
    ///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
    ///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< RSVDP   - Dbi: RSVDP
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t USP_16G_TX_PRESET1 : 4;
    ///< Upstream Port 16.0 GT/s Transmitter Preset1.  - Case A: When Operating
    ///< port is Downstream port and whether the Crosslink is supported or
    ///< not, this field represents the value sent on Lane 1 during 16.0 GT/s
    ///< equalization.  - Case B: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 0, this field is intended for debug and
    ///< diagnostics. It contains the value captured from Lane 1 during Link
    ///< Equalization.  - Case C: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 1, Field is not used or affected by the
    ///< current Link Equalization. Field value will be used if a future crosslink
    ///< negotiation switches the Operating Port Direction so that case A applies.
    ///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
    ///< B also has a writable but not readable register internally with following
    ///< access attributes. For case B and C, the writable register's value
    ///< is set to implementation specific 16.0 GT/s Transmitter Preset bits
    ///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
    ///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==01b.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R   -
    ///< Dbi: R
    ///< AccessType="RO" BitOffset="12" ResetValue="0x4"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl16g_cap_pl16g_cap_off_20h_reg_t;

#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DEFAULT (0x00004040U)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_RD_MASK (0x0000ffffU)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_WR_MASK (0x00000000U)


///< Downstream Port 16.0 GT/s Transmitter Preset0. Transmitter Preset
///< of Lane 0 used for 16.0 GT/s equalization by this Port when the Port
///< is operating as a Downstream Port. This field is ignored when the
///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
///< Note: The access attributes of this field are as follows:  - Wire:
///< RSVDP   - Dbi: RSVDP
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST0_BF_OFF ( 0)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST0_BF_WID ( 4)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST0_BF_MSK (0x0000000F)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST0_BF_DEF (0x00000000)

///< Upstream Port 16.0 GT/s Transmitter Preset0.  - Case A: When Operating
///< port is Downstream port and whether the Crosslink is supported or
///< not, this field represents the value sent on Lane 0 during 16.0 GT/s
///< equalization.  - Case B: When Operating port is Upstream port and
///< Crosslink Supported bit is 0, this field is intended for debug and
///< diagnostics. It contains the value captured from Lane 0 during Link
///< Equalization.  - Case C: When Operating port is Upstream port and
///< Crosslink Supported bit is 1, Field is not used or affected by the
///< current Link Equalization. Field value will be used if a future crosslink
///< negotiation switches the Operating Port Direction so that case A applies.
///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
///< B also has a writable but not readable register internally with following
///< access attributes. For case B and C, the writable register's value
///< is set to implementation specific 16.0 GT/s Transmitter Preset bits
///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==01b.   Note:
///< The access attributes of this field are as follows:  - Wire: R   -
///< Dbi: R
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST0_BF_OFF ( 4)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST0_BF_WID ( 4)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST0_BF_MSK (0x000000F0)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST0_BF_DEF (0x00000040)

///< Downstream Port 16.0 GT/s Transmitter Preset1. Transmitter Preset
///< of Lane 1 used for 16.0 GT/s equalization by this Port when the Port
///< is operating as a Downstream Port. This field is ignored when the
///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
///< Supported is 0b, this field is RsvdP. Otherwise, this field is HwInit.
///< Note: The access attributes of this field are as follows:  - Wire:
///< RSVDP   - Dbi: RSVDP
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST1_BF_OFF ( 8)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST1_BF_WID ( 4)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST1_BF_MSK (0x00000F00)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_DSP_16G_TX_PRST1_BF_DEF (0x00000000)

///< Upstream Port 16.0 GT/s Transmitter Preset1.  - Case A: When Operating
///< port is Downstream port and whether the Crosslink is supported or
///< not, this field represents the value sent on Lane 1 during 16.0 GT/s
///< equalization.  - Case B: When Operating port is Upstream port and
///< Crosslink Supported bit is 0, this field is intended for debug and
///< diagnostics. It contains the value captured from Lane 1 during Link
///< Equalization.  - Case C: When Operating port is Upstream port and
///< Crosslink Supported bit is 1, Field is not used or affected by the
///< current Link Equalization. Field value will be used if a future crosslink
///< negotiation switches the Operating Port Direction so that case A applies.
///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
///< B also has a writable but not readable register internally with following
///< access attributes. For case B and C, the writable register's value
///< is set to implementation specific 16.0 GT/s Transmitter Preset bits
///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==01b.   Note:
///< The access attributes of this field are as follows:  - Wire: R   -
///< Dbi: R
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST1_BF_OFF (12)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST1_BF_WID ( 4)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST1_BF_MSK (0x0000F000)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_USP_16G_TX_PRST1_BF_DEF (0x00004000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MARGIN_CAP_MARGIN_EXT_CAP_HDR_REG register description at address offset 0x17c
  *
  * Register default value:        0x18C10027
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MARGIN_CAP/MARGIN_EXT_CAP_HDR_REG
  * Margining Extended Capability Header.
  */

typedef union {
  struct {
    uint32_t EXTENDED_CAP_ID : 16;
    ///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
    ///< ID number that indicates the nature and format of the Extended Capability.
    ///< The Extended Capability ID for the Physical Layer 16.0 GT/s Margining
    ///< Extended Capability is 0027h.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x27"
    uint32_t CAP_VERSION : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present. This
    ///< field is depends on version of the specification.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
    ///< register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Capability structure or 000h if no other items exist in
    ///< the linked list of Capabilities. For Extended Capabilities implemented
    ///< in Configuration Space, this offset is relative to the beginning of
    ///< PCI-compatible Configuration Space and thus must always be either
    ///< 000h (for terminating list of Capabilities) or greaterthan 0FFh.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x18C"
  } ;
  uint32_t value;
} pcie_ctl_margin_cap_margin_ext_cap_hdr_reg_t;

#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_DEFAULT (0x18c10027U)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_RD_MASK (0xffffffffU)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_WR_MASK (0x00000000U)


///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
///< ID number that indicates the nature and format of the Extended Capability.
///< The Extended Capability ID for the Physical Layer 16.0 GT/s Margining
///< Extended Capability is 0027h.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_WID (16)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_DEF (0x00000027)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present. This
///< field is depends on version of the specification.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
///< register field is sticky.
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_CAP_VER_BF_OFF (16)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_CAP_VER_BF_WID ( 4)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_CAP_VER_BF_MSK (0x000F0000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_CAP_VER_BF_DEF (0x00010000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Capability structure or 000h if no other items exist in
///< the linked list of Capabilities. For Extended Capabilities implemented
///< in Configuration Space, this offset is relative to the beginning of
///< PCI-compatible Configuration Space and thus must always be either
///< 000h (for terminating list of Capabilities) or greaterthan 0FFh.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_NEXT_OFFSET_BF_DEF (0x18C00000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STATUS_REG register description at address offset 0x180
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MARGIN_CAP/MARGIN_PORT_CAPABILITIES_STATUS_REG
  * Margining Port Capabilities and Status Register.
  */

typedef union {
  struct {
    uint32_t MARGINING_USES_DRIVER_SOFTWARE : 1;
    ///< Margining uses Driver Software. If Set, indicates that Margining is
    ///< partially implemented using Device Driver software. Margining Software
    ///< Ready indicates when this software is initialized. If Clear, Margining
    ///< does not require device driver software. In this case the value read
    ///< from Margining Software Ready is undefined.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
    uint32_t MARGINING_READY : 1;
    ///< Margining Ready. Indicates when the Margining feature is ready to
    ///< accept margining commands. Behavior is undefined if this bit is Clear
    ///< and, for any Lane, any of the Receiver Number , Margin Type , Usage
    ///< Model , or Margin Payload fields are written. If Margining uses Driver
    ///< Software is Set, Margining Ready must be Set no later than 100 ms
    ///< after the later of Margining Software Ready becoming Set or the link
    ///< training to 16.0 GT/s.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t MARGINING_SOFTWARE_READY : 1;
    ///< Margining Software Ready. When Margining uses Driver Software is Set,
    ///< then this bit, when Set, indicates that the required software has
    ///< performed the required initialization. The value of this bit is undefined
    ///< if Margining uses Driver Software is Clear. The default value of this
    ///< bit is implementation specific. If Margining uses Driver Software
    ///< is Clear, Margining Ready must be Set no later than 100 ms after the
    ///< Link trains to 16.0 GT/s. Default value is implementation specific.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_margin_cap_margin_port_capabilities_stat_reg_t;

#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_DEFAULT (0x00000000U)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_RD_MASK (0x00030001U)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_WR_MASK (0x00000000U)


///< Margining uses Driver Software. If Set, indicates that Margining is
///< partially implemented using Device Driver software. Margining Software
///< Ready indicates when this software is initialized. If Clear, Margining
///< does not require device driver software. In this case the value read
///< from Margining Software Ready is undefined.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_USES_DRIVER_SOFTWARE_BF_OFF ( 0)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_USES_DRIVER_SOFTWARE_BF_WID ( 1)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_USES_DRIVER_SOFTWARE_BF_MSK (0x00000001)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_USES_DRIVER_SOFTWARE_BF_DEF (0x00000000)

///< Margining Ready. Indicates when the Margining feature is ready to
///< accept margining commands. Behavior is undefined if this bit is Clear
///< and, for any Lane, any of the Receiver Number , Margin Type , Usage
///< Model , or Margin Payload fields are written. If Margining uses Driver
///< Software is Set, Margining Ready must be Set no later than 100 ms
///< after the later of Margining Software Ready becoming Set or the link
///< training to 16.0 GT/s.
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_READY_BF_OFF (16)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_READY_BF_WID ( 1)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_READY_BF_MSK (0x00010000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_READY_BF_DEF (0x00000000)

///< Margining Software Ready. When Margining uses Driver Software is Set,
///< then this bit, when Set, indicates that the required software has
///< performed the required initialization. The value of this bit is undefined
///< if Margining uses Driver Software is Clear. The default value of this
///< bit is implementation specific. If Margining uses Driver Software
///< is Clear, Margining Ready must be Set no later than 100 ms after the
///< Link trains to 16.0 GT/s. Default value is implementation specific.
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_SOFTWARE_READY_BF_OFF (17)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_SOFTWARE_READY_BF_WID ( 1)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_SOFTWARE_READY_BF_MSK (0x00020000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_MARGINING_SOFTWARE_READY_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MARGIN_CAP_MARGIN_LANE_CNTRL_STATUS0_REG register description at address offset 0x184
  *
  * Register default value:        0x00009C38
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MARGIN_CAP/MARGIN_LANE_CNTRL_STATUS0_REG
  * Margining Lane Control and Status Register for Lane 0.
  */

typedef union {
  struct {
    uint32_t RECEIVER_NUMBER : 3;
    ///< Receiver Number for Lane 0. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t MARGIN_TYPE : 3;
    ///< Margin Type for Lane 0. The default value is 111b. This field must
    ///< be reset to the default value if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x7"
    uint32_t USAGE_MODEL : 1;
    ///< Usage Model for Lane 0. This field must be reset to the default value
    ///< if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t MARGIN_PAYLOAD : 8;
    ///< Margin Payload for Lane 0. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x9C"
    uint32_t RECEIVER_NUMBER_STATUS : 3;
    ///< Receiver Number(Status) for Lane 0. For Downstream Ports, this field
    ///< must be reset to the default value if the Port goes to DL_Down status.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t MARGIN_TYPE_STATUS : 3;
    ///< Margin Type(Status) for Lane 0. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t USAGE_MODEL_STATUS : 1;
    ///< Usage Model(Status) for Lane 0. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t MARGIN_PAYLOAD_STATUS : 8;
    ///< Margin Payload(Status) for Lane 0. This field is only meaningful,
    ///< when the Margin Type is a defined encoding other than 'No Command'.
    ///< This field must be reset to the default value if the Port goes to
    ///< DL_Down status.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_margin_cap_margin_lane_cntrl_stat0_reg_t;

#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_DEFAULT (0x00009c38U)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RD_MASK (0xff7fff7fU)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_WR_MASK (0x0000ff7fU)


///< Receiver Number for Lane 0. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_BF_OFF ( 0)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_BF_MSK (0x00000007)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_BF_DEF (0x00000000)

///< Margin Type for Lane 0. The default value is 111b. This field must
///< be reset to the default value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_BF_OFF ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_BF_MSK (0x00000038)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_BF_DEF (0x00000038)

///< Usage Model for Lane 0. This field must be reset to the default value
///< if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_BF_OFF ( 6)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_BF_WID ( 1)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_BF_MSK (0x00000040)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_BF_DEF (0x00000000)

///< Margin Payload for Lane 0. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_BF_OFF ( 8)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_BF_WID ( 8)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_BF_MSK (0x0000FF00)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_BF_DEF (0x00009C00)

///< Receiver Number(Status) for Lane 0. For Downstream Ports, this field
///< must be reset to the default value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_STAT_BF_OFF (16)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_STAT_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_STAT_BF_MSK (0x00070000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_RECEIVER_NUMBER_STAT_BF_DEF (0x00000000)

///< Margin Type(Status) for Lane 0. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_STAT_BF_OFF (19)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_STAT_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_STAT_BF_MSK (0x00380000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_TYPE_STAT_BF_DEF (0x00000000)

///< Usage Model(Status) for Lane 0. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_STAT_BF_OFF (22)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_STAT_BF_WID ( 1)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_STAT_BF_MSK (0x00400000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_USAGE_MODEL_STAT_BF_DEF (0x00000000)

///< Margin Payload(Status) for Lane 0. This field is only meaningful,
///< when the Margin Type is a defined encoding other than 'No Command'.
///< This field must be reset to the default value if the Port goes to
///< DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_STAT_BF_OFF (24)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_STAT_BF_WID ( 8)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_STAT_BF_MSK (0xFF000000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_MARGIN_PAYLOAD_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_MARGIN_CAP_MARGIN_LANE_CNTRL_STATUS1_REG register description at address offset 0x188
  *
  * Register default value:        0x00009C38
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_MARGIN_CAP/MARGIN_LANE_CNTRL_STATUS1_REG
  * Margining Lane Control and Status Register for Lane 1.
  */

typedef union {
  struct {
    uint32_t RECEIVER_NUMBER : 3;
    ///< Receiver Number for Lane 1. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t MARGIN_TYPE : 3;
    ///< Margin Type for Lane 1. The default value is 111b. This field must
    ///< be reset to the default value if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x7"
    uint32_t USAGE_MODEL : 1;
    ///< Usage Model for Lane 1. This field must be reset to the default value
    ///< if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t MARGIN_PAYLOAD : 8;
    ///< Margin Payload for Lane 1. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x9C"
    uint32_t RECEIVER_NUMBER_STATUS : 3;
    ///< Receiver Number(Status) for Lane 1. For Downstream Ports, this field
    ///< must be reset to the default value if the Port goes to DL_Down status.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t MARGIN_TYPE_STATUS : 3;
    ///< Margin Type(Status) for Lane 1. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t USAGE_MODEL_STATUS : 1;
    ///< Usage Model(Status) for Lane 1. This field must be reset to the default
    ///< value if the Port goes to DL_Down status.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t MARGIN_PAYLOAD_STATUS : 8;
    ///< Margin Payload(Status) for Lane 1. This field is only meaningful,
    ///< when the Margin Type is a defined encoding other than 'No Command'.
    ///< This field must be reset to the default value if the Port goes to
    ///< DL_Down status.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_margin_cap_margin_lane_cntrl_stat1_reg_t;

#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_DEFAULT (0x00009c38U)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RD_MASK (0xff7fff7fU)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_WR_MASK (0x0000ff7fU)


///< Receiver Number for Lane 1. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_BF_OFF ( 0)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_BF_MSK (0x00000007)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_BF_DEF (0x00000000)

///< Margin Type for Lane 1. The default value is 111b. This field must
///< be reset to the default value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_BF_OFF ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_BF_MSK (0x00000038)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_BF_DEF (0x00000038)

///< Usage Model for Lane 1. This field must be reset to the default value
///< if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_BF_OFF ( 6)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_BF_WID ( 1)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_BF_MSK (0x00000040)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_BF_DEF (0x00000000)

///< Margin Payload for Lane 1. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_BF_OFF ( 8)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_BF_WID ( 8)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_BF_MSK (0x0000FF00)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_BF_DEF (0x00009C00)

///< Receiver Number(Status) for Lane 1. For Downstream Ports, this field
///< must be reset to the default value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_STAT_BF_OFF (16)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_STAT_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_STAT_BF_MSK (0x00070000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_RECEIVER_NUMBER_STAT_BF_DEF (0x00000000)

///< Margin Type(Status) for Lane 1. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_STAT_BF_OFF (19)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_STAT_BF_WID ( 3)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_STAT_BF_MSK (0x00380000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_TYPE_STAT_BF_DEF (0x00000000)

///< Usage Model(Status) for Lane 1. This field must be reset to the default
///< value if the Port goes to DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_STAT_BF_OFF (22)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_STAT_BF_WID ( 1)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_STAT_BF_MSK (0x00400000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_USAGE_MODEL_STAT_BF_DEF (0x00000000)

///< Margin Payload(Status) for Lane 1. This field is only meaningful,
///< when the Margin Type is a defined encoding other than 'No Command'.
///< This field must be reset to the default value if the Port goes to
///< DL_Down status.
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_STAT_BF_OFF (24)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_STAT_BF_WID ( 8)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_STAT_BF_MSK (0xFF000000)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_MARGIN_PAYLOAD_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_EXT_CAP_HDR_REG register description at address offset 0x18c
  *
  * Register default value:        0x1B01002A
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_EXT_CAP_HDR_REG
  * Physical Layer 32.0 GT/s Extended Capability Header.
  */

typedef union {
  struct {
    uint32_t EXTENDED_CAP_ID : 16;
    ///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
    ///< ID number that indicates the nature and format of the Extended Capability.
    ///< The Extended Capability ID for the Physical Layer 32.0 GT/s Capability
    ///< is 002Ah.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x2A"
    uint32_t CAP_VERSION : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present. This
    ///< bit depends on the version of the specification.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
    ///< register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Capability structure or 000h if no other items exist in
    ///< the linked list of Capabilities. For Extended Capabilities implemented
    ///< in Configuration Space, this offset is relative to the beginning of
    ///< PCI-compatible Configuration Space and thus must always be either
    ///< 000h (for terminating list of Capabilities) or greater than 0FFh.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x1B0"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_ext_cap_hdr_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_DEFAULT (0x1b01002aU)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_RD_MASK (0xffffffffU)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_WR_MASK (0x00000000U)


///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
///< ID number that indicates the nature and format of the Extended Capability.
///< The Extended Capability ID for the Physical Layer 32.0 GT/s Capability
///< is 002Ah.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_WID (16)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_EXTENDED_CAP_ID_BF_DEF (0x0000002A)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present. This
///< bit depends on the version of the specification.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
///< register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_CAP_VER_BF_OFF (16)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_CAP_VER_BF_WID ( 4)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_CAP_VER_BF_MSK (0x000F0000)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_CAP_VER_BF_DEF (0x00010000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Capability structure or 000h if no other items exist in
///< the linked list of Capabilities. For Extended Capabilities implemented
///< in Configuration Space, this offset is relative to the beginning of
///< PCI-compatible Configuration Space and thus must always be either
///< 000h (for terminating list of Capabilities) or greater than 0FFh.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_NEXT_OFFSET_BF_DEF (0x1B000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_CAPABILITY_REG register description at address offset 0x190
  *
  * Register default value:        0x00000100
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_CAPABILITY_REG
  * 32.0 GT/s Capabilities Register.
  */

typedef union {
  struct {
    uint32_t EQ_BYPASS_HIGHEST_RATE_SUPPORT : 1;
    ///< Equalization bypass to highest rate Supported. Must be 1b for Ports
    ///< that support 32.0 GT/s or higher data rates.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi:  if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t NO_EQ_NEEDED_SUPPORT : 1;
    ///< No Equalization Needed Support.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t MOD_TS_PCIE_SUPPORT : 1;
    ///< Modified TS Usage Mode 0 Supported. This bit must be 1b.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x1"
    uint32_t MOD_TS_TRAING_SET_MSG_SUPPORT : 1;
    ///< Modified TS Usage Mode 1 Supported, Training Set Message.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t MOD_TS_RSVD_USAGE_MODE : 5;
    ///< Modified TS Reserved Usage Modes. Reserved bits for future Usage Modes
    ///< defined by the PCISIG. Must be 0 0000b.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_capability_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_DEFAULT (0x00000100U)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_RD_MASK (0x0000fb03U)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_WR_MASK (0x00000000U)


///< Equalization bypass to highest rate Supported. Must be 1b for Ports
///< that support 32.0 GT/s or higher data rates.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi:  if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_EQ_BYP_HIGHEST_RATE_SUPPORT_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_EQ_BYP_HIGHEST_RATE_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_EQ_BYP_HIGHEST_RATE_SUPPORT_BF_MSK (0x00000001)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_EQ_BYP_HIGHEST_RATE_SUPPORT_BF_DEF (0x00000000)

///< No Equalization Needed Support.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_NO_EQ_NEEDED_SUPPORT_BF_OFF ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_NO_EQ_NEEDED_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_NO_EQ_NEEDED_SUPPORT_BF_MSK (0x00000002)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_NO_EQ_NEEDED_SUPPORT_BF_DEF (0x00000000)

///< Modified TS Usage Mode 0 Supported. This bit must be 1b.   Note: The
///< access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_PCIE_SUPPORT_BF_OFF ( 8)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_PCIE_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_PCIE_SUPPORT_BF_MSK (0x00000100)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_PCIE_SUPPORT_BF_DEF (0x00000100)

///< Modified TS Usage Mode 1 Supported, Training Set Message.
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_TRAING_SET_MSG_SUPPORT_BF_OFF ( 9)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_TRAING_SET_MSG_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_TRAING_SET_MSG_SUPPORT_BF_MSK (0x00000200)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_TRAING_SET_MSG_SUPPORT_BF_DEF (0x00000000)

///< Modified TS Reserved Usage Modes. Reserved bits for future Usage Modes
///< defined by the PCISIG. Must be 0 0000b.
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_RSVD_USAGE_MODE_BF_OFF (11)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_RSVD_USAGE_MODE_BF_WID ( 5)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_RSVD_USAGE_MODE_BF_MSK (0x0000F800)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_MOD_TS_RSVD_USAGE_MODE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_CONTROL_REG register description at address offset 0x194
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_CONTROL_REG
  * 32.0 GT/s Control Register.
  */

typedef union {
  struct {
    uint32_t EQ_BYPASS_HIGHEST_RATE_DISABLE : 1;
    ///< Equalization bypass to highest rate Disable. If Equalization bypass
    ///< to highest rate Supported is Set, this bit is RWS with a default value
    ///< of 0b.   Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t NO_EQ_NEEDED_DISABLE : 1;
    ///< No Equalization Needed Disable. If No Equalization Needed Supported
    ///< is Set, this bit is RWS with a default value of 0b.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t MOD_TS_USAGE_MODE_SELECT : 3;
    ///< Modified TS Usage Mode Selected. This field indicates which Usage
    ///< Mode is used by this Downstream Port. In Upstream Ports, this field
    ///< is RsvdP. Default is 000b. All encodings other than the  defined encodings
    ///< are reserved. Unused bits in this field are permitted to be hardwired
    ///< to 0b. If the only supported usage mode is PCI Express, this field
    ///< is permitted to he hardwired to 000b. If 001b, PCIe protocol only
    ///< with vendor defined Training Set Messages. If 010b, Alternate Protocol
    ///< Negotiation.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_ctrl_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_DEFAULT (0x00000000U)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_RD_MASK (0x00000703U)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_WR_MASK (0x00000003U)


///< Equalization bypass to highest rate Disable. If Equalization bypass
///< to highest rate Supported is Set, this bit is RWS with a default value
///< of 0b.   Note: This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_EQ_BYP_HIGHEST_RATE_DIS_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_EQ_BYP_HIGHEST_RATE_DIS_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_EQ_BYP_HIGHEST_RATE_DIS_BF_MSK (0x00000001)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_EQ_BYP_HIGHEST_RATE_DIS_BF_DEF (0x00000000)

///< No Equalization Needed Disable. If No Equalization Needed Supported
///< is Set, this bit is RWS with a default value of 0b.   Note: This register
///< field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_NO_EQ_NEEDED_DIS_BF_OFF ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_NO_EQ_NEEDED_DIS_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_NO_EQ_NEEDED_DIS_BF_MSK (0x00000002)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_NO_EQ_NEEDED_DIS_BF_DEF (0x00000000)

///< Modified TS Usage Mode Selected. This field indicates which Usage
///< Mode is used by this Downstream Port. In Upstream Ports, this field
///< is RsvdP. Default is 000b. All encodings other than the  defined encodings
///< are reserved. Unused bits in this field are permitted to be hardwired
///< to 0b. If the only supported usage mode is PCI Express, this field
///< is permitted to he hardwired to 000b. If 001b, PCIe protocol only
///< with vendor defined Training Set Messages. If 010b, Alternate Protocol
///< Negotiation.
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_MOD_TS_USAGE_MODE_SEL_BF_OFF ( 8)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_MOD_TS_USAGE_MODE_SEL_BF_WID ( 3)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_MOD_TS_USAGE_MODE_SEL_BF_MSK (0x00000700)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_MOD_TS_USAGE_MODE_SEL_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_STATUS_REG register description at address offset 0x198
  *
  * Register default value:        0x00000200
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_STATUS_REG
  * 32.0 GT/s Status Register.
  */

typedef union {
  struct {
    uint32_t EQ_32G_CPL : 1;
    ///< Equalization 32.0GT/s Complete. For a Multi-Function Upstream Port,
    ///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
    ///< Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t EQ_32G_CPL_P1 : 1;
    ///< Equalization 32.0GT/s Phase 1 Successful. For a Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EQ_32G_CPL_P2 : 1;
    ///< Equalization 32.0GT/s Phase 2 Successful. For a Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t EQ_32G_CPL_P3 : 1;
    ///< Equalization 32.0GT/s Phase 3 Successful. For a Multi-Function Upstream
    ///< Port, this bit must be implemented in Function 0 and RsvdZ in other
    ///< Functions.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t LINK_EQ_32G_REQ : 1;
    ///< Link Equalization Request 32.0GT/s. This bit is Set by hardware to
    ///< request the 32.0 GT/s Link equalization process to be performed on
    ///< the Link. For a Multi-Function Upstream Port, this bit must be implemented
    ///< in Function 0 and RsvdZ in other Functions.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW/1C/V" BitOffset="4" ResetValue="0x0"
    uint32_t MOD_TS_RCVD : 1;
    ///< Modified TS Received. This bit is Cleared when the Link is Down. This
    ///< bit is Set when the Modified TS1/TS2 Ordered Set is received.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t RX_ENH_LINK_BEHAVIOR_CTRL : 2;
    ///< Received Enhanced Link Behavior Control. This field contains the Enhanced
    ///< Link Behavior Control bits from the most recent TS1 or TS2 received
    ///< in the Polling or Configuration states.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t TX_PRECODING_ON : 1;
    ///< Transmitter Precoding On. This field indicates whether the Receiver
    ///< asked this transmitter to enable Precoding. This bit is cleared on
    ///< DL_Down.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t TX_PRECODE_REQ : 1;
    ///< Transmitter Precode Request.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RW/V" BitOffset="9" ResetValue="0x1"
    uint32_t NO_EQ_NEEDED_RCVD : 1;
    ///< No Equalization Needed Received. This bit is Set when this Port either
    ///< received a Modified TS1/TS2 with the No Equalization Needed bit Set
    ///< or received a non-modified TS1/TS2 was received with the No Equalization
    ///< Needed encoding. This bit is cleared on DL_Down.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_stat_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_STAT_DEFAULT (0x00000200U)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_RD_MASK (0x000007ffU)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_WR_MASK (0x00000210U)


///< Equalization 32.0GT/s Complete. For a Multi-Function Upstream Port,
///< this bit must be implemented in Function 0 and RsvdZ in other Functions.
///< Note: This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_BF_MSK (0x00000001)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_BF_DEF (0x00000000)

///< Equalization 32.0GT/s Phase 1 Successful. For a Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions.   Note: This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P1_BF_OFF ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P1_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P1_BF_MSK (0x00000002)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P1_BF_DEF (0x00000000)

///< Equalization 32.0GT/s Phase 2 Successful. For a Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions.   Note: This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P2_BF_OFF ( 2)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P2_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P2_BF_MSK (0x00000004)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P2_BF_DEF (0x00000000)

///< Equalization 32.0GT/s Phase 3 Successful. For a Multi-Function Upstream
///< Port, this bit must be implemented in Function 0 and RsvdZ in other
///< Functions.   Note: This register field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P3_BF_OFF ( 3)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P3_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P3_BF_MSK (0x00000008)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_EQ_32G_CPL_P3_BF_DEF (0x00000000)

///< Link Equalization Request 32.0GT/s. This bit is Set by hardware to
///< request the 32.0 GT/s Link equalization process to be performed on
///< the Link. For a Multi-Function Upstream Port, this bit must be implemented
///< in Function 0 and RsvdZ in other Functions.   Note: This register
///< field is sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_LINK_EQ_32G_REQ_BF_OFF ( 4)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_LINK_EQ_32G_REQ_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_LINK_EQ_32G_REQ_BF_MSK (0x00000010)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_LINK_EQ_32G_REQ_BF_DEF (0x00000000)

///< Modified TS Received. This bit is Cleared when the Link is Down. This
///< bit is Set when the Modified TS1/TS2 Ordered Set is received.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_MOD_TS_RCVD_BF_OFF ( 5)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_MOD_TS_RCVD_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_MOD_TS_RCVD_BF_MSK (0x00000020)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_MOD_TS_RCVD_BF_DEF (0x00000000)

///< Received Enhanced Link Behavior Control. This field contains the Enhanced
///< Link Behavior Control bits from the most recent TS1 or TS2 received
///< in the Polling or Configuration states.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_RX_ENH_LINK_BEHAVIOR_CTRL_BF_OFF ( 6)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_RX_ENH_LINK_BEHAVIOR_CTRL_BF_WID ( 2)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_RX_ENH_LINK_BEHAVIOR_CTRL_BF_MSK (0x000000C0)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_RX_ENH_LINK_BEHAVIOR_CTRL_BF_DEF (0x00000000)

///< Transmitter Precoding On. This field indicates whether the Receiver
///< asked this transmitter to enable Precoding. This bit is cleared on
///< DL_Down.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODING_ON_BF_OFF ( 8)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODING_ON_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODING_ON_BF_MSK (0x00000100)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODING_ON_BF_DEF (0x00000000)

///< Transmitter Precode Request.   Note: The access attributes of this
///< field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODE_REQ_BF_OFF ( 9)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODE_REQ_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODE_REQ_BF_MSK (0x00000200)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_TX_PRECODE_REQ_BF_DEF (0x00000200)

///< No Equalization Needed Received. This bit is Set when this Port either
///< received a Modified TS1/TS2 with the No Equalization Needed bit Set
///< or received a non-modified TS1/TS2 was received with the No Equalization
///< Needed encoding. This bit is cleared on DL_Down.
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_NO_EQ_NEEDED_RCVD_BF_OFF (10)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_NO_EQ_NEEDED_RCVD_BF_WID ( 1)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_NO_EQ_NEEDED_RCVD_BF_MSK (0x00000400)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_NO_EQ_NEEDED_RCVD_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_REG register description at address offset 0x19c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_RCVD_MOD_TS_DATA1_REG
  * Received Modified TS Data 1 Register.
  */

typedef union {
  struct {
    uint32_t RCVD_MOD_TS_USAGE_MODE : 3;
    ///< Received Modified TS Usage Mode. If Modified TS Received is Set, this
    ///< field contains the Modified TS Usage field from the Modified TS1/TS2
    ///< Ordered Set. If Modified TS Received is Clear, this field contains
    ///< 000b. Unused bits in this field are permitted to he hardwired by controller
    ///< to 0b. If PCI Express (Usage Mode 0) is the only one supported, this
    ///< field is permitted to be hardwired to 000b.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t RCVD_MOD_TS_INFO1 : 13;
    ///< Received Modified TS Information 1. If Modified TS Received is Set,
    ///< this field contains the Modified TS Information 1 field from the Modified
    ///< TS1/TS2 Ordered Set. If Modified TS Received is Clear, this field
    ///< contains 0 0000 0000 0000b.  - 15:8  -- contain the value of Symbol
    ///< 9  - 7:3  -- contain bits 7:3 of Symbol 8 If PCI Express (Usage Mode
    ///< 0) is the only one supported, this field is permitted to be hardwired
    ///< to 0 0000 0000 0000b by controller.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t RCVD_MOD_TS_VENDER_ID : 16;
    ///< Received Modified TS Vendor ID. If Modified TS Received is Set, this
    ///< field contains the Modified TS Vendor ID field from the Modified TS1/TS2
    ///< Ordered Set received. If Modified TS Received is Clear, this field
    ///< contains 0000h.  - 15:8  -- Contain the value of Symbol 11.  - 7:0
    ///< -- Contain the value of Symbol 10. If PCI Express (Usage Mode 0) is
    ///< the only one supported, this field is permitted to be hardwired to
    ///< 0000h.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_rcvd_mod_ts_data1_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_DEFAULT (0x00000000U)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RD_MASK (0xffffffffU)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_WR_MASK (0x00000000U)


///< Received Modified TS Usage Mode. If Modified TS Received is Set, this
///< field contains the Modified TS Usage field from the Modified TS1/TS2
///< Ordered Set. If Modified TS Received is Clear, this field contains
///< 000b. Unused bits in this field are permitted to he hardwired by controller
///< to 0b. If PCI Express (Usage Mode 0) is the only one supported, this
///< field is permitted to be hardwired to 000b.
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_USAGE_MODE_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_USAGE_MODE_BF_WID ( 3)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_USAGE_MODE_BF_MSK (0x00000007)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_USAGE_MODE_BF_DEF (0x00000000)

///< Received Modified TS Information 1. If Modified TS Received is Set,
///< this field contains the Modified TS Information 1 field from the Modified
///< TS1/TS2 Ordered Set. If Modified TS Received is Clear, this field
///< contains 0 0000 0000 0000b.  - 15:8  -- contain the value of Symbol
///< 9  - 7:3  -- contain bits 7:3 of Symbol 8 If PCI Express (Usage Mode
///< 0) is the only one supported, this field is permitted to be hardwired
///< to 0 0000 0000 0000b by controller.
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_INFO1_BF_OFF ( 3)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_INFO1_BF_WID (13)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_INFO1_BF_MSK (0x0000FFF8)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_INFO1_BF_DEF (0x00000000)

///< Received Modified TS Vendor ID. If Modified TS Received is Set, this
///< field contains the Modified TS Vendor ID field from the Modified TS1/TS2
///< Ordered Set received. If Modified TS Received is Clear, this field
///< contains 0000h.  - 15:8  -- Contain the value of Symbol 11.  - 7:0
///< -- Contain the value of Symbol 10. If PCI Express (Usage Mode 0) is
///< the only one supported, this field is permitted to be hardwired to
///< 0000h.
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_VENDER_ID_BF_OFF (16)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_VENDER_ID_BF_WID (16)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_VENDER_ID_BF_MSK (0xFFFF0000)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_RCVD_MOD_TS_VENDER_ID_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_REG register description at address offset 0x1a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_RCVD_MOD_TS_DATA2_REG
  * Received Modified TS Data 2 Register.
  */

typedef union {
  struct {
    uint32_t RCVD_MOD_TS_INFO2 : 24;
    ///< Received Modified TS Information 2. If Modified TS Received is Set,
    ///< this field contains the Modified TS Information 2 field from the received
    ///< Modified TS1/TS2 Ordered Set. If Modified TS Received is Clear, this
    ///< field contains 00 0000h.  - 23:16  -- Contain the value of Symbol
    ///< 12.  - 16:8  -- Contain the value of Symbol 13.  - 7:0  -- Contain
    ///< the value of Symbol 14. If PCI Express (Usage Mode 0) is the only
    ///< one supported, this field is permitted to be hardwired to 00 0000h.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t RCVD_ALT_PROTOCOL_NEGO_STATUS : 2;
    ///< Alternate Protocol Negotation Status. Indicates the status of the
    ///< Alternate Protocol Negotiaiton. If Modified TS Usage Mode 1 Supported
    ///< - Training Set Message and Modified TS Usage Mode 2 Supported - Alternate
    ///< Protocol are both Clear, this register is permitted to be hardwired
    ///< to 0000 0000h by controller. If Modified TS Usage Mode 2 Supported
    ///< - Alternate Protocol is Clear, this bit is hardwired to 0b. If Modified
    ///< TS Usage Mode Selected does not equal 2, this bit contains 0b.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_rcvd_mod_ts_data2_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_DEFAULT (0x00000000U)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RD_MASK (0x03ffffffU)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_WR_MASK (0x00000000U)


///< Received Modified TS Information 2. If Modified TS Received is Set,
///< this field contains the Modified TS Information 2 field from the received
///< Modified TS1/TS2 Ordered Set. If Modified TS Received is Clear, this
///< field contains 00 0000h.  - 23:16  -- Contain the value of Symbol
///< 12.  - 16:8  -- Contain the value of Symbol 13.  - 7:0  -- Contain
///< the value of Symbol 14. If PCI Express (Usage Mode 0) is the only
///< one supported, this field is permitted to be hardwired to 00 0000h.
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_MOD_TS_INFO2_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_MOD_TS_INFO2_BF_WID (24)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_MOD_TS_INFO2_BF_MSK (0x00FFFFFF)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_MOD_TS_INFO2_BF_DEF (0x00000000)

///< Alternate Protocol Negotation Status. Indicates the status of the
///< Alternate Protocol Negotiaiton. If Modified TS Usage Mode 1 Supported
///< - Training Set Message and Modified TS Usage Mode 2 Supported - Alternate
///< Protocol are both Clear, this register is permitted to be hardwired
///< to 0000 0000h by controller. If Modified TS Usage Mode 2 Supported
///< - Alternate Protocol is Clear, this bit is hardwired to 0b. If Modified
///< TS Usage Mode Selected does not equal 2, this bit contains 0b.
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_ALT_PROTOCOL_NEGO_STAT_BF_OFF (24)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_ALT_PROTOCOL_NEGO_STAT_BF_WID ( 2)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_ALT_PROTOCOL_NEGO_STAT_BF_MSK (0x03000000)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_RCVD_ALT_PROTOCOL_NEGO_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_REG register description at address offset 0x1a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_TX_MOD_TS_DATA1_REG
  * Transmitted Modified TS Data 1 Register.
  */

typedef union {
  struct {
    uint32_t TX_MOD_TS_USAGE_MODE : 3;
    ///< Transmitted Modified TS Usage Mode. If Modified TS Received is Set,
    ///< this field contains the Modified TS Usage field from the last Modified
    ///< TS1/TS2 Ordered Set transmitted during the most recent LTSSM State.
    ///< Unused bits in this field are permitted to he hardwired to 0b. If
    ///< PCI Express (Usage Mode 0) is the only one supported, this field is
    ///< permitted to be hardwired to 000b.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_MOD_TS_INFO1 : 13;
    ///< Transmitted Modified TS Information 1. If Modified TS Received is
    ///< Set, this field contains the Modified TS Information 1 field from
    ///< Modified TS2 Ordered Set transmitted during the Configuration.Complete
    ///< LTSSM State.   Bits [15:8] contain the value of Symbol 9   Bits [7:3]
    ///< contain bits 7:3 of Symbol 8 If PCI Express (Usage Mode 0) is the
    ///< only one supported, this field is permitted to be hardwired to 0 0000
    ///< 0000 0000b.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t TX_MOD_TS_VENDER_ID : 16;
    ///< Transmitted Modified TS Vendor ID. If Modified TS Received is Set,
    ///< this field contains the Modified TS Vendor ID field from the last
    ///< Modified TS1/TS2 Ordered Set transmitted during the most recent LTSSM
    ///< State.  - Bits 15:8 contain the value of Symbol 11.  - Bits 7:0 contain
    ///< the value of Symbol 10. If PCI Express (Usage Mode 0) is the only
    ///< one supported, this field is permitted to be hardwired to 0000h by
    ///< controller.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_tx_mod_ts_data1_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_DEFAULT (0x00000000U)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_RD_MASK (0xffffffffU)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_WR_MASK (0x00000000U)


///< Transmitted Modified TS Usage Mode. If Modified TS Received is Set,
///< this field contains the Modified TS Usage field from the last Modified
///< TS1/TS2 Ordered Set transmitted during the most recent LTSSM State.
///< Unused bits in this field are permitted to he hardwired to 0b. If
///< PCI Express (Usage Mode 0) is the only one supported, this field is
///< permitted to be hardwired to 000b.
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_USAGE_MODE_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_USAGE_MODE_BF_WID ( 3)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_USAGE_MODE_BF_MSK (0x00000007)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_USAGE_MODE_BF_DEF (0x00000000)

///< Transmitted Modified TS Information 1. If Modified TS Received is
///< Set, this field contains the Modified TS Information 1 field from
///< Modified TS2 Ordered Set transmitted during the Configuration.Complete
///< LTSSM State.   Bits [15:8] contain the value of Symbol 9   Bits [7:3]
///< contain bits 7:3 of Symbol 8 If PCI Express (Usage Mode 0) is the
///< only one supported, this field is permitted to be hardwired to 0 0000
///< 0000 0000b.
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_INFO1_BF_OFF ( 3)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_INFO1_BF_WID (13)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_INFO1_BF_MSK (0x0000FFF8)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_INFO1_BF_DEF (0x00000000)

///< Transmitted Modified TS Vendor ID. If Modified TS Received is Set,
///< this field contains the Modified TS Vendor ID field from the last
///< Modified TS1/TS2 Ordered Set transmitted during the most recent LTSSM
///< State.  - Bits 15:8 contain the value of Symbol 11.  - Bits 7:0 contain
///< the value of Symbol 10. If PCI Express (Usage Mode 0) is the only
///< one supported, this field is permitted to be hardwired to 0000h by
///< controller.
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_VENDER_ID_BF_OFF (16)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_VENDER_ID_BF_WID (16)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_VENDER_ID_BF_MSK (0xFFFF0000)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_TX_MOD_TS_VENDER_ID_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_REG register description at address offset 0x1a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_TX_MOD_TS_DATA2_REG
  * Transmitted Modified TS Data 2 Register.
  */

typedef union {
  struct {
    uint32_t TX_MOD_TS_INFO2 : 24;
    ///< Transmitted Modified TS Information 2. If Modified TS Received is
    ///< Set, this field contains the Modified TS Information 2 field from
    ///< the last Modified TS1/TS2 Ordered Set transmitted during the most
    ///< recent LTSSM State.   Bits [23:16] contain the value of Symbol 12.
    ///< Bits [16:8] contain the value of Symbol 13.   Bits [7:0] contain the
    ///< value of Symbol 14. If PCI Express (Usage Mode 0) is the only one
    ///< supported, this field is permitted to be hardwired to 00 0000h by
    ///< the controller.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_ALT_PROTOCOL_NEGO_STATUS : 2;
    ///< Alternate Protocol Negotation Status. Indicates the status of the
    ///< Alternate Protocol Negotiaiton. Encodings are : If Modified TS Usage
    ///< Mode 1 Supported - Training Set Message and Modified TS Usage Mode
    ///< 2 Supported - Alternate Protocol are both Clear, this register is
    ///< permitted to be hardwired to 0000 0000h by controller. If Modified
    ///< TS Usage Mode 2 Supported - Alternate Protocol is Clear, this bit
    ///< is hardwired to 0b. If Modified TS Usage Mode Selected does not equal
    ///< 2, this bit contains 0b.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_tx_mod_ts_data2_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_DEFAULT (0x00000000U)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_RD_MASK (0x03ffffffU)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_WR_MASK (0x00000000U)


///< Transmitted Modified TS Information 2. If Modified TS Received is
///< Set, this field contains the Modified TS Information 2 field from
///< the last Modified TS1/TS2 Ordered Set transmitted during the most
///< recent LTSSM State.   Bits [23:16] contain the value of Symbol 12.
///< Bits [16:8] contain the value of Symbol 13.   Bits [7:0] contain the
///< value of Symbol 14. If PCI Express (Usage Mode 0) is the only one
///< supported, this field is permitted to be hardwired to 00 0000h by
///< the controller.
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_MOD_TS_INFO2_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_MOD_TS_INFO2_BF_WID (24)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_MOD_TS_INFO2_BF_MSK (0x00FFFFFF)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_MOD_TS_INFO2_BF_DEF (0x00000000)

///< Alternate Protocol Negotation Status. Indicates the status of the
///< Alternate Protocol Negotiaiton. Encodings are : If Modified TS Usage
///< Mode 1 Supported - Training Set Message and Modified TS Usage Mode
///< 2 Supported - Alternate Protocol are both Clear, this register is
///< permitted to be hardwired to 0000 0000h by controller. If Modified
///< TS Usage Mode 2 Supported - Alternate Protocol is Clear, this bit
///< is hardwired to 0b. If Modified TS Usage Mode Selected does not equal
///< 2, this bit contains 0b.
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_ALT_PROTOCOL_NEGO_STAT_BF_OFF (24)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_ALT_PROTOCOL_NEGO_STAT_BF_WID ( 2)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_ALT_PROTOCOL_NEGO_STAT_BF_MSK (0x03000000)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_TX_ALT_PROTOCOL_NEGO_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PL32G_CAP_PL32G_CAP_OFF_20H_REG register description at address offset 0x1ac
  *
  * Register default value:        0x00004040
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PL32G_CAP/PL32G_CAP_OFF_20H_REG
  * 32.0 GT/s Lane Equalization Control Register for Lane 0-3.
  */

typedef union {
  struct {
    uint32_t DSP_32G_TX_PRESET0 : 4;
    ///< Downstream Port 32.0 GT/s Transmitter Preset0. Transmitter Preset
    ///< of Lane 0 used for 32.0 GT/s equalization by this Port when the Port
    ///< is operating as a Downstream Port. This field is ignored when the
    ///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
    ///< Supported is 0b, this field is RsvdP, otherwise, this field is HwInit.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t USP_32G_TX_PRESET0 : 4;
    ///< Upstream Port 32.0 GT/s Transmitter Preset0.  - Case A: When Operating
    ///< port is Downstream port and whether the Crosslink is supported or
    ///< not, this field representss the value sent on Lane 0 during 32.0 GT/s
    ///< equalization.  - Case B: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 0, this field is intended for debug and
    ///< diagnostics. It contains the value captured from Lane 0 during Link
    ///< Equalization.  - Case C: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 1, Field is not used or affected by the
    ///< current Link Equalization. Field value will be used if a future crosslink
    ///< negotiation switches the Operating Port Direction so that case A applies.
    ///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
    ///< B also has a writable but not readable register internally with following
    ///< access attributes. For case B and C, the writable register's value
    ///< is set to implementation specific 32.0 GT/s Transmitter Preset bits
    ///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
    ///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==10b.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x4"
    uint32_t DSP_32G_TX_PRESET1 : 4;
    ///< Downstream Port 32.0 GT/s Transmitter Preset1. Transmitter Preset
    ///< of Lane 1 used for 32.0 GT/s equalization by this Port when the Port
    ///< is operating as a Downstream Port. This field is ignored when the
    ///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
    ///< Supported is 0b, this field is RsvdP, otherwise, this field is HwInit.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t USP_32G_TX_PRESET1 : 4;
    ///< Upstream Port 32.0 GT/s Transmitter Preset1.  - Case A: When Operating
    ///< port is Downstream port and whether the Crosslink is supported or
    ///< not, this field representss the value sent on Lane 1 during 32.0 GT/s
    ///< equalization.  - Case B: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 0, this field is intended for debug and
    ///< diagnostics. It contains the value captured from Lane 1 during Link
    ///< Equalization.  - Case C: When Operating port is Upstream port and
    ///< Crosslink Supported bit is 1, Field is not used or affected by the
    ///< current Link Equalization. Field value will be used if a future crosslink
    ///< negotiation switches the Operating Port Direction so that case A applies.
    ///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
    ///< B also has a writable but not readable register internally with following
    ///< access attributes. For case B and C, the writable register's value
    ///< is set to implementation specific 32.0 GT/s Transmitter Preset bits
    ///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
    ///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==10b.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x4"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_pl32g_cap_pl32g_cap_off_20h_reg_t;

#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DEFAULT (0x00004040U)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_RD_MASK (0x0000ffffU)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_WR_MASK (0x00000000U)


///< Downstream Port 32.0 GT/s Transmitter Preset0. Transmitter Preset
///< of Lane 0 used for 32.0 GT/s equalization by this Port when the Port
///< is operating as a Downstream Port. This field is ignored when the
///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
///< Supported is 0b, this field is RsvdP, otherwise, this field is HwInit.
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST0_BF_OFF ( 0)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST0_BF_WID ( 4)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST0_BF_MSK (0x0000000F)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST0_BF_DEF (0x00000000)

///< Upstream Port 32.0 GT/s Transmitter Preset0.  - Case A: When Operating
///< port is Downstream port and whether the Crosslink is supported or
///< not, this field representss the value sent on Lane 0 during 32.0 GT/s
///< equalization.  - Case B: When Operating port is Upstream port and
///< Crosslink Supported bit is 0, this field is intended for debug and
///< diagnostics. It contains the value captured from Lane 0 during Link
///< Equalization.  - Case C: When Operating port is Upstream port and
///< Crosslink Supported bit is 1, Field is not used or affected by the
///< current Link Equalization. Field value will be used if a future crosslink
///< negotiation switches the Operating Port Direction so that case A applies.
///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
///< B also has a writable but not readable register internally with following
///< access attributes. For case B and C, the writable register's value
///< is set to implementation specific 32.0 GT/s Transmitter Preset bits
///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==10b.
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST0_BF_OFF ( 4)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST0_BF_WID ( 4)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST0_BF_MSK (0x000000F0)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST0_BF_DEF (0x00000040)

///< Downstream Port 32.0 GT/s Transmitter Preset1. Transmitter Preset
///< of Lane 1 used for 32.0 GT/s equalization by this Port when the Port
///< is operating as a Downstream Port. This field is ignored when the
///< Port is operating as an Upstream Port. For an Upstream Port if Crosslink
///< Supported is 0b, this field is RsvdP, otherwise, this field is HwInit.
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST1_BF_OFF ( 8)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST1_BF_WID ( 4)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST1_BF_MSK (0x00000F00)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_DSP_32G_TX_PRST1_BF_DEF (0x00000000)

///< Upstream Port 32.0 GT/s Transmitter Preset1.  - Case A: When Operating
///< port is Downstream port and whether the Crosslink is supported or
///< not, this field representss the value sent on Lane 1 during 32.0 GT/s
///< equalization.  - Case B: When Operating port is Upstream port and
///< Crosslink Supported bit is 0, this field is intended for debug and
///< diagnostics. It contains the value captured from Lane 1 during Link
///< Equalization.  - Case C: When Operating port is Upstream port and
///< Crosslink Supported bit is 1, Field is not used or affected by the
///< current Link Equalization. Field value will be used if a future crosslink
///< negotiation switches the Operating Port Direction so that case A applies.
///< For case A and C, Field is HwInit. For case B, Field is RO.   Case
///< B also has a writable but not readable register internally with following
///< access attributes. For case B and C, the writable register's value
///< is set to implementation specific 32.0 GT/s Transmitter Preset bits
///< in optional EQ TS2 OS if USP_SEND_8GT_EQ_TS2_DISABLE field of PORT_LOGIC
///< - GEN3_RELATED_OFF register is 0b with RATE_SHADOW_SEL==10b.
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST1_BF_OFF (12)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST1_BF_WID ( 4)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST1_BF_MSK (0x0000F000)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_USP_32G_TX_PRST1_BF_DEF (0x00004000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_RAS_DES_CAP_HEADER_REG register description at address offset 0x1b0
  *
  * Register default value:        0x2B01000B
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/RAS_DES_CAP_HEADER_REG
  * Vendor-Specific Extended Capability Header.
  */

typedef union {
  struct {
    uint32_t EXTENDED_CAP_ID : 16;
    ///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
    ///< ID number that indicates the nature and format of the Extended Capability.
    ///< Extended Capability ID for the Vendor-Specific Extended Capability
    ///< is 000Bh.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xB"
    uint32_t CAP_VERSION : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present. Value
    ///< of this field is depends on the version of the specification.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
    ///< This register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Capability structure or 000h if no other items exist in
    ///< the linked list of Capabilities. For Extended Capabilities implemented
    ///< in Configuration Space, this offset is relative to the beginning of
    ///< PCI-compatible Configuration Space and thus must always be either
    ///< 000h (for terminating list of Capabilities) or greater than 0FFh.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x2B0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_ras_des_cap_header_reg_t;

#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_DEFAULT (0x2b01000bU)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_WR_MASK (0x00000000U)


///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
///< ID number that indicates the nature and format of the Extended Capability.
///< Extended Capability ID for the Vendor-Specific Extended Capability
///< is 000Bh.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_EXTENDED_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_EXTENDED_CAP_ID_BF_WID (16)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_EXTENDED_CAP_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_EXTENDED_CAP_ID_BF_DEF (0x0000000B)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present. Value
///< of this field is depends on the version of the specification.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note:
///< This register field is sticky.
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_CAP_VER_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_CAP_VER_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_CAP_VER_BF_MSK (0x000F0000)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_CAP_VER_BF_DEF (0x00010000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Capability structure or 000h if no other items exist in
///< the linked list of Capabilities. For Extended Capabilities implemented
///< in Configuration Space, this offset is relative to the beginning of
///< PCI-compatible Configuration Space and thus must always be either
///< 000h (for terminating list of Capabilities) or greater than 0FFh.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_NEXT_OFFSET_BF_DEF (0x2B000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_REG register description at address offset 0x1b4
  *
  * Register default value:        0x10040002
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/VENDOR_SPECIFIC_HEADER_REG
  * Vendor-Specific Header.
  */

typedef union {
  struct {
    uint32_t VSEC_ID : 16;
    ///< VSEC ID. This field is a vendor-defined ID number that indicates the
    ///< nature and format of the VSEC structure. Software must qualify the
    ///< Vendor ID before interpreting this field.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x2"
    uint32_t VSEC_REV : 4;
    ///< VSEC Rev. This field is a vendor-defined version number that indicates
    ///< the version of the VSEC structure. Software must qualify the Vendor
    ///< ID and VSEC ID before interpreting this field.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x4"
    uint32_t VSEC_LENGTH : 12;
    ///< VSEC Length. This field indicates the number of bytes in the entire
    ///< VSEC structure, including the Vendor-Specific Extended Capability
    ///< Header, the Vendor-Specific Header, and the vendor-specific registers.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x100"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_vendor_specific_header_reg_t;

#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_DEFAULT (0x10040002U)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_WR_MASK (0x00000000U)


///< VSEC ID. This field is a vendor-defined ID number that indicates the
///< nature and format of the VSEC structure. Software must qualify the
///< Vendor ID before interpreting this field.
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_ID_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_ID_BF_WID (16)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_ID_BF_DEF (0x00000002)

///< VSEC Rev. This field is a vendor-defined version number that indicates
///< the version of the VSEC structure. Software must qualify the Vendor
///< ID and VSEC ID before interpreting this field.
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_REV_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_REV_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_REV_BF_MSK (0x000F0000)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_REV_BF_DEF (0x00040000)

///< VSEC Length. This field indicates the number of bytes in the entire
///< VSEC structure, including the Vendor-Specific Extended Capability
///< Header, the Vendor-Specific Header, and the vendor-specific registers.
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_LENGTH_BF_OFF (20)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_LENGTH_BF_WID (12)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_LENGTH_BF_MSK (0xFFF00000)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_VSEC_LENGTH_BF_DEF (0x10000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EVENT_COUNTER_CONTROL_REG register description at address offset 0x1b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EVENT_COUNTER_CONTROL_REG
  * Event Counter Control.
  */

typedef union {
  struct {
    uint32_t EVENT_COUNTER_CLEAR : 2;
    ///< Event Counter Clear. Clears the Event Counter selected by the EVENT_COUNTER_EVENT_SELECT
    ///< and EVENT_COUNTER_LANE_SELECT fields in this register. You can clear
    ///< the value of a specific Event Counter by writing the 'per clear' code
    ///< and you can clear all event counters at once by writing the 'all clear'
    ///< code. The read value is always '0'. Other values are reserved.  TDISP
    ///< Prot :WP
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t EVENT_COUNTER_ENABLE : 3;
    ///< Event Counter Enable. Enables/disables the Event Counter selected
    ///< by the EVENT_COUNTER_EVENT_SELECT and EVENT_COUNTER_LANE_SELECT fields
    ///< in this register. By default, all event counters are disabled. You
    ///< can enable/disable a specific Event Counter by writing the 'per event
    ///< off' or 'per event on' codes. You can enable/disable all event counters
    ///< by writing the 'all on' or 'all off' codes. The read value is always
    ///< '0'. For other values no change.  TDISP Prot :WP
    ///< AccessType="WS/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
    uint32_t EVENT_COUNTER_STATUS : 1;
    ///< Event Counter Status. This register returns the current value of the
    ///< Event Counter selected by the following fields:  - EVENT_COUNTER_EVENT_SELECT
    ///< - EVENT_COUNTER_LANE_SELECT   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t EVENT_COUNTER_LANE_SELECT : 4;
    ///< Event Counter Lane Select. This field in conjunction with EVENT_COUNTER_EVENT_SELECT
    ///< indexes the Event Counter data returned by the EVENT_COUNTER_DATA_REG
    ///< register.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t EVENT_COUNTER_EVENT_SELECT : 12;
    ///< Event Counter Data Select. This field in conjunction with the EVENT_COUNTER_LANE_SELECT
    ///< field indexes the Event Counter data returned by the EVENT_COUNTER_DATA_REG
    ///< register.  - 27-24: Group number(4-bit: 0..0x7)  - 23-16: Event number(8-bit:
    ///< 0..0x13) within the Group  - .. For detailed definitions of Group
    ///< number and Event number, see the RAS DES chapter in the Databook.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_event_cnter_ctrl_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_RD_MASK (0x0fff0f80U)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_WR_MASK (0x0fff0f1fU)


///< Event Counter Clear. Clears the Event Counter selected by the EVENT_COUNTER_EVENT_SELECT
///< and EVENT_COUNTER_LANE_SELECT fields in this register. You can clear
///< the value of a specific Event Counter by writing the 'per clear' code
///< and you can clear all event counters at once by writing the 'all clear'
///< code. The read value is always '0'. Other values are reserved.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_CLR_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_CLR_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_CLR_BF_MSK (0x00000003)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_CLR_BF_DEF (0x00000000)

///< Event Counter Enable. Enables/disables the Event Counter selected
///< by the EVENT_COUNTER_EVENT_SELECT and EVENT_COUNTER_LANE_SELECT fields
///< in this register. By default, all event counters are disabled. You
///< can enable/disable a specific Event Counter by writing the 'per event
///< off' or 'per event on' codes. You can enable/disable all event counters
///< by writing the 'all on' or 'all off' codes. The read value is always
///< '0'. For other values no change.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EN_BF_OFF ( 2)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EN_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EN_BF_MSK (0x0000001C)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EN_BF_DEF (0x00000000)

///< Event Counter Status. This register returns the current value of the
///< Event Counter selected by the following fields:  - EVENT_COUNTER_EVENT_SELECT
///< - EVENT_COUNTER_LANE_SELECT   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_STAT_BF_OFF ( 7)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_STAT_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_STAT_BF_MSK (0x00000080)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_STAT_BF_DEF (0x00000000)

///< Event Counter Lane Select. This field in conjunction with EVENT_COUNTER_EVENT_SELECT
///< indexes the Event Counter data returned by the EVENT_COUNTER_DATA_REG
///< register.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_LANE_SEL_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_LANE_SEL_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_LANE_SEL_BF_MSK (0x00000F00)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_LANE_SEL_BF_DEF (0x00000000)

///< Event Counter Data Select. This field in conjunction with the EVENT_COUNTER_LANE_SELECT
///< field indexes the Event Counter data returned by the EVENT_COUNTER_DATA_REG
///< register.  - 27-24: Group number(4-bit: 0..0x7)  - 23-16: Event number(8-bit:
///< 0..0x13) within the Group  - .. For detailed definitions of Group
///< number and Event number, see the RAS DES chapter in the Databook.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EVENT_SEL_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EVENT_SEL_BF_WID (12)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EVENT_SEL_BF_MSK (0x0FFF0000)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_EVENT_CNTER_EVENT_SEL_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EVENT_COUNTER_DATA_REG register description at address offset 0x1bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EVENT_COUNTER_DATA_REG
  * Event Counter Data.
  */

typedef union {
  struct {
    uint32_t EVENT_COUNTER_DATA : 32;
    ///< Event Counter Data. This register returns the data selected by the
    ///< following fields:  - EVENT_COUNTER_EVENT_SELECT in EVENT_COUNTER_CONTROL_REG
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_event_cnter_data_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_WR_MASK (0x00000000U)


///< Event Counter Data. This register returns the data selected by the
///< following fields:  - EVENT_COUNTER_EVENT_SELECT in EVENT_COUNTER_CONTROL_REG
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_EVENT_CNTER_DATA_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_EVENT_CNTER_DATA_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_EVENT_CNTER_DATA_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_EVENT_CNTER_DATA_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ_ENABLE_REG register description at address offset 0x1e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ_ENABLE_REG
  * Error Injection Enable.
  */

typedef union {
  struct {
    uint32_t ERROR_INJECTION0_ENABLE : 1;
    ///< Error Injection0 Enable (CRC Error). Enables insertion of errors into
    ///< various CRC. For more information, see the EINJ0_CRC_REG register.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t ERROR_INJECTION1_ENABLE : 1;
    ///< Error Injection1 Enable (Sequence Number Error). Enables insertion
    ///< of errors into sequence numbers. For more information, see the EINJ1_SEQNUM_REG
    ///< register.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERROR_INJECTION2_ENABLE : 1;
    ///< Error Injection2 Enable (DLLP Error). Enables insertion of DLLP errors.
    ///< For more information, see the EINJ2_DLLP_REG register.   Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint32_t ERROR_INJECTION3_ENABLE : 1;
    ///< Error Injection3 Enable (Symbol DataK Mask Error or Sync Header Error).
    ///< Enables DataK masking of special symbols or the breaking of the sync
    ///< header. For more information, see the EINJ3_SYMBOL_REG register.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x0"
    uint32_t ERROR_INJECTION4_ENABLE : 1;
    ///< Error Injection4 Enable (FC Credit Update Error). Enables insertion
    ///< of errors into UpdateFCs. For more information, see the EINJ4_FC_REG
    ///< register.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint32_t ERROR_INJECTION5_ENABLE : 1;
    ///< Error Injection5 Enable (TLP Duplicate/Nullify Error). Enables insertion
    ///< of duplicate/nullified TLPs. For more information, see the EINJ5_SP_TLP_REG
    ///< register.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="5" ResetValue="0x0"
    uint32_t ERROR_INJECTION6_ENABLE : 1;
    ///< Error Injection6 Enable (Specific TLP Error). Enables insertion of
    ///< errors into the packets that you select.  You can set this bit to
    ///< '1' when you have disabled RAS datapath protection (DP) by setting
    ///< CX_RASDP = CX_RASDP_RAM_PROT =0.  You can set this bit to '1' when
    ///< you have disabled the address translation by setting ADDR_TRANSLATION_SUPPORT_EN=0.
    ///< For more information, see the EINJ6_COMPARE_*_REG/EINJ6_CHANGE_*_REG/EINJ6_TLP_REG
    ///< registers.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj_en_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_RD_MASK (0x0000007fU)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_WR_MASK (0x0000007fU)


///< Error Injection0 Enable (CRC Error). Enables insertion of errors into
///< various CRC. For more information, see the EINJ0_CRC_REG register.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION0_EN_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION0_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION0_EN_BF_MSK (0x00000001)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION0_EN_BF_DEF (0x00000000)

///< Error Injection1 Enable (Sequence Number Error). Enables insertion
///< of errors into sequence numbers. For more information, see the EINJ1_SEQNUM_REG
///< register.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION1_EN_BF_OFF ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION1_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION1_EN_BF_MSK (0x00000002)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION1_EN_BF_DEF (0x00000000)

///< Error Injection2 Enable (DLLP Error). Enables insertion of DLLP errors.
///< For more information, see the EINJ2_DLLP_REG register.   Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION2_EN_BF_OFF ( 2)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION2_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION2_EN_BF_MSK (0x00000004)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION2_EN_BF_DEF (0x00000000)

///< Error Injection3 Enable (Symbol DataK Mask Error or Sync Header Error).
///< Enables DataK masking of special symbols or the breaking of the sync
///< header. For more information, see the EINJ3_SYMBOL_REG register.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION3_EN_BF_OFF ( 3)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION3_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION3_EN_BF_MSK (0x00000008)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION3_EN_BF_DEF (0x00000000)

///< Error Injection4 Enable (FC Credit Update Error). Enables insertion
///< of errors into UpdateFCs. For more information, see the EINJ4_FC_REG
///< register.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION4_EN_BF_OFF ( 4)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION4_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION4_EN_BF_MSK (0x00000010)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION4_EN_BF_DEF (0x00000000)

///< Error Injection5 Enable (TLP Duplicate/Nullify Error). Enables insertion
///< of duplicate/nullified TLPs. For more information, see the EINJ5_SP_TLP_REG
///< register.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION5_EN_BF_OFF ( 5)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION5_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION5_EN_BF_MSK (0x00000020)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION5_EN_BF_DEF (0x00000000)

///< Error Injection6 Enable (Specific TLP Error). Enables insertion of
///< errors into the packets that you select.  You can set this bit to
///< '1' when you have disabled RAS datapath protection (DP) by setting
///< CX_RASDP = CX_RASDP_RAM_PROT =0.  You can set this bit to '1' when
///< you have disabled the address translation by setting ADDR_TRANSLATION_SUPPORT_EN=0.
///< For more information, see the EINJ6_COMPARE_*_REG/EINJ6_CHANGE_*_REG/EINJ6_TLP_REG
///< registers.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION6_EN_BF_OFF ( 6)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION6_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION6_EN_BF_MSK (0x00000040)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_ERR_INJECTION6_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ0_CRC_REG register description at address offset 0x1e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ0_CRC_REG
  * Error Injection Control 0 (CRC Error).
  */

typedef union {
  struct {
    uint32_t EINJ0_COUNT : 8;
    ///< Error injection count. Indicates the number of errors. This register
    ///< is decremented when the errors have been inserted.   If the counter
    ///< value is 0x01 and error is inserted, ERROR_INJECTION0_ENABLE in EINJ_ENABLE_REG
    ///< returns 0b.   If the counter value is 0x00 and ERROR_INJECTION0_ENABLE=1,
    ///< the errors are inserted until ERROR_INJECTION0_ENABLE is set to '0'.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t EINJ0_CRC_TYPE : 4;
    ///< Error injection type. Selects the type of CRC error to be inserted.
    ///< All encodings other than the defined encodings are reserved.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj0_crc_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_RD_MASK (0x00000fffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_WR_MASK (0x00000fffU)


///< Error injection count. Indicates the number of errors. This register
///< is decremented when the errors have been inserted.   If the counter
///< value is 0x01 and error is inserted, ERROR_INJECTION0_ENABLE in EINJ_ENABLE_REG
///< returns 0b.   If the counter value is 0x00 and ERROR_INJECTION0_ENABLE=1,
///< the errors are inserted until ERROR_INJECTION0_ENABLE is set to '0'.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CNT_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CNT_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CNT_BF_MSK (0x000000FF)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CNT_BF_DEF (0x00000000)

///< Error injection type. Selects the type of CRC error to be inserted.
///< All encodings other than the defined encodings are reserved.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CRC_TYPE_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CRC_TYPE_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CRC_TYPE_BF_MSK (0x00000F00)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_EINJ0_CRC_TYPE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ1_SEQNUM_REG register description at address offset 0x1e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ1_SEQNUM_REG
  * Error Injection Control 1 (Sequence Number Error).
  */

typedef union {
  struct {
    uint32_t EINJ1_COUNT : 8;
    ///< Error injection count. Indicates the number of errors. This register
    ///< is decremented as the errors are being inserted.   If the counter
    ///< value is 0x01 and error is inserted, ERROR_INJECTION1_ENABLE in EINJ_ENABLE_REG
    ///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION1_ENABLE=1,
    ///< the errors are inserted until ERROR_INJECTION1_ENABLE is set to '0'.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t EINJ1_SEQNUM_TYPE : 1;
    ///< Sequence number type. Selects the type of sequence number.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 7;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
    uint32_t EINJ1_BAD_SEQNUM : 13;
    ///< Bad sequence number. Indicates the value to add/subtract from the
    ///< naturally-assigned sequence numbers. This value is represented by
    ///< two's complement. For example:  - Set Type, SEQ# and Count  -- EINJ1_SEQNUM_TYPE
    ///< =0 (Insert errors into new TLPs)  -- EINJ1_BAD_SEQNUM =0x1FFD (represents
    ///< -3)  -- EINJ1_COUNT =1  - Enable Error Injection  -- ERROR_INJECTION1_ENABLE
    ///< =1  - Send a TLP from the controller's Application Interface  -- Assume
    ///< SEQ#5 is given to the TLP.  - The SEQ# is Changed to #2 by the Error
    ///< Injection Function in Layer2.  -- 5 + (-3) = 2  - The TLP with SEQ#2
    ///< is Transmitted to PCIe Link. Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj1_seqnum_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_RD_MASK (0x1fff01ffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_WR_MASK (0x1fff01ffU)


///< Error injection count. Indicates the number of errors. This register
///< is decremented as the errors are being inserted.   If the counter
///< value is 0x01 and error is inserted, ERROR_INJECTION1_ENABLE in EINJ_ENABLE_REG
///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION1_ENABLE=1,
///< the errors are inserted until ERROR_INJECTION1_ENABLE is set to '0'.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_CNT_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_CNT_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_CNT_BF_MSK (0x000000FF)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_CNT_BF_DEF (0x00000000)

///< Sequence number type. Selects the type of sequence number.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_SEQNUM_TYPE_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_SEQNUM_TYPE_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_SEQNUM_TYPE_BF_MSK (0x00000100)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_SEQNUM_TYPE_BF_DEF (0x00000000)

///< Bad sequence number. Indicates the value to add/subtract from the
///< naturally-assigned sequence numbers. This value is represented by
///< two's complement. For example:  - Set Type, SEQ# and Count  -- EINJ1_SEQNUM_TYPE
///< =0 (Insert errors into new TLPs)  -- EINJ1_BAD_SEQNUM =0x1FFD (represents
///< -3)  -- EINJ1_COUNT =1  - Enable Error Injection  -- ERROR_INJECTION1_ENABLE
///< =1  - Send a TLP from the controller's Application Interface  -- Assume
///< SEQ#5 is given to the TLP.  - The SEQ# is Changed to #2 by the Error
///< Injection Function in Layer2.  -- 5 + (-3) = 2  - The TLP with SEQ#2
///< is Transmitted to PCIe Link. Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_BAD_SEQNUM_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_BAD_SEQNUM_BF_WID (13)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_BAD_SEQNUM_BF_MSK (0x1FFF0000)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_EINJ1_BAD_SEQNUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ2_DLLP_REG register description at address offset 0x1ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ2_DLLP_REG
  * Error Injection Control 2 (DLLP Error).
  */

typedef union {
  struct {
    uint32_t EINJ2_COUNT : 8;
    ///< Error injection count. Indicates the number of errors. This register
    ///< is decremented as the errors are being inserted.   If the counter
    ///< value is 0x01 and the error is inserted, ERROR_INJECTION2_ENABLE in
    ///< EINJ_ENABLE_REG returns '0'.   If the counter value is 0x00 and ERROR_INJECTION2_ENABLE
    ///< =1, the errors are inserted until ERROR_INJECTION2_ENABLE is set to
    ///< '0'. This register is affected only when EINJ2_DLLP_TYPE =2'10b.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t EINJ2_DLLP_TYPE : 2;
    ///< DLLP Type. Selects the type of DLLP errors to be inserted.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj2_dllp_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_RD_MASK (0x000003ffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_WR_MASK (0x000003ffU)


///< Error injection count. Indicates the number of errors. This register
///< is decremented as the errors are being inserted.   If the counter
///< value is 0x01 and the error is inserted, ERROR_INJECTION2_ENABLE in
///< EINJ_ENABLE_REG returns '0'.   If the counter value is 0x00 and ERROR_INJECTION2_ENABLE
///< =1, the errors are inserted until ERROR_INJECTION2_ENABLE is set to
///< '0'. This register is affected only when EINJ2_DLLP_TYPE =2'10b.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_CNT_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_CNT_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_CNT_BF_MSK (0x000000FF)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_CNT_BF_DEF (0x00000000)

///< DLLP Type. Selects the type of DLLP errors to be inserted.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_DLLP_TYPE_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_DLLP_TYPE_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_DLLP_TYPE_BF_MSK (0x00000300)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_EINJ2_DLLP_TYPE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ3_SYMBOL_REG register description at address offset 0x1f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ3_SYMBOL_REG
  * Error Injection Control 3 (Symbol Error).
  */

typedef union {
  struct {
    uint32_t EINJ3_COUNT : 8;
    ///< Error injection count. Indicates the number of errors. This register
    ///< is decremented as the errors are being inserted.   If the counter
    ///< value is 0x01 and error is inserted, ERROR_INJECTION3_ENABLE in EINJ_ENABLE_REG
    ///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION3_ENABLE
    ///< =1, the errors are inserted until ERROR_INJECTION3_ENABLE is set to
    ///< '0'.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t EINJ3_SYMBOL_TYPE : 3;
    ///< Error Type. 8b/10b encoding - Mask K symbol. It is not supported to
    ///< insert errors into the first ordered-set after exiting from TxElecIdle
    ///< when CX_FREQ_STEP_EN has been enabled. All encodings other than the
    ///< defined encodings are reserved.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj3_symbol_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_RD_MASK (0x000007ffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_WR_MASK (0x000007ffU)


///< Error injection count. Indicates the number of errors. This register
///< is decremented as the errors are being inserted.   If the counter
///< value is 0x01 and error is inserted, ERROR_INJECTION3_ENABLE in EINJ_ENABLE_REG
///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION3_ENABLE
///< =1, the errors are inserted until ERROR_INJECTION3_ENABLE is set to
///< '0'.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_CNT_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_CNT_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_CNT_BF_MSK (0x000000FF)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_CNT_BF_DEF (0x00000000)

///< Error Type. 8b/10b encoding - Mask K symbol. It is not supported to
///< insert errors into the first ordered-set after exiting from TxElecIdle
///< when CX_FREQ_STEP_EN has been enabled. All encodings other than the
///< defined encodings are reserved.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_SYMBOL_TYPE_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_SYMBOL_TYPE_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_SYMBOL_TYPE_BF_MSK (0x00000700)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_EINJ3_SYMBOL_TYPE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ4_FC_REG register description at address offset 0x1f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ4_FC_REG
  * Error Injection Control 4 (FC Credit Error).
  */

typedef union {
  struct {
    uint32_t EINJ4_COUNT : 8;
    ///< Error injection count. Indicates the number of errors. This register
    ///< is decremented as the errors are being inserted.   If the counter
    ///< value is 0x01 and error is inserted, ERROR_INJECTION4_ENABLE in EINJ_ENABLE_REG
    ///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION4_ENABLE
    ///< =1, the errors are inserted until ERROR_INJECTION4_ENABLE is set to
    ///< '0'.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t EINJ4_UPDFC_TYPE : 3;
    ///< Update-FC type. Selects the credit type.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t EINJ4_VC_NUMBER : 3;
    ///< VC Number. Indicates target VC Number.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
    uint32_t EINJ4_BAD_UPDFC_VALUE : 13;
    ///< Bad update-FC credit value. Indicates the value to add/subtract from
    ///< the UpdateFC credit. This value is represented by two's complement.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj4_fc_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_RD_MASK (0x1fff77ffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_WR_MASK (0x1fff77ffU)


///< Error injection count. Indicates the number of errors. This register
///< is decremented as the errors are being inserted.   If the counter
///< value is 0x01 and error is inserted, ERROR_INJECTION4_ENABLE in EINJ_ENABLE_REG
///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION4_ENABLE
///< =1, the errors are inserted until ERROR_INJECTION4_ENABLE is set to
///< '0'.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_CNT_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_CNT_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_CNT_BF_MSK (0x000000FF)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_CNT_BF_DEF (0x00000000)

///< Update-FC type. Selects the credit type.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_UPDFC_TYPE_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_UPDFC_TYPE_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_UPDFC_TYPE_BF_MSK (0x00000700)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_UPDFC_TYPE_BF_DEF (0x00000000)

///< VC Number. Indicates target VC Number.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_VC_NUMBER_BF_OFF (12)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_VC_NUMBER_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_VC_NUMBER_BF_MSK (0x00007000)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_VC_NUMBER_BF_DEF (0x00000000)

///< Bad update-FC credit value. Indicates the value to add/subtract from
///< the UpdateFC credit. This value is represented by two's complement.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_BAD_UPDFC_VAL_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_BAD_UPDFC_VAL_BF_WID (13)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_BAD_UPDFC_VAL_BF_MSK (0x1FFF0000)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_EINJ4_BAD_UPDFC_VAL_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ5_SP_TLP_REG register description at address offset 0x1f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ5_SP_TLP_REG
  * Error Injection Control 5 (Specific TLP Error).
  */

typedef union {
  struct {
    uint32_t EINJ5_COUNT : 8;
    ///< Error injection count. Indicates the number of errors. This register
    ///< is decremented as the errors are being inserted.   If the counter
    ///< value is 0x01 and error is inserted, ERROR_INJECTION5_ENABLE in EINJ_ENABLE_REG
    ///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION5_ENABLE
    ///< =1, the errors are inserted until ERROR_INJECTION5_ENABLE is set to
    ///< '0'.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t EINJ5_SPECIFIED_TLP : 1;
    ///< Specified TLP. Selects the specified TLP to be inserted.   Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj5_sp_tlp_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_RD_MASK (0x000001ffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_WR_MASK (0x000001ffU)


///< Error injection count. Indicates the number of errors. This register
///< is decremented as the errors are being inserted.   If the counter
///< value is 0x01 and error is inserted, ERROR_INJECTION5_ENABLE in EINJ_ENABLE_REG
///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION5_ENABLE
///< =1, the errors are inserted until ERROR_INJECTION5_ENABLE is set to
///< '0'.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_CNT_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_CNT_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_CNT_BF_MSK (0x000000FF)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_CNT_BF_DEF (0x00000000)

///< Specified TLP. Selects the specified TLP to be inserted.   Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_SPECIFIED_TLP_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_SPECIFIED_TLP_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_SPECIFIED_TLP_BF_MSK (0x00000100)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_EINJ5_SPECIFIED_TLP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_POINT_H0_REG register description at address offset 0x1fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_POINT_H0_REG
  * Error Injection Control 6 (Compare Point Header DWORD #0).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_POINT_H0 : 32;
    ///< Packet Compare Point: 1st DWORD.  Specifies which Tx TLP header DWORD#0
    ///< bits to compare with the corresponding bits in the Packet Compare
    ///< Value registers (EINJ6_COMPARE_VALUE*).  When all specified bits (in
    ///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
    ///< inserts errors into the TLP.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_point_h0_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_WR_MASK (0xffffffffU)


///< Packet Compare Point: 1st DWORD.  Specifies which Tx TLP header DWORD#0
///< bits to compare with the corresponding bits in the Packet Compare
///< Value registers (EINJ6_COMPARE_VALUE*).  When all specified bits (in
///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
///< inserts errors into the TLP.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_EINJ6_CMP_POINT_H0_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_EINJ6_CMP_POINT_H0_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_EINJ6_CMP_POINT_H0_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_EINJ6_CMP_POINT_H0_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_POINT_H1_REG register description at address offset 0x200
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_POINT_H1_REG
  * Error Injection Control 6 (Compare Point Header DWORD #1).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_POINT_H1 : 32;
    ///< Packet Compare Point: 2nd DWORD.  Specifies which Tx TLP header DWORD#1
    ///< bits to compare with the corresponding bits in the Packet Compare
    ///< Value registers (EINJ6_COMPARE_VALUE*).  When all specified bits (in
    ///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
    ///< inserts errors into the TLP.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_point_h1_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_WR_MASK (0xffffffffU)


///< Packet Compare Point: 2nd DWORD.  Specifies which Tx TLP header DWORD#1
///< bits to compare with the corresponding bits in the Packet Compare
///< Value registers (EINJ6_COMPARE_VALUE*).  When all specified bits (in
///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
///< inserts errors into the TLP.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_EINJ6_CMP_POINT_H1_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_EINJ6_CMP_POINT_H1_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_EINJ6_CMP_POINT_H1_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_EINJ6_CMP_POINT_H1_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_POINT_H2_REG register description at address offset 0x204
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_POINT_H2_REG
  * Error Injection Control 6 (Compare Point Header DWORD #2).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_POINT_H2 : 32;
    ///< Packet Compare Point: 3rd DWORD. Specifies which Tx TLP header DWORD#2
    ///< bits to compare with the corresponding bits in the Packet Compare
    ///< Value registers (EINJ6_COMPARE_VALUE*). When all specified bits (in
    ///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
    ///< inserts errors into the TLP.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_point_h2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_WR_MASK (0xffffffffU)


///< Packet Compare Point: 3rd DWORD. Specifies which Tx TLP header DWORD#2
///< bits to compare with the corresponding bits in the Packet Compare
///< Value registers (EINJ6_COMPARE_VALUE*). When all specified bits (in
///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
///< inserts errors into the TLP.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_EINJ6_CMP_POINT_H2_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_EINJ6_CMP_POINT_H2_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_EINJ6_CMP_POINT_H2_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_EINJ6_CMP_POINT_H2_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_POINT_H3_REG register description at address offset 0x208
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_POINT_H3_REG
  * Error Injection Control 6 (Compare Point Header DWORD #3).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_POINT_H3 : 32;
    ///< Packet Compare Point: 4th DWORD.  Specifies which Tx TLP header DWORD#3
    ///< bits to compare with the corresponding bits in the Packet Compare
    ///< Value registers (EINJ6_COMPARE_VALUE*).  When all specified bits (in
    ///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
    ///< inserts errors into the TLP.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_point_h3_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_WR_MASK (0xffffffffU)


///< Packet Compare Point: 4th DWORD.  Specifies which Tx TLP header DWORD#3
///< bits to compare with the corresponding bits in the Packet Compare
///< Value registers (EINJ6_COMPARE_VALUE*).  When all specified bits (in
///< the Tx TLP header and EINJ6_COMPARE_VALUE*) match, the controller
///< inserts errors into the TLP.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_EINJ6_CMP_POINT_H3_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_EINJ6_CMP_POINT_H3_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_EINJ6_CMP_POINT_H3_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_EINJ6_CMP_POINT_H3_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_VALUE_H0_REG register description at address offset 0x20c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_VALUE_H0_REG
  * Error Injection Control 6 (Compare Value Header DWORD #0).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_VALUE_H0 : 32;
    ///< Packet Compare Value: 1st DWORD.  Specifies the value to compare against
    ///< Tx the TLP header DWORD#0 bits specified in the Packet Compare Point
    ///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_val_h0_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_WR_MASK (0xffffffffU)


///< Packet Compare Value: 1st DWORD.  Specifies the value to compare against
///< Tx the TLP header DWORD#0 bits specified in the Packet Compare Point
///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_EINJ6_CMP_VAL_H0_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_EINJ6_CMP_VAL_H0_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_EINJ6_CMP_VAL_H0_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_EINJ6_CMP_VAL_H0_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_VALUE_H1_REG register description at address offset 0x210
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_VALUE_H1_REG
  * Error Injection Control 6 (Compare Value Header DWORD #1).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_VALUE_H1 : 32;
    ///< Packet Compare Value: 2nd DWORD.  Specifies the value to compare against
    ///< Tx the TLP header DWORD#1 bits specified in the Packet Compare Point
    ///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_val_h1_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_WR_MASK (0xffffffffU)


///< Packet Compare Value: 2nd DWORD.  Specifies the value to compare against
///< Tx the TLP header DWORD#1 bits specified in the Packet Compare Point
///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_EINJ6_CMP_VAL_H1_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_EINJ6_CMP_VAL_H1_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_EINJ6_CMP_VAL_H1_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_EINJ6_CMP_VAL_H1_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_VALUE_H2_REG register description at address offset 0x214
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_VALUE_H2_REG
  * Error Injection Control 6 (Compare Value Header DWORD #2).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_VALUE_H2 : 32;
    ///< Packet Compare Value: 3rd DWORD.  Specifies the value to compare against
    ///< Tx the TLP header DWORD#2 bits specified in the Packet Compare Point
    ///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_val_h2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_WR_MASK (0xffffffffU)


///< Packet Compare Value: 3rd DWORD.  Specifies the value to compare against
///< Tx the TLP header DWORD#2 bits specified in the Packet Compare Point
///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_EINJ6_CMP_VAL_H2_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_EINJ6_CMP_VAL_H2_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_EINJ6_CMP_VAL_H2_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_EINJ6_CMP_VAL_H2_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_COMPARE_VALUE_H3_REG register description at address offset 0x218
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_COMPARE_VALUE_H3_REG
  * Error Injection Control 6 (Compare Value Header DWORD #3).
  */

typedef union {
  struct {
    uint32_t EINJ6_COMPARE_VALUE_H3 : 32;
    ///< Packet Compare Value: 4th DWORD.  Specifies the value to compare against
    ///< Tx the TLP header DWORD#3 bits specified in the Packet Compare Point
    ///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_cmp_val_h3_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_WR_MASK (0xffffffffU)


///< Packet Compare Value: 4th DWORD.  Specifies the value to compare against
///< Tx the TLP header DWORD#3 bits specified in the Packet Compare Point
///< registers (EINJ6_COMPARE_POINT*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_EINJ6_CMP_VAL_H3_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_EINJ6_CMP_VAL_H3_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_EINJ6_CMP_VAL_H3_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_EINJ6_CMP_VAL_H3_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_REG register description at address offset 0x21c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_POINT_H0_REG
  * Error Injection Control 6 (Change Point Header DWORD #0).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_POINT_H0 : 32;
    ///< Packet Change Point: 1st DWORD.  Specifies which Tx TLP header DWORD#0
    ///< bits to replace with the corresponding bits in the Packet Change Value
    ///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_point_h0_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_WR_MASK (0xffffffffU)


///< Packet Change Point: 1st DWORD.  Specifies which Tx TLP header DWORD#0
///< bits to replace with the corresponding bits in the Packet Change Value
///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_EINJ6_CHANGE_POINT_H0_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_EINJ6_CHANGE_POINT_H0_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_EINJ6_CHANGE_POINT_H0_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_EINJ6_CHANGE_POINT_H0_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_REG register description at address offset 0x220
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_POINT_H1_REG
  * Error Injection Control 6 (Change Point Header DWORD #1).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_POINT_H1 : 32;
    ///< Packet Change Point: 2nd DWORD.  Specifies which Tx TLP header DWORD#1
    ///< bits to replace with the corresponding bits in the Packet Change Value
    ///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_point_h1_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_WR_MASK (0xffffffffU)


///< Packet Change Point: 2nd DWORD.  Specifies which Tx TLP header DWORD#1
///< bits to replace with the corresponding bits in the Packet Change Value
///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_EINJ6_CHANGE_POINT_H1_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_EINJ6_CHANGE_POINT_H1_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_EINJ6_CHANGE_POINT_H1_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_EINJ6_CHANGE_POINT_H1_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_REG register description at address offset 0x224
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_POINT_H2_REG
  * Error Injection Control 6 (Change Point Header DWORD #2).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_POINT_H2 : 32;
    ///< Packet Change Point: 3rd DWORD.  Specifies which Tx TLP header DWORD#2
    ///< bits to replace with the corresponding bits in the Packet Change Value
    ///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_point_h2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_WR_MASK (0xffffffffU)


///< Packet Change Point: 3rd DWORD.  Specifies which Tx TLP header DWORD#2
///< bits to replace with the corresponding bits in the Packet Change Value
///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_EINJ6_CHANGE_POINT_H2_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_EINJ6_CHANGE_POINT_H2_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_EINJ6_CHANGE_POINT_H2_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_EINJ6_CHANGE_POINT_H2_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_REG register description at address offset 0x228
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_POINT_H3_REG
  * Error Injection Control 6 (Change Point Header DWORD #3).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_POINT_H3 : 32;
    ///< Packet Change Point: 4th DWORD.  Specifies which Tx TLP header DWORD#3
    ///< bits to replace with the corresponding bits in the Packet Change Value
    ///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_point_h3_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_WR_MASK (0xffffffffU)


///< Packet Change Point: 4th DWORD.  Specifies which Tx TLP header DWORD#3
///< bits to replace with the corresponding bits in the Packet Change Value
///< registers (EINJ6_CHANGE_VALUE*).   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_EINJ6_CHANGE_POINT_H3_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_EINJ6_CHANGE_POINT_H3_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_EINJ6_CHANGE_POINT_H3_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_EINJ6_CHANGE_POINT_H3_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_VALUE_H0_REG register description at address offset 0x22c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_VALUE_H0_REG
  * Error Injection Control 6 (Change Value Header DWORD #0).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_VALUE_H0 : 32;
    ///< Packet Change Value: 1st DWORD.  Specifies replacement values for
    ///< the Tx TLP header DWORD#0 bits defined in the Packet Change Point
    ///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
    ///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_val_h0_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_WR_MASK (0xffffffffU)


///< Packet Change Value: 1st DWORD.  Specifies replacement values for
///< the Tx TLP header DWORD#0 bits defined in the Packet Change Point
///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_EINJ6_CHANGE_VAL_H0_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_EINJ6_CHANGE_VAL_H0_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_EINJ6_CHANGE_VAL_H0_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_EINJ6_CHANGE_VAL_H0_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_VALUE_H1_REG register description at address offset 0x230
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_VALUE_H1_REG
  * Error Injection Control 6 (Change Value Header DWORD #1).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_VALUE_H1 : 32;
    ///< Packet Change Value: 2nd DWORD.  Specifies replacement values for
    ///< the Tx TLP header DWORD#1 bits defined in the Packet Change Point
    ///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
    ///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_val_h1_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_WR_MASK (0xffffffffU)


///< Packet Change Value: 2nd DWORD.  Specifies replacement values for
///< the Tx TLP header DWORD#1 bits defined in the Packet Change Point
///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_EINJ6_CHANGE_VAL_H1_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_EINJ6_CHANGE_VAL_H1_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_EINJ6_CHANGE_VAL_H1_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_EINJ6_CHANGE_VAL_H1_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_VALUE_H2_REG register description at address offset 0x234
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_VALUE_H2_REG
  * Error Injection Control 6 (Change Value Header DWORD #2).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_VALUE_H2 : 32;
    ///< Packet Change Value: 3rd DWORD.  Specifies replacement values for
    ///< the Tx TLP header DWORD#2 bits defined in the Packet Change Point
    ///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
    ///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_val_h2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_WR_MASK (0xffffffffU)


///< Packet Change Value: 3rd DWORD.  Specifies replacement values for
///< the Tx TLP header DWORD#2 bits defined in the Packet Change Point
///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_EINJ6_CHANGE_VAL_H2_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_EINJ6_CHANGE_VAL_H2_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_EINJ6_CHANGE_VAL_H2_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_EINJ6_CHANGE_VAL_H2_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_CHANGE_VALUE_H3_REG register description at address offset 0x238
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_CHANGE_VALUE_H3_REG
  * Error Injection Control 6 (Change Value Header DWORD #3).
  */

typedef union {
  struct {
    uint32_t EINJ6_CHANGE_VALUE_H3 : 32;
    ///< Packet Change Value: 4th DWORD.  Specifies replacement values for
    ///< the Tx TLP header DWORD#3 bits defined in the Packet Change Point
    ///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
    ///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_change_val_h3_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_WR_MASK (0xffffffffU)


///< Packet Change Value: 4th DWORD.  Specifies replacement values for
///< the Tx TLP header DWORD#3 bits defined in the Packet Change Point
///< registers (EINJ6_CHANGE_POINT*).  Only applies when the EINJ6_INVERTED_CONTROL
///< field in EINJ6_TLP_REG is '0'.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_EINJ6_CHANGE_VAL_H3_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_EINJ6_CHANGE_VAL_H3_BF_WID (32)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_EINJ6_CHANGE_VAL_H3_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_EINJ6_CHANGE_VAL_H3_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_EINJ6_TLP_REG register description at address offset 0x23c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/EINJ6_TLP_REG
  * Error Injection Control 6 (Packet Error).
  */

typedef union {
  struct {
    uint32_t EINJ6_COUNT : 8;
    ///< Error Injection Count. Indicates the number of errors to insert. This
    ///< counter is decremented while errors are been inserted.   If the counter
    ///< value is 0x01 and error is inserted, ERROR_INJECTION6_ENABLE in EINJ_ENABLE_REG
    ///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION6_ENABLE=1,
    ///< errors are inserted until ERROR_INJECTION6_ENABLE is set to '0'.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t EINJ6_INVERTED_CONTROL : 1;
    ///< Inverted Error Injection Control. Encodded values given as above.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t EINJ6_PACKET_TYPE : 3;
    ///< Packet type. Selects the TLP packets to inject errors into. All encodings
    ///< other than the specified encodings are reserved.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_einj6_tlp_reg_t;

#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_RD_MASK (0x00000fffU)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_WR_MASK (0x00000fffU)


///< Error Injection Count. Indicates the number of errors to insert. This
///< counter is decremented while errors are been inserted.   If the counter
///< value is 0x01 and error is inserted, ERROR_INJECTION6_ENABLE in EINJ_ENABLE_REG
///< returns '0'.   If the counter value is 0x00 and ERROR_INJECTION6_ENABLE=1,
///< errors are inserted until ERROR_INJECTION6_ENABLE is set to '0'.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_CNT_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_CNT_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_CNT_BF_MSK (0x000000FF)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_CNT_BF_DEF (0x00000000)

///< Inverted Error Injection Control. Encodded values given as above.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_INVERTED_CTRL_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_INVERTED_CTRL_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_INVERTED_CTRL_BF_MSK (0x00000100)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_INVERTED_CTRL_BF_DEF (0x00000000)

///< Packet type. Selects the TLP packets to inject errors into. All encodings
///< other than the specified encodings are reserved.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_PACKET_TYPE_BF_OFF ( 9)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_PACKET_TYPE_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_PACKET_TYPE_BF_MSK (0x00000E00)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_EINJ6_PACKET_TYPE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_CONTROL1_REG register description at address offset 0x250
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_CONTROL1_REG
  * Silicon Debug Control 1.
  */

typedef union {
  struct {
    uint32_t FORCE_DETECT_LANE : 16;
    ///< Force Detect Lane. This field is a bit vector of lanes to force receiver
    ///< detection on. When the FORCE_DETECT_LANE_EN field is set, the controller
    ///< ignores receiver detection from PHY during LTSSM Detect state and
    ///< uses this value instead.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_DETECT_LANE_EN : 1;
    ///< Force Detect Lane Enable.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t TX_EIOS_NUM : 2;
    ///< Number of Tx EIOS. This register sets the number of transmit EIOS
    ///< for L0s/L1 entry and Disable/Loopback/Hot-reset exit. The controller
    ///< selects the greater value between this register and the value defined
    ///< by the PCI-SIG specification.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t LOW_POWER_INTERVAL : 2;
    ///< Low Power Entry Interval Time.  Interval Time that the controller
    ///< starts monitoring RXELECIDLE signal after L0s/L1/L2 entry. You should
    ///< set the value according to the latency from receiving EIOS to, RXELECIDLE
    ///< assertion at the PHY.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_ctrl1_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_RD_MASK (0x00f1ffffU)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_WR_MASK (0x00f1ffffU)


///< Force Detect Lane. This field is a bit vector of lanes to force receiver
///< detection on. When the FORCE_DETECT_LANE_EN field is set, the controller
///< ignores receiver detection from PHY during LTSSM Detect state and
///< uses this value instead.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_BF_WID (16)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_BF_MSK (0x0000FFFF)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_BF_DEF (0x00000000)

///< Force Detect Lane Enable.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_EN_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_FORCE_DETECT_LANE_EN_BF_DEF (0x00000000)

///< Number of Tx EIOS. This register sets the number of transmit EIOS
///< for L0s/L1 entry and Disable/Loopback/Hot-reset exit. The controller
///< selects the greater value between this register and the value defined
///< by the PCI-SIG specification.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_TX_EIOS_NUM_BF_OFF (20)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_TX_EIOS_NUM_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_TX_EIOS_NUM_BF_MSK (0x00300000)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_TX_EIOS_NUM_BF_DEF (0x00000000)

///< Low Power Entry Interval Time.  Interval Time that the controller
///< starts monitoring RXELECIDLE signal after L0s/L1/L2 entry. You should
///< set the value according to the latency from receiving EIOS to, RXELECIDLE
///< assertion at the PHY.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_LOW_PWR_INTERVAL_BF_OFF (22)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_LOW_PWR_INTERVAL_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_LOW_PWR_INTERVAL_BF_MSK (0x00C00000)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_LOW_PWR_INTERVAL_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_CONTROL2_REG register description at address offset 0x254
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_CONTROL2_REG
  * Silicon Debug Control 2.
  */

typedef union {
  struct {
    uint32_t HOLD_LTSSM : 1;
    ///< Hold and Release LTSSM.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RECOVERY_REQUEST : 1;
    ///< Recovery Request.   TDISP Prot :WP
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t NOACK_FORCE_LINKDOWN : 1;
    ///< Force LinkDown.   Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
    uint32_t DIRECT_RECIDLE_TO_CONFIG : 1;
    ///< Direct Recovery.Idle to Configuration.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DIRECT_POLCOMP_TO_DETECT : 1;
    ///< Direct Polling.Compliance to Detect.   Note: This register field is
    ///< sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t DIRECT_LPBKSLV_TO_EXIT : 1;
    ///< Direct Loopback Slave To Exit.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t FRAMING_ERR_RECOVERY_DISABLE : 1;
    ///< Framing Error Recovery Disable.  This bit disables a transition to
    ///< Recovery state when a Framing Error is occurred.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_ctrl2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_RD_MASK (0x00010705U)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_WR_MASK (0x00010707U)


///< Hold and Release LTSSM.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_HOLD_LTSSM_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_HOLD_LTSSM_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_HOLD_LTSSM_BF_MSK (0x00000001)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_HOLD_LTSSM_BF_DEF (0x00000000)

///< Recovery Request.   TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_RECOVERY_REQUEST_BF_OFF ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_RECOVERY_REQUEST_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_RECOVERY_REQUEST_BF_MSK (0x00000002)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_RECOVERY_REQUEST_BF_DEF (0x00000000)

///< Force LinkDown.   Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_NOACK_FORCE_LINKDOWN_BF_OFF ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_NOACK_FORCE_LINKDOWN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_NOACK_FORCE_LINKDOWN_BF_MSK (0x00000004)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_NOACK_FORCE_LINKDOWN_BF_DEF (0x00000000)

///< Direct Recovery.Idle to Configuration.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_RECIDLE_TO_CFG_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_RECIDLE_TO_CFG_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_RECIDLE_TO_CFG_BF_MSK (0x00000100)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_RECIDLE_TO_CFG_BF_DEF (0x00000000)

///< Direct Polling.Compliance to Detect.   Note: This register field is
///< sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_POLCOMP_TO_DETECT_BF_OFF ( 9)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_POLCOMP_TO_DETECT_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_POLCOMP_TO_DETECT_BF_MSK (0x00000200)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_POLCOMP_TO_DETECT_BF_DEF (0x00000000)

///< Direct Loopback Slave To Exit.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_LPBKSLV_TO_EXIT_BF_OFF (10)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_LPBKSLV_TO_EXIT_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_LPBKSLV_TO_EXIT_BF_MSK (0x00000400)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_DIRECT_LPBKSLV_TO_EXIT_BF_DEF (0x00000000)

///< Framing Error Recovery Disable.  This bit disables a transition to
///< Recovery state when a Framing Error is occurred.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_FRAMING_ERR_RECOVERY_DIS_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_FRAMING_ERR_RECOVERY_DIS_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_FRAMING_ERR_RECOVERY_DIS_BF_MSK (0x00010000)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_FRAMING_ERR_RECOVERY_DIS_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_STATUS_L1LANE_REG register description at address offset 0x260
  *
  * Register default value:        0x00180000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_STATUS_L1LANE_REG
  * Silicon Debug Status(Layer1 Per-lane).
  */

typedef union {
  struct {
    uint32_t LANE_SELECT : 4;
    ///< Lane Select.  Lane Select register for Silicon Debug Status Register
    ///< of Layer1-PerLane.   Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
    uint32_t PIPE_RXPOLARITY : 1;
    ///< PIPE:RxPolarity.  Indicates PIPE RXPOLARITY signal of selected lane
    ///< number(LANE_SELECT).   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t PIPE_DETECT_LANE : 1;
    ///< PIPE:Detect Lane.  Indicates whether PHY indicates receiver detection
    ///< or not on selected lane number(LANE_SELECT).   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t PIPE_RXVALID : 1;
    ///< PIPE:RxValid.  Indicates PIPE RXVALID signal of selected lane number(LANE_SELECT).
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t PIPE_RXELECIDLE : 1;
    ///< PIPE:RxElecIdle.  Indicates PIPE RXELECIDLE signal of selected lane
    ///< number(LANE_SELECT).   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x1"
    uint32_t PIPE_TXELECIDLE : 1;
    ///< PIPE:TxElecIdle.  Indicates PIPE TXELECIDLE signal of selected lane
    ///< number(LANE_SELECT).   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x1"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
    uint32_t DESKEW_POINTER : 8;
    ///< Deskew Pointer.  Indicates Deskew pointer of internal Deskew buffer
    ///< of selected lane number(LANE_SELECT).   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_stat_l1lane_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_DEFAULT (0x00180000U)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_RD_MASK (0xff1f000fU)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_WR_MASK (0x0000000fU)


///< Lane Select.  Lane Select register for Silicon Debug Status Register
///< of Layer1-PerLane.   Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_LANE_SEL_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_LANE_SEL_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_LANE_SEL_BF_MSK (0x0000000F)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_LANE_SEL_BF_DEF (0x00000000)

///< PIPE:RxPolarity.  Indicates PIPE RXPOLARITY signal of selected lane
///< number(LANE_SELECT).   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXPOLARITY_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXPOLARITY_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXPOLARITY_BF_MSK (0x00010000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXPOLARITY_BF_DEF (0x00000000)

///< PIPE:Detect Lane.  Indicates whether PHY indicates receiver detection
///< or not on selected lane number(LANE_SELECT).   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_DETECT_LANE_BF_OFF (17)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_DETECT_LANE_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_DETECT_LANE_BF_MSK (0x00020000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_DETECT_LANE_BF_DEF (0x00000000)

///< PIPE:RxValid.  Indicates PIPE RXVALID signal of selected lane number(LANE_SELECT).
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXVALID_BF_OFF (18)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXVALID_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXVALID_BF_MSK (0x00040000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXVALID_BF_DEF (0x00000000)

///< PIPE:RxElecIdle.  Indicates PIPE RXELECIDLE signal of selected lane
///< number(LANE_SELECT).   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXELECIDLE_BF_OFF (19)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXELECIDLE_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXELECIDLE_BF_MSK (0x00080000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_RXELECIDLE_BF_DEF (0x00080000)

///< PIPE:TxElecIdle.  Indicates PIPE TXELECIDLE signal of selected lane
///< number(LANE_SELECT).   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_TXELECIDLE_BF_OFF (20)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_TXELECIDLE_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_TXELECIDLE_BF_MSK (0x00100000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_PIPE_TXELECIDLE_BF_DEF (0x00100000)

///< Deskew Pointer.  Indicates Deskew pointer of internal Deskew buffer
///< of selected lane number(LANE_SELECT).   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_DESKEW_PTR_BF_OFF (24)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_DESKEW_PTR_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_DESKEW_PTR_BF_MSK (0xFF000000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_DESKEW_PTR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_STATUS_L1LTSSM_REG register description at address offset 0x264
  *
  * Register default value:        0x00000200
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_STATUS_L1LTSSM_REG
  * Silicon Debug Status(Layer1 LTSSM).
  */

typedef union {
  struct {
    uint32_t FRAMING_ERR_PTR : 7;
    ///< First Framing Error Pointer.  Identifies the first Framing Error using
    ///< the following encoding. The field contents are only valid value when
    ///< FRAMING_ERR =1.  - Received Unexpected Framing Token (Values 01h to
    ///< 06h)  - Received Unexpected STP Token (Values 11h to 13h)  - Received
    ///< Unexpected Block (Values 21h to 30h) All encodings other than the
    ///< defined encodings are reserved.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FRAMING_ERR : 1;
    ///< Framing Error.  Indicates Framing Error detection status.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/1C/V" BitOffset="7" ResetValue="0x0"
    uint32_t PIPE_POWER_DOWN : 3;
    ///< PIPE:PowerDown.  Indicates PIPE PowerDown signal.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x2"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t LANE_REVERSAL : 1;
    ///< Lane Reversal Operation.  Receiver detected lane reversal.  This field
    ///< is only valid in the L0 LTSSM state.   Note: This register field is
    ///< sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint32_t LTSSM_VARIABLE : 16;
    ///< LTSSM Variable.  Indicates internal LTSSM variables defined in the
    ///< PCI Express Base Specification. For other value idle_to_rlock_transitioned.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_stat_l1ltssm_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_DEFAULT (0x00000200U)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_RD_MASK (0xffff87ffU)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_WR_MASK (0x00000080U)


///< First Framing Error Pointer.  Identifies the first Framing Error using
///< the following encoding. The field contents are only valid value when
///< FRAMING_ERR =1.  - Received Unexpected Framing Token (Values 01h to
///< 06h)  - Received Unexpected STP Token (Values 11h to 13h)  - Received
///< Unexpected Block (Values 21h to 30h) All encodings other than the
///< defined encodings are reserved.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_PTR_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_PTR_BF_WID ( 7)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_PTR_BF_MSK (0x0000007F)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_PTR_BF_DEF (0x00000000)

///< Framing Error.  Indicates Framing Error detection status.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_BF_OFF ( 7)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_BF_MSK (0x00000080)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_FRAMING_ERR_BF_DEF (0x00000000)

///< PIPE:PowerDown.  Indicates PIPE PowerDown signal.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_PIPE_PWR_DOWN_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_PIPE_PWR_DOWN_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_PIPE_PWR_DOWN_BF_MSK (0x00000700)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_PIPE_PWR_DOWN_BF_DEF (0x00000200)

///< Lane Reversal Operation.  Receiver detected lane reversal.  This field
///< is only valid in the L0 LTSSM state.   Note: This register field is
///< sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LANE_REVERSAL_BF_OFF (15)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LANE_REVERSAL_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LANE_REVERSAL_BF_MSK (0x00008000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LANE_REVERSAL_BF_DEF (0x00000000)

///< LTSSM Variable.  Indicates internal LTSSM variables defined in the
///< PCI Express Base Specification. For other value idle_to_rlock_transitioned.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LTSSM_VARIABLE_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LTSSM_VARIABLE_BF_WID (16)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LTSSM_VARIABLE_BF_MSK (0xFFFF0000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_LTSSM_VARIABLE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_STATUS_PM_REG register description at address offset 0x268
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_STATUS_PM_REG
  * Silicon Debug Status(PM).
  */

typedef union {
  struct {
    uint32_t PM_DSP_LINK_STATE : 4;
    ///< Internal PM DSP Link FSM state.  Indicates internal PM Downstream
    ///< Port Link FSM state of Power Management controller.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t PM_DSP_PROT_STATE : 4;
    ///< Internal PM DSP Prot FSM state.  Indicates internal PM Downstream
    ///< Port Protocol FSM state of Power Management controller.   Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t PM_USP_LINK_STATE : 4;
    ///< Internal PM USP Link FSM state.  Indicates internal PM Upstream Port
    ///< Link FSM state of Power Management controller.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t PME_RESEND_FLAG : 1;
    ///< PME Re-send flag.  When the DUT sends a PM_PME message TLP, the DUT
    ///< sets PME_Status bit. If host software does not clear PME_Status bit
    ///< for 100ms(+50%/-5%), the DUT resends the PM_PME Message. This bit
    ///< indicates that a PM_PME was resent.   Note: This register field is
    ///< sticky.  TDISP Prot :WP
    ///< AccessType="RW/1C/V" BitOffset="12" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="13" ResetValue="None"
    uint32_t LATCHED_NFTS : 8;
    ///< Latched N_FTS. Indicates the value of N_FTS in the received TS Ordered
    ///< Sets from the Link Partner.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t PM_L0S_STATE : 3;
    ///< Internal PM L0S FSM state.  Indicates internal PM L0S FSM state of
    ///< Power Management controller.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t PM_USP_PROT_STATE : 4;
    ///< Internal PM USP Prot FSM state.  Indicates internal PM Upstream Port
    ///< Protocol FSM State of Power Management controller.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_stat_pm_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_RD_MASK (0x7fff1fffU)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_WR_MASK (0x00001000U)


///< Internal PM DSP Link FSM state.  Indicates internal PM Downstream
///< Port Link FSM state of Power Management controller.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_LINK_STATE_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_LINK_STATE_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_LINK_STATE_BF_MSK (0x0000000F)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_LINK_STATE_BF_DEF (0x00000000)

///< Internal PM DSP Prot FSM state.  Indicates internal PM Downstream
///< Port Protocol FSM state of Power Management controller.   Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_PROT_STATE_BF_OFF ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_PROT_STATE_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_PROT_STATE_BF_MSK (0x000000F0)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_DSP_PROT_STATE_BF_DEF (0x00000000)

///< Internal PM USP Link FSM state.  Indicates internal PM Upstream Port
///< Link FSM state of Power Management controller.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_LINK_STATE_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_LINK_STATE_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_LINK_STATE_BF_MSK (0x00000F00)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_LINK_STATE_BF_DEF (0x00000000)

///< PME Re-send flag.  When the DUT sends a PM_PME message TLP, the DUT
///< sets PME_Status bit. If host software does not clear PME_Status bit
///< for 100ms(+50%/-5%), the DUT resends the PM_PME Message. This bit
///< indicates that a PM_PME was resent.   Note: This register field is
///< sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_PME_RESEND_FLAG_BF_OFF (12)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_PME_RESEND_FLAG_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_PME_RESEND_FLAG_BF_MSK (0x00001000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_PME_RESEND_FLAG_BF_DEF (0x00000000)

///< Latched N_FTS. Indicates the value of N_FTS in the received TS Ordered
///< Sets from the Link Partner.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_LATCHED_NFTS_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_LATCHED_NFTS_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_LATCHED_NFTS_BF_MSK (0x00FF0000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_LATCHED_NFTS_BF_DEF (0x00000000)

///< Internal PM L0S FSM state.  Indicates internal PM L0S FSM state of
///< Power Management controller.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_L0S_STATE_BF_OFF (24)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_L0S_STATE_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_L0S_STATE_BF_MSK (0x07000000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_L0S_STATE_BF_DEF (0x00000000)

///< Internal PM USP Prot FSM state.  Indicates internal PM Upstream Port
///< Protocol FSM State of Power Management controller.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_PROT_STATE_BF_OFF (27)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_PROT_STATE_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_PROT_STATE_BF_MSK (0x78000000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_USP_PROT_STATE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_STATUS_L2_REG register description at address offset 0x26c
  *
  * Register default value:        0x00FFF000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_STATUS_L2_REG
  * Silicon Debug Status(Layer2).
  */

typedef union {
  struct {
    uint32_t TX_TLP_SEQ_NO : 12;
    ///< Tx Tlp Sequence Number. Indicates next transmit sequence number for
    ///< transmit TLP.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t RX_ACK_SEQ_NO : 12;
    ///< Tx Ack Sequence Number. Indicates ACKD_SEQ which is updated by receiving
    ///< ACK/NAK DLLP.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0xFFF"
    uint32_t DLCMSM : 2;
    ///< DLCMSM. Indicates the current DLCMSM.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t FC_INIT1 : 1;
    ///< FC_INIT1. Indicates the controller is in FC_INIT1(VC0) state.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint32_t FC_INIT2 : 1;
    ///< FC_INIT2. Indicates the controller is in FC_INIT2(VC0) state.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_stat_l2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_DEFAULT (0x00fff000U)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_RD_MASK (0x0fffffffU)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_WR_MASK (0x00000000U)


///< Tx Tlp Sequence Number. Indicates next transmit sequence number for
///< transmit TLP.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_TX_TLP_SEQ_NO_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_TX_TLP_SEQ_NO_BF_WID (12)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_TX_TLP_SEQ_NO_BF_MSK (0x00000FFF)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_TX_TLP_SEQ_NO_BF_DEF (0x00000000)

///< Tx Ack Sequence Number. Indicates ACKD_SEQ which is updated by receiving
///< ACK/NAK DLLP.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_RX_ACK_SEQ_NO_BF_OFF (12)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_RX_ACK_SEQ_NO_BF_WID (12)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_RX_ACK_SEQ_NO_BF_MSK (0x00FFF000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_RX_ACK_SEQ_NO_BF_DEF (0x00FFF000)

///< DLCMSM. Indicates the current DLCMSM.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_DLCMSM_BF_OFF (24)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_DLCMSM_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_DLCMSM_BF_MSK (0x03000000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_DLCMSM_BF_DEF (0x00000000)

///< FC_INIT1. Indicates the controller is in FC_INIT1(VC0) state.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT1_BF_OFF (26)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT1_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT1_BF_MSK (0x04000000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT1_BF_DEF (0x00000000)

///< FC_INIT2. Indicates the controller is in FC_INIT2(VC0) state.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT2_BF_OFF (27)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT2_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT2_BF_MSK (0x08000000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_FC_INIT2_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_STATUS_L3FC_REG register description at address offset 0x270
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_STATUS_L3FC_REG
  * Silicon Debug Status(Layer3 FC).
  */

typedef union {
  struct {
    uint32_t CREDIT_SEL_VC : 3;
    ///< Credit Select(VC). This field in conjunction with the CREDIT_SEL_CREDIT_TYPE,
    ///< CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select fields determines
    ///< that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1 data
    ///< fields.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CREDIT_SEL_CREDIT_TYPE : 1;
    ///< Credit Select(Credit Type). This field in conjunction with the CREDIT_SEL_VC,
    ///< CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select fields determines
    ///< that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1 data
    ///< fields.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CREDIT_SEL_TLP_TYPE : 2;
    ///< Credit Select(TLP Type). This field in conjunction with the CREDIT_SEL_VC,
    ///< CREDIT_SEL_CREDIT_TYPE, and CREDIT_SEL_HD viewport-select fields determines
    ///< that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1 data
    ///< fields.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CREDIT_SEL_HD : 1;
    ///< Credit Select(HeaderData). This field in conjunction with the CREDIT_SEL_VC,
    ///< CREDIT_SEL_CREDIT_TYPE, and CREDIT_SEL_TLP_TYPE viewport-select fields
    ///< determines that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1
    ///< data fields.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t CREDIT_DATA0 : 12;
    ///< Credit Data0. Current FC credit data selected by the CREDIT_SEL_VC,
    ///< CREDIT_SEL_CREDIT_TYPE, CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select
    ///< fields.  - Rx: Credit Received Value  - Tx: Credit Consumed Value
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t CREDIT_DATA1 : 12;
    ///< Credit Data1. Current FC credit data selected by the CREDIT_SEL_VC,
    ///< CREDIT_SEL_CREDIT_TYPE, CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select
    ///< fields.  - Rx: Credit Allocated Value  - Tx: Credit Limit Value. This
    ///< value is valid when DLCMSM=0x3(DL_ACTIVE).   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_stat_l3fc_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_RD_MASK (0xffffff7fU)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_WR_MASK (0x0000007fU)


///< Credit Select(VC). This field in conjunction with the CREDIT_SEL_CREDIT_TYPE,
///< CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select fields determines
///< that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1 data
///< fields.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_VC_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_VC_BF_WID ( 3)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_VC_BF_MSK (0x00000007)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_VC_BF_DEF (0x00000000)

///< Credit Select(Credit Type). This field in conjunction with the CREDIT_SEL_VC,
///< CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select fields determines
///< that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1 data
///< fields.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_CREDIT_TYPE_BF_OFF ( 3)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_CREDIT_TYPE_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_CREDIT_TYPE_BF_MSK (0x00000008)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_CREDIT_TYPE_BF_DEF (0x00000000)

///< Credit Select(TLP Type). This field in conjunction with the CREDIT_SEL_VC,
///< CREDIT_SEL_CREDIT_TYPE, and CREDIT_SEL_HD viewport-select fields determines
///< that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1 data
///< fields.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_TLP_TYPE_BF_OFF ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_TLP_TYPE_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_TLP_TYPE_BF_MSK (0x00000030)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_TLP_TYPE_BF_DEF (0x00000000)

///< Credit Select(HeaderData). This field in conjunction with the CREDIT_SEL_VC,
///< CREDIT_SEL_CREDIT_TYPE, and CREDIT_SEL_TLP_TYPE viewport-select fields
///< determines that data that is returned by the CREDIT_DATA0 and CREDIT_DATA1
///< data fields.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_HD_BF_OFF ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_HD_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_HD_BF_MSK (0x00000040)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_SEL_HD_BF_DEF (0x00000000)

///< Credit Data0. Current FC credit data selected by the CREDIT_SEL_VC,
///< CREDIT_SEL_CREDIT_TYPE, CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select
///< fields.  - Rx: Credit Received Value  - Tx: Credit Consumed Value
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA0_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA0_BF_WID (12)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA0_BF_MSK (0x000FFF00)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA0_BF_DEF (0x00000000)

///< Credit Data1. Current FC credit data selected by the CREDIT_SEL_VC,
///< CREDIT_SEL_CREDIT_TYPE, CREDIT_SEL_TLP_TYPE, and CREDIT_SEL_HD viewport-select
///< fields.  - Rx: Credit Allocated Value  - Tx: Credit Limit Value. This
///< value is valid when DLCMSM=0x3(DL_ACTIVE).   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA1_BF_OFF (20)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA1_BF_WID (12)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA1_BF_MSK (0xFFF00000)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_CREDIT_DATA1_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_STATUS_L3_REG register description at address offset 0x274
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_STATUS_L3_REG
  * Silicon Debug Status(Layer3).
  */

typedef union {
  struct {
    uint32_t MFTLP_POINTER : 7;
    ///< First Malformed TLP Error Pointer. Indicates the element of the received
    ///< first malformed TLP. This pointer is validated by MFTLP_STATUS. All
    ///< encodings other than the defined encodings are reserved.   Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t MFTLP_STATUS : 1;
    ///< Malformed TLP Status. Indicates malformed TLP has occurred.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/1C/V" BitOffset="7" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_stat_l3_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_RD_MASK (0x000000ffU)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_WR_MASK (0x00000080U)


///< First Malformed TLP Error Pointer. Indicates the element of the received
///< first malformed TLP. This pointer is validated by MFTLP_STATUS. All
///< encodings other than the defined encodings are reserved.   Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_PTR_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_PTR_BF_WID ( 7)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_PTR_BF_MSK (0x0000007F)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_PTR_BF_DEF (0x00000000)

///< Malformed TLP Status. Indicates malformed TLP has occurred.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_STAT_BF_OFF ( 7)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_STAT_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_STAT_BF_MSK (0x00000080)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_MFTLP_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_EQ_CONTROL1_REG register description at address offset 0x280
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_EQ_CONTROL1_REG
  * Silicon Debug EQ Control 1.
  */

typedef union {
  struct {
    uint32_t EQ_LANE_SEL : 4;
    ///< EQ Status Lane Select. Setting this field in conjunction with the
    ///< EQ_RATE_SEL field determines the per-lane Silicon Debug EQ Status
    ///< data returned by the SD_EQ_CONTROL[2/3] and SD_EQ_STATUS[1/2/3] viewport
    ///< registers.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t EQ_RATE_SEL : 2;
    ///< EQ Status Rate Select. Setting this field in conjunction with the
    ///< EQ_LANE_SEL field determines the per-lane Silicon Debug EQ Status
    ///< data returned by the SD_EQ_CONTROL[2/3] and SD_EQ_STATUS[1/2/3] viewport
    ///< registers.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t EXT_EQ_TIMEOUT : 2;
    ///< Extends EQ Phase2/3 Timeout. This field is used when the LTSSM is
    ///< in Recovery.EQ2/3. When this field is set, the value of EQ2/3 timeout
    ///< is extended.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t EVAL_INTERVAL_TIME : 2;
    ///< Eval Interval Time. Indicates interval time of RxEqEval assertion.
    ///< This field is used for EQ Master(DSP in EQ Phase3/USP in EQ Phase2).
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
    uint32_t FOM_TARGET_ENABLE : 1;
    ///< FOM Target Enable. Enables the FOM_TARGET fields.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t FOM_TARGET : 8;
    ///< FOM Target. Indicates figure of merit target criteria value of EQ
    ///< Master(DSP in EQ Phase3/USP in EQ Phase2).  This field is only valid
    ///< when GEN3_EQ_FB_MODE is 0001b(Figure Of Merit).   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_eq_ctrl1_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_RD_MASK (0xff83033fU)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_WR_MASK (0xff83033fU)


///< EQ Status Lane Select. Setting this field in conjunction with the
///< EQ_RATE_SEL field determines the per-lane Silicon Debug EQ Status
///< data returned by the SD_EQ_CONTROL[2/3] and SD_EQ_STATUS[1/2/3] viewport
///< registers.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_LANE_SEL_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_LANE_SEL_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_LANE_SEL_BF_MSK (0x0000000F)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_LANE_SEL_BF_DEF (0x00000000)

///< EQ Status Rate Select. Setting this field in conjunction with the
///< EQ_LANE_SEL field determines the per-lane Silicon Debug EQ Status
///< data returned by the SD_EQ_CONTROL[2/3] and SD_EQ_STATUS[1/2/3] viewport
///< registers.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_RATE_SEL_BF_OFF ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_RATE_SEL_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_RATE_SEL_BF_MSK (0x00000030)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EQ_RATE_SEL_BF_DEF (0x00000000)

///< Extends EQ Phase2/3 Timeout. This field is used when the LTSSM is
///< in Recovery.EQ2/3. When this field is set, the value of EQ2/3 timeout
///< is extended.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EXT_EQ_TIMEOUT_BF_OFF ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EXT_EQ_TIMEOUT_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EXT_EQ_TIMEOUT_BF_MSK (0x00000300)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EXT_EQ_TIMEOUT_BF_DEF (0x00000000)

///< Eval Interval Time. Indicates interval time of RxEqEval assertion.
///< This field is used for EQ Master(DSP in EQ Phase3/USP in EQ Phase2).
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EVAL_INTERVAL_TIME_BF_OFF (16)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EVAL_INTERVAL_TIME_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EVAL_INTERVAL_TIME_BF_MSK (0x00030000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_EVAL_INTERVAL_TIME_BF_DEF (0x00000000)

///< FOM Target Enable. Enables the FOM_TARGET fields.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_EN_BF_OFF (23)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_EN_BF_MSK (0x00800000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_EN_BF_DEF (0x00000000)

///< FOM Target. Indicates figure of merit target criteria value of EQ
///< Master(DSP in EQ Phase3/USP in EQ Phase2).  This field is only valid
///< when GEN3_EQ_FB_MODE is 0001b(Figure Of Merit).   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_BF_OFF (24)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_BF_MSK (0xFF000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_FOM_TARGET_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_EQ_CONTROL2_REG register description at address offset 0x284
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_EQ_CONTROL2_REG
  * Silicon Debug EQ Control 2.
  */

typedef union {
  struct {
    uint32_t FORCE_LOCAL_TX_PRE_CURSOR : 6;
    ///< Force Local Transmitter Pre-cursor. Indicates the coefficient value
    ///< of EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of the value
    ///< instructed from link partner. If CX_GEN6_SPEED is set and select rate
    ///< in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [5:4] is not used.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_LOCAL_TX_CURSOR : 6;
    ///< Force Local Transmitter Cursor. Indicates the coefficient value of
    ///< EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of the value
    ///< instructed from link partner.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t FORCE_LOCAL_TX_POST_CURSOR : 6;
    ///< Force Local Transmitter Post-Cursor. Indicates the coefficient value
    ///< of EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of the value
    ///< instructed from link partner. If CX_GEN6_SPEED is set and select rate
    ///< in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [17] is not used.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="12" ResetValue="0x0"
    uint32_t FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR : 6;
    ///< If select rate in the EQ_RATE_SEL field is 8.0GT/s Speed, Bit [20:18]
    ///< corresponds to Force Local Receiver Preset Hint. Indicates the RxPresetHint
    ///< value of EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of received
    ///< or set value. If CX_GEN6_SPEED is set and select rate in the EQ_RATE_SEL
    ///< field is 64.0GT/s Speed, Force Local Transmitter 2nd Pre-Cursor. Bit
    ///< [23:21] is not used. Indicates the coefficient value of EQ Slave(DSP
    ///< in EQ Phase2/USP in EQ Phase3), instead of the value instructed from
    ///< link partner. If select rate in the EQ_RATE_SEL field is other than
    ///< 8.0GT/s or 64.0 GT/s Speed, this feature is not available.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="18" ResetValue="0x0"
    uint32_t FORCE_LOCAL_TX_PRESET : 4;
    ///< Force Local Transmitter Preset. Indicates initial preset value of
    ///< USP in EQ Slave(EQ Phase2) instead of receiving EQ TS2. If select
    ///< rate in the EQ_RATE_SEL field is 32.0GT/s Speed, this feature is not
    ///< available.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="24" ResetValue="0x0"
    uint32_t FORCE_LOCAL_TX_COEF_ENABLE : 1;
    ///< Force Local Transmitter Coefficient Enable. Enables the following
    ///< fields:  - FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR  -
    ///< FORCE_LOCAL_TX_PRE_CURSOR  - FORCE_LOCAL_TX_CURSOR  - FORCE_LOCAL_TX_POST_CURSOR
    ///< FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR field is enabled
    ///< only when CX_GEN6_SPEED is set and select rate in the EQ_RATE_SEL
    ///< field is 64.0GT/s Speed.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW/V" BitOffset="28" ResetValue="0x0"
    uint32_t FORCE_LOCAL_RX_HINT_ENABLE : 1;
    ///< Force Local Receiver Preset Hint Enable. Enables the FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR
    ///< field. If select rate in the EQ_RATE_SEL field is other than 8.0GT/s
    ///< Speed, this feature is not available.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="29" ResetValue="0x0"
    uint32_t FORCE_LOCAL_TX_PRESET_ENABLE : 1;
    ///< Force Local Transmitter Preset Enable. Enables the FORCE_LOCAL_TX_PRESET
    ///< field. If select rate in the EQ_RATE_SEL field is 32.0GT/s Speed,
    ///< this feature is not available.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_eq_ctrl2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_RD_MASK (0x7fffffffU)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_WR_MASK (0x7fffffffU)


///< Force Local Transmitter Pre-cursor. Indicates the coefficient value
///< of EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of the value
///< instructed from link partner. If CX_GEN6_SPEED is set and select rate
///< in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [5:4] is not used.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRE_CURSOR_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRE_CURSOR_BF_MSK (0x0000003F)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRE_CURSOR_BF_DEF (0x00000000)

///< Force Local Transmitter Cursor. Indicates the coefficient value of
///< EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of the value
///< instructed from link partner.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_CURSOR_BF_OFF ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_CURSOR_BF_MSK (0x00000FC0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_CURSOR_BF_DEF (0x00000000)

///< Force Local Transmitter Post-Cursor. Indicates the coefficient value
///< of EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of the value
///< instructed from link partner. If CX_GEN6_SPEED is set and select rate
///< in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [17] is not used.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_POST_CURSOR_BF_OFF (12)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_POST_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_POST_CURSOR_BF_MSK (0x0003F000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_POST_CURSOR_BF_DEF (0x00000000)

///< If select rate in the EQ_RATE_SEL field is 8.0GT/s Speed, Bit [20:18]
///< corresponds to Force Local Receiver Preset Hint. Indicates the RxPresetHint
///< value of EQ Slave(DSP in EQ Phase2/USP in EQ Phase3), instead of received
///< or set value. If CX_GEN6_SPEED is set and select rate in the EQ_RATE_SEL
///< field is 64.0GT/s Speed, Force Local Transmitter 2nd Pre-Cursor. Bit
///< [23:21] is not used. Indicates the coefficient value of EQ Slave(DSP
///< in EQ Phase2/USP in EQ Phase3), instead of the value instructed from
///< link partner. If select rate in the EQ_RATE_SEL field is other than
///< 8.0GT/s or 64.0 GT/s Speed, this feature is not available.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR_BF_OFF (18)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR_BF_MSK (0x00FC0000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR_BF_DEF (0x00000000)

///< Force Local Transmitter Preset. Indicates initial preset value of
///< USP in EQ Slave(EQ Phase2) instead of receiving EQ TS2. If select
///< rate in the EQ_RATE_SEL field is 32.0GT/s Speed, this feature is not
///< available.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_BF_OFF (24)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_BF_WID ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_BF_MSK (0x0F000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_BF_DEF (0x00000000)

///< Force Local Transmitter Coefficient Enable. Enables the following
///< fields:  - FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR  -
///< FORCE_LOCAL_TX_PRE_CURSOR  - FORCE_LOCAL_TX_CURSOR  - FORCE_LOCAL_TX_POST_CURSOR
///< FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR field is enabled
///< only when CX_GEN6_SPEED is set and select rate in the EQ_RATE_SEL
///< field is 64.0GT/s Speed.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_COEF_EN_BF_OFF (28)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_COEF_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_COEF_EN_BF_MSK (0x10000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_COEF_EN_BF_DEF (0x00000000)

///< Force Local Receiver Preset Hint Enable. Enables the FORCE_LOCAL_RX_HINT_OR_FORCE_LOCAL_TX_2ND_PRE_CURSOR
///< field. If select rate in the EQ_RATE_SEL field is other than 8.0GT/s
///< Speed, this feature is not available.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_EN_BF_OFF (29)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_EN_BF_MSK (0x20000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_RX_HINT_EN_BF_DEF (0x00000000)

///< Force Local Transmitter Preset Enable. Enables the FORCE_LOCAL_TX_PRESET
///< field. If select rate in the EQ_RATE_SEL field is 32.0GT/s Speed,
///< this feature is not available.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_EN_BF_OFF (30)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_EN_BF_MSK (0x40000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_FORCE_LOCAL_TX_PRST_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_EQ_CONTROL3_REG register description at address offset 0x288
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_EQ_CONTROL3_REG
  * Silicon Debug EQ Control 3.
  */

typedef union {
  struct {
    uint32_t FORCE_REMOTE_TX_PRE_CURSOR : 6;
    ///< Force Remote Transmitter Pre-Cursor. Indicates the coefficient value
    ///< of EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of the value
    ///< instructed from local PHY in dirchange mode. If CX_GEN6_SPEED is set
    ///< and select rate in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [5:4]
    ///< is not used.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_REMOTE_TX_CURSOR : 6;
    ///< Force Remote Transmitter Cursor. Indicates the coefficient value of
    ///< EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of the value
    ///< instructed from local PHY in dirchange mode.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t FORCE_REMOTE_TX_POST_CURSOR : 6;
    ///< Force Remote Transmitter Post-Cursor. Indicates the coefficient value
    ///< of EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of the value
    ///< instructed from local PHY in dirchange mode. If CX_GEN6_SPEED is set
    ///< and select rate in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [17]
    ///< is not used.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="12" ResetValue="0x0"
    uint32_t FORCE_REMOTE_TX_2ND_PRE_CURSOR : 6;
    ///< Force Remote Transmitter 2nd Pre-Cursor. Indicates the coefficient
    ///< value of EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of
    ///< the value instructed from local PHY in dirchange mode. Bit [23:21]
    ///< is not used. If select rate in the EQ_RATE_SEL field is other than
    ///< 64.0GT/s Speed, this feature is not available. This field is reserved
    ///< when CX_GEN6_SPEED is not set.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="18" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t FORCE_REMOTE_TX_COEF_ENABLE : 1;
    ///< Force Remote Transmitter Coefficient Enable. Enables the following
    ///< fields:  - FORCE_REMOTE_TX_2ND_PRE_CURSOR  - FORCE_REMOTE_TX_PRE_CURSOR
    ///< - FORCE_REMOTE_TX_CURSOR  - FORCE_REMOTE_TX_POST_CURSOR FORCE_REMOTE_TX_2ND_PRE_CURSOR
    ///< field is enabled only when CX_GEN6_SPEED is set and select rate in
    ///< the EQ_RATE_SEL field is 64.0GT/s Speed. This function can only be
    ///< used when GEN3_EQ_FB_MODE = 0000b(Direction Change)   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="28" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_eq_ctrl3_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_RD_MASK (0x10ffffffU)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_WR_MASK (0x10ffffffU)


///< Force Remote Transmitter Pre-Cursor. Indicates the coefficient value
///< of EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of the value
///< instructed from local PHY in dirchange mode. If CX_GEN6_SPEED is set
///< and select rate in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [5:4]
///< is not used.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_PRE_CURSOR_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_PRE_CURSOR_BF_MSK (0x0000003F)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_PRE_CURSOR_BF_DEF (0x00000000)

///< Force Remote Transmitter Cursor. Indicates the coefficient value of
///< EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of the value
///< instructed from local PHY in dirchange mode.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_CURSOR_BF_OFF ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_CURSOR_BF_MSK (0x00000FC0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_CURSOR_BF_DEF (0x00000000)

///< Force Remote Transmitter Post-Cursor. Indicates the coefficient value
///< of EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of the value
///< instructed from local PHY in dirchange mode. If CX_GEN6_SPEED is set
///< and select rate in the EQ_RATE_SEL field is 64.0GT/s Speed, Bit [17]
///< is not used.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_POST_CURSOR_BF_OFF (12)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_POST_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_POST_CURSOR_BF_MSK (0x0003F000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_POST_CURSOR_BF_DEF (0x00000000)

///< Force Remote Transmitter 2nd Pre-Cursor. Indicates the coefficient
///< value of EQ Master(DSP in EQ Phase3/USP in EQ Phase2), instead of
///< the value instructed from local PHY in dirchange mode. Bit [23:21]
///< is not used. If select rate in the EQ_RATE_SEL field is other than
///< 64.0GT/s Speed, this feature is not available. This field is reserved
///< when CX_GEN6_SPEED is not set.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_2ND_PRE_CURSOR_BF_OFF (18)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_2ND_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_2ND_PRE_CURSOR_BF_MSK (0x00FC0000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_2ND_PRE_CURSOR_BF_DEF (0x00000000)

///< Force Remote Transmitter Coefficient Enable. Enables the following
///< fields:  - FORCE_REMOTE_TX_2ND_PRE_CURSOR  - FORCE_REMOTE_TX_PRE_CURSOR
///< - FORCE_REMOTE_TX_CURSOR  - FORCE_REMOTE_TX_POST_CURSOR FORCE_REMOTE_TX_2ND_PRE_CURSOR
///< field is enabled only when CX_GEN6_SPEED is set and select rate in
///< the EQ_RATE_SEL field is 64.0GT/s Speed. This function can only be
///< used when GEN3_EQ_FB_MODE = 0000b(Direction Change)   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_COEF_EN_BF_OFF (28)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_COEF_EN_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_COEF_EN_BF_MSK (0x10000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_FORCE_REMOTE_TX_COEF_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_EQ_STATUS1_REG register description at address offset 0x290
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_EQ_STATUS1_REG
  * Silicon Debug EQ Status 1.
  */

typedef union {
  struct {
    uint32_t EQ_SEQUENCE : 1;
    ///< EQ Sequence. Indicates that the controller is starting the equalization
    ///< sequence.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t EQ_CONVERGENCE_INFO : 2;
    ///< EQ Convergence Info. Indicates equalization convergence information.
    ///< This bit is automatically cleared when the controller starts EQ Master
    ///< phase again.  Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EQ_RULED_VIOLATION : 1;
    ///< EQ Rule D Violation. Indicates that coefficients rule D violation
    ///< is detected in the values provided by PHY using direction change method
    ///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
    ///< rule D correspond to the rules d) from section  Rules for Transmitter
    ///< Coefficents  in the PCI Express Base Specification. If select rate
    ///< in the EQ_RATE_SEL field is other than 64.0GT/s Speed, this feature
    ///< is not available. This field is reserved when CX_GEN6_SPEED is not
    ///< set.  This bit is automatically cleared when the controller starts
    ///< EQ Master phase again.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t EQ_RULEA_VIOLATION : 1;
    ///< EQ Rule A Violation. Indicates that coefficients rule A violation
    ///< is detected in the values provided by PHY using direction change method
    ///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
    ///< rules A correspond to the rules a) from section  Rules for Transmitter
    ///< Coefficents  in the PCI Express Base Specification.  This bit is automatically
    ///< cleared when the controller starts EQ Master phase again.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t EQ_RULEB_VIOLATION : 1;
    ///< EQ Rule B Violation. Indicates that coefficients rule B violation
    ///< is detected in the values provided by PHY using direction change method
    ///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
    ///< rules B correspond to the rules b) from section  Rules for Transmitter
    ///< Coefficents  in the PCI Express Base Specification.  This bit is automatically
    ///< cleared when the controller starts EQ Master phase again.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t EQ_RULEC_VIOLATION : 1;
    ///< EQ Rule C Violation. Indicates that coefficients rule C violation
    ///< is detected in the values provided by PHY using direction change method
    ///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
    ///< rule C  correspond to the rules c) from section  Rules for Transmitter
    ///< Coefficents  in the PCI Express Base Specification.  This bit is automatically
    ///< cleared when the controller starts EQ Master phase again.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t EQ_REJECT_EVENT : 1;
    ///< EQ Reject Event. Indicates that the controller receives two consecutive
    ///< TS1 OS w/Reject=1b during EQ Master phase(DSP in EQ Phase3/USP in
    ///< EQ Phase2). This bit is automatically cleared when the controller
    ///< starts EQ Master phase again.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t EQ_REMOTE_2ND_PRE_CURSOR : 6;
    ///< EQ Remote 2nd Pre-Cursor. Indicates Remote 2nd pre cursor coefficient
    ///< value. This field is reserved when CX_GEN6_SPEED is not set.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_eq_stat1_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_RD_MASK (0xfc0000ffU)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_WR_MASK (0x00000000U)


///< EQ Sequence. Indicates that the controller is starting the equalization
///< sequence.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_SEQUENCE_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_SEQUENCE_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_SEQUENCE_BF_MSK (0x00000001)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_SEQUENCE_BF_DEF (0x00000000)

///< EQ Convergence Info. Indicates equalization convergence information.
///< This bit is automatically cleared when the controller starts EQ Master
///< phase again.  Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_CONVERGENCE_INFO_BF_OFF ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_CONVERGENCE_INFO_BF_WID ( 2)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_CONVERGENCE_INFO_BF_MSK (0x00000006)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_CONVERGENCE_INFO_BF_DEF (0x00000000)

///< EQ Rule D Violation. Indicates that coefficients rule D violation
///< is detected in the values provided by PHY using direction change method
///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
///< rule D correspond to the rules d) from section  Rules for Transmitter
///< Coefficents  in the PCI Express Base Specification. If select rate
///< in the EQ_RATE_SEL field is other than 64.0GT/s Speed, this feature
///< is not available. This field is reserved when CX_GEN6_SPEED is not
///< set.  This bit is automatically cleared when the controller starts
///< EQ Master phase again.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULED_VIOLATION_BF_OFF ( 3)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULED_VIOLATION_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULED_VIOLATION_BF_MSK (0x00000008)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULED_VIOLATION_BF_DEF (0x00000000)

///< EQ Rule A Violation. Indicates that coefficients rule A violation
///< is detected in the values provided by PHY using direction change method
///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
///< rules A correspond to the rules a) from section  Rules for Transmitter
///< Coefficents  in the PCI Express Base Specification.  This bit is automatically
///< cleared when the controller starts EQ Master phase again.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEA_VIOLATION_BF_OFF ( 4)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEA_VIOLATION_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEA_VIOLATION_BF_MSK (0x00000010)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEA_VIOLATION_BF_DEF (0x00000000)

///< EQ Rule B Violation. Indicates that coefficients rule B violation
///< is detected in the values provided by PHY using direction change method
///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
///< rules B correspond to the rules b) from section  Rules for Transmitter
///< Coefficents  in the PCI Express Base Specification.  This bit is automatically
///< cleared when the controller starts EQ Master phase again.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEB_VIOLATION_BF_OFF ( 5)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEB_VIOLATION_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEB_VIOLATION_BF_MSK (0x00000020)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEB_VIOLATION_BF_DEF (0x00000000)

///< EQ Rule C Violation. Indicates that coefficients rule C violation
///< is detected in the values provided by PHY using direction change method
///< during EQ Master phase(DSP in EQ Phase3/USP in EQ Phase2). The coefficients
///< rule C  correspond to the rules c) from section  Rules for Transmitter
///< Coefficents  in the PCI Express Base Specification.  This bit is automatically
///< cleared when the controller starts EQ Master phase again.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEC_VIOLATION_BF_OFF ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEC_VIOLATION_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEC_VIOLATION_BF_MSK (0x00000040)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_RULEC_VIOLATION_BF_DEF (0x00000000)

///< EQ Reject Event. Indicates that the controller receives two consecutive
///< TS1 OS w/Reject=1b during EQ Master phase(DSP in EQ Phase3/USP in
///< EQ Phase2). This bit is automatically cleared when the controller
///< starts EQ Master phase again.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REJECT_EVENT_BF_OFF ( 7)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REJECT_EVENT_BF_WID ( 1)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REJECT_EVENT_BF_MSK (0x00000080)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REJECT_EVENT_BF_DEF (0x00000000)

///< EQ Remote 2nd Pre-Cursor. Indicates Remote 2nd pre cursor coefficient
///< value. This field is reserved when CX_GEN6_SPEED is not set.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REMOTE_2ND_PRE_CURSOR_BF_OFF (26)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REMOTE_2ND_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REMOTE_2ND_PRE_CURSOR_BF_MSK (0xFC000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_EQ_REMOTE_2ND_PRE_CURSOR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_EQ_STATUS2_REG register description at address offset 0x294
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_EQ_STATUS2_REG
  * Silicon Debug EQ Status 2.
  */

typedef union {
  struct {
    uint32_t EQ_LOCAL_PRE_CURSOR : 6;
    ///< EQ Local Pre-Cursor. Indicates Local pre cursor coefficient value.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t EQ_LOCAL_CURSOR : 6;
    ///< EQ Local Cursor. Indicates Local cursor coefficient value.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t EQ_LOCAL_POST_CURSOR : 6;
    ///< EQ Local Post-Cursor. Indicates Local post cursor coefficient value.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t EQ_LOCAL_RX_HINT_OR_EQ_LOCAL_2ND_PRE_CURSOR : 6;
    ///< If select rate in the EQ_RATE_SEL field is 8.0GT/s Speed, Bit [20:18]
    ///< corresponds to EQ Local Receiver Preset Hint. Indicates Local Receiver
    ///< Preset Hint value. If select rate in the EQ_RATE_SEL field is 64.0GT/s
    ///< Speed, EQ Local 2nd Pre-Cursor. Indicates Local 2nd pre cursor coefficient
    ///< value. If CX_GEN6_SPEED is set and select rate in the EQ_RATE_SEL
    ///< field is other than 8.0GT/s or 64.0 GT/s Speed, this feature is not
    ///< available.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t EQ_LOCAL_FOM_VALUE : 8;
    ///< EQ Local Figure of Merit. Indicates Local maximum Figure of Merit
    ///< value.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_eq_stat2_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_RD_MASK (0xffffffffU)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_WR_MASK (0x00000000U)


///< EQ Local Pre-Cursor. Indicates Local pre cursor coefficient value.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_PRE_CURSOR_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_PRE_CURSOR_BF_MSK (0x0000003F)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_PRE_CURSOR_BF_DEF (0x00000000)

///< EQ Local Cursor. Indicates Local cursor coefficient value.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_CURSOR_BF_OFF ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_CURSOR_BF_MSK (0x00000FC0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_CURSOR_BF_DEF (0x00000000)

///< EQ Local Post-Cursor. Indicates Local post cursor coefficient value.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_POST_CURSOR_BF_OFF (12)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_POST_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_POST_CURSOR_BF_MSK (0x0003F000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_POST_CURSOR_BF_DEF (0x00000000)

///< If select rate in the EQ_RATE_SEL field is 8.0GT/s Speed, Bit [20:18]
///< corresponds to EQ Local Receiver Preset Hint. Indicates Local Receiver
///< Preset Hint value. If select rate in the EQ_RATE_SEL field is 64.0GT/s
///< Speed, EQ Local 2nd Pre-Cursor. Indicates Local 2nd pre cursor coefficient
///< value. If CX_GEN6_SPEED is set and select rate in the EQ_RATE_SEL
///< field is other than 8.0GT/s or 64.0 GT/s Speed, this feature is not
///< available.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_RX_HINT_OR_EQ_LOCAL_2ND_PRE_CURSOR_BF_OFF (18)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_RX_HINT_OR_EQ_LOCAL_2ND_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_RX_HINT_OR_EQ_LOCAL_2ND_PRE_CURSOR_BF_MSK (0x00FC0000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_RX_HINT_OR_EQ_LOCAL_2ND_PRE_CURSOR_BF_DEF (0x00000000)

///< EQ Local Figure of Merit. Indicates Local maximum Figure of Merit
///< value.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_FOM_VAL_BF_OFF (24)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_FOM_VAL_BF_WID ( 8)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_FOM_VAL_BF_MSK (0xFF000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_EQ_LOCAL_FOM_VAL_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_RAS_DES_CAP_SD_EQ_STATUS3_REG register description at address offset 0x298
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_RAS_DES_CAP/SD_EQ_STATUS3_REG
  * Silicon Debug EQ Status 3.
  */

typedef union {
  struct {
    uint32_t EQ_REMOTE_PRE_CURSOR : 6;
    ///< EQ Remote Pre-Cursor. Indicates Remote pre cursor coefficient value.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t EQ_REMOTE_CURSOR : 6;
    ///< EQ Remote Cursor. Indicates Remote cursor coefficient value.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t EQ_REMOTE_POST_CURSOR : 6;
    ///< EQ Remote Post-Cursor. Indicates Remote post cursor coefficient value.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t EQ_REMOTE_LF : 6;
    ///< EQ Remote LF. Indicates Remote LF value.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t EQ_REMOTE_FS : 6;
    ///< EQ Remote FS. Indicates Remote FS value.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_ras_des_cap_sd_eq_stat3_reg_t;

#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_DEFAULT (0x00000000U)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_RD_MASK (0x3fffffffU)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_WR_MASK (0x00000000U)


///< EQ Remote Pre-Cursor. Indicates Remote pre cursor coefficient value.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_PRE_CURSOR_BF_OFF ( 0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_PRE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_PRE_CURSOR_BF_MSK (0x0000003F)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_PRE_CURSOR_BF_DEF (0x00000000)

///< EQ Remote Cursor. Indicates Remote cursor coefficient value.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_CURSOR_BF_OFF ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_CURSOR_BF_MSK (0x00000FC0)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_CURSOR_BF_DEF (0x00000000)

///< EQ Remote Post-Cursor. Indicates Remote post cursor coefficient value.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_POST_CURSOR_BF_OFF (12)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_POST_CURSOR_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_POST_CURSOR_BF_MSK (0x0003F000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_POST_CURSOR_BF_DEF (0x00000000)

///< EQ Remote LF. Indicates Remote LF value.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_LF_BF_OFF (18)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_LF_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_LF_BF_MSK (0x00FC0000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_LF_BF_DEF (0x00000000)

///< EQ Remote FS. Indicates Remote FS value.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_FS_BF_OFF (24)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_FS_BF_WID ( 6)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_FS_BF_MSK (0x3F000000)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_EQ_REMOTE_FS_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF register description at address offset 0x2b0
  *
  * Register default value:        0x2BC10025
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_DLINK_CAP/DATA_LINK_FEATURE_EXT_HDR_OFF
  * Data Link Feature Extended Capability Header Register.
  */

typedef union {
  struct {
    uint32_t DLINK_EXT_CAP_ID : 16;
    ///< Capability ID. This field is a PCI-SIG defined ID number that indicates
    ///< the nature and format of the Extended Capability. Extended Capability
    ///< ID for Data Link Feature is 0025h.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x25"
    uint32_t DLINK_CAP_VERSION : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present. This
    ///< field depends on the version of the specification.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
    ///< register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t DLINK_NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Capability structure or 000h, if no other items exist
    ///< in the linked list of Capabilities. For Extended Capabilities implemented
    ///< in Configuration Space, this offset is relative to the beginning of
    ///< PCI-compatible Configuration Space and thus must always be either
    ///< 000h (for terminating list of Capabilities) or greater than 0FFh.
    ///< The bottom 2 bits of this offset are Reserved and must be implemented
    ///< as 00b although software must mask them to allow for future uses of
    ///< these bits.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x2BC"
  } ;
  uint32_t value;
} pcie_ctl_dlink_cap_data_link_feature_ext_hdr_off_reg_t;

#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DEFAULT (0x2bc10025U)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_WR_MASK (0x00000000U)


///< Capability ID. This field is a PCI-SIG defined ID number that indicates
///< the nature and format of the Extended Capability. Extended Capability
///< ID for Data Link Feature is 0025h.   Note: The access attributes of
///< this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_EXT_CAP_ID_BF_OFF ( 0)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_EXT_CAP_ID_BF_WID (16)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_EXT_CAP_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_EXT_CAP_ID_BF_DEF (0x00000025)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present. This
///< field depends on the version of the specification.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)  Note: This
///< register field is sticky.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_CAP_VER_BF_OFF (16)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_CAP_VER_BF_WID ( 4)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_CAP_VER_BF_MSK (0x000F0000)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_CAP_VER_BF_DEF (0x00010000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Capability structure or 000h, if no other items exist
///< in the linked list of Capabilities. For Extended Capabilities implemented
///< in Configuration Space, this offset is relative to the beginning of
///< PCI-compatible Configuration Space and thus must always be either
///< 000h (for terminating list of Capabilities) or greater than 0FFh.
///< The bottom 2 bits of this offset are Reserved and must be implemented
///< as 00b although software must mask them to allow for future uses of
///< these bits.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_DLINK_NEXT_OFFSET_BF_DEF (0x2BC00000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF register description at address offset 0x2b4
  *
  * Register default value:        0x80000001
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_DLINK_CAP/DATA_LINK_FEATURE_CAP_OFF
  * Data Link Feature Capabilities Register.
  */

typedef union {
  struct {
    uint32_t SCALED_FLOW_CNTL_SUPPORTED : 1;
    ///< Local Scaled Flow Control Supported.   This bit indicates that this
    ///< Port supports Scaled Flow Control Feature   Note: The access attributes
    ///< of this field are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x1"
    uint32_t LCL_IMMEDIATE_READINESS : 1;
    ///< Local Immediate Readiness.   This Bit indicates that all non-virtual
    ///< functions in this port hace immediate readiness set.  This bit MUST@FLIT
    ///< be meaningful. in non-Flit mode, this bit is meaningful when set,
    ///< but when clear indicates either some non-virtual function has immediate
    ///< readiness clear or that this port is not providing this information.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t LCL_EXTENDED_VC_CNT : 3;
    ///< Local Extended VC Count.   This field indicates the number of VC resources
    ///< supported by this port. This is tte value of the extended VC count
    ///< field in either the multi-function virtual channel extended capability
    ///< or the virtual channel extended capability (With capability ID 0002h).
    ///< This field is meaningful in Flit Mode. In Non-Flit Mode, this field
    ///< must be zero.   Note: The access attributes of this field are as follows:
    ///< - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else
    ///< R(sticky)
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t LCL_L0P_EXIT_LTNCY : 3;
    ///< This is a data link parameter.  This field indicates this Port's knowledge
    ///< of L0p Exit Latency. The value reported is the larger of Port L0p
    ///< Exit Latency and Retimer L0p Exit Latency. The actual time required
    ///< to widen the Link is the larger of Local L0p Exit Latency and Remote
    ///< L0p Exit Latency. The Downstream Port's Retimer L0p Exit Latency should
    ///< include retimers that are part of the system. The Upstream Port's
    ///< Retimer L0p Exit Latency should include retimers that are part of
    ///< the add-in card. Defined encodings are: This field is meaningful in
    ///< Flit Mode. In Non-Flit Mode, this field must be zero.   Note: The
    ///< access attributes of this field are as follows:  - Wire: DEVICE_CAPABILITIES_REG.PCIE_CAP_FLIT_MODE_SUPP
    ///< ? RO : RO    - Dbi: DEVICE_CAPABILITIES_REG.PCIE_CAP_FLIT_MODE_SUPP
    ///< ? DBI_WRITABLE : RO
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t FUTURE_FEATURE_SUPPORTED : 15;
    ///< Local Future Data Link Feature Supported.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t DL_FEATURE_EXCHANGE_EN : 1;
    ///< Data Link Feature Exchange Enable. If Set, this bit indicates that
    ///< this Port will enter the DL_Feature negotiation state.   Note: The
    ///< access attributes of this field are as follows:  - Wire: HWINIT
    ///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< AccessType="RO" BitOffset="31" ResetValue="0x1"
  } ;
  uint32_t value;
} pcie_ctl_dlink_cap_data_link_feature_cap_off_reg_t;

#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_DEFAULT (0x80000001U)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_RD_MASK (0x807fffffU)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_WR_MASK (0x00000000U)


///< Local Scaled Flow Control Supported.   This bit indicates that this
///< Port supports Scaled Flow Control Feature   Note: The access attributes
///< of this field are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_SCALED_FLOW_CNTL_SUPPORTED_BF_OFF ( 0)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_SCALED_FLOW_CNTL_SUPPORTED_BF_WID ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_SCALED_FLOW_CNTL_SUPPORTED_BF_MSK (0x00000001)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_SCALED_FLOW_CNTL_SUPPORTED_BF_DEF (0x00000001)

///< Local Immediate Readiness.   This Bit indicates that all non-virtual
///< functions in this port hace immediate readiness set.  This bit MUST@FLIT
///< be meaningful. in non-Flit mode, this bit is meaningful when set,
///< but when clear indicates either some non-virtual function has immediate
///< readiness clear or that this port is not providing this information.
///< Note: The access attributes of this field are as follows:  - Wire:
///< HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_IMMEDIATE_READINESS_BF_OFF ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_IMMEDIATE_READINESS_BF_WID ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_IMMEDIATE_READINESS_BF_MSK (0x00000002)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_IMMEDIATE_READINESS_BF_DEF (0x00000000)

///< Local Extended VC Count.   This field indicates the number of VC resources
///< supported by this port. This is tte value of the extended VC count
///< field in either the multi-function virtual channel extended capability
///< or the virtual channel extended capability (With capability ID 0002h).
///< This field is meaningful in Flit Mode. In Non-Flit Mode, this field
///< must be zero.   Note: The access attributes of this field are as follows:
///< - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else
///< R(sticky)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_EXTENDED_VC_CNT_BF_OFF ( 2)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_EXTENDED_VC_CNT_BF_WID ( 3)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_EXTENDED_VC_CNT_BF_MSK (0x0000001C)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_EXTENDED_VC_CNT_BF_DEF (0x00000000)

///< This is a data link parameter.  This field indicates this Port's knowledge
///< of L0p Exit Latency. The value reported is the larger of Port L0p
///< Exit Latency and Retimer L0p Exit Latency. The actual time required
///< to widen the Link is the larger of Local L0p Exit Latency and Remote
///< L0p Exit Latency. The Downstream Port's Retimer L0p Exit Latency should
///< include retimers that are part of the system. The Upstream Port's
///< Retimer L0p Exit Latency should include retimers that are part of
///< the add-in card. Defined encodings are: This field is meaningful in
///< Flit Mode. In Non-Flit Mode, this field must be zero.   Note: The
///< access attributes of this field are as follows:  - Wire: DEVICE_CAPABILITIES_REG.PCIE_CAP_FLIT_MODE_SUPP
///< ? RO : RO    - Dbi: DEVICE_CAPABILITIES_REG.PCIE_CAP_FLIT_MODE_SUPP
///< ? DBI_WRITABLE : RO
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_L0P_EXIT_LTNCY_BF_OFF ( 5)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_L0P_EXIT_LTNCY_BF_WID ( 3)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_L0P_EXIT_LTNCY_BF_MSK (0x000000E0)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_LCL_L0P_EXIT_LTNCY_BF_DEF (0x00000000)

///< Local Future Data Link Feature Supported.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W(sticky) else R(sticky)  Note: This register field is
///< sticky.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_FUTURE_FEATURE_SUPPORTED_BF_OFF ( 8)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_FUTURE_FEATURE_SUPPORTED_BF_WID (15)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_FUTURE_FEATURE_SUPPORTED_BF_MSK (0x007FFF00)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_FUTURE_FEATURE_SUPPORTED_BF_DEF (0x00000000)

///< Data Link Feature Exchange Enable. If Set, this bit indicates that
///< this Port will enter the DL_Feature negotiation state.   Note: The
///< access attributes of this field are as follows:  - Wire: HWINIT
///< - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_DL_FEATURE_EXCHANGE_EN_BF_OFF (31)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_DL_FEATURE_EXCHANGE_EN_BF_WID ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_DL_FEATURE_EXCHANGE_EN_BF_MSK (0x80000000)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_DL_FEATURE_EXCHANGE_EN_BF_DEF (0x80000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_DLINK_CAP_DATA_LINK_FEATURE_STATUS_OFF register description at address offset 0x2b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_DLINK_CAP/DATA_LINK_FEATURE_STATUS_OFF
  * Data Link Feature Status Register.
  */

typedef union {
  struct {
    uint32_t REMOTE_SCALED_FLOW_CNTL_SUPPORTED : 1;
    ///< Remote Scaled Flow Control Supported.  This bit indicates that the
    ///< Remote Port supports the Scaled Flow Control Feature.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t REMOTE_IMMEDIATE_READINESS : 1;
    ///< Remote Immediate Readiness.  This bit indicates that all non-virtual
    ///< functions in the remote port have Immediate Readiness Set.  In Flit
    ///< Mode, This bit is always meaningful. In Non-Flit Mode, This bit is
    ///< meaningful when set, But when clear indicates either that some non-virtual
    ///< function has Immediate Readiness clear or that the remote port is
    ///< not providing this information.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t REMOTE_EXTENDED_VC_CNT : 3;
    ///< Extended VC count.  This field indicates the number of the VC resources
    ///< supported by the sending port. This is the value of the extended VC
    ///< count field in either the Multi-Function Virtual Channel extended
    ///< capability or the virtual channel extended capability (with capabality
    ///< ID 0002h).  This field is meaningful in Flit Mode. In non-flit mode,
    ///< This field must be zero.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t REMOTE_L0P_EXIT_LTNCY : 3;
    ///< Remote L0p Exit Latency. Data Link Parameter This field indicates
    ///< the remote Port's L0p Exit Latency. The value reported indicates the
    ///< length of time the remote Port requires to complete widening a link
    ///< using L0p. If the remote Port does not support L0p, this field must
    ///< contain 000b. Defined encodings are:
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t REMOTE_RESERVED : 15;
    ///< Remote Data Link RSVDP [22:8].
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t DATA_LINK_FEATURE_STATUS_VALID : 1;
    ///< Remote Data Link Feature Supported Valid. This field indicates that
    ///< the Port has received a Data Link Feature DLLP in state DL_Feature
    ///< and that the Remote Data Link Feature Supported and Remote Data Link
    ///< Feature Ack fields are meaningful. This field is Cleared on entry
    ///< to state DL_Inactive.
    ///< AccessType="RO/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_dlink_cap_data_link_feature_stat_off_reg_t;

#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_RD_MASK (0x807fffffU)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_WR_MASK (0x00000000U)


///< Remote Scaled Flow Control Supported.  This bit indicates that the
///< Remote Port supports the Scaled Flow Control Feature.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_SCALED_FLOW_CNTL_SUPPORTED_BF_OFF ( 0)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_SCALED_FLOW_CNTL_SUPPORTED_BF_WID ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_SCALED_FLOW_CNTL_SUPPORTED_BF_MSK (0x00000001)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_SCALED_FLOW_CNTL_SUPPORTED_BF_DEF (0x00000000)

///< Remote Immediate Readiness.  This bit indicates that all non-virtual
///< functions in the remote port have Immediate Readiness Set.  In Flit
///< Mode, This bit is always meaningful. In Non-Flit Mode, This bit is
///< meaningful when set, But when clear indicates either that some non-virtual
///< function has Immediate Readiness clear or that the remote port is
///< not providing this information.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_IMMEDIATE_READINESS_BF_OFF ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_IMMEDIATE_READINESS_BF_WID ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_IMMEDIATE_READINESS_BF_MSK (0x00000002)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_IMMEDIATE_READINESS_BF_DEF (0x00000000)

///< Extended VC count.  This field indicates the number of the VC resources
///< supported by the sending port. This is the value of the extended VC
///< count field in either the Multi-Function Virtual Channel extended
///< capability or the virtual channel extended capability (with capabality
///< ID 0002h).  This field is meaningful in Flit Mode. In non-flit mode,
///< This field must be zero.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_EXTENDED_VC_CNT_BF_OFF ( 2)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_EXTENDED_VC_CNT_BF_WID ( 3)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_EXTENDED_VC_CNT_BF_MSK (0x0000001C)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_EXTENDED_VC_CNT_BF_DEF (0x00000000)

///< Remote L0p Exit Latency. Data Link Parameter This field indicates
///< the remote Port's L0p Exit Latency. The value reported indicates the
///< length of time the remote Port requires to complete widening a link
///< using L0p. If the remote Port does not support L0p, this field must
///< contain 000b. Defined encodings are:
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_L0P_EXIT_LTNCY_BF_OFF ( 5)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_L0P_EXIT_LTNCY_BF_WID ( 3)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_L0P_EXIT_LTNCY_BF_MSK (0x000000E0)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_L0P_EXIT_LTNCY_BF_DEF (0x00000000)

///< Remote Data Link RSVDP [22:8].
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_RESERVED_BF_OFF ( 8)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_RESERVED_BF_WID (15)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_RESERVED_BF_MSK (0x007FFF00)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REMOTE_RESERVED_BF_DEF (0x00000000)

///< Remote Data Link Feature Supported Valid. This field indicates that
///< the Port has received a Data Link Feature DLLP in state DL_Feature
///< and that the Remote Data Link Feature Supported and Remote Data Link
///< Feature Ack fields are meaningful. This field is Cleared on entry
///< to state DL_Inactive.
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_DATA_LINK_FEATURE_STAT_VALID_BF_OFF (31)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_DATA_LINK_FEATURE_STAT_VALID_BF_WID ( 1)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_DATA_LINK_FEATURE_STAT_VALID_BF_MSK (0x80000000)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_DATA_LINK_FEATURE_STAT_VALID_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF register description at address offset 0x2bc
  *
  * Register default value:        0x2D41000B
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_VSECDMA_CAP/VSECDMA_EXT_CAP_HDR_OFF
  * PCIe Extended Capability ID, Capability Version, and Next Capability Offset Register.
  */

typedef union {
  struct {
    uint32_t ID : 16;
    ///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
    ///< ID number that indicates the nature and format of the Extended Capability.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xB"
    uint32_t CAP : 4;
    ///< Capability Version. This field is a PCI-SIG defined version number
    ///< that indicates the version of the Capability structure present. A
    ///< version of the specification that changes the Extended Capability
    ///< in a way that is not otherwise identifiable (that is, through a new
    ///< Capability field) is permitted to increment this field. All such changes
    ///< to the Capability structure must be software-compatible. Software
    ///< must check for Capability Version numbers that are greater than or
    ///< equal to the highest number defined when the software is written,
    ///< as Functions reporting any such Capability Version numbers will contain
    ///< a Capability structure that is compatible with that piece of software.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint32_t NEXT_OFFSET : 12;
    ///< Next Capability Offset. This field contains the offset to the next
    ///< PCI Express Capability structure or 000h if no other items exist in
    ///< the linked list of Capabilities. For Extended Capabilities implemented
    ///< in Configuration Space, this offset is relative to the beginning of
    ///< PCI-compatible Configuration Space and thus must always be either
    ///< 000h (for terminating list of Capabilities) or greater than 0FFh.
    ///< The bottom 2 bits of this offset are Reserved and must be implemented
    ///< as 00b although software must mask them to allow for future uses of
    ///< these bits.   Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
    ///< else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x2D4"
  } ;
  uint32_t value;
} pcie_ctl_vsecdma_cap_vsecdma_ext_cap_hdr_off_reg_t;

#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_DEFAULT (0x2d41000bU)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_WR_MASK (0x00000000U)


///< PCI Express Extended Capability ID. This field is a PCI-SIG defined
///< ID number that indicates the nature and format of the Extended Capability.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_ID_BF_OFF ( 0)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_ID_BF_WID (16)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_ID_BF_DEF (0x0000000B)

///< Capability Version. This field is a PCI-SIG defined version number
///< that indicates the version of the Capability structure present. A
///< version of the specification that changes the Extended Capability
///< in a way that is not otherwise identifiable (that is, through a new
///< Capability field) is permitted to increment this field. All such changes
///< to the Capability structure must be software-compatible. Software
///< must check for Capability Version numbers that are greater than or
///< equal to the highest number defined when the software is written,
///< as Functions reporting any such Capability Version numbers will contain
///< a Capability structure that is compatible with that piece of software.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky) else R(sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_CAP_BF_OFF (16)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_CAP_BF_WID ( 4)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_CAP_BF_MSK (0x000F0000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_CAP_BF_DEF (0x00010000)

///< Next Capability Offset. This field contains the offset to the next
///< PCI Express Capability structure or 000h if no other items exist in
///< the linked list of Capabilities. For Extended Capabilities implemented
///< in Configuration Space, this offset is relative to the beginning of
///< PCI-compatible Configuration Space and thus must always be either
///< 000h (for terminating list of Capabilities) or greater than 0FFh.
///< The bottom 2 bits of this offset are Reserved and must be implemented
///< as 00b although software must mask them to allow for future uses of
///< these bits.   Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W(sticky)
///< else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_OFF (20)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_WID (12)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_MSK (0xFFF00000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_BF_DEF (0x2D400000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF register description at address offset 0x2c0
  *
  * Register default value:        0x01800006
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_VSECDMA_CAP/VSECDMA_VENDOR_SPECIFIC_HDR_OFF
  * Vendor Specific Header Register.
  */

typedef union {
  struct {
    uint32_t VSEC_ID : 16;
    ///< VSEC ID. This field is a vendor-defined ID number that indicates the
    ///< nature and format of the VSEC structure. Software must qualify the
    ///< Vendor ID before interpreting this field.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x6"
    uint32_t VSEC_REV : 4;
    ///< VSEC Rev. This field is a vendor-defined version number that indicates
    ///< the version of the VSEC structure. Software must qualify the Vendor
    ///< ID and VSEC ID before interpreting this field.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t VSEC_LENGTH : 12;
    ///< VSEC Length. This field indicates the number of bytes in the entire
    ///< VSEC structure, including the Vendor-Specific Extended Capability
    ///< Header, the Vendor-Specific Header, and the vendor-specific registers.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x18"
  } ;
  uint32_t value;
} pcie_ctl_vsecdma_cap_vsecdma_vendor_specific_hdr_off_reg_t;

#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_DEFAULT (0x01800006U)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_WR_MASK (0x00000000U)


///< VSEC ID. This field is a vendor-defined ID number that indicates the
///< nature and format of the VSEC structure. Software must qualify the
///< Vendor ID before interpreting this field.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_BF_OFF ( 0)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_BF_WID (16)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_BF_DEF (0x00000006)

///< VSEC Rev. This field is a vendor-defined version number that indicates
///< the version of the VSEC structure. Software must qualify the Vendor
///< ID and VSEC ID before interpreting this field.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_BF_OFF (16)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_BF_WID ( 4)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_BF_MSK (0x000F0000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_BF_DEF (0x00000000)

///< VSEC Length. This field indicates the number of bytes in the entire
///< VSEC structure, including the Vendor-Specific Extended Capability
///< Header, the Vendor-Specific Header, and the vendor-specific registers.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_BF_OFF (20)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_BF_WID (12)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_BF_MSK (0xFFF00000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_BF_DEF (0x01800000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF register description at address offset 0x2c4
  *
  * Register default value:        0x35A80407
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_VSECDMA_CAP/VSECDMA_DEVICE_INFORMATION_OFF
  * DMA and related AXI Bridge Implementation Information.
  */

typedef union {
  struct {
    uint32_t MAP_FORMAT : 3;
    ///< Defines the register map format and features to be one of the following
    ///< values: Other values are reserved.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x7"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
    uint32_t BARN : 3;
    ///< Bar Number. This field provides information regarding the DMA register
    ///< and BAR number mapping.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x4"
    uint32_t PFN : 5;
    ///< Physical Function Number. This field provides information regarding
    ///< the DMA register and physical function mapping.
    ///< AccessType="RO" BitOffset="11" ResetValue="0x0"
    uint32_t CHANNEL_SEPARATION : 3;
    ///< If the MAP_FORMAT is set to HDMA_NATIVE, this field specifies the
    ///< read write channel address separation. Other values are reserved.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t AXI : 1;
    ///< This field provides information about AXI interface usage. It reports
    ///< the value of AXI_POPULATED configuration parameter.
    ///< AccessType="RO" BitOffset="19" ResetValue="0x1"
    uint32_t MASTER_BUS_WIDTH : 3;
    ///< This field provides information regarding the AXI manager data bus
    ///< width. It reports the value of MASTER_BUS_DATA_WIDTH configuration
    ///< parameter.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x2"
    uint32_t MASTER_BURST_LENGTH : 3;
    ///< Reports the CC_MSTR_BURST_LEN configuration parameter.
    ///< AccessType="RO" BitOffset="23" ResetValue="0x3"
    uint32_t MASTER_PAGE_BOUNDARY_POINTER_WIDTH : 4;
    ///< This field provides address page boundary information. It reports
    ///< the value of CC_MSTR_PAGE_BOUNDARY_PW configuration parameter.
    ///< AccessType="RO" BitOffset="26" ResetValue="0xD"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_vsecdma_cap_vsecdma_device_information_off_reg_t;

#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_DEFAULT (0x35a80407U)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_RD_MASK (0x3fffff07U)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_WR_MASK (0x00000000U)


///< Defines the register map format and features to be one of the following
///< values: Other values are reserved.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_FORMAT_BF_OFF ( 0)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_FORMAT_BF_WID ( 3)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_FORMAT_BF_MSK (0x00000007)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_FORMAT_BF_DEF (0x00000007)

///< Bar Number. This field provides information regarding the DMA register
///< and BAR number mapping.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_BF_OFF ( 8)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_BF_WID ( 3)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_BF_MSK (0x00000700)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_BF_DEF (0x00000400)

///< Physical Function Number. This field provides information regarding
///< the DMA register and physical function mapping.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_BF_OFF (11)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_BF_WID ( 5)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_BF_MSK (0x0000F800)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_BF_DEF (0x00000000)

///< If the MAP_FORMAT is set to HDMA_NATIVE, this field specifies the
///< read write channel address separation. Other values are reserved.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_CH_SEPARATION_BF_OFF (16)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_CH_SEPARATION_BF_WID ( 3)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_CH_SEPARATION_BF_MSK (0x00070000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_CH_SEPARATION_BF_DEF (0x00000000)

///< This field provides information about AXI interface usage. It reports
///< the value of AXI_POPULATED configuration parameter.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_AXI_BF_OFF (19)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_AXI_BF_WID ( 1)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_AXI_BF_MSK (0x00080000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_AXI_BF_DEF (0x00080000)

///< This field provides information regarding the AXI manager data bus
///< width. It reports the value of MASTER_BUS_DATA_WIDTH configuration
///< parameter.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_BF_OFF (20)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_BF_WID ( 3)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_BF_MSK (0x00700000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_BF_DEF (0x00200000)

///< Reports the CC_MSTR_BURST_LEN configuration parameter.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_BF_OFF (23)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_BF_WID ( 3)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_BF_MSK (0x03800000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_BF_DEF (0x01800000)

///< This field provides address page boundary information. It reports
///< the value of CC_MSTR_PAGE_BOUNDARY_PW configuration parameter.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_PTR_WIDTH_BF_OFF (26)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_PTR_WIDTH_BF_WID ( 4)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_PTR_WIDTH_BF_MSK (0x3C000000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_PTR_WIDTH_BF_DEF (0x34000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF register description at address offset 0x2c8
  *
  * Register default value:        0x00020002
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_VSECDMA_CAP/VSECDMA_NUM_CHAN_OFF
  * Number of Implemented Channels Register.
  */

typedef union {
  struct {
    uint32_t NUM_DMA_WR_CHAN : 10;
    ///< This field provides information regarding the number of implemented
    ///< write channels. It reports the value of CC_NUM_DMA_WR_CHAN parameter.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x2"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t NUM_DMA_RD_CHAN : 10;
    ///< This field provides information regarding the number of implemented
    ///< read channels. It reports the value of CC_NUM_DMA_RD_CHAN parameter.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x2"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_vsecdma_cap_vsecdma_num_chan_off_reg_t;

#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_DEFAULT (0x00020002U)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_RD_MASK (0x03ff03ffU)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_WR_MASK (0x00000000U)


///< This field provides information regarding the number of implemented
///< write channels. It reports the value of CC_NUM_DMA_WR_CHAN parameter.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_BF_OFF ( 0)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_BF_WID (10)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_BF_MSK (0x000003FF)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_BF_DEF (0x00000002)

///< This field provides information regarding the number of implemented
///< read channels. It reports the value of CC_NUM_DMA_RD_CHAN parameter.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_BF_OFF (16)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_BF_WID (10)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_BF_MSK (0x03FF0000)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_BF_DEF (0x00020000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF register description at address offset 0x2cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_VSECDMA_CAP/VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF
  * DMA Register Map Start Address Offset Low Register.
  */

typedef union {
  struct {
    uint32_t UNROLL_ADDR_OFFSET_LOW : 32;
    ///< BAR address offset, 32-bit LSB.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_vsecdma_cap_vsecdma_unroll_addr_offset_low_off_reg_t;

#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_WR_MASK (0x00000000U)


///< BAR address offset, 32-bit LSB.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_BF_OFF ( 0)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_BF_WID (32)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF register description at address offset 0x2d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_VSECDMA_CAP/VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF
  * DMA Register Map Start Address Offset High Register.
  */

typedef union {
  struct {
    uint32_t UNROLL_ADDR_OFFSET_HIGH : 32;
    ///< BAR address offset, 32-bit MSB.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_vsecdma_cap_vsecdma_unroll_addr_offset_high_off_reg_t;

#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_WR_MASK (0x00000000U)


///< BAR address offset, 32-bit MSB.
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_BF_OFF ( 0)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_BF_WID (32)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_ACK_LATENCY_TIMER_OFF register description at address offset 0x700
  *
  * Register default value:        0x06110205
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/ACK_LATENCY_TIMER_OFF
  * Ack Latency Timer and Replay Timer Register.
  */

typedef union {
  struct {
    uint32_t ROUND_TRIP_LATENCY_TIME_LIMIT : 16;
    ///< Ack Latency Timer Limit. The Ack latency timer expires when it reaches
    ///< this limit. For more information, see  ACK/NAK Scheduling  in the
    ///< Databook.  - You can modify the effective timer limit through the
    ///< TIMER_MOD_ACK_NAK field of the TIMER_CTRL_MAX_FUNC_NUM_OFF register.
    ///< - After reset, the controller updates the default according to the
    ///< Negotiated Link Width, Max_Payload_Size, and speed. The value is determined
    ///< from Tables 3-7, 3-8, and 3-9 of the PCI Express Base Specification.
    ///< - The limit must reflect the round trip latency from requester to
    ///< completer.  - If there is a change in the payload size or link width,
    ///< the controller overrides any value that you have written to this register
    ///< field, and resets the field back to the specification-defined value.
    ///< The controller does not change the value in the TIMER_MOD_ACK_NAK
    ///< field of the TIMER_CTRL_MAX_FUNC_NUM_OFF register.   TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x205"
    uint32_t REPLAY_TIME_LIMIT : 16;
    ///< Replay Timer Limit. The replay timer expires when it reaches this
    ///< limit. The controller initiates a replay upon reception of a NAK or
    ///< when the replay timer expires. For more information, see  Transmit
    ///< Replay  in the Databook.  - You can modify the effective timer limit
    ///< through the TIMER_MOD_REPLAY_TIMER field of the TIMER_CTRL_MAX_FUNC_NUM_OFF
    ///< register.  - After reset, the controller updates the default according
    ///< to the Negotiated Link Width, Max_Payload_Size, and speed. The value
    ///< is determined from Tables 3-4, 3-5, and 3-6 of the PCI Express Base
    ///< Specification.  - If there is a change in the payload size or link
    ///< speed, the controller overrides any value that you have written to
    ///< this register field, and resets the field back to the specification-defined
    ///< value. The controller does not change the value in the TIMER_MOD_REPLAY_TIMER
    ///< field of the TIMER_CTRL_MAX_FUNC_NUM_OFF register.   TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="16" ResetValue="0x611"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_ack_latency_timer_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_DEFAULT (0x06110205U)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_WR_MASK (0xffffffffU)


///< Ack Latency Timer Limit. The Ack latency timer expires when it reaches
///< this limit. For more information, see  ACK/NAK Scheduling  in the
///< Databook.  - You can modify the effective timer limit through the
///< TIMER_MOD_ACK_NAK field of the TIMER_CTRL_MAX_FUNC_NUM_OFF register.
///< - After reset, the controller updates the default according to the
///< Negotiated Link Width, Max_Payload_Size, and speed. The value is determined
///< from Tables 3-7, 3-8, and 3-9 of the PCI Express Base Specification.
///< - The limit must reflect the round trip latency from requester to
///< completer.  - If there is a change in the payload size or link width,
///< the controller overrides any value that you have written to this register
///< field, and resets the field back to the specification-defined value.
///< The controller does not change the value in the TIMER_MOD_ACK_NAK
///< field of the TIMER_CTRL_MAX_FUNC_NUM_OFF register.   TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_BF_MSK (0x0000FFFF)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_BF_DEF (0x00000205)

///< Replay Timer Limit. The replay timer expires when it reaches this
///< limit. The controller initiates a replay upon reception of a NAK or
///< when the replay timer expires. For more information, see  Transmit
///< Replay  in the Databook.  - You can modify the effective timer limit
///< through the TIMER_MOD_REPLAY_TIMER field of the TIMER_CTRL_MAX_FUNC_NUM_OFF
///< register.  - After reset, the controller updates the default according
///< to the Negotiated Link Width, Max_Payload_Size, and speed. The value
///< is determined from Tables 3-4, 3-5, and 3-6 of the PCI Express Base
///< Specification.  - If there is a change in the payload size or link
///< speed, the controller overrides any value that you have written to
///< this register field, and resets the field back to the specification-defined
///< value. The controller does not change the value in the TIMER_MOD_REPLAY_TIMER
///< field of the TIMER_CTRL_MAX_FUNC_NUM_OFF register.   TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_BF_MSK (0xFFFF0000)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_BF_DEF (0x06110000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF register description at address offset 0x704
  *
  * Register default value:        0xFFFFFFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/VENDOR_SPEC_DLLP_OFF
  * Vendor Specific DLLP Register.
  */

typedef union {
  struct {
    uint32_t VENDOR_SPEC_DLLP : 32;
    ///< Vendor Specific DLLP Register. You can use this register to send a
    ///< specific PCI Express DLLP. Your application can write 8-bit DLLP Type
    ///< and 24-bit Payload data into this register, and set the VENDOR_SPECIFIC_DLLP_REQ
    ///< field of the PORT_LINK_CTRL_OFF, to send the DLLP.  - Bits[7:0]: DLLP
    ///< Type  - Bits[31:8]: Vendor Defined Payload (24 bits)   Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFFFFFFFF"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_vendor_spec_dllp_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_DEFAULT (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_WR_MASK (0xffffffffU)


///< Vendor Specific DLLP Register. You can use this register to send a
///< specific PCI Express DLLP. Your application can write 8-bit DLLP Type
///< and 24-bit Payload data into this register, and set the VENDOR_SPECIFIC_DLLP_REQ
///< field of the PORT_LINK_CTRL_OFF, to send the DLLP.  - Bits[7:0]: DLLP
///< Type  - Bits[31:8]: Vendor Defined Payload (24 bits)   Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_BF_DEF (0xFFFFFFFF)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PORT_FORCE_OFF register description at address offset 0x708
  *
  * Register default value:        0x00800004
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PORT_FORCE_OFF
  * Port Force Link Register.
  */

typedef union {
  struct {
    uint32_t LINK_NUM : 8;
    ///< Link Number. Not used for endpoint.   Note: This register field is
    ///< sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x4"
    uint32_t FORCED_LTSSM : 4;
    ///< Forced Link Command. The link command that the controller is forced
    ///< to transmit when you set FORCE_EN bit (Force Link). Link command encoding
    ///< is defined by the ltssm_cmd variable in workspace/src/Layer1/smlh_ltssm.v.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t FORCE_EN : 1;
    ///< Force Link. The controller supports a testing and debug capability
    ///< to allow your software to force the LTSSM state machine into a specific
    ///< state, and to force the controller to transmit a specific Link Command.
    ///< Asserting this bit triggers the following actions:  - Forces the LTSSM
    ///< to the state specified by the Forced LTSSM State field.  - Forces
    ///< the controller to transmit the command specified by the Forced Link
    ///< Command field. This is a self-clearing register field. Reading from
    ///< this register field always returns a '0'.
    ///< AccessType="WS/V" BitOffset="15" ResetValue="0x0"
    uint32_t LINK_STATE : 6;
    ///< Forced LTSSM State. The LTSSM state that the controller is forced
    ///< to when you set the FORCE_EN bit (Force Link). LTSSM state encoding
    ///< is defined by the lts_state variable in workspace/src/Layer1/smlh_ltssm.v.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t SUPPORT_PART_LANES_RXEI_EXIT : 1;
    ///< Support LTSSM transition from Polling.Active to Polling.Config based
    ///< on Rx 8 TSs on any lanes which are Rx EI exit too from base spec after
    ///< 24ms timeout. This prevents some lanes detected but not Rx EI exit
    ///< and LTSSM cannot move to Polling.Config. You must set the parameter
    ///< CX_AUTO_LANE_FLIP_CTRL_EN true for the auto lanes reversal.   Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DO_DESKEW_FOR_SRIS : 1;
    ///< Use the transitions from TS2 to Logical Idle Symbol, SKP OS to Logical
    ///< Idle Symbol, EIEOS to Logical Idle Symbol, and FTS Sequence to SKP
    ///< OS to do deskew instead of using received SKP OS or TS1 to TS2 transition
    ///< if DO_DESKEW_FOR_SRIS is set to '1'. Always set to '1' for flit mode
    ///< enabled.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_port_force_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_DEFAULT (0x00800004U)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_RD_MASK (0x00ff0fffU)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_WR_MASK (0x00ff8fffU)


///< Link Number. Not used for endpoint.   Note: This register field is
///< sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_NUM_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_NUM_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_NUM_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_NUM_BF_DEF (0x00000004)

///< Forced Link Command. The link command that the controller is forced
///< to transmit when you set FORCE_EN bit (Force Link). Link command encoding
///< is defined by the ltssm_cmd variable in workspace/src/Layer1/smlh_ltssm.v.
///< Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCED_LTSSM_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCED_LTSSM_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCED_LTSSM_BF_MSK (0x00000F00)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCED_LTSSM_BF_DEF (0x00000000)

///< Force Link. The controller supports a testing and debug capability
///< to allow your software to force the LTSSM state machine into a specific
///< state, and to force the controller to transmit a specific Link Command.
///< Asserting this bit triggers the following actions:  - Forces the LTSSM
///< to the state specified by the Forced LTSSM State field.  - Forces
///< the controller to transmit the command specified by the Forced Link
///< Command field. This is a self-clearing register field. Reading from
///< this register field always returns a '0'.
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCE_EN_BF_OFF (15)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCE_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCE_EN_BF_MSK (0x00008000)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_FORCE_EN_BF_DEF (0x00000000)

///< Forced LTSSM State. The LTSSM state that the controller is forced
///< to when you set the FORCE_EN bit (Force Link). LTSSM state encoding
///< is defined by the lts_state variable in workspace/src/Layer1/smlh_ltssm.v.
///< Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_STATE_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_STATE_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_STATE_BF_MSK (0x003F0000)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_LINK_STATE_BF_DEF (0x00000000)

///< Support LTSSM transition from Polling.Active to Polling.Config based
///< on Rx 8 TSs on any lanes which are Rx EI exit too from base spec after
///< 24ms timeout. This prevents some lanes detected but not Rx EI exit
///< and LTSSM cannot move to Polling.Config. You must set the parameter
///< CX_AUTO_LANE_FLIP_CTRL_EN true for the auto lanes reversal.   Note:
///< This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_SUPPORT_PART_LANES_RXEI_EXIT_BF_OFF (22)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_SUPPORT_PART_LANES_RXEI_EXIT_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_SUPPORT_PART_LANES_RXEI_EXIT_BF_MSK (0x00400000)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_SUPPORT_PART_LANES_RXEI_EXIT_BF_DEF (0x00000000)

///< Use the transitions from TS2 to Logical Idle Symbol, SKP OS to Logical
///< Idle Symbol, EIEOS to Logical Idle Symbol, and FTS Sequence to SKP
///< OS to do deskew instead of using received SKP OS or TS1 to TS2 transition
///< if DO_DESKEW_FOR_SRIS is set to '1'. Always set to '1' for flit mode
///< enabled.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_DO_DESKEW_FOR_SRIS_BF_OFF (23)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_DO_DESKEW_FOR_SRIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_DO_DESKEW_FOR_SRIS_BF_MSK (0x00800000)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_DO_DESKEW_FOR_SRIS_BF_DEF (0x00800000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF register description at address offset 0x70c
  *
  * Register default value:        0x9BFFFF00
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/ACK_F_ASPM_CTRL_OFF
  * Ack Frequency and L0-L1 ASPM Control Register.
  */

typedef union {
  struct {
    uint32_t ACK_FREQ : 8;
    ///< Ack Frequency. The controller accumulates the number of pending ACKs
    ///< specified here (up to 255) before scheduling an ACK DLLP.  - 0: Indicates
    ///< that this Ack Frequency Counter feature is turned off. The controller
    ///< generates a low-priority ACK request for every TLP that it receives.
    ///< The controller waits until the ACK Latency Timer expires, then converts
    ///< the current low-priority ACK request to a high-priority ACK request
    ///< and schedules the DLLP for transmission to the remote link partner.
    ///< - 1-255: Indicates that the controller will schedule a high-priority
    ///< ACK after receiving this number of TLPs. It might schedule the ACK
    ///< before receiving this number of TLPs if the ACK Latency Timer expires,
    ///< but never later. For a typical system, you do not have to modify the
    ///< default setting. For more information, see  ACK/NAK Scheduling  in
    ///< the Databook.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t ACK_N_FTS : 8;
    ///< The number of Fast Training Sequence(N_FTS) ordered sets to be transmitted
    ///< when transitioning from L0s to L0.   Note: This register field is
    ///< sticky.
    ///< AccessType="RW" BitOffset="8" ResetValue="0xFF"
    uint32_t COMMON_CLK_N_FTS : 8;
    ///< Common Clock N_FTS. This is the N_FTS when common clock is used. The
    ///< number of Fast Training Sequence(N_FTS) ordered sets to be transmitted
    ///< when transitioning from L0s to L0.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="16" ResetValue="0xFF"
    uint32_t L0S_ENTRANCE_LATENCY : 3;
    ///< L0s Entrance Latency.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x3"
    uint32_t L1_ENTRANCE_LATENCY : 3;
    ///< L1 Entrance Latency. Note: Programming this timer with a value greater
    ///< that 32us has no effect unless extended sync is used, or all of the
    ///< credits are infinite.  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x3"
    uint32_t ENTER_ASPM : 1;
    ///< ASPM L1 Entry Control.
    ///< AccessType="WS/V" BitOffset="30" ResetValue="0x0"
    uint32_t ASPM_L1_TIMER_ENABLE : 1;
    ///< ASPM L1 Timer Enable. This register controls the behaviour of the
    ///< controller ASPM L1 Entry Timer.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x1"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_ack_f_aspm_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_DEFAULT (0x9bffff00U)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_RD_MASK (0xbfffffffU)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_WR_MASK (0xffffffffU)


///< Ack Frequency. The controller accumulates the number of pending ACKs
///< specified here (up to 255) before scheduling an ACK DLLP.  - 0: Indicates
///< that this Ack Frequency Counter feature is turned off. The controller
///< generates a low-priority ACK request for every TLP that it receives.
///< The controller waits until the ACK Latency Timer expires, then converts
///< the current low-priority ACK request to a high-priority ACK request
///< and schedules the DLLP for transmission to the remote link partner.
///< - 1-255: Indicates that the controller will schedule a high-priority
///< ACK after receiving this number of TLPs. It might schedule the ACK
///< before receiving this number of TLPs if the ACK Latency Timer expires,
///< but never later. For a typical system, you do not have to modify the
///< default setting. For more information, see  ACK/NAK Scheduling  in
///< the Databook.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_BF_DEF (0x00000000)

///< The number of Fast Training Sequence(N_FTS) ordered sets to be transmitted
///< when transitioning from L0s to L0.   Note: This register field is
///< sticky.
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_BF_MSK (0x0000FF00)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_BF_DEF (0x0000FF00)

///< Common Clock N_FTS. This is the N_FTS when common clock is used. The
///< number of Fast Training Sequence(N_FTS) ordered sets to be transmitted
///< when transitioning from L0s to L0.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_CLK_N_FTS_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_CLK_N_FTS_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_CLK_N_FTS_BF_MSK (0x00FF0000)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_CLK_N_FTS_BF_DEF (0x00FF0000)

///< L0s Entrance Latency.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L0S_ENTRANCE_LATENCY_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L0S_ENTRANCE_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L0S_ENTRANCE_LATENCY_BF_MSK (0x07000000)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L0S_ENTRANCE_LATENCY_BF_DEF (0x03000000)

///< L1 Entrance Latency. Note: Programming this timer with a value greater
///< that 32us has no effect unless extended sync is used, or all of the
///< credits are infinite.  Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L1_ENTRANCE_LATENCY_BF_OFF (27)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L1_ENTRANCE_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L1_ENTRANCE_LATENCY_BF_MSK (0x38000000)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_L1_ENTRANCE_LATENCY_BF_DEF (0x18000000)

///< ASPM L1 Entry Control.
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ENTER_ASPM_BF_OFF (30)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ENTER_ASPM_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ENTER_ASPM_BF_MSK (0x40000000)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ENTER_ASPM_BF_DEF (0x00000000)

///< ASPM L1 Timer Enable. This register controls the behaviour of the
///< controller ASPM L1 Entry Timer.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ASPM_L1_TIMER_EN_BF_OFF (31)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ASPM_L1_TIMER_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ASPM_L1_TIMER_EN_BF_MSK (0x80000000)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ASPM_L1_TIMER_EN_BF_DEF (0x80000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PORT_LINK_CTRL_OFF register description at address offset 0x710
  *
  * Register default value:        0x00030120
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PORT_LINK_CTRL_OFF
  * Port Link Control Register.
  */

typedef union {
  struct {
    uint32_t VENDOR_SPECIFIC_DLLP_REQ : 1;
    ///< Vendor Specific DLLP Request.  Reading from this self-clearing register
    ///< field always returns a '0'.   TDISP Prot :WP
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t SCRAMBLE_DISABLE : 1;
    ///< Scramble Disable. Turns off data scrambling.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t LOOPBACK_ENABLE : 1;
    ///< Loopback Enable. Turns on loopback. For more information, see  Loopback
    ///< in the Databook.   Note: The access attributes of this field are as
    ///< follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t RESET_ASSERT : 1;
    ///< Reset Assert. Triggers a recovery and forces the LTSSM to the hot
    ///< reset state (downstream port only).   Note: This register field is
    ///< sticky.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
    uint32_t DLL_LINK_EN : 1;
    ///< DLL Link Enable.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint32_t LINK_DISABLE : 1;
    ///< LINK_DISABLE is an internally reserved field. Do not use.  Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t FAST_LINK_MODE : 1;
    ///< Fast Link Mode. Sets all internal LTSSM millisecond timers to Fast
    ///< Mode for speeding up simulation. Forces the LTSSM training (link initialization)
    ///< to use shorter time-outs and to link up faster.  - The default scaling
    ///< factor can be changed using the DEFAULT_FAST_LINK_SCALING_FACTOR parameter
    ///< or through the FAST_LINK_SCALING_FACTOR field in the TIMER_CTRL_MAX_FUNC_NUM_OFF
    ///< register.  - Fast Link Mode can also be activated by setting the diag_ctrl_bus[2]
    ///< pin to '1'. For more information, see the  Fast Link Simulation Mode
    ///< section in the  Integrating the Controller with the PHY or Application
    ///< RTL or Verification IP  chapter of the User Guide.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t LINK_RATE : 4;
    ///< LINK_RATE is an internally reserved field. Do not use.  Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t LINK_CAPABLE : 6;
    ///< Link Mode Enable. Sets the number of lanes in the link that you want
    ///< to connect to the link partner. When you have unused lanes in your
    ///< system, then you must change the value in this register to reflect
    ///< the number of lanes. You must also change the value in the  Predetermined
    ///< Number of Lanes  field of the  Link Width and Speed Change Control
    ///< Register . For more information, see  How to Tie Off Unused Lanes
    ///< . For information on upsizing and downsizing the link width, see
    ///< Link Establishment .   Note: The access attributes of this field are
    ///< as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x3"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t BEACON_ENABLE : 1;
    ///< BEACON_ENABLE is an internally reserved field. Do not use.  Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t CORRUPT_LCRC_ENABLE : 1;
    ///< CORRUPT_LCRC_ENABLE is an internally reserved field. Do not use.
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t EXTENDED_SYNCH : 1;
    ///< EXTENDED_SYNCH is an internally reserved field. Do not use.  Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t TRANSMIT_LANE_REVERSALE_ENABLE : 1;
    ///< TRANSMIT_LANE_REVERSALE_ENABLE is an internally reserved field. Do
    ///< not use.  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_port_link_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_DEFAULT (0x00030120U)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_RD_MASK (0x0f3f0fefU)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_WR_MASK (0x0f3f0fefU)


///< Vendor Specific DLLP Request.  Reading from this self-clearing register
///< field always returns a '0'.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_VENDOR_SPECIFIC_DLLP_REQ_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_VENDOR_SPECIFIC_DLLP_REQ_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_VENDOR_SPECIFIC_DLLP_REQ_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_VENDOR_SPECIFIC_DLLP_REQ_BF_DEF (0x00000000)

///< Scramble Disable. Turns off data scrambling.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_SCRAMBLE_DIS_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_SCRAMBLE_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_SCRAMBLE_DIS_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_SCRAMBLE_DIS_BF_DEF (0x00000000)

///< Loopback Enable. Turns on loopback. For more information, see  Loopback
///< in the Databook.   Note: The access attributes of this field are as
///< follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LOOPBACK_EN_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LOOPBACK_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LOOPBACK_EN_BF_MSK (0x00000004)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LOOPBACK_EN_BF_DEF (0x00000000)

///< Reset Assert. Triggers a recovery and forces the LTSSM to the hot
///< reset state (downstream port only).   Note: This register field is
///< sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_RST_ASSERT_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_RST_ASSERT_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_RST_ASSERT_BF_MSK (0x00000008)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_RST_ASSERT_BF_DEF (0x00000000)

///< DLL Link Enable.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_DLL_LINK_EN_BF_OFF ( 5)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_DLL_LINK_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_DLL_LINK_EN_BF_MSK (0x00000020)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_DLL_LINK_EN_BF_DEF (0x00000020)

///< LINK_DISABLE is an internally reserved field. Do not use.  Note: This
///< register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_DIS_BF_OFF ( 6)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_DIS_BF_MSK (0x00000040)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_DIS_BF_DEF (0x00000000)

///< Fast Link Mode. Sets all internal LTSSM millisecond timers to Fast
///< Mode for speeding up simulation. Forces the LTSSM training (link initialization)
///< to use shorter time-outs and to link up faster.  - The default scaling
///< factor can be changed using the DEFAULT_FAST_LINK_SCALING_FACTOR parameter
///< or through the FAST_LINK_SCALING_FACTOR field in the TIMER_CTRL_MAX_FUNC_NUM_OFF
///< register.  - Fast Link Mode can also be activated by setting the diag_ctrl_bus[2]
///< pin to '1'. For more information, see the  Fast Link Simulation Mode
///< section in the  Integrating the Controller with the PHY or Application
///< RTL or Verification IP  chapter of the User Guide.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_FAST_LINK_MODE_BF_OFF ( 7)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_FAST_LINK_MODE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_FAST_LINK_MODE_BF_MSK (0x00000080)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_FAST_LINK_MODE_BF_DEF (0x00000000)

///< LINK_RATE is an internally reserved field. Do not use.  Note: This
///< register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_RATE_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_RATE_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_RATE_BF_MSK (0x00000F00)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_RATE_BF_DEF (0x00000100)

///< Link Mode Enable. Sets the number of lanes in the link that you want
///< to connect to the link partner. When you have unused lanes in your
///< system, then you must change the value in this register to reflect
///< the number of lanes. You must also change the value in the  Predetermined
///< Number of Lanes  field of the  Link Width and Speed Change Control
///< Register . For more information, see  How to Tie Off Unused Lanes
///< . For information on upsizing and downsizing the link width, see
///< Link Establishment .   Note: The access attributes of this field are
///< as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_CAPABLE_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_CAPABLE_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_CAPABLE_BF_MSK (0x003F0000)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_LINK_CAPABLE_BF_DEF (0x00030000)

///< BEACON_ENABLE is an internally reserved field. Do not use.  Note:
///< This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_BEACON_EN_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_BEACON_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_BEACON_EN_BF_MSK (0x01000000)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_BEACON_EN_BF_DEF (0x00000000)

///< CORRUPT_LCRC_ENABLE is an internally reserved field. Do not use.
///< Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_CORRUPT_LCRC_EN_BF_OFF (25)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_CORRUPT_LCRC_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_CORRUPT_LCRC_EN_BF_MSK (0x02000000)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_CORRUPT_LCRC_EN_BF_DEF (0x00000000)

///< EXTENDED_SYNCH is an internally reserved field. Do not use.  Note:
///< This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_EXTENDED_SYNCH_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_EXTENDED_SYNCH_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_EXTENDED_SYNCH_BF_MSK (0x04000000)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_EXTENDED_SYNCH_BF_DEF (0x00000000)

///< TRANSMIT_LANE_REVERSALE_ENABLE is an internally reserved field. Do
///< not use.  Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_TRANSMIT_LANE_REVERSALE_EN_BF_OFF (27)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_TRANSMIT_LANE_REVERSALE_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_TRANSMIT_LANE_REVERSALE_EN_BF_MSK (0x08000000)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_TRANSMIT_LANE_REVERSALE_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_LANE_SKEW_OFF register description at address offset 0x714
  *
  * Register default value:        0x08000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/LANE_SKEW_OFF
  * Lane Skew Register.
  */

typedef union {
  struct {
    uint32_t INSERT_LANE_SKEW : 23;
    ///< INSERT_LANE_SKEW is an internally reserved field. Do not use.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DRIFT_BUFFER_DESKEW_ENABLE : 1;
    ///< DRIFT_BUFFER_DESKEW_ENABLE is an internally reserved field. Do not
    ///< use.  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t FLOW_CTRL_DISABLE : 1;
    ///< Flow Control Disable. Prevents the controller from sending FC DLLPs.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t ACK_NAK_DISABLE : 1;
    ///< Ack/Nak Disable. Prevents the controller from sending ACK and NAK
    ///< DLLPs.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t ELASTIC_BUFFER_MODE : 1;
    ///< Selects Elasticity Buffer operating mode:   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t IMPLEMENT_NUM_LANES : 4;
    ///< Implementation-specific Number of Lanes. Set the implementation-specific
    ///< number of lanes. The number of lanes to be used when in Loopback Master.
    ///< The number of lanes programmed must be equal to or less than the valid
    ///< number of lanes set in LINK_CAPABLE field. You must configure this
    ///< field before initiating Loopback by writing in the LOOPBACK_ENABLE
    ///< field. The controller will transition from Loopback.Entry to Loopback.Active
    ///< after receiving two consecutive TS1 Ordered Sets with the Loopback
    ///< bit asserted on the implementation specific number of lanes configured
    ///< in this field.  Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint32_t DISABLE_LANE_TO_LANE_DESKEW : 1;
    ///< Disable Lane-to-Lane Deskew. Causes the controller to disable the
    ///< internal Lane-to-Lane deskew logic.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_lane_skew_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DEFAULT (0x08000000U)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_WR_MASK (0xffffffffU)


///< INSERT_LANE_SKEW is an internally reserved field. Do not use.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_INSERT_LANE_SKEW_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_INSERT_LANE_SKEW_BF_WID (23)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_INSERT_LANE_SKEW_BF_MSK (0x007FFFFF)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_INSERT_LANE_SKEW_BF_DEF (0x00000000)

///< DRIFT_BUFFER_DESKEW_ENABLE is an internally reserved field. Do not
///< use.  Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DRIFT_BUFF_DESKEW_EN_BF_OFF (23)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DRIFT_BUFF_DESKEW_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DRIFT_BUFF_DESKEW_EN_BF_MSK (0x00800000)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DRIFT_BUFF_DESKEW_EN_BF_DEF (0x00000000)

///< Flow Control Disable. Prevents the controller from sending FC DLLPs.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_FLOW_CTRL_DIS_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_FLOW_CTRL_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_FLOW_CTRL_DIS_BF_MSK (0x01000000)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_FLOW_CTRL_DIS_BF_DEF (0x00000000)

///< Ack/Nak Disable. Prevents the controller from sending ACK and NAK
///< DLLPs.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ACK_NAK_DIS_BF_OFF (25)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ACK_NAK_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ACK_NAK_DIS_BF_MSK (0x02000000)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ACK_NAK_DIS_BF_DEF (0x00000000)

///< Selects Elasticity Buffer operating mode:   Note: The access attributes
///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ELASTIC_BUFF_MODE_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ELASTIC_BUFF_MODE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ELASTIC_BUFF_MODE_BF_MSK (0x04000000)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ELASTIC_BUFF_MODE_BF_DEF (0x00000000)

///< Implementation-specific Number of Lanes. Set the implementation-specific
///< number of lanes. The number of lanes to be used when in Loopback Master.
///< The number of lanes programmed must be equal to or less than the valid
///< number of lanes set in LINK_CAPABLE field. You must configure this
///< field before initiating Loopback by writing in the LOOPBACK_ENABLE
///< field. The controller will transition from Loopback.Entry to Loopback.Active
///< after receiving two consecutive TS1 Ordered Sets with the Loopback
///< bit asserted on the implementation specific number of lanes configured
///< in this field.  Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_BF_OFF (27)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_BF_MSK (0x78000000)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_BF_DEF (0x08000000)

///< Disable Lane-to-Lane Deskew. Causes the controller to disable the
///< internal Lane-to-Lane deskew logic.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DIS_LANE_TO_LANE_DESKEW_BF_OFF (31)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DIS_LANE_TO_LANE_DESKEW_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DIS_LANE_TO_LANE_DESKEW_BF_MSK (0x80000000)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_DIS_LANE_TO_LANE_DESKEW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF register description at address offset 0x718
  *
  * Register default value:        0x60018000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/TIMER_CTRL_MAX_FUNC_NUM_OFF
  * Timer Control and Max Function Number Register.
  */

typedef union {
  struct {
    uint32_t MAX_FUNC_NUM : 8;
    ///< Maximum function number that can be used in a request. Configuration
    ///< requests targeted at function numbers above this value are returned
    ///< with UR (unsupported request).   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t TIMER_MOD_REPLAY_TIMER : 5;
    ///< Replay Timer Limit Modifier. Increases the time-out value for the
    ///< replay timer in increments of 64 clock cycles at Gen1 or Gen2 speed,
    ///< and in increments of 256 clock cycles at Gen3 speed. A value of '0'
    ///< represents no modification to the timer limit. For more information,
    ///< see the REPLAY_TIME_LIMIT field of the ACK_LATENCY_TIMER_OFF register.
    ///< At Gen3 speed, the controller automatically changes the value of this
    ///< field to DEFAULT_GEN3_REPLAY_ADJ.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="14" ResetValue="0x6"
    uint32_t TIMER_MOD_ACK_NAK : 5;
    ///< Ack Latency Timer Modifier. Increases the timer value for the Ack
    ///< latency timer in increments of 64 clock cycles. A value of '0' represents
    ///< no modification to the timer value. For more information, see the
    ///< ROUND_TRIP_LATENCY_TIME_LIMIT field of the ACK_LATENCY_TIMER_OFF register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t UPDATE_FREQ_TIMER : 5;
    ///< UPDATE_FREQ_TIMER is an internally reserved field. Do not use.  Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t FAST_LINK_SCALING_FACTOR : 2;
    ///< Fast Link Timer Scaling Factor. Sets the scaling factor of LTSSM timer
    ///< when FAST_LINK_MODE field in PORT_LINK_CTRL_OFF is set to '1'. Default
    ///< is set by the hidden configuration parameter DEFAULT_FAST_LINK_SCALING_FACTOR
    ///< which defaults to '0'.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x3"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_timer_ctrl_max_func_num_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_DEFAULT (0x60018000U)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_RD_MASK (0x7fffc0ffU)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_WR_MASK (0x7fffc0ffU)


///< Maximum function number that can be used in a request. Configuration
///< requests targeted at function numbers above this value are returned
///< with UR (unsupported request).   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_BF_DEF (0x00000000)

///< Replay Timer Limit Modifier. Increases the time-out value for the
///< replay timer in increments of 64 clock cycles at Gen1 or Gen2 speed,
///< and in increments of 256 clock cycles at Gen3 speed. A value of '0'
///< represents no modification to the timer limit. For more information,
///< see the REPLAY_TIME_LIMIT field of the ACK_LATENCY_TIMER_OFF register.
///< At Gen3 speed, the controller automatically changes the value of this
///< field to DEFAULT_GEN3_REPLAY_ADJ.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_BF_OFF (14)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_BF_MSK (0x0007C000)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_BF_DEF (0x00018000)

///< Ack Latency Timer Modifier. Increases the timer value for the Ack
///< latency timer in increments of 64 clock cycles. A value of '0' represents
///< no modification to the timer value. For more information, see the
///< ROUND_TRIP_LATENCY_TIME_LIMIT field of the ACK_LATENCY_TIMER_OFF register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_BF_OFF (19)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_BF_MSK (0x00F80000)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_BF_DEF (0x00000000)

///< UPDATE_FREQ_TIMER is an internally reserved field. Do not use.  Note:
///< This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_BF_MSK (0x1F000000)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_BF_DEF (0x00000000)

///< Fast Link Timer Scaling Factor. Sets the scaling factor of LTSSM timer
///< when FAST_LINK_MODE field in PORT_LINK_CTRL_OFF is set to '1'. Default
///< is set by the hidden configuration parameter DEFAULT_FAST_LINK_SCALING_FACTOR
///< which defaults to '0'.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_BF_OFF (29)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_BF_MSK (0x60000000)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_BF_DEF (0x60000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF register description at address offset 0x71c
  *
  * Register default value:        0x00080140
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/SYMBOL_TIMER_FILTER_1_OFF
  * Symbol Timer Register and Filter Mask 1 Register.
  */

typedef union {
  struct {
    uint32_t SKP_INT_VAL : 11;
    ///< SKP Interval Value. The number of symbol times to wait between transmitting
    ///< SKP ordered sets. The controller waits the number of symbol times
    ///< in this register plus 1, between transmitting SKP ordered sets. Your
    ///< application must program this register accordingly.  For example,
    ///< if 1536 were programmed into this register (in a 250 MHz controller),
    ///< then the controller actually transmits SKP ordered sets once every
    ///< 1537 symbol times.  The value programmed to this register is actually
    ///< clock ticks and not symbol times. In a 125 MHz controller, programming
    ///< the value programmed to this register should be scaled down by a factor
    ///< of 2 (because one clock tick =two symbol times in this case).  Note:
    ///< This value is not used at Gen3 speed; the skip interval is hardcoded
    ///< to 370 blocks.   Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x140"
    uint32_t EIDLE_TIMER : 4;
    ///< EIDLE_TIMER is an internally reserved field. Do not use.  Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t DISABLE_FC_WD_TIMER : 1;
    ///< Disable FC Watchdog Timer.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t MASK_RADM_1 : 16;
    ///< Filter Mask 1. The Filter Mask 1 Register modifies the RADM filtering
    ///< and error handling rules. For more information, see the  Receive Filtering
    ///< section. In each case, '0' applies the associated filtering rule and
    ///< '1' masks the associated filtering rule.  31: CX_FLT_MASK_RC_CFG_DISCARD
    ///< - 0x0: For RADM RC filter to not allow CFG transaction being received
    ///< - 0x1: For RADM RC filter to allow CFG transaction being received
    ///< 30: CX_FLT_MASK_RC_IO_DISCARD  - 0x0: For RADM RC filter to not allow
    ///< IO transaction being received  - 0x1: For RADM RC filter to allow
    ///< IO transaction being received 29: CX_FLT_MASK_MSG_DROP  - 0x0: Drop
    ///< MSG TLP (except for Vendor MSG). Send decoded message on the SII.
    ///< - 0x1: Do not Drop MSG (except for Vendor MSG). Send message TLPs
    ///< to your application on TRGT1 and send decoded message on the SII.
    ///< - The default for this bit is the inverse of FLT_DROP_MSG. That is,
    ///< if FLT_DROP_MSG =1, then the default of this bit is '0' (drop message
    ///< TLPs). This bit only controls message TLPs other than Vendor MSGs.
    ///< Vendor MSGs are controlled by Filter Mask Register 2, bits [1:0].
    ///< The controller never passes ATS Invalidate messages to the SII interface
    ///< regardless of this filter rule setting. The controller passes all
    ///< ATS Invalidate messages to TRGT1 (or AXI bridge manager), as they
    ///< are too big for the SII. 28: CX_FLT_MASK_CPL_ECRC_DISCARD  - Only
    ///< used when completion queue is advertised with infinite credits and
    ///< is in store-and-forward mode.  - 0x0: Discard completions with ECRC
    ///< errors  - 0x1: Allow completions with ECRC errors to be passed up
    ///< - Reserved field for SW. 27: CX_FLT_MASK_ECRC_DISCARD  - 0x0: Discard
    ///< TLPs with ECRC errors  - 0x1: Allow TLPs with ECRC errors to be passed
    ///< up 26: CX_FLT_MASK_CPL_LEN_MATCH  - 0x0: Enforce length match for
    ///< completions; a violation results in cpl_abort, and possibly AER of
    ///< unexp_cpl_err  - 0x1: Mask length match for completions 25: CX_FLT_MASK_CPL_ATTR_MATCH
    ///< - 0x0: Enforce attribute match for completions; a violation results
    ///< in a malformed TLP error, and possibly AER of unexp_cpl_err, cpl_rcvd_ur,
    ///< cpl_rcvd_ca  - 0x1: Mask attribute match for completions 24: CX_FLT_MASK_CPL_TC_MATCH
    ///< - 0x0: Enforce Traffic Class match for completions; a violation results
    ///< in a malformed TLP error, and possibly AER of unexp_cpl_err, cpl_rcvd_ur,
    ///< cpl_rcvd_ca  - 0x1: Mask Traffic Class match for completions 23: CX_FLT_MASK_CPL_FUNC_MATCH
    ///< - 0x0: Enforce function match for completions; a violation results
    ///< in cpl_abort, and possibly AER of unexp_cpl_err, cpl_rcvd_ur, cpl_rcvd_ca
    ///< - 0x1: Mask function match for completions 22: CX_FLT_MASK_CPL_REQID_MATCH
    ///< - 0x0: Enforce Req. Id match for completions; a violation result in
    ///< cpl_abort, and possibly AER of unexp_cpl_err, cpl_rcvd_ur, cpl_rcvd_ca
    ///< - 0x1: Mask Req. Id match for completions 21: CX_FLT_MASK_CPL_TAGERR_MATCH
    ///< - 0x0: Enforce Tag Error Rules for completions; a violation result
    ///< in cpl_abort, and possibly AER of unexp_cpl_err, cpl_rcvd_ur, cpl_rcvd_ca
    ///< - 0x1: Mask Tag Error Rules for completions 20: CX_FLT_MASK_LOCKED_RD_AS_UR
    ///< - 0x0: Treat locked Read TLPs as UR for EP; Supported for RC  - 0x1:
    ///< Treat locked Read TLPs as Supported for EP; UR for RC 19: CX_FLT_MASK_CFG_TYPE1_REQ_AS_UR
    ///< - 0x0: Treat CFG type1 TLPs as UR for EP; Supported for RC  - 0x1:
    ///< Treat CFG type1 TLPs as Supported for EP; UR for RC  - When CX_SRIOV_ENABLE
    ///< is set then this bit is set to allow the filter to process Type 1
    ///< Config requests if the EP consumes more than one bus number.  - When
    ///< CX_IDE_ENABLE is set then this bit is set to allow the filter to process
    ///< Type 1 Config requests when those are received on a Selective Stream
    ///< as indicated by the IDE Core and only if they match an implemented
    ///< function. 18: CX_FLT_MASK_UR_OUTSIDE_BAR  - 0x0: Treat out-of-bar
    ///< TLPs as UR  - 0x1: Do not treat out-of-bar TLPs as UR 17: CX_FLT_MASK_UR_POIS
    ///< - 0x0: Treat poisoned request TLPs as UR  - 0x1: Do not treat poisoned
    ///< request TLPs as UR  - The native controller always passes poisoned
    ///< completions to your application except when you are using the DMA
    ///< read channel.  - For Multistream Architecture, When CX_FLT_MASK_UR_POIS=1,
    ///< TLP is sent to TRGT1 as poisoned TLP, in this case error must be logged
    ///< by your application. 16: CX_FLT_MASK_UR_FUNC_MISMATCH  - 0x0: Treat
    ///< Function MisMatched TLPs as UR  - 0x1: Do not treat Function MisMatched
    ///< TLPs as UR  - CX_FLT_MASK_UR_FUNC_MISMATCH is not allowed to be set
    ///< unless CONFIG_LIMIT_REG =0 and TARGET_ABOVE_CONFIG_LIMIT_REG =2 in
    ///< MISC_CONTROL_1_OFF register or CFG_TLP_BYPASS_EN_REG =1 and TARGET_ABOVE_CONFIG_LIMIT_REG
    ///< =2 in MISC_CONTROL_1_OFF register.   Note: This register field is
    ///< sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="16" ResetValue="0x8"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_symbol_timer_filter_1_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_DEFAULT (0x00080140U)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_WR_MASK (0xffffffffU)


///< SKP Interval Value. The number of symbol times to wait between transmitting
///< SKP ordered sets. The controller waits the number of symbol times
///< in this register plus 1, between transmitting SKP ordered sets. Your
///< application must program this register accordingly.  For example,
///< if 1536 were programmed into this register (in a 250 MHz controller),
///< then the controller actually transmits SKP ordered sets once every
///< 1537 symbol times.  The value programmed to this register is actually
///< clock ticks and not symbol times. In a 125 MHz controller, programming
///< the value programmed to this register should be scaled down by a factor
///< of 2 (because one clock tick =two symbol times in this case).  Note:
///< This value is not used at Gen3 speed; the skip interval is hardcoded
///< to 370 blocks.   Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_BF_WID (11)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_BF_MSK (0x000007FF)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_BF_DEF (0x00000140)

///< EIDLE_TIMER is an internally reserved field. Do not use.  Note: This
///< register field is sticky.
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_BF_OFF (11)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_BF_MSK (0x00007800)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_BF_DEF (0x00000000)

///< Disable FC Watchdog Timer.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_DIS_FC_WD_TIMER_BF_OFF (15)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_DIS_FC_WD_TIMER_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_DIS_FC_WD_TIMER_BF_MSK (0x00008000)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_DIS_FC_WD_TIMER_BF_DEF (0x00000000)

///< Filter Mask 1. The Filter Mask 1 Register modifies the RADM filtering
///< and error handling rules. For more information, see the  Receive Filtering
///< section. In each case, '0' applies the associated filtering rule and
///< '1' masks the associated filtering rule.  31: CX_FLT_MASK_RC_CFG_DISCARD
///< - 0x0: For RADM RC filter to not allow CFG transaction being received
///< - 0x1: For RADM RC filter to allow CFG transaction being received
///< 30: CX_FLT_MASK_RC_IO_DISCARD  - 0x0: For RADM RC filter to not allow
///< IO transaction being received  - 0x1: For RADM RC filter to allow
///< IO transaction being received 29: CX_FLT_MASK_MSG_DROP  - 0x0: Drop
///< MSG TLP (except for Vendor MSG). Send decoded message on the SII.
///< - 0x1: Do not Drop MSG (except for Vendor MSG). Send message TLPs
///< to your application on TRGT1 and send decoded message on the SII.
///< - The default for this bit is the inverse of FLT_DROP_MSG. That is,
///< if FLT_DROP_MSG =1, then the default of this bit is '0' (drop message
///< TLPs). This bit only controls message TLPs other than Vendor MSGs.
///< Vendor MSGs are controlled by Filter Mask Register 2, bits [1:0].
///< The controller never passes ATS Invalidate messages to the SII interface
///< regardless of this filter rule setting. The controller passes all
///< ATS Invalidate messages to TRGT1 (or AXI bridge manager), as they
///< are too big for the SII. 28: CX_FLT_MASK_CPL_ECRC_DISCARD  - Only
///< used when completion queue is advertised with infinite credits and
///< is in store-and-forward mode.  - 0x0: Discard completions with ECRC
///< errors  - 0x1: Allow completions with ECRC errors to be passed up
///< - Reserved field for SW. 27: CX_FLT_MASK_ECRC_DISCARD  - 0x0: Discard
///< TLPs with ECRC errors  - 0x1: Allow TLPs with ECRC errors to be passed
///< up 26: CX_FLT_MASK_CPL_LEN_MATCH  - 0x0: Enforce length match for
///< completions; a violation results in cpl_abort, and possibly AER of
///< unexp_cpl_err  - 0x1: Mask length match for completions 25: CX_FLT_MASK_CPL_ATTR_MATCH
///< - 0x0: Enforce attribute match for completions; a violation results
///< in a malformed TLP error, and possibly AER of unexp_cpl_err, cpl_rcvd_ur,
///< cpl_rcvd_ca  - 0x1: Mask attribute match for completions 24: CX_FLT_MASK_CPL_TC_MATCH
///< - 0x0: Enforce Traffic Class match for completions; a violation results
///< in a malformed TLP error, and possibly AER of unexp_cpl_err, cpl_rcvd_ur,
///< cpl_rcvd_ca  - 0x1: Mask Traffic Class match for completions 23: CX_FLT_MASK_CPL_FUNC_MATCH
///< - 0x0: Enforce function match for completions; a violation results
///< in cpl_abort, and possibly AER of unexp_cpl_err, cpl_rcvd_ur, cpl_rcvd_ca
///< - 0x1: Mask function match for completions 22: CX_FLT_MASK_CPL_REQID_MATCH
///< - 0x0: Enforce Req. Id match for completions; a violation result in
///< cpl_abort, and possibly AER of unexp_cpl_err, cpl_rcvd_ur, cpl_rcvd_ca
///< - 0x1: Mask Req. Id match for completions 21: CX_FLT_MASK_CPL_TAGERR_MATCH
///< - 0x0: Enforce Tag Error Rules for completions; a violation result
///< in cpl_abort, and possibly AER of unexp_cpl_err, cpl_rcvd_ur, cpl_rcvd_ca
///< - 0x1: Mask Tag Error Rules for completions 20: CX_FLT_MASK_LOCKED_RD_AS_UR
///< - 0x0: Treat locked Read TLPs as UR for EP; Supported for RC  - 0x1:
///< Treat locked Read TLPs as Supported for EP; UR for RC 19: CX_FLT_MASK_CFG_TYPE1_REQ_AS_UR
///< - 0x0: Treat CFG type1 TLPs as UR for EP; Supported for RC  - 0x1:
///< Treat CFG type1 TLPs as Supported for EP; UR for RC  - When CX_SRIOV_ENABLE
///< is set then this bit is set to allow the filter to process Type 1
///< Config requests if the EP consumes more than one bus number.  - When
///< CX_IDE_ENABLE is set then this bit is set to allow the filter to process
///< Type 1 Config requests when those are received on a Selective Stream
///< as indicated by the IDE Core and only if they match an implemented
///< function. 18: CX_FLT_MASK_UR_OUTSIDE_BAR  - 0x0: Treat out-of-bar
///< TLPs as UR  - 0x1: Do not treat out-of-bar TLPs as UR 17: CX_FLT_MASK_UR_POIS
///< - 0x0: Treat poisoned request TLPs as UR  - 0x1: Do not treat poisoned
///< request TLPs as UR  - The native controller always passes poisoned
///< completions to your application except when you are using the DMA
///< read channel.  - For Multistream Architecture, When CX_FLT_MASK_UR_POIS=1,
///< TLP is sent to TRGT1 as poisoned TLP, in this case error must be logged
///< by your application. 16: CX_FLT_MASK_UR_FUNC_MISMATCH  - 0x0: Treat
///< Function MisMatched TLPs as UR  - 0x1: Do not treat Function MisMatched
///< TLPs as UR  - CX_FLT_MASK_UR_FUNC_MISMATCH is not allowed to be set
///< unless CONFIG_LIMIT_REG =0 and TARGET_ABOVE_CONFIG_LIMIT_REG =2 in
///< MISC_CONTROL_1_OFF register or CFG_TLP_BYPASS_EN_REG =1 and TARGET_ABOVE_CONFIG_LIMIT_REG
///< =2 in MISC_CONTROL_1_OFF register.   Note: This register field is
///< sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_BF_MSK (0xFFFF0000)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_BF_DEF (0x00080000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_FILTER_MASK_2_OFF register description at address offset 0x720
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/FILTER_MASK_2_OFF
  * Filter Mask 2 Register.
  */

typedef union {
  struct {
    uint32_t MASK_RADM_2 : 32;
    ///< Filter Mask 2. This field modifies the RADM filtering and error handling
    ///< rules. For more information, see the  Receive Filtering  in the Databook.
    ///< In each case, '0' applies the associated filtering rule and '1' masks
    ///< the associated filtering rule.  31:17: Reserved 16: CX_FLT_MASK_RP_TDISP_EN_TBIT_SET_NOT_LOCK_SEL_STR
    ///< - 0x0: Drop Request if IDE-Tbit==1 while RMEDA_CTL1.TDISP_EN==1 but
    ///< it is not on locked selective stream. Valid only for Root Ports when
    ///< CC_RP_TDISP is enabled  - 0x1: Do not drop Request if IDE-Tbit==1
    ///< while RMEDA_CTL1.TDISP_EN==1 but it is not on locked selective stream.
    ///< Valid only for Root Ports when CC_RP_TDISP is enabled 15: CX_FLT_MASK_RP_TDISP_EN_CLEAR_TBIT_SET
    ///< - 0x0: Drop Request if IDE-Tbit==1 while RMEDA_CTL1.TDISP_EN==0. Valid
    ///< only for Root Ports when CC_RP_TDISP is enabled  - 0x1: Do not drop
    ///< Request if IDE-Tbit==1 while RMEDA_CTL1.TDISP_EN==0. Valid only for
    ///< Root Ports when CC_RP_TDISP is enabled  14: CX_FLT_MASK_RCB_CHECK
    ///< The Read Completion Boundary (RCB) determines the naturally aligned
    ///< address boundaries on which a Completer is permitted to break up the
    ///< response for a single Read Request into multiple Completions. If the
    ///< received completion violates this rules the controller handles the
    ///< Completion as a malformed TLP. To disable this filtering rule the
    ///< user can set the mask field, CX_FLT_MASK_RCB_CHECK, to 1.   - 0x0:
    ///< Disable masking of CPL RCB check.  - 0x1: Enable masking of CPL RCB
    ///< check.  13: CX_FLT_MASK_TDISP_DROP_CPL_NOT_RUN  - 0x0: Drop CPL for
    ///< Memory Reads received while TEE not in RUN for TDISP devices  - 0x1:
    ///< Do not drop CPL for Memory Reads while TEE not in RUN for TDISP devices
    ///< 12: CX_FLT_MASK_TDISP_DROP_ATS_CPL_TBIT  - 0x0: Drop CPL for ATS Translation
    ///< Requests when Tbit=0 for TDISP devices  - 0x1: Do not drop CPL for
    ///< ATS Translation Requests when Tbit=0 for TDISP devices 11: CX_FLT_UNMASK_ATOMIC_SPECIFIC_RULES
    ///< - 0x0: Lower Address is checked for Cpls related to AtomicOps Requests.
    ///< - 0x1: Lower Address is not checked for Cpls related to AtomicOps
    ///< Requests. 10: CX_FLT_UNMASK_ATS_SPECIFIC_RULES  - 0x0: Cpls for ATS
    ///< Requests are processed as MemRd-related Cpl.  - 0x1: Lower Address
    ///< is not checked for Cpls related to ATS Requests. An ATS-related Cpl
    ///< completes the request if it has a Byte Count that is equal to four
    ///< times the Length field. 9: CX_FLT_MASK_CPL_IN_LUT_CHECK  - 0x0: Disable
    ///< masking of checking if the tag of CPL is registered in LUT  - 0x1:
    ///< Enable masking of checking if the tag of CPL is registered in LUT
    ///< 8: CX_FLT_MASK_POIS_ERROR_REPORTING  - 0x0: Disable masking of error
    ///< reporting for Poisoned TLPs  - 0x1: Enable masking of error reporting
    ///< for Poisoned TLPs  - This bit is not applicable for Multistream Architecture.
    ///< 7: CX_FLT_MASK_PRS_DROP  - 0x0: Allow PRS message to pass through
    ///< - 0x1: Drop PRS Messages silently  - This bit is ignored when the
    ///< CX_FLT_MASK_MSG_DROP bit in the MASK_RADM_1 field of the SYMBOL_TIMER_FILTER_1_OFF
    ///< register is set to '1'. 6: CX_FLT_UNMASK_TD  - 0x0: Disable unmask
    ///< TD bit if CX_STRIP_ECRC_ENABLE  - 0x1: Enable unmask TD bit if CX_STRIP_ECRC_ENABLE
    ///< 5: CX_FLT_UNMASK_UR_POIS_TRGT0  - 0x0: Disable unmask CX_FLT_MASK_UR_POIS
    ///< with TRGT0 destination  - 0x1: Enable unmask CX_FLT_MASK_UR_POIS with
    ///< TRGT0 destination 4: CX_FLT_MASK_LN_VENMSG1_DROP  - 0x0: Allow LN
    ///< message to pass through  - 0x1: Drop LN Messages silently 3: CX_FLT_MASK_HANDLE_FLUSH
    ///< - 0x0: Disable controller Filter to handle flush request  - 0x1: Enable
    ///< controller Filter to handle flush request 2: CX_FLT_MASK_DABORT_4UCPL
    ///< - 0x0: Enable DLLP abort for unexpected completion  - 0x1: Do not
    ///< enable DLLP abort for unexpected completion 1: CX_FLT_MASK_VENMSG1_DROP
    ///< - 0x0: Vendor MSG Type 1 dropped silently  - 0x1: Vendor MSG Type
    ///< 1 not dropped 0: CX_FLT_MASK_VENMSG0_DROP  - 0x0: Vendor MSG Type
    ///< 0 dropped with UR error reporting  - 0x1: Vendor MSG Type 0 not dropped
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_filter_mask_2_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_WR_MASK (0xffffffffU)


///< Filter Mask 2. This field modifies the RADM filtering and error handling
///< rules. For more information, see the  Receive Filtering  in the Databook.
///< In each case, '0' applies the associated filtering rule and '1' masks
///< the associated filtering rule.  31:17: Reserved 16: CX_FLT_MASK_RP_TDISP_EN_TBIT_SET_NOT_LOCK_SEL_STR
///< - 0x0: Drop Request if IDE-Tbit==1 while RMEDA_CTL1.TDISP_EN==1 but
///< it is not on locked selective stream. Valid only for Root Ports when
///< CC_RP_TDISP is enabled  - 0x1: Do not drop Request if IDE-Tbit==1
///< while RMEDA_CTL1.TDISP_EN==1 but it is not on locked selective stream.
///< Valid only for Root Ports when CC_RP_TDISP is enabled 15: CX_FLT_MASK_RP_TDISP_EN_CLEAR_TBIT_SET
///< - 0x0: Drop Request if IDE-Tbit==1 while RMEDA_CTL1.TDISP_EN==0. Valid
///< only for Root Ports when CC_RP_TDISP is enabled  - 0x1: Do not drop
///< Request if IDE-Tbit==1 while RMEDA_CTL1.TDISP_EN==0. Valid only for
///< Root Ports when CC_RP_TDISP is enabled  14: CX_FLT_MASK_RCB_CHECK
///< The Read Completion Boundary (RCB) determines the naturally aligned
///< address boundaries on which a Completer is permitted to break up the
///< response for a single Read Request into multiple Completions. If the
///< received completion violates this rules the controller handles the
///< Completion as a malformed TLP. To disable this filtering rule the
///< user can set the mask field, CX_FLT_MASK_RCB_CHECK, to 1.   - 0x0:
///< Disable masking of CPL RCB check.  - 0x1: Enable masking of CPL RCB
///< check.  13: CX_FLT_MASK_TDISP_DROP_CPL_NOT_RUN  - 0x0: Drop CPL for
///< Memory Reads received while TEE not in RUN for TDISP devices  - 0x1:
///< Do not drop CPL for Memory Reads while TEE not in RUN for TDISP devices
///< 12: CX_FLT_MASK_TDISP_DROP_ATS_CPL_TBIT  - 0x0: Drop CPL for ATS Translation
///< Requests when Tbit=0 for TDISP devices  - 0x1: Do not drop CPL for
///< ATS Translation Requests when Tbit=0 for TDISP devices 11: CX_FLT_UNMASK_ATOMIC_SPECIFIC_RULES
///< - 0x0: Lower Address is checked for Cpls related to AtomicOps Requests.
///< - 0x1: Lower Address is not checked for Cpls related to AtomicOps
///< Requests. 10: CX_FLT_UNMASK_ATS_SPECIFIC_RULES  - 0x0: Cpls for ATS
///< Requests are processed as MemRd-related Cpl.  - 0x1: Lower Address
///< is not checked for Cpls related to ATS Requests. An ATS-related Cpl
///< completes the request if it has a Byte Count that is equal to four
///< times the Length field. 9: CX_FLT_MASK_CPL_IN_LUT_CHECK  - 0x0: Disable
///< masking of checking if the tag of CPL is registered in LUT  - 0x1:
///< Enable masking of checking if the tag of CPL is registered in LUT
///< 8: CX_FLT_MASK_POIS_ERROR_REPORTING  - 0x0: Disable masking of error
///< reporting for Poisoned TLPs  - 0x1: Enable masking of error reporting
///< for Poisoned TLPs  - This bit is not applicable for Multistream Architecture.
///< 7: CX_FLT_MASK_PRS_DROP  - 0x0: Allow PRS message to pass through
///< - 0x1: Drop PRS Messages silently  - This bit is ignored when the
///< CX_FLT_MASK_MSG_DROP bit in the MASK_RADM_1 field of the SYMBOL_TIMER_FILTER_1_OFF
///< register is set to '1'. 6: CX_FLT_UNMASK_TD  - 0x0: Disable unmask
///< TD bit if CX_STRIP_ECRC_ENABLE  - 0x1: Enable unmask TD bit if CX_STRIP_ECRC_ENABLE
///< 5: CX_FLT_UNMASK_UR_POIS_TRGT0  - 0x0: Disable unmask CX_FLT_MASK_UR_POIS
///< with TRGT0 destination  - 0x1: Enable unmask CX_FLT_MASK_UR_POIS with
///< TRGT0 destination 4: CX_FLT_MASK_LN_VENMSG1_DROP  - 0x0: Allow LN
///< message to pass through  - 0x1: Drop LN Messages silently 3: CX_FLT_MASK_HANDLE_FLUSH
///< - 0x0: Disable controller Filter to handle flush request  - 0x1: Enable
///< controller Filter to handle flush request 2: CX_FLT_MASK_DABORT_4UCPL
///< - 0x0: Enable DLLP abort for unexpected completion  - 0x1: Do not
///< enable DLLP abort for unexpected completion 1: CX_FLT_MASK_VENMSG1_DROP
///< - 0x0: Vendor MSG Type 1 dropped silently  - 0x1: Vendor MSG Type
///< 1 not dropped 0: CX_FLT_MASK_VENMSG0_DROP  - 0x0: Vendor MSG Type
///< 0 dropped with UR error reporting  - 0x1: Vendor MSG Type 0 not dropped
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_MASK_RADM_2_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_MASK_RADM_2_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_MASK_RADM_2_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_MASK_RADM_2_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PL_DEBUG0_OFF register description at address offset 0x728
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PL_DEBUG0_OFF
  * Debug Register 0.
  */

typedef union {
  struct {
    uint32_t DEB_REG_0 : 32;
    ///< The value on cxpl_debug_info[31:0].
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pl_dbg0_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_WR_MASK (0x00000000U)


///< The value on cxpl_debug_info[31:0].
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_DEB_0_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_DEB_0_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_DEB_0_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_DEB_0_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PL_DEBUG1_OFF register description at address offset 0x72c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PL_DEBUG1_OFF
  * Debug Register 1.
  */

typedef union {
  struct {
    uint32_t DEB_REG_1 : 32;
    ///< The value on cxpl_debug_info[63:32].
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pl_dbg1_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_WR_MASK (0x00000000U)


///< The value on cxpl_debug_info[63:32].
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_DEB_1_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_DEB_1_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_DEB_1_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_DEB_1_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_TX_P_FC_CREDIT_STATUS_OFF register description at address offset 0x730
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/TX_P_FC_CREDIT_STATUS_OFF
  * Transmit Posted FC Credit Status.
  */

typedef union {
  struct {
    uint32_t TX_P_DATA_FC_CREDIT : 16;
    ///< Transmit Posted Data FC Credits.  - The posted Data credits advertised
    ///< by the receiver at the other end of the link, updated with each UpdateFC
    ///< DLLP.  - Default value depends on the number of advertised credits
    ///< for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_ph_cdts,
    ///< xtlh_xadm_pd_cdts]; When the number of advertised posted credits (both
    ///< header and data) are infinite, then the default would be [4'b0, 12'hFFF,
    ///< 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_ph_cdts, xtlh_xadm_pd_cdts];
    ///< When the number of advertised posted credits (both header and data)
    ///< are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_P_HEADER_FC_CREDIT : 12;
    ///< Transmit Posted Header FC Credits.  - The posted Header credits advertised
    ///< by the receiver at the other end of the link, updated with each UpdateFC
    ///< DLLP.  - Default value depends on the number of advertised credits
    ///< for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_ph_cdts,
    ///< xtlh_xadm_pd_cdts]; When the number of advertised posted credits (both
    ///< header and data) are infinite, then the default would be [4'b0, 12'hFFF,
    ///< 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_ph_cdts, xtlh_xadm_pd_cdts];
    ///< When the number of advertised posted credits (both header and data)
    ///< are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_tx_p_fc_credit_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_RD_MASK (0x0fffffffU)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_WR_MASK (0x00000000U)


///< Transmit Posted Data FC Credits.  - The posted Data credits advertised
///< by the receiver at the other end of the link, updated with each UpdateFC
///< DLLP.  - Default value depends on the number of advertised credits
///< for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_ph_cdts,
///< xtlh_xadm_pd_cdts]; When the number of advertised posted credits (both
///< header and data) are infinite, then the default would be [4'b0, 12'hFFF,
///< 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_ph_cdts, xtlh_xadm_pd_cdts];
///< When the number of advertised posted credits (both header and data)
///< are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_DATA_FC_CREDIT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_DATA_FC_CREDIT_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_DATA_FC_CREDIT_BF_MSK (0x0000FFFF)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_DATA_FC_CREDIT_BF_DEF (0x00000000)

///< Transmit Posted Header FC Credits.  - The posted Header credits advertised
///< by the receiver at the other end of the link, updated with each UpdateFC
///< DLLP.  - Default value depends on the number of advertised credits
///< for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_ph_cdts,
///< xtlh_xadm_pd_cdts]; When the number of advertised posted credits (both
///< header and data) are infinite, then the default would be [4'b0, 12'hFFF,
///< 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_ph_cdts, xtlh_xadm_pd_cdts];
///< When the number of advertised posted credits (both header and data)
///< are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_HEADER_FC_CREDIT_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_HEADER_FC_CREDIT_BF_WID (12)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_HEADER_FC_CREDIT_BF_MSK (0x0FFF0000)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_TX_P_HEADER_FC_CREDIT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_TX_NP_FC_CREDIT_STATUS_OFF register description at address offset 0x734
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/TX_NP_FC_CREDIT_STATUS_OFF
  * Transmit Non-Posted FC Credit Status.
  */

typedef union {
  struct {
    uint32_t TX_NP_DATA_FC_CREDIT : 16;
    ///< Transmit Non-Posted Data FC Credits.  - The non-posted Data credits
    ///< advertised by the receiver at the other end of the link, updated with
    ///< each UpdateFC DLLP.  - Default value depends on the number of advertised
    ///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_nph_cdts,
    ///< xtlh_xadm_npd_cdts]; When the number of advertised non-posted credits
    ///< (both header and data) are infinite, then the default would be [4'b0,
    ///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_nph_cdts, xtlh_xadm_npd_cdts];
    ///< When the number of advertised non-posted credits (both header and
    ///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_NP_HEADER_FC_CREDIT : 12;
    ///< Transmit Non-Posted Header FC Credits.  - The non-posted Header credits
    ///< advertised by the receiver at the other end of the link, updated with
    ///< each UpdateFC DLLP.  - Default value depends on the number of advertised
    ///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_nph_cdts,
    ///< xtlh_xadm_npd_cdts]; When the number of advertised non-posted credits
    ///< (both header and data) are infinite, then the default would be [4'b0,
    ///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_nph_cdts, xtlh_xadm_npd_cdts];
    ///< When the number of advertised non-posted credits (both header and
    ///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_tx_np_fc_credit_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_RD_MASK (0x0fffffffU)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_WR_MASK (0x00000000U)


///< Transmit Non-Posted Data FC Credits.  - The non-posted Data credits
///< advertised by the receiver at the other end of the link, updated with
///< each UpdateFC DLLP.  - Default value depends on the number of advertised
///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_nph_cdts,
///< xtlh_xadm_npd_cdts]; When the number of advertised non-posted credits
///< (both header and data) are infinite, then the default would be [4'b0,
///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_nph_cdts, xtlh_xadm_npd_cdts];
///< When the number of advertised non-posted credits (both header and
///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_DATA_FC_CREDIT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_DATA_FC_CREDIT_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_DATA_FC_CREDIT_BF_MSK (0x0000FFFF)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_DATA_FC_CREDIT_BF_DEF (0x00000000)

///< Transmit Non-Posted Header FC Credits.  - The non-posted Header credits
///< advertised by the receiver at the other end of the link, updated with
///< each UpdateFC DLLP.  - Default value depends on the number of advertised
///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_nph_cdts,
///< xtlh_xadm_npd_cdts]; When the number of advertised non-posted credits
///< (both header and data) are infinite, then the default would be [4'b0,
///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_nph_cdts, xtlh_xadm_npd_cdts];
///< When the number of advertised non-posted credits (both header and
///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_HEADER_FC_CREDIT_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_HEADER_FC_CREDIT_BF_WID (12)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_HEADER_FC_CREDIT_BF_MSK (0x0FFF0000)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_TX_NP_HEADER_FC_CREDIT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_TX_CPL_FC_CREDIT_STATUS_OFF register description at address offset 0x738
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/TX_CPL_FC_CREDIT_STATUS_OFF
  * Transmit Completion FC Credit Status
  */

typedef union {
  struct {
    uint32_t TX_CPL_DATA_FC_CREDIT : 16;
    ///< Transmit Completion Data FC Credits.  - The Completion Data credits
    ///< advertised by the receiver at the other end of the link, updated with
    ///< each UpdateFC DLLP.  - Default value depends on the number of advertised
    ///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_cplh_cdts,
    ///< xtlh_xadm_cpld_cdts]; When the number of advertised completion credits
    ///< (both header and data) are infinite, then the default would be [4'b0,
    ///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_cplh_cdts, xtlh_xadm_cpld_cdts];
    ///< When the number of advertised completion credits (both header and
    ///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_CPL_HEADER_FC_CREDIT : 12;
    ///< Transmit Completion Header FC Credits.  - The Completion Header credits
    ///< advertised by the receiver at the other end of the link, updated with
    ///< each UpdateFC DLLP.  - Default value depends on the number of advertised
    ///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_cplh_cdts,
    ///< xtlh_xadm_cpld_cdts]; When the number of advertised completion credits
    ///< (both header and data) are infinite, then the default would be [4'b0,
    ///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_cplh_cdts, xtlh_xadm_cpld_cdts];
    ///< When the number of advertised completion credits (both header and
    ///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_tx_cpl_fc_credit_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_RD_MASK (0x0fffffffU)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_WR_MASK (0x00000000U)


///< Transmit Completion Data FC Credits.  - The Completion Data credits
///< advertised by the receiver at the other end of the link, updated with
///< each UpdateFC DLLP.  - Default value depends on the number of advertised
///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_cplh_cdts,
///< xtlh_xadm_cpld_cdts]; When the number of advertised completion credits
///< (both header and data) are infinite, then the default would be [4'b0,
///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_cplh_cdts, xtlh_xadm_cpld_cdts];
///< When the number of advertised completion credits (both header and
///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_DATA_FC_CREDIT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_DATA_FC_CREDIT_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_DATA_FC_CREDIT_BF_MSK (0x0000FFFF)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_DATA_FC_CREDIT_BF_DEF (0x00000000)

///< Transmit Completion Header FC Credits.  - The Completion Header credits
///< advertised by the receiver at the other end of the link, updated with
///< each UpdateFC DLLP.  - Default value depends on the number of advertised
///< credits for header and data  - Scaled Flow Control: [4'b0, xtlh_xadm_cplh_cdts,
///< xtlh_xadm_cpld_cdts]; When the number of advertised completion credits
///< (both header and data) are infinite, then the default would be [4'b0,
///< 12'hFFF, 16'hFFFF].  - No Scaling: [12'b0, xtlh_xadm_cplh_cdts, xtlh_xadm_cpld_cdts];
///< When the number of advertised completion credits (both header and
///< data) are infinite, then the default would be [12'b0, 8'hFF, 12'hFFF].
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_HEADER_FC_CREDIT_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_HEADER_FC_CREDIT_BF_WID (12)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_HEADER_FC_CREDIT_BF_MSK (0x0FFF0000)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_TX_CPL_HEADER_FC_CREDIT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_QUEUE_STATUS_OFF register description at address offset 0x73c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/QUEUE_STATUS_OFF
  * Queue Status.
  */

typedef union {
  struct {
    uint32_t RX_TLP_FC_CREDIT_NON_RETURN : 1;
    ///< Received TLP FC Credits Not Returned.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_RETRY_BUFFER_NE : 1;
    ///< Transmit Retry Buffer Not Empty.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t RX_QUEUE_NON_EMPTY : 1;
    ///< Receive Credit Queue Not Empty.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t RX_QUEUE_OVERFLOW : 1;
    ///< Receive Credit Queue Overflow.   TDISP Prot :WDB
    ///< AccessType="RW/1C/V" BitOffset="3" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
    uint32_t RX_SERIALIZATION_Q_NON_EMPTY : 1;
    ///< Receive Serialization Queue Not Empty.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t TIMER_MOD_FLOW_CONTROL : 13;
    ///< FC Latency Timer Override Value. When you set the  FC Latency Timer
    ///< Override Enable  in this register, the value in this field will override
    ///< the FC latency timer value that the controller calculates according
    ///< to the PCIe specification. For more information, see  Flow Control
    ///< in the Databook.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
    uint32_t TIMER_MOD_FLOW_CONTROL_EN : 1;
    ///< FC Latency Timer Override Enable.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_que_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RD_MASK (0x9fff200fU)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_WR_MASK (0x9fff0008U)


///< Received TLP FC Credits Not Returned.
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_TLP_FC_CREDIT_NON_RETURN_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_TLP_FC_CREDIT_NON_RETURN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_TLP_FC_CREDIT_NON_RETURN_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_TLP_FC_CREDIT_NON_RETURN_BF_DEF (0x00000000)

///< Transmit Retry Buffer Not Empty.
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TX_RETRY_BUFF_NE_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TX_RETRY_BUFF_NE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TX_RETRY_BUFF_NE_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TX_RETRY_BUFF_NE_BF_DEF (0x00000000)

///< Receive Credit Queue Not Empty.
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_NON_EMPTY_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_NON_EMPTY_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_NON_EMPTY_BF_MSK (0x00000004)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_NON_EMPTY_BF_DEF (0x00000000)

///< Receive Credit Queue Overflow.   TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_OVERFLOW_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_OVERFLOW_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_OVERFLOW_BF_MSK (0x00000008)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_QUE_OVERFLOW_BF_DEF (0x00000000)

///< Receive Serialization Queue Not Empty.
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_SERIALIZATION_Q_NON_EMPTY_BF_OFF (13)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_SERIALIZATION_Q_NON_EMPTY_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_SERIALIZATION_Q_NON_EMPTY_BF_MSK (0x00002000)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_RX_SERIALIZATION_Q_NON_EMPTY_BF_DEF (0x00000000)

///< FC Latency Timer Override Value. When you set the  FC Latency Timer
///< Override Enable  in this register, the value in this field will override
///< the FC latency timer value that the controller calculates according
///< to the PCIe specification. For more information, see  Flow Control
///< in the Databook.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_BF_WID (13)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_BF_MSK (0x1FFF0000)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_BF_DEF (0x00000000)

///< FC Latency Timer Override Enable.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_EN_BF_OFF (31)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_EN_BF_MSK (0x80000000)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_TIMER_MOD_FLOW_CTRL_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_VC_TX_ARBI_1_OFF register description at address offset 0x740
  *
  * Register default value:        0x0000000F
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/VC_TX_ARBI_1_OFF
  * VC Transmit Arbitration Register 1.
  */

typedef union {
  struct {
    uint32_t WRR_WEIGHT_VC_0 : 8;
    ///< WRR Weight for VC0.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t WRR_WEIGHT_VC_1 : 8;
    ///< WRR Weight for VC1.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t WRR_WEIGHT_VC_2 : 8;
    ///< WRR Weight for VC2.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t WRR_WEIGHT_VC_3 : 8;
    ///< WRR Weight for VC3.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_vc_tx_arbi_1_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_DEFAULT (0x0000000fU)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WR_MASK (0x00000000U)


///< WRR Weight for VC0.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_BF_DEF (0x0000000F)

///< WRR Weight for VC1.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_BF_MSK (0x0000FF00)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_BF_DEF (0x00000000)

///< WRR Weight for VC2.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_BF_MSK (0x00FF0000)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_BF_DEF (0x00000000)

///< WRR Weight for VC3.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_BF_MSK (0xFF000000)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_VC_TX_ARBI_2_OFF register description at address offset 0x744
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/VC_TX_ARBI_2_OFF
  * VC Transmit Arbitration Register 2.
  */

typedef union {
  struct {
    uint32_t WRR_WEIGHT_VC_4 : 8;
    ///< WRR Weight for VC4.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t WRR_WEIGHT_VC_5 : 8;
    ///< WRR Weight for VC5.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t WRR_WEIGHT_VC_6 : 8;
    ///< WRR Weight for VC6.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t WRR_WEIGHT_VC_7 : 8;
    ///< WRR Weight for VC7.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R   - Dbi: R
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_vc_tx_arbi_2_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WR_MASK (0x00000000U)


///< WRR Weight for VC4.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_BF_DEF (0x00000000)

///< WRR Weight for VC5.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_BF_MSK (0x0000FF00)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_BF_DEF (0x00000000)

///< WRR Weight for VC6.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_BF_MSK (0x00FF0000)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_BF_DEF (0x00000000)

///< WRR Weight for VC7.   Note: The access attributes of this field are
///< as follows:  - Wire: R   - Dbi: R
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_BF_MSK (0xFF000000)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF register description at address offset 0x748
  *
  * Register default value:        0x46220130
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/VC0_P_RX_Q_CTRL_OFF
  * Segmented-Buffer VC0 Posted Receive Queue Control.
  */

typedef union {
  struct {
    uint32_t VC0_P_DATA_CREDIT : 12;
    ///< VC0 Posted Data Credits. The number of initial posted data credits
    ///< for VC0, used only in the segmented-buffer configuration.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: R (sticky)  Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x130"
    uint32_t VC0_P_HEADER_CREDIT : 8;
    ///< VC0 Posted Header Credits. The number of initial posted header credits
    ///< for VC0, used only in the segmented-buffer configuration.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: R (sticky)  Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="12" ResetValue="0x20"
    uint32_t RESERVED4 : 1;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t VC0_P_TLP_Q_MODE : 3;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint32_t VC0_P_HDR_SCALE : 2;
    ///< VC0 Scale Posted Header Credits.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="24" ResetValue="0x2"
    uint32_t VC0_P_DATA_SCALE : 2;
    ///< VC0 Scale Posted Data Credits.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="26" ResetValue="0x1"
    uint32_t RESERVED5 : 2;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t TLP_TYPE_ORDERING_VC0 : 1;
    ///< TLP Type Ordering for VC0. Determines the TLP type ordering rule for
    ///< VC0 receive queues, used only in the segmented-buffer configuration:
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint32_t VC_ORDERING_RX_Q : 1;
    ///< VC Ordering for Receive Queues. Determines the VC ordering rule for
    ///< the receive queues, used only in the segmented-buffer configuration:
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_vc0_p_rx_q_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_DEFAULT (0x46220130U)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_WR_MASK (0xffffffffU)


///< VC0 Posted Data Credits. The number of initial posted data credits
///< for VC0, used only in the segmented-buffer configuration.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: R (sticky)  Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_CREDIT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_CREDIT_BF_WID (12)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_CREDIT_BF_MSK (0x00000FFF)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_CREDIT_BF_DEF (0x00000130)

///< VC0 Posted Header Credits. The number of initial posted header credits
///< for VC0, used only in the segmented-buffer configuration.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: R (sticky)  Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HEADER_CREDIT_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HEADER_CREDIT_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HEADER_CREDIT_BF_MSK (0x000FF000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HEADER_CREDIT_BF_DEF (0x00020000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED4_BF_OFF (20)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED4_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED4_BF_MSK (0x00100000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED4_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_TLP_Q_MODE_BF_OFF (21)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_TLP_Q_MODE_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_TLP_Q_MODE_BF_MSK (0x00E00000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_TLP_Q_MODE_BF_DEF (0x00200000)

///< VC0 Scale Posted Header Credits.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HDR_SCALE_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HDR_SCALE_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HDR_SCALE_BF_MSK (0x03000000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_HDR_SCALE_BF_DEF (0x02000000)

///< VC0 Scale Posted Data Credits.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_SCALE_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_SCALE_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_SCALE_BF_MSK (0x0C000000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC0_P_DATA_SCALE_BF_DEF (0x04000000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED5_BF_OFF (28)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED5_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED5_BF_MSK (0x30000000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_RESERVED5_BF_DEF (0x00000000)

///< TLP Type Ordering for VC0. Determines the TLP type ordering rule for
///< VC0 receive queues, used only in the segmented-buffer configuration:
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC0_BF_OFF (30)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC0_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC0_BF_MSK (0x40000000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC0_BF_DEF (0x40000000)

///< VC Ordering for Receive Queues. Determines the VC ordering rule for
///< the receive queues, used only in the segmented-buffer configuration:
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC_ORDERING_RX_Q_BF_OFF (31)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC_ORDERING_RX_Q_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC_ORDERING_RX_Q_BF_MSK (0x80000000)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_VC_ORDERING_RX_Q_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF register description at address offset 0x74c
  *
  * Register default value:        0x06220020
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/VC0_NP_RX_Q_CTRL_OFF
  * Segmented-Buffer VC0 Non-Posted Receive Queue Control.
  */

typedef union {
  struct {
    uint32_t VC0_NP_DATA_CREDIT : 12;
    ///< VC0 Non-Posted Data Credits. The number of initial non-posted data
    ///< credits for VC0, used only in the segmented-buffer configuration.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x20"
    uint32_t VC0_NP_HEADER_CREDIT : 8;
    ///< VC0 Non-Posted Header Credits. The number of initial non-posted header
    ///< credits for VC0, used only in the segmented-buffer configuration.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="12" ResetValue="0x20"
    uint32_t RESERVED6 : 1;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t VC0_NP_TLP_Q_MODE : 3;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint32_t VC0_NP_HDR_SCALE : 2;
    ///< VC0 Scale Non-Posted Header Credits.   Note: This register field is
    ///< sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="24" ResetValue="0x2"
    uint32_t VC0_NP_DATA_SCALE : 2;
    ///< VC0 Scale Non-Posted Data Credits.   Note: This register field is
    ///< sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="26" ResetValue="0x1"
    uint32_t RESERVED7 : 4;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_vc0_np_rx_q_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_DEFAULT (0x06220020U)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_WR_MASK (0xffffffffU)


///< VC0 Non-Posted Data Credits. The number of initial non-posted data
///< credits for VC0, used only in the segmented-buffer configuration.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_CREDIT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_CREDIT_BF_WID (12)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_CREDIT_BF_MSK (0x00000FFF)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_CREDIT_BF_DEF (0x00000020)

///< VC0 Non-Posted Header Credits. The number of initial non-posted header
///< credits for VC0, used only in the segmented-buffer configuration.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HEADER_CREDIT_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HEADER_CREDIT_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HEADER_CREDIT_BF_MSK (0x000FF000)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HEADER_CREDIT_BF_DEF (0x00020000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED6_BF_OFF (20)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED6_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED6_BF_MSK (0x00100000)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED6_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_TLP_Q_MODE_BF_OFF (21)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_TLP_Q_MODE_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_TLP_Q_MODE_BF_MSK (0x00E00000)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_TLP_Q_MODE_BF_DEF (0x00200000)

///< VC0 Scale Non-Posted Header Credits.   Note: This register field is
///< sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HDR_SCALE_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HDR_SCALE_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HDR_SCALE_BF_MSK (0x03000000)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_HDR_SCALE_BF_DEF (0x02000000)

///< VC0 Scale Non-Posted Data Credits.   Note: This register field is
///< sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_SCALE_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_SCALE_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_SCALE_BF_MSK (0x0C000000)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_VC0_NP_DATA_SCALE_BF_DEF (0x04000000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED7_BF_OFF (28)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED7_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED7_BF_MSK (0xF0000000)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_RESERVED7_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF register description at address offset 0x750
  *
  * Register default value:        0x06200000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/VC0_CPL_RX_Q_CTRL_OFF
  * Segmented-Buffer VC0 Completion Receive Queue Control.
  */

typedef union {
  struct {
    uint32_t VC0_CPL_DATA_CREDIT : 12;
    ///< VC0 Completion Data Credits. The number of initial Completion data
    ///< credits for VC0, used only in the segmented-buffer configuration.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t VC0_CPL_HEADER_CREDIT : 8;
    ///< VC0 Completion Header Credits. The number of initial Completion header
    ///< credits for VC0, used only in the segmented-buffer configuration.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t RESERVED8 : 1;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t VC0_CPL_TLP_Q_MODE : 3;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint32_t VC0_CPL_HDR_SCALE : 2;
    ///< VC0 Scale CPL Header Credits.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="24" ResetValue="0x2"
    uint32_t VC0_CPL_DATA_SCALE : 2;
    ///< VC0 Scale CPL Data Credits.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="26" ResetValue="0x1"
    uint32_t RESERVED9 : 4;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_vc0_cpl_rx_q_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_DEFAULT (0x06200000U)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_WR_MASK (0xffffffffU)


///< VC0 Completion Data Credits. The number of initial Completion data
///< credits for VC0, used only in the segmented-buffer configuration.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_CREDIT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_CREDIT_BF_WID (12)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_CREDIT_BF_MSK (0x00000FFF)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_CREDIT_BF_DEF (0x00000000)

///< VC0 Completion Header Credits. The number of initial Completion header
///< credits for VC0, used only in the segmented-buffer configuration.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: R (sticky)  Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HEADER_CREDIT_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HEADER_CREDIT_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HEADER_CREDIT_BF_MSK (0x000FF000)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HEADER_CREDIT_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED8_BF_OFF (20)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED8_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED8_BF_MSK (0x00100000)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED8_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_TLP_Q_MODE_BF_OFF (21)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_TLP_Q_MODE_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_TLP_Q_MODE_BF_MSK (0x00E00000)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_TLP_Q_MODE_BF_DEF (0x00200000)

///< VC0 Scale CPL Header Credits.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HDR_SCALE_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HDR_SCALE_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HDR_SCALE_BF_MSK (0x03000000)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_HDR_SCALE_BF_DEF (0x02000000)

///< VC0 Scale CPL Data Credits.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_SCALE_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_SCALE_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_SCALE_BF_MSK (0x0C000000)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_VC0_CPL_DATA_SCALE_BF_DEF (0x04000000)

///< Reserved.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED9_BF_OFF (28)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED9_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED9_BF_MSK (0xF0000000)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_RESERVED9_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN2_CTRL_OFF register description at address offset 0x80c
  *
  * Register default value:        0x300102FF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN2_CTRL_OFF
  * Link Width and Speed Change Control Register.
  */

typedef union {
  struct {
    uint32_t FAST_TRAINING_SEQ : 8;
    ///< Sets the Number of Fast Training Sequences (N_FTS) that the controller
    ///< advertises as its N_FTS during Gen2 or above link training. This value
    ///< is used to inform the link partner about the PHY's ability to recover
    ///< synchronization after a low power state. The number should be provided
    ///< by the PHY vendor. Do not set N_FTS to zero; doing so can cause the
    ///< LTSSM to go into the recovery state when exiting from L0s.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W (sticky)
    ///< - Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFF"
    uint32_t NUM_OF_LANES : 5;
    ///< Predetermined Number of Lanes. Defines the number of lanes which are
    ///< connected and not bad. Used to limit the effective link width to ignore
    ///< 'broken  or  unused  lanes that detect a receiver. Indicates the number
    ///< of lanes to check for exit from Electrical Idle in Polling.Active
    ///< and L2.Idle. It is possible that the LTSSM might detect a receiver
    ///< on a bad or broken lane during the Detect Substate. However, it is
    ///< also possible that such a lane might also fail to exit Electrical
    ///< Idle and therefore prevent a valid link from being configured. This
    ///< value is referred to as the  Predetermined Number of Lanes  in section
    ///< 4.2.6.2.1 of the PCI Express Base Specification. When you have unused
    ///< lanes in your system, then you must change the value in this register
    ///< to reflect the number of lanes. You must also change the value in
    ///< the  Link Mode Enable  field of PORT_LINK_CTRL_OFF. The value in this
    ///< register is normally the same as the encoded value in PORT_LINK_CTRL_OFF.
    ///< If you find that one of your used lanes is bad then you must reduce
    ///< the value in this register. For more information, see  How to Tie
    ///< Off Unused Lanes  in the Databook. For information on upsizing and
    ///< downsizing the link width, see  Link Establishment  in the Databook.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x2"
    uint32_t PRE_DET_LANE : 3;
    ///< Predetermined Lane for Auto Flip. This field defines which physical
    ///< lane is connected to logical Lane0 by the flip operation performed
    ///< in Detect. This field is used to restrict the receiver detect procedure
    ///< to a particular lane when the default detect and polling procedure
    ///< performed on all lanes cannot be successful. A notable example of
    ///< when it is useful to program this field to a value different from
    ///< the default, is when a lane is asymmetrically broken, that is, it
    ///< is detected in Detect LTSSM state but it cannot exit Electrical Idle
    ///< in Polling LTSSM state.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t AUTO_LANE_FLIP_CTRL_EN : 1;
    ///< Enable Auto flipping of the lanes. You must set the CX_AUTO_LANE_FLIP_CTRL_EN
    ///< configuration parameter to include the hardware for this feature in
    ///< the controller. For more information, see the 'Lane Reversal' appendix
    ///< in the Databook.   Note: The access attributes of this field are as
    ///< follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t DIRECT_SPEED_CHANGE : 1;
    ///< Directed Speed Change.  When the speed change occurs, the controller
    ///< will clear the contents of this field; and a read to this field by
    ///< your software will return a '0'. To manually initiate the speed change:
    ///< - Write to LINK_CONTROL2_LINK_STATUS2_REG.PCIE_CAP_TARGET_LINK_SPEED
    ///< in the local device  - De-assert this field  - Assert this field If
    ///< you set the default of this field using the DEFAULT_GEN2_SPEED_CHANGE
    ///< configuration parameter to '1', then the speed change is initiated
    ///< automatically after link up, and the controller clears the contents
    ///< of this field. If you want to prevent this automatic speed change,
    ///< then write a lower speed value to the Target Link Speed field of the
    ///< Link Control 2 register (LINK_CONTROL2_LINK_STATUS2_OFF.PCIE_CAP_TARGET_LINK_SPEED)
    ///< through the DBI before link up.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="17" ResetValue="0x0"
    uint32_t CONFIG_PHY_TX_CHANGE : 1;
    ///< Config PHY Tx Swing. Controls the PHY transmitter voltage swing level.
    ///< The controller drives the mac_phy_txswing output from this register
    ///< bit field.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t CONFIG_TX_COMP_RX : 1;
    ///< Config Tx Compliance Receive Bit.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SEL_DEEMPHASIS : 1;
    ///< Used to set the de-emphasis level for upstream ports. This bit selects
    ///< the level of de-emphasis the link operates at.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W (sticky)   -
    ///< Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t GEN1_EI_INFERENCE : 1;
    ///< Electrical Idle Inference Mode at Gen1 Rate. Programmable mode to
    ///< determine inferred electrical idle (EI) in Recovery.Speed or Loopback.Active
    ///< (as slave) state at Gen1 speed by looking for a '1' value on RxElecIdle
    ///< instead of looking for a '0' on RxValid. If the PHY fails to de-assert
    ///< the RxValid signal in Recovery.Speed or Loopback.Active (because of
    ///< corrupted EIOS for example), then EI cannot be inferred successfully
    ///< in the controller by just detecting the condition RxValid=0.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t SELECT_DEEMPH_VAR_MUX : 1;
    ///< The select_deemphasis variable for DSP on entry to Recovery.RcvrCfg
    ///< state is muxed between the Selectable De-emphasis field in the Link
    ///< Control 2 register and the value requested by the Upstream Port in
    ///< the eight consecutive TS1 Ordered Sets it received.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t SELECTABLE_DEEMPH_BIT_MUX : 1;
    ///< The selectable deemphasis bit (Symbol 4 bit 6) of the transmitted
    ///< TS2 Ordered Sets for DSP in Recovery.RcvrCfg state is muxed between
    ///< the Selectable De-emphasis field in the Link Control 2 register and
    ///< the value requested by USP in Recovery.RcvrLock state through Tx TS1s
    ///< from USP.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t LANE_UNDER_TEST : 4;
    ///< The Lane Under Test is the lane for Forced Lane Flip or for Loopback
    ///< Eq. Only one lane is configured each time. The default of this field
    ///< is the CX_DEFAULT_LANE_UNDER_TEST configuration parameter.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t EQ_FOR_LOOPBACK : 1;
    ///< Perform EQ in Loopback in Gen5 and above data rate. The default of
    ///< this field is the CX_DEFAULT_GEN5_EQ_FOR_LOOPBACK configuration parameter.
    ///< Loopback master enters Loopback.Active only because of receiving 2
    ///< TS1s with Loopback bit asserted (not the 2ms timeout of Txing Compliance
    ///< Receive bit) if EQ_FOR_LOOPBACK is set to 1.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint32_t TX_MOD_CMPL_PATTERN_FOR_LOOPBACK : 1;
    ///< Require Loopback slave to transmit Modified Compliance Pattern in
    ///< Loopback.Active state at Gen5 rate. The default of this field is the
    ///< CX_DEFAULT_GEN5_TX_MOD_CMPL_PATTERN_FOR_LOOPBACK configuration paramete
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x1"
    uint32_t FORCE_LANE_FLIP : 1;
    ///< Enable to force the LANE_UNDER_TEST physical lane flips to logical
    ///< lane 0. All the other physical lanes are turned off. The LINK_CAPABLE
    ///< register must be set to 1 and only x1 link can be formed if the FORCE_LANE_FLIP
    ///< register is set to 1.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: R/W (sticky)  Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen2_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_DEFAULT (0x300102ffU)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_RD_MASK (0x7fffffffU)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_WR_MASK (0x7fffffffU)


///< Sets the Number of Fast Training Sequences (N_FTS) that the controller
///< advertises as its N_FTS during Gen2 or above link training. This value
///< is used to inform the link partner about the PHY's ability to recover
///< synchronization after a low power state. The number should be provided
///< by the PHY vendor. Do not set N_FTS to zero; doing so can cause the
///< LTSSM to go into the recovery state when exiting from L0s.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W (sticky)
///< - Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FAST_TRAINING_SEQ_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FAST_TRAINING_SEQ_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FAST_TRAINING_SEQ_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FAST_TRAINING_SEQ_BF_DEF (0x000000FF)

///< Predetermined Number of Lanes. Defines the number of lanes which are
///< connected and not bad. Used to limit the effective link width to ignore
///< 'broken  or  unused  lanes that detect a receiver. Indicates the number
///< of lanes to check for exit from Electrical Idle in Polling.Active
///< and L2.Idle. It is possible that the LTSSM might detect a receiver
///< on a bad or broken lane during the Detect Substate. However, it is
///< also possible that such a lane might also fail to exit Electrical
///< Idle and therefore prevent a valid link from being configured. This
///< value is referred to as the  Predetermined Number of Lanes  in section
///< 4.2.6.2.1 of the PCI Express Base Specification. When you have unused
///< lanes in your system, then you must change the value in this register
///< to reflect the number of lanes. You must also change the value in
///< the  Link Mode Enable  field of PORT_LINK_CTRL_OFF. The value in this
///< register is normally the same as the encoded value in PORT_LINK_CTRL_OFF.
///< If you find that one of your used lanes is bad then you must reduce
///< the value in this register. For more information, see  How to Tie
///< Off Unused Lanes  in the Databook. For information on upsizing and
///< downsizing the link width, see  Link Establishment  in the Databook.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_NUM_OF_LANES_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_NUM_OF_LANES_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_NUM_OF_LANES_BF_MSK (0x00001F00)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_NUM_OF_LANES_BF_DEF (0x00000200)

///< Predetermined Lane for Auto Flip. This field defines which physical
///< lane is connected to logical Lane0 by the flip operation performed
///< in Detect. This field is used to restrict the receiver detect procedure
///< to a particular lane when the default detect and polling procedure
///< performed on all lanes cannot be successful. A notable example of
///< when it is useful to program this field to a value different from
///< the default, is when a lane is asymmetrically broken, that is, it
///< is detected in Detect LTSSM state but it cannot exit Electrical Idle
///< in Polling LTSSM state.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_PRE_DET_LANE_BF_OFF (13)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_PRE_DET_LANE_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_PRE_DET_LANE_BF_MSK (0x0000E000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_PRE_DET_LANE_BF_DEF (0x00000000)

///< Enable Auto flipping of the lanes. You must set the CX_AUTO_LANE_FLIP_CTRL_EN
///< configuration parameter to include the hardware for this feature in
///< the controller. For more information, see the 'Lane Reversal' appendix
///< in the Databook.   Note: The access attributes of this field are as
///< follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_AUTO_LANE_FLIP_CTRL_EN_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_AUTO_LANE_FLIP_CTRL_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_AUTO_LANE_FLIP_CTRL_EN_BF_MSK (0x00010000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_AUTO_LANE_FLIP_CTRL_EN_BF_DEF (0x00010000)

///< Directed Speed Change.  When the speed change occurs, the controller
///< will clear the contents of this field; and a read to this field by
///< your software will return a '0'. To manually initiate the speed change:
///< - Write to LINK_CONTROL2_LINK_STATUS2_REG.PCIE_CAP_TARGET_LINK_SPEED
///< in the local device  - De-assert this field  - Assert this field If
///< you set the default of this field using the DEFAULT_GEN2_SPEED_CHANGE
///< configuration parameter to '1', then the speed change is initiated
///< automatically after link up, and the controller clears the contents
///< of this field. If you want to prevent this automatic speed change,
///< then write a lower speed value to the Target Link Speed field of the
///< Link Control 2 register (LINK_CONTROL2_LINK_STATUS2_OFF.PCIE_CAP_TARGET_LINK_SPEED)
///< through the DBI before link up.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_DIRECT_SPEED_CHANGE_BF_OFF (17)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_DIRECT_SPEED_CHANGE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_DIRECT_SPEED_CHANGE_BF_MSK (0x00020000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_DIRECT_SPEED_CHANGE_BF_DEF (0x00000000)

///< Config PHY Tx Swing. Controls the PHY transmitter voltage swing level.
///< The controller drives the mac_phy_txswing output from this register
///< bit field.   Note: The access attributes of this field are as follows:
///< - Wire: R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_PHY_TX_CHANGE_BF_OFF (18)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_PHY_TX_CHANGE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_PHY_TX_CHANGE_BF_MSK (0x00040000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_PHY_TX_CHANGE_BF_DEF (0x00000000)

///< Config Tx Compliance Receive Bit.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_TX_RX_BF_OFF (19)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_TX_RX_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_TX_RX_BF_MSK (0x00080000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_CFG_TX_RX_BF_DEF (0x00000000)

///< Used to set the de-emphasis level for upstream ports. This bit selects
///< the level of de-emphasis the link operates at.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W (sticky)   -
///< Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPHASIS_BF_OFF (20)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPHASIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPHASIS_BF_MSK (0x00100000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPHASIS_BF_DEF (0x00000000)

///< Electrical Idle Inference Mode at Gen1 Rate. Programmable mode to
///< determine inferred electrical idle (EI) in Recovery.Speed or Loopback.Active
///< (as slave) state at Gen1 speed by looking for a '1' value on RxElecIdle
///< instead of looking for a '0' on RxValid. If the PHY fails to de-assert
///< the RxValid signal in Recovery.Speed or Loopback.Active (because of
///< corrupted EIOS for example), then EI cannot be inferred successfully
///< in the controller by just detecting the condition RxValid=0.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_GEN1_EI_INFERENCE_BF_OFF (21)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_GEN1_EI_INFERENCE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_GEN1_EI_INFERENCE_BF_MSK (0x00200000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_GEN1_EI_INFERENCE_BF_DEF (0x00000000)

///< The select_deemphasis variable for DSP on entry to Recovery.RcvrCfg
///< state is muxed between the Selectable De-emphasis field in the Link
///< Control 2 register and the value requested by the Upstream Port in
///< the eight consecutive TS1 Ordered Sets it received.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPH_VAR_MUX_BF_OFF (22)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPH_VAR_MUX_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPH_VAR_MUX_BF_MSK (0x00400000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SEL_DEEMPH_VAR_MUX_BF_DEF (0x00000000)

///< The selectable deemphasis bit (Symbol 4 bit 6) of the transmitted
///< TS2 Ordered Sets for DSP in Recovery.RcvrCfg state is muxed between
///< the Selectable De-emphasis field in the Link Control 2 register and
///< the value requested by USP in Recovery.RcvrLock state through Tx TS1s
///< from USP.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SELBL_DEEMPH_BIT_MUX_BF_OFF (23)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SELBL_DEEMPH_BIT_MUX_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SELBL_DEEMPH_BIT_MUX_BF_MSK (0x00800000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_SELBL_DEEMPH_BIT_MUX_BF_DEF (0x00000000)

///< The Lane Under Test is the lane for Forced Lane Flip or for Loopback
///< Eq. Only one lane is configured each time. The default of this field
///< is the CX_DEFAULT_LANE_UNDER_TEST configuration parameter.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_LANE_UNDER_TEST_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_LANE_UNDER_TEST_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_LANE_UNDER_TEST_BF_MSK (0x0F000000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_LANE_UNDER_TEST_BF_DEF (0x00000000)

///< Perform EQ in Loopback in Gen5 and above data rate. The default of
///< this field is the CX_DEFAULT_GEN5_EQ_FOR_LOOPBACK configuration parameter.
///< Loopback master enters Loopback.Active only because of receiving 2
///< TS1s with Loopback bit asserted (not the 2ms timeout of Txing Compliance
///< Receive bit) if EQ_FOR_LOOPBACK is set to 1.   Note: The access attributes
///< of this field are as follows:  - Wire: R (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_EQ_FOR_LOOPBACK_BF_OFF (28)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_EQ_FOR_LOOPBACK_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_EQ_FOR_LOOPBACK_BF_MSK (0x10000000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_EQ_FOR_LOOPBACK_BF_DEF (0x10000000)

///< Require Loopback slave to transmit Modified Compliance Pattern in
///< Loopback.Active state at Gen5 rate. The default of this field is the
///< CX_DEFAULT_GEN5_TX_MOD_CMPL_PATTERN_FOR_LOOPBACK configuration paramete
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_TX_MOD_CMPL_PATTERN_FOR_LOOPBACK_BF_OFF (29)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_TX_MOD_CMPL_PATTERN_FOR_LOOPBACK_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_TX_MOD_CMPL_PATTERN_FOR_LOOPBACK_BF_MSK (0x20000000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_TX_MOD_CMPL_PATTERN_FOR_LOOPBACK_BF_DEF (0x20000000)

///< Enable to force the LANE_UNDER_TEST physical lane flips to logical
///< lane 0. All the other physical lanes are turned off. The LINK_CAPABLE
///< register must be set to 1 and only x1 link can be formed if the FORCE_LANE_FLIP
///< register is set to 1.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: R/W (sticky)  Note: This
///< register field is sticky.
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FORCE_LANE_FLIP_BF_OFF (30)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FORCE_LANE_FLIP_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FORCE_LANE_FLIP_BF_MSK (0x40000000)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_FORCE_LANE_FLIP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PHY_STATUS_OFF register description at address offset 0x810
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PHY_STATUS_OFF
  * PHY Status Register.
  */

typedef union {
  struct {
    uint32_t PHY_STATUS : 32;
    ///< PHY Status. Data received directly from the phy_cfg_status bus. These
    ///< is a GPIO register reflecting the values on the static phy_cfg_status
    ///< input signals. The usage is left completely to the user and does not
    ///< in any way influence controller functionality. You can use it for
    ///< any static sideband status signalling requirements that you have for
    ///< your PHY.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_phy_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_WR_MASK (0x00000000U)


///< PHY Status. Data received directly from the phy_cfg_status bus. These
///< is a GPIO register reflecting the values on the static phy_cfg_status
///< input signals. The usage is left completely to the user and does not
///< in any way influence controller functionality. You can use it for
///< any static sideband status signalling requirements that you have for
///< your PHY.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_PHY_STAT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_PHY_STAT_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_PHY_STAT_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_PHY_STAT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PHY_CONTROL_OFF register description at address offset 0x814
  *
  * Register default value:        0x00000041
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PHY_CONTROL_OFF
  * PHY Control Register.
  */

typedef union {
  struct {
    uint32_t PHY_CONTROL : 32;
    ///< PHY Control. Data sent directly to the cfg_phy_control bus. This is
    ///< a GPIO register driving the values on the static cfg_phy_control output
    ///< signals, and does not in any way influence controller functionality.
    ///< It can be used for any static sideband control signaling requirements
    ///< that you have for your PHY. Usage of this register and the associated
    ///< GPIO bus is RESERVED when the controller is connected to a Synopsys
    ///< PHY.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x41"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_phy_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_DEFAULT (0x00000041U)
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_WR_MASK (0xffffffffU)


///< PHY Control. Data sent directly to the cfg_phy_control bus. This is
///< a GPIO register driving the values on the static cfg_phy_control output
///< signals, and does not in any way influence controller functionality.
///< It can be used for any static sideband control signaling requirements
///< that you have for your PHY. Usage of this register and the associated
///< GPIO bus is RESERVED when the controller is connected to a Synopsys
///< PHY.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_PHY_CTRL_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_PHY_CTRL_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_PHY_CTRL_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_PHY_CTRL_BF_DEF (0x00000041)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_TRGT_MAP_CTRL_OFF register description at address offset 0x81c
  *
  * Register default value:        0x0000004F
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/TRGT_MAP_CTRL_OFF
  * Programmable Target Map Control Register.
  */

typedef union {
  struct {
    uint32_t TARGET_MAP_PF : 6;
    ///< Target Values for each BAR on the PF Function selected by the index
    ///< number. This register does not respect the Byte Enable setting, any
    ///< write will affect all register bits.   TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0xF"
    uint32_t TARGET_MAP_ROM : 1;
    ///< Target Value for the ROM page of the PF Function selected by the index
    ///< number. This register does not respect the Byte Enable setting, any
    ///< write will affect all register bits.   TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x1"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t TARGET_MAP_RESERVED_13_15 : 3;
    ///< Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: RSVDP   - Dbi: R (sticky)  TDISP Prot :WP
    ///< AccessType="RO" BitOffset="13" ResetValue="0x0"
    uint32_t TARGET_MAP_INDEX : 5;
    ///< The number of the PF Function on which the Target Values are set.
    ///< This register does not respect the Byte Enable setting, any write
    ///< will affect all register bits. This register can be used to read or
    ///< re-program the target for function numbers from 0 to 31 only.   TDISP
    ///< Prot :WP
    ///< AccessType="RW/V" BitOffset="16" ResetValue="0x0"
    uint32_t TARGET_MAP_RESERVED_21_31 : 11;
    ///< Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: RSVDP   - Dbi: R (sticky)  TDISP Prot :WP
    ///< AccessType="RO" BitOffset="21" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_trgt_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_DEFAULT (0x0000004fU)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_RD_MASK (0xffffe07fU)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_WR_MASK (0x001f007fU)


///< Target Values for each BAR on the PF Function selected by the index
///< number. This register does not respect the Byte Enable setting, any
///< write will affect all register bits.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_PF_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_PF_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_PF_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_PF_BF_DEF (0x0000000F)

///< Target Value for the ROM page of the PF Function selected by the index
///< number. This register does not respect the Byte Enable setting, any
///< write will affect all register bits.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_ROM_BF_OFF ( 6)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_ROM_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_ROM_BF_MSK (0x00000040)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_ROM_BF_DEF (0x00000040)

///< Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: RSVDP   - Dbi: R (sticky)  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_13_15_BF_OFF (13)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_13_15_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_13_15_BF_MSK (0x0000E000)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_13_15_BF_DEF (0x00000000)

///< The number of the PF Function on which the Target Values are set.
///< This register does not respect the Byte Enable setting, any write
///< will affect all register bits. This register can be used to read or
///< re-program the target for function numbers from 0 to 31 only.   TDISP
///< Prot :WP
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_INDEX_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_INDEX_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_INDEX_BF_MSK (0x001F0000)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_INDEX_BF_DEF (0x00000000)

///< Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: RSVDP   - Dbi: R (sticky)  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_21_31_BF_OFF (21)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_21_31_BF_WID (11)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_21_31_BF_MSK (0xFFE00000)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_TARGET_RESERVED_21_31_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_CLOCK_GATING_CTRL_OFF register description at address offset 0x88c
  *
  * Register default value:        0x00000003
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/CLOCK_GATING_CTRL_OFF
  * Clock Gating Control Register.
  */

typedef union {
  struct {
    uint32_t RADM_CLK_GATING_EN : 1;
    ///< RADM Clock Gating Enable. This register, if set, enables the RADM
    ///< to autonomously enable and disable its clock. The DWC_pcie_clk_rst.v
    ///< module provides the gated clock, radm_clk_g, to the RADM and is enabled
    ///< when the controllers clock enable signal, en_radm_clk_g, is asserted.
    ///< The RADM clock is a gated version of the controller clock, core_clk.
    ///< The controller de-asserts en_radm_clk_g when there is no Rx traffic,
    ///< Rx queues and pre/post-queue pipelines are empty, RADM completion
    ///< LUT is empty, and there are no FLR actions pending.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t AXI_CLK_GATING_EN : 1;
    ///< AXI Clock Gating Enable. This register enables the AXI Bridge to autonomously
    ///< enable and disable the AXI Manager clock, the AXI Subordinate clock
    ///< and the AXI DBI slave clock. The DWC_pcie_clk_rst.v module provides
    ///< the gated clock, mstr_axi_aclk_gated, to the AXI Bridge and is enabled
    ///< when the controllers clock enable signal, mstr_aclk_active, is asserted.
    ///< For the AXI Subordinate this module provides the gated clock, slv_axi_aclk_gated,
    ///< to the AXI Bridge and is enabled when the controllers clock enable
    ///< signal, slv_aclk_active, is asserted. If the AXI DBI Slave is enabled
    ///< (DBI_4SLAVE_POPULATED=1) the module provides the gated clock, dbi_axi_aclk_gated,
    ///< to the AXI Bridge and is enabled when the controllers clock enable
    ///< signal, dbi_aclk_active, is asserted. The controller de-asserts the
    ///< clock enable signals when the respective AXI Manager/Subordinate interfaces
    ///< are idle.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_clk_gating_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_DEFAULT (0x00000003U)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_RD_MASK (0x00000003U)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_WR_MASK (0x00000003U)


///< RADM Clock Gating Enable. This register, if set, enables the RADM
///< to autonomously enable and disable its clock. The DWC_pcie_clk_rst.v
///< module provides the gated clock, radm_clk_g, to the RADM and is enabled
///< when the controllers clock enable signal, en_radm_clk_g, is asserted.
///< The RADM clock is a gated version of the controller clock, core_clk.
///< The controller de-asserts en_radm_clk_g when there is no Rx traffic,
///< Rx queues and pre/post-queue pipelines are empty, RADM completion
///< LUT is empty, and there are no FLR actions pending.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_RADM_CLK_GATING_EN_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_RADM_CLK_GATING_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_RADM_CLK_GATING_EN_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_RADM_CLK_GATING_EN_BF_DEF (0x00000001)

///< AXI Clock Gating Enable. This register enables the AXI Bridge to autonomously
///< enable and disable the AXI Manager clock, the AXI Subordinate clock
///< and the AXI DBI slave clock. The DWC_pcie_clk_rst.v module provides
///< the gated clock, mstr_axi_aclk_gated, to the AXI Bridge and is enabled
///< when the controllers clock enable signal, mstr_aclk_active, is asserted.
///< For the AXI Subordinate this module provides the gated clock, slv_axi_aclk_gated,
///< to the AXI Bridge and is enabled when the controllers clock enable
///< signal, slv_aclk_active, is asserted. If the AXI DBI Slave is enabled
///< (DBI_4SLAVE_POPULATED=1) the module provides the gated clock, dbi_axi_aclk_gated,
///< to the AXI Bridge and is enabled when the controllers clock enable
///< signal, dbi_aclk_active, is asserted. The controller de-asserts the
///< clock enable signals when the respective AXI Manager/Subordinate interfaces
///< are idle.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_AXI_CLK_GATING_EN_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_AXI_CLK_GATING_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_AXI_CLK_GATING_EN_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_AXI_CLK_GATING_EN_BF_DEF (0x00000002)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN3_RELATED_OFF register description at address offset 0x890
  *
  * Register default value:        0x00402000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN3_RELATED_OFF
  * Gen3 Control Register.
  */

typedef union {
  struct {
    uint32_t GEN3_ZRXDC_NONCOMPL : 1;
    ///< Gen3 Receiver Impedance ZRX-DC Not Compliant. Receivers that operate
    ///< at 8.0 GT/s with an impedance other than the range defined by the
    ///< ZRX-DC parameter for 2.5 GT/s (40-60 Ohms) must meet additional behavior
    ///< requirements in the following LTSSM states: Polling, Rx_L0s, L1, L2,
    ///< and Disabled. Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register
    ///< is shared for Gen3 and Gen4/Gen5 data rates.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NO_SEED_VALUE_CHANGE : 1;
    ///< If this bit is set to 1, the seed value of LFSR for scrambler at Gen3
    ///< rate does not change after LinkUp = 1. This bit takes effect only
    ///< when CX_AUTO_LANE_FLIP_CTRL_EN is supported. This feature requires
    ///< both sides of the link support it.  Note: this register is shared
    ///< for Gen3 and Gen4/Gen5 data rates.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t DISABLE_SCRAMBLER_GEN_3 : 1;
    ///< Disable Scrambler for Gen3 and Gen4 Data Rate. The Gen3 and Gen4 scrambler/descrambler
    ///< within the controller needs to be disabled when the scrambling function
    ///< is implemented outside of the controller (for example within the PHY).
    ///< Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shared for
    ///< Gen3 and Gen4/Gen5 data rate.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t EQ_PHASE_2_3 : 1;
    ///< Equalization Phase 2 and Phase 3 Disable. This applies to downstream
    ///< ports only.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5 data rate.
    ///< If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate. If RATE_SHADOW_SEL==01b,
    ///< this register is for Gen4 data rate. If RATE_SHADOW_SEL==10b, this
    ///< register is for Gen5 data rate. If RATE_SHADOW_SEL==11b, this register
    ///< is for Gen6 data rate.  Note: The access attributes of this field
    ///< are as follows:  - Wire: see description   - Dbi: see description
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t EQ_EIEOS_CNT : 1;
    ///< Equalization EIEOS Count Reset Disable. Disable requesting reset of
    ///< EIEOS count during equalization.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED,
    ///< this register is shared for Gen3 and Gen4/Gen5 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t EQ_REDO : 1;
    ///< Equalization Redo Disable. Disable autonomous mechanism for requesting
    ///< to redo the equalization process. The received presets or coefficients
    ///< mismatch in Recovery.RcvrLock after Recovery EQ phases causes the
    ///< EQ redo requests. If the EQ redo is infinite or you do not want eq
    ///< requests and redo, setting this bit to 1 will stop the EQ requests
    ///< and EQ redo so that the link can go ahead to L0 state for packet trasmissions.
    ///< Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shared for
    ///< Gen3 and Gen4/Gen5 data rate.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t RXEQ_PH01_EN : 1;
    ///< Rx Equalization Phase 0/Phase 1 Hold Enable. When this bit is set
    ///< the upstream port holds phase 0 (the downstream port holds phase 1)
    ///< for 10ms. Holding phase 0 or phase 1 can be used to allow sufficient
    ///< time for Rx Equalization to be performed by the PHY. This bit is used
    ///< during Virtex-7 Gen3 equalization. The programmable bits [RXEQ_PH01_EN,
    ///< EQ_PHASE_2_3] can be used to obtain the following variations of the
    ///< equalization procedure: Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate. If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate. If RATE_SHADOW_SEL==10b,
    ///< this register is for Gen5 data rate. If RATE_SHADOW_SEL==11b, this
    ///< register is for Gen6 data rate.  Note: The access attributes of this
    ///< field are as follows:  - Wire: see description   - Dbi: see description
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t RXEQ_RGRDLESS_RXTS : 1;
    ///< When set to '1', the controller as Gen3 EQ master asserts RxEqEval
    ///< to instruct the PHY to do Rx adaptation and evaluation after a 500ns
    ///< timeout from a new preset request. Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate. If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate. If RATE_SHADOW_SEL==10b,
    ///< this register is for Gen5 data rate. If RATE_SHADOW_SEL==11b, this
    ///< register is for Gen6 data rate.   Note: The access attributes of this
    ///< field are as follows:  - Wire: see description   - Dbi: see description
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t GEN3_EQ_PSET_COEF_MAP_MODE_PROG : 1;
    ///< Enable Programmable Table for Gen3 Equalization Presets to Coefficients
    ///< Mapping, for Gen3, Gen4, Gen5 and Gen6 Data Rate.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shared for Gen3 and Gen4/Gen5/Gen6 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t GEN3_EQUALIZATION_DISABLE : 1;
    ///< Equalization Disable. Disable equalization feature. This bit cannot
    ///< be changed once the LTSSM starts link training.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED,
    ///< this register is shared for Gen3 and Gen4/Gen5 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t GEN3_DLLP_XMT_DELAY_DISABLE : 1;
    ///< DLLP Transmission Delay Disable. Disable delay transmission of DLLPs
    ///< before equalization.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this
    ///< register is shared for Gen3 and Gen4/Gen5 data rate.   Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t GEN3_DC_BALANCE_DISABLE : 1;
    ///< DC Balance Disable. Disable DC Balance feature.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED,
    ///< this register is shared for Gen3 and Gen4/Gen5 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="19" ResetValue="None"
    uint32_t AUTO_EQ_DISABLE : 1;
    ///< Autonomous Equalization Disable.  Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate.  - If RATE_SHADOW_SEL==00b, this register is RSVD.  - If RATE_SHADOW_SEL==01b,
    ///< this register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this
    ///< register is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register
    ///< is for Gen6 data rate.   Note: The access attributes of this field
    ///< are as follows:  - Wire: see description   - Dbi: see description
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="21" ResetValue="0x0"
    uint32_t USP_SEND_8GT_EQ_TS2_DISABLE : 1;
    ///< Upstream Port Send 8GT/s or 16GT/s EQ TS2 Disable. The base spec defines
    ///< that USP can optionally send 8GT or 16GT EQ TS2, which implies that
    ///< USP can set DSP TxPreset value in Gen4 or Gen5 Data Rate. This applies
    ///< to upstream ports only; It does not apply to downstream ports.  Note:
    ///< - When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shadow register
    ///< for Gen3 and Gen4/Gen5 data rate.  - If RATE_SHADOW_SEL==00b, this
    ///< register is RSVD.  - If RATE_SHADOW_SEL==01b, this register is for
    ///< Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register is for Gen5
    ///< data rate.  - If RATE_SHADOW_SEL==11b, this register is for Gen6 data
    ///< rate.  Value after reset in Gen4/Gen5/Gen6 is DEFAULT_GEN4_USP_SEND_8GT_EQ_TS2_DISABLE/DEFAULT_GEN5_USP_SEND_16GT_EQ_TS2_DISABLE/DEFAULT_GEN6_USP_SEND_16GT_EQ_TS2_DISABLE.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< see description   - Dbi: see description  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="22" ResetValue="0x1"
    uint32_t GEN3_EQ_INVREQ_EVAL_DIFF_DISABLE : 1;
    ///< Eq InvalidRequest and RxEqEval Different Time Assertion Disable. Disable
    ///< the assertion of Eq InvalidRequest and RxEqEval at different time.
    ///< Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shared for
    ///< Gen3 and Gen4/Gen5 data rate.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RATE_SHADOW_SEL : 2;
    ///< Rate Shadow Select. This register value decide the Data Rate of shadow
    ///< register. The following shadow registers are controlled by this register.
    ///< - GEN3_RELATED_OFF[9] EQ_PHASE_2_3  - GEN3_RELATED_OFF[12] RXEQ_PH01_EN
    ///< - GEN3_RELATED_OFF[19] RE_EQ_REQUEST_ENABLE  - GEN3_RELATED_OFF[21]
    ///< AUTO_EQ_DISABLE  - GEN3_RELATED_OFF[22] USP_SEND_8GT_EQ_TS2_DISABLE
    ///< - GEN3_EQ_LOCAL_FS_LF_OFF[5:0] GEN3_EQ_LOCAL_LF  - GEN3_EQ_LOCAL_FS_LF_OFF[11:6]
    ///< GEN3_EQ_LOCAL_FS  - GEN3_EQ_PSET_COEFF_MAP_0[5:0] GEN3_EQ_PRE_CURSOR_PSET
    ///< - GEN3_EQ_PSET_COEFF_MAP_0[11:6] GEN3_EQ_CURSOR_PSET  - GEN3_EQ_PSET_COEFF_MAP_0[17:12]
    ///< GEN3_EQ_POST_CURSOR_PSET  - GEN3_EQ_PSET_COEFF_MAP_0[20:18] GEN6_EQ_PRE_CURSOR_2_PSET
    ///< - GEN3_FCOEF_VEC_DEPTH_OFF[4:0] GEN3_FCOEF_MAX_VEC_DEPTH  - GEN3_FCOEF_VEC_DEPTH_OFF[11:8]
    ///< GEN3_FCOEF_ACCESS_VAR  - GEN3_FCOEF_LANE1_0_OFF[5:0] GEN3_FCOEF_LANE0_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE1_0_OFF[11:6] GEN3_FCOEF_LANE0_POST_CURSOR  - GEN3_FCOEF_LANE1_0_OFF[14:12]
    ///< GEN6_FCOEF_LANE0_PRE_CURSOR_2  - GEN3_FCOEF_LANE1_0_OFF[21:16] GEN3_FCOEF_LANE1_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE1_0_OFF[27:22] GEN3_FCOEF_LANE1_POST_CURSOR  - GEN3_FCOEF_LANE1_0_OFF[30:28]
    ///< GEN6_FCOEF_LANE1_PRE_CURSOR_2  - GEN3_FCOEF_LANE3_2_OFF[5:0] GEN3_FCOEF_LANE2_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE3_2_OFF[11:6] GEN3_FCOEF_LANE2_POST_CURSOR  - GEN3_FCOEF_LANE3_2_OFF[14:12]
    ///< GEN6_FCOEF_LANE2_PRE_CURSOR_2  - GEN3_FCOEF_LANE3_2_OFF[21:16] GEN3_FCOEF_LANE3_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE3_2_OFF[27:22] GEN3_FCOEF_LANE3_POST_CURSOR  - GEN3_FCOEF_LANE3_2_OFF[30:28]
    ///< GEN6_FCOEF_LANE3_PRE_CURSOR_2  - GEN3_FCOEF_LANE5_4_OFF[5:0] GEN3_FCOEF_LANE4_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE5_4_OFF[11:6] GEN3_FCOEF_LANE4_POST_CURSOR  - GEN3_FCOEF_LANE5_4_OFF[14:12]
    ///< GEN6_FCOEF_LANE4_PRE_CURSOR_2  - GEN3_FCOEF_LANE5_4_OFF[21:16] GEN3_FCOEF_LANE5_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE5_4_OFF[27:22] GEN3_FCOEF_LANE5_POST_CURSOR  - GEN3_FCOEF_LANE5_4_OFF[30:28]
    ///< GEN6_FCOEF_LANE5_PRE_CURSOR_2  - GEN3_FCOEF_LANE7_6_OFF[5:0] GEN3_FCOEF_LANE6_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE7_6_OFF[11:6] GEN3_FCOEF_LANE6_POST_CURSOR  - GEN3_FCOEF_LANE7_6_OFF[14:12]
    ///< GEN6_FCOEF_LANE6_PRE_CURSOR_2  - GEN3_FCOEF_LANE7_6_OFF[21:16] GEN3_FCOEF_LANE7_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE7_6_OFF[27:22] GEN3_FCOEF_LANE7_POST_CURSOR  - GEN3_FCOEF_LANE7_6_OFF[30:28]
    ///< GEN6_FCOEF_LANE7_PRE_CURSOR_2  - GEN3_FCOEF_LANE9_8_OFF[5:0] GEN3_FCOEF_LANE8_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE9_8_OFF[11:6] GEN3_FCOEF_LANE8_POST_CURSOR  - GEN3_FCOEF_LANE9_8_OFF[14:12]
    ///< GEN6_FCOEF_LANE8_PRE_CURSOR_2  - GEN3_FCOEF_LANE9_8_OFF[21:16] GEN3_FCOEF_LANE9_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE9_8_OFF[27:22] GEN3_FCOEF_LANE9_POST_CURSOR  - GEN3_FCOEF_LANE9_8_OFF[30:28]
    ///< GEN6_FCOEF_LANE9_PRE_CURSOR_2  - GEN3_FCOEF_LANE11_10_OFF[5:0] GEN3_FCOEF_LANE10_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE11_10_OFF[11:6] GEN3_FCOEF_LANE10_POST_CURSOR  -
    ///< GEN3_FCOEF_LANE11_10_OFF[14:12] GEN6_FCOEF_LANE10_PRE_CURSOR_2  -
    ///< GEN3_FCOEF_LANE11_10_OFF[21:16] GEN3_FCOEF_LANE11_PRE_CURSOR  - GEN3_FCOEF_LANE11_10_OFF[27:22]
    ///< GEN3_FCOEF_LANE11_POST_CURSOR  - GEN3_FCOEF_LANE11_10_OFF[30:28] GEN6_FCOEF_LANE11_PRE_CURSOR_2
    ///< - GEN3_FCOEF_LANE13_12_OFF[5:0] GEN3_FCOEF_LANE12_PRE_CURSOR  - GEN3_FCOEF_LANE13_12_OFF[11:6]
    ///< GEN3_FCOEF_LANE12_POST_CURSOR  - GEN3_FCOEF_LANE13_12_OFF[14:12] GEN6_FCOEF_LANE12_PRE_CURSOR_2
    ///< - GEN3_FCOEF_LANE13_12_OFF[21:16] GEN3_FCOEF_LANE13_PRE_CURSOR  -
    ///< GEN3_FCOEF_LANE13_12_OFF[27:22] GEN3_FCOEF_LANE13_POST_CURSOR  - GEN3_FCOEF_LANE13_12_OFF[30:28]
    ///< GEN6_FCOEF_LANE13_PRE_CURSOR_2  - GEN3_FCOEF_LANE15_14_OFF[5:0] GEN3_FCOEF_LANE14_PRE_CURSOR
    ///< - GEN3_FCOEF_LANE15_14_OFF[11:6] GEN3_FCOEF_LANE14_POST_CURSOR  -
    ///< GEN3_FCOEF_LANE15_14_OFF[14:12] GEN6_FCOEF_LANE14_PRE_CURSOR_2  -
    ///< GEN3_FCOEF_LANE15_14_OFF[21:16] GEN3_FCOEF_LANE15_PRE_CURSOR  - GEN3_FCOEF_LANE15_14_OFF[27:22]
    ///< GEN3_FCOEF_LANE15_POST_CURSOR  - GEN3_FCOEF_LANE15_14_OFF[30:28] GEN6_FCOEF_LANE15_PRE_CURSOR_2
    ///< - GEN3_EQ_CONTROL_OFF[3:0] GEN3_EQ_FB_MODE  - GEN3_EQ_CONTROL_OFF[4]
    ///< GEN3_EQ_PHASE23_EXIT_MODE  - GEN3_EQ_CONTROL_OFF[5] GEN3_EQ_EVAL_2MS_DISABLE
    ///< - GEN3_EQ_CONTROL_OFF[7] GEN3_EQ_EVAL_2MS_EXTEND  - GEN3_EQ_CONTROL_OFF[23:8]
    ///< GEN3_EQ_PSET_REQ_VEC  - GEN3_EQ_CONTROL_OFF[24] GEN3_EQ_FOM_INC_INITIAL_EVAL
    ///< - GEN3_EQ_CONTROL_OFF[25] GEN3_EQ_PSET_REQ_AS_COEF  - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[4:0]
    ///< GEN3_EQ_FMDC_T_MIN_PHASE23  - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[9:5]
    ///< GEN3_EQ_FMDC_N_EVALS  - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[13:10] GEN3_EQ_FMDC_MAX_PRE_CUSROR_DELTA
    ///< - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[17:14] GEN3_EQ_FMDC_MAX_POST_CUSROR_DELTA
    ///< - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[21:18] GEN6_EQ_FMDC_MAX_PRE_CURSOR2_DELTA
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen3_related_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_DEFAULT (0x00402000U)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RD_MASK (0x03e7bf03U)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_WR_MASK (0x03e7bf03U)


///< Gen3 Receiver Impedance ZRX-DC Not Compliant. Receivers that operate
///< at 8.0 GT/s with an impedance other than the range defined by the
///< ZRX-DC parameter for 2.5 GT/s (40-60 Ohms) must meet additional behavior
///< requirements in the following LTSSM states: Polling, Rx_L0s, L1, L2,
///< and Disabled. Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register
///< is shared for Gen3 and Gen4/Gen5 data rates.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL_BF_DEF (0x00000000)

///< If this bit is set to 1, the seed value of LFSR for scrambler at Gen3
///< rate does not change after LinkUp = 1. This bit takes effect only
///< when CX_AUTO_LANE_FLIP_CTRL_EN is supported. This feature requires
///< both sides of the link support it.  Note: this register is shared
///< for Gen3 and Gen4/Gen5 data rates.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_NO_SEED_VAL_CHANGE_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_NO_SEED_VAL_CHANGE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_NO_SEED_VAL_CHANGE_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_NO_SEED_VAL_CHANGE_BF_DEF (0x00000000)

///< Disable Scrambler for Gen3 and Gen4 Data Rate. The Gen3 and Gen4 scrambler/descrambler
///< within the controller needs to be disabled when the scrambling function
///< is implemented outside of the controller (for example within the PHY).
///< Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shared for
///< Gen3 and Gen4/Gen5 data rate.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_DIS_SCRAMBLER_GEN_3_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_DIS_SCRAMBLER_GEN_3_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_DIS_SCRAMBLER_GEN_3_BF_MSK (0x00000100)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_DIS_SCRAMBLER_GEN_3_BF_DEF (0x00000000)

///< Equalization Phase 2 and Phase 3 Disable. This applies to downstream
///< ports only.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5 data rate.
///< If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate. If RATE_SHADOW_SEL==01b,
///< this register is for Gen4 data rate. If RATE_SHADOW_SEL==10b, this
///< register is for Gen5 data rate. If RATE_SHADOW_SEL==11b, this register
///< is for Gen6 data rate.  Note: The access attributes of this field
///< are as follows:  - Wire: see description   - Dbi: see description
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_PHASE_2_3_BF_OFF ( 9)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_PHASE_2_3_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_PHASE_2_3_BF_MSK (0x00000200)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_PHASE_2_3_BF_DEF (0x00000000)

///< Equalization EIEOS Count Reset Disable. Disable requesting reset of
///< EIEOS count during equalization.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED,
///< this register is shared for Gen3 and Gen4/Gen5 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_EIEOS_CNT_BF_OFF (10)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_EIEOS_CNT_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_EIEOS_CNT_BF_MSK (0x00000400)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_EIEOS_CNT_BF_DEF (0x00000000)

///< Equalization Redo Disable. Disable autonomous mechanism for requesting
///< to redo the equalization process. The received presets or coefficients
///< mismatch in Recovery.RcvrLock after Recovery EQ phases causes the
///< EQ redo requests. If the EQ redo is infinite or you do not want eq
///< requests and redo, setting this bit to 1 will stop the EQ requests
///< and EQ redo so that the link can go ahead to L0 state for packet trasmissions.
///< Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shared for
///< Gen3 and Gen4/Gen5 data rate.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_REDO_BF_OFF (11)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_REDO_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_REDO_BF_MSK (0x00000800)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_EQ_REDO_BF_DEF (0x00000000)

///< Rx Equalization Phase 0/Phase 1 Hold Enable. When this bit is set
///< the upstream port holds phase 0 (the downstream port holds phase 1)
///< for 10ms. Holding phase 0 or phase 1 can be used to allow sufficient
///< time for Rx Equalization to be performed by the PHY. This bit is used
///< during Virtex-7 Gen3 equalization. The programmable bits [RXEQ_PH01_EN,
///< EQ_PHASE_2_3] can be used to obtain the following variations of the
///< equalization procedure: Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate. If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate. If RATE_SHADOW_SEL==10b,
///< this register is for Gen5 data rate. If RATE_SHADOW_SEL==11b, this
///< register is for Gen6 data rate.  Note: The access attributes of this
///< field are as follows:  - Wire: see description   - Dbi: see description
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_PH01_EN_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_PH01_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_PH01_EN_BF_MSK (0x00001000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_PH01_EN_BF_DEF (0x00000000)

///< When set to '1', the controller as Gen3 EQ master asserts RxEqEval
///< to instruct the PHY to do Rx adaptation and evaluation after a 500ns
///< timeout from a new preset request. Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate. If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate. If RATE_SHADOW_SEL==10b,
///< this register is for Gen5 data rate. If RATE_SHADOW_SEL==11b, this
///< register is for Gen6 data rate.   Note: The access attributes of this
///< field are as follows:  - Wire: see description   - Dbi: see description
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_RGRDLESS_RXTS_BF_OFF (13)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_RGRDLESS_RXTS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_RGRDLESS_RXTS_BF_MSK (0x00002000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RXEQ_RGRDLESS_RXTS_BF_DEF (0x00002000)

///< Enable Programmable Table for Gen3 Equalization Presets to Coefficients
///< Mapping, for Gen3, Gen4, Gen5 and Gen6 Data Rate.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shared for Gen3 and Gen4/Gen5/Gen6 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_PSET_COEF_MODE_PROG_BF_OFF (15)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_PSET_COEF_MODE_PROG_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_PSET_COEF_MODE_PROG_BF_MSK (0x00008000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_PSET_COEF_MODE_PROG_BF_DEF (0x00000000)

///< Equalization Disable. Disable equalization feature. This bit cannot
///< be changed once the LTSSM starts link training.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED,
///< this register is shared for Gen3 and Gen4/Gen5 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQUALIZATION_DIS_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQUALIZATION_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQUALIZATION_DIS_BF_MSK (0x00010000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQUALIZATION_DIS_BF_DEF (0x00000000)

///< DLLP Transmission Delay Disable. Disable delay transmission of DLLPs
///< before equalization.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this
///< register is shared for Gen3 and Gen4/Gen5 data rate.   Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DLLP_XMT_DELAY_DIS_BF_OFF (17)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DLLP_XMT_DELAY_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DLLP_XMT_DELAY_DIS_BF_MSK (0x00020000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DLLP_XMT_DELAY_DIS_BF_DEF (0x00000000)

///< DC Balance Disable. Disable DC Balance feature.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED,
///< this register is shared for Gen3 and Gen4/Gen5 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DC_BALANCE_DIS_BF_OFF (18)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DC_BALANCE_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DC_BALANCE_DIS_BF_MSK (0x00040000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_DC_BALANCE_DIS_BF_DEF (0x00000000)

///< Autonomous Equalization Disable.  Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate.  - If RATE_SHADOW_SEL==00b, this register is RSVD.  - If RATE_SHADOW_SEL==01b,
///< this register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this
///< register is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register
///< is for Gen6 data rate.   Note: The access attributes of this field
///< are as follows:  - Wire: see description   - Dbi: see description
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_AUTO_EQ_DIS_BF_OFF (21)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_AUTO_EQ_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_AUTO_EQ_DIS_BF_MSK (0x00200000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_AUTO_EQ_DIS_BF_DEF (0x00000000)

///< Upstream Port Send 8GT/s or 16GT/s EQ TS2 Disable. The base spec defines
///< that USP can optionally send 8GT or 16GT EQ TS2, which implies that
///< USP can set DSP TxPreset value in Gen4 or Gen5 Data Rate. This applies
///< to upstream ports only; It does not apply to downstream ports.  Note:
///< - When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shadow register
///< for Gen3 and Gen4/Gen5 data rate.  - If RATE_SHADOW_SEL==00b, this
///< register is RSVD.  - If RATE_SHADOW_SEL==01b, this register is for
///< Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register is for Gen5
///< data rate.  - If RATE_SHADOW_SEL==11b, this register is for Gen6 data
///< rate.  Value after reset in Gen4/Gen5/Gen6 is DEFAULT_GEN4_USP_SEND_8GT_EQ_TS2_DISABLE/DEFAULT_GEN5_USP_SEND_16GT_EQ_TS2_DISABLE/DEFAULT_GEN6_USP_SEND_16GT_EQ_TS2_DISABLE.
///< Note: The access attributes of this field are as follows:  - Wire:
///< see description   - Dbi: see description  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_USP_SEND_8GT_EQ_TS2_DIS_BF_OFF (22)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_USP_SEND_8GT_EQ_TS2_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_USP_SEND_8GT_EQ_TS2_DIS_BF_MSK (0x00400000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_USP_SEND_8GT_EQ_TS2_DIS_BF_DEF (0x00400000)

///< Eq InvalidRequest and RxEqEval Different Time Assertion Disable. Disable
///< the assertion of Eq InvalidRequest and RxEqEval at different time.
///< Note: When CX_GEN4_SPEED/CX_GEN5_SPEED, this register is shared for
///< Gen3 and Gen4/Gen5 data rate.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_INVREQ_EVAL_DIFF_DIS_BF_OFF (23)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_INVREQ_EVAL_DIFF_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_INVREQ_EVAL_DIFF_DIS_BF_MSK (0x00800000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_GEN3_EQ_INVREQ_EVAL_DIFF_DIS_BF_DEF (0x00000000)

///< Rate Shadow Select. This register value decide the Data Rate of shadow
///< register. The following shadow registers are controlled by this register.
///< - GEN3_RELATED_OFF[9] EQ_PHASE_2_3  - GEN3_RELATED_OFF[12] RXEQ_PH01_EN
///< - GEN3_RELATED_OFF[19] RE_EQ_REQUEST_ENABLE  - GEN3_RELATED_OFF[21]
///< AUTO_EQ_DISABLE  - GEN3_RELATED_OFF[22] USP_SEND_8GT_EQ_TS2_DISABLE
///< - GEN3_EQ_LOCAL_FS_LF_OFF[5:0] GEN3_EQ_LOCAL_LF  - GEN3_EQ_LOCAL_FS_LF_OFF[11:6]
///< GEN3_EQ_LOCAL_FS  - GEN3_EQ_PSET_COEFF_MAP_0[5:0] GEN3_EQ_PRE_CURSOR_PSET
///< - GEN3_EQ_PSET_COEFF_MAP_0[11:6] GEN3_EQ_CURSOR_PSET  - GEN3_EQ_PSET_COEFF_MAP_0[17:12]
///< GEN3_EQ_POST_CURSOR_PSET  - GEN3_EQ_PSET_COEFF_MAP_0[20:18] GEN6_EQ_PRE_CURSOR_2_PSET
///< - GEN3_FCOEF_VEC_DEPTH_OFF[4:0] GEN3_FCOEF_MAX_VEC_DEPTH  - GEN3_FCOEF_VEC_DEPTH_OFF[11:8]
///< GEN3_FCOEF_ACCESS_VAR  - GEN3_FCOEF_LANE1_0_OFF[5:0] GEN3_FCOEF_LANE0_PRE_CURSOR
///< - GEN3_FCOEF_LANE1_0_OFF[11:6] GEN3_FCOEF_LANE0_POST_CURSOR  - GEN3_FCOEF_LANE1_0_OFF[14:12]
///< GEN6_FCOEF_LANE0_PRE_CURSOR_2  - GEN3_FCOEF_LANE1_0_OFF[21:16] GEN3_FCOEF_LANE1_PRE_CURSOR
///< - GEN3_FCOEF_LANE1_0_OFF[27:22] GEN3_FCOEF_LANE1_POST_CURSOR  - GEN3_FCOEF_LANE1_0_OFF[30:28]
///< GEN6_FCOEF_LANE1_PRE_CURSOR_2  - GEN3_FCOEF_LANE3_2_OFF[5:0] GEN3_FCOEF_LANE2_PRE_CURSOR
///< - GEN3_FCOEF_LANE3_2_OFF[11:6] GEN3_FCOEF_LANE2_POST_CURSOR  - GEN3_FCOEF_LANE3_2_OFF[14:12]
///< GEN6_FCOEF_LANE2_PRE_CURSOR_2  - GEN3_FCOEF_LANE3_2_OFF[21:16] GEN3_FCOEF_LANE3_PRE_CURSOR
///< - GEN3_FCOEF_LANE3_2_OFF[27:22] GEN3_FCOEF_LANE3_POST_CURSOR  - GEN3_FCOEF_LANE3_2_OFF[30:28]
///< GEN6_FCOEF_LANE3_PRE_CURSOR_2  - GEN3_FCOEF_LANE5_4_OFF[5:0] GEN3_FCOEF_LANE4_PRE_CURSOR
///< - GEN3_FCOEF_LANE5_4_OFF[11:6] GEN3_FCOEF_LANE4_POST_CURSOR  - GEN3_FCOEF_LANE5_4_OFF[14:12]
///< GEN6_FCOEF_LANE4_PRE_CURSOR_2  - GEN3_FCOEF_LANE5_4_OFF[21:16] GEN3_FCOEF_LANE5_PRE_CURSOR
///< - GEN3_FCOEF_LANE5_4_OFF[27:22] GEN3_FCOEF_LANE5_POST_CURSOR  - GEN3_FCOEF_LANE5_4_OFF[30:28]
///< GEN6_FCOEF_LANE5_PRE_CURSOR_2  - GEN3_FCOEF_LANE7_6_OFF[5:0] GEN3_FCOEF_LANE6_PRE_CURSOR
///< - GEN3_FCOEF_LANE7_6_OFF[11:6] GEN3_FCOEF_LANE6_POST_CURSOR  - GEN3_FCOEF_LANE7_6_OFF[14:12]
///< GEN6_FCOEF_LANE6_PRE_CURSOR_2  - GEN3_FCOEF_LANE7_6_OFF[21:16] GEN3_FCOEF_LANE7_PRE_CURSOR
///< - GEN3_FCOEF_LANE7_6_OFF[27:22] GEN3_FCOEF_LANE7_POST_CURSOR  - GEN3_FCOEF_LANE7_6_OFF[30:28]
///< GEN6_FCOEF_LANE7_PRE_CURSOR_2  - GEN3_FCOEF_LANE9_8_OFF[5:0] GEN3_FCOEF_LANE8_PRE_CURSOR
///< - GEN3_FCOEF_LANE9_8_OFF[11:6] GEN3_FCOEF_LANE8_POST_CURSOR  - GEN3_FCOEF_LANE9_8_OFF[14:12]
///< GEN6_FCOEF_LANE8_PRE_CURSOR_2  - GEN3_FCOEF_LANE9_8_OFF[21:16] GEN3_FCOEF_LANE9_PRE_CURSOR
///< - GEN3_FCOEF_LANE9_8_OFF[27:22] GEN3_FCOEF_LANE9_POST_CURSOR  - GEN3_FCOEF_LANE9_8_OFF[30:28]
///< GEN6_FCOEF_LANE9_PRE_CURSOR_2  - GEN3_FCOEF_LANE11_10_OFF[5:0] GEN3_FCOEF_LANE10_PRE_CURSOR
///< - GEN3_FCOEF_LANE11_10_OFF[11:6] GEN3_FCOEF_LANE10_POST_CURSOR  -
///< GEN3_FCOEF_LANE11_10_OFF[14:12] GEN6_FCOEF_LANE10_PRE_CURSOR_2  -
///< GEN3_FCOEF_LANE11_10_OFF[21:16] GEN3_FCOEF_LANE11_PRE_CURSOR  - GEN3_FCOEF_LANE11_10_OFF[27:22]
///< GEN3_FCOEF_LANE11_POST_CURSOR  - GEN3_FCOEF_LANE11_10_OFF[30:28] GEN6_FCOEF_LANE11_PRE_CURSOR_2
///< - GEN3_FCOEF_LANE13_12_OFF[5:0] GEN3_FCOEF_LANE12_PRE_CURSOR  - GEN3_FCOEF_LANE13_12_OFF[11:6]
///< GEN3_FCOEF_LANE12_POST_CURSOR  - GEN3_FCOEF_LANE13_12_OFF[14:12] GEN6_FCOEF_LANE12_PRE_CURSOR_2
///< - GEN3_FCOEF_LANE13_12_OFF[21:16] GEN3_FCOEF_LANE13_PRE_CURSOR  -
///< GEN3_FCOEF_LANE13_12_OFF[27:22] GEN3_FCOEF_LANE13_POST_CURSOR  - GEN3_FCOEF_LANE13_12_OFF[30:28]
///< GEN6_FCOEF_LANE13_PRE_CURSOR_2  - GEN3_FCOEF_LANE15_14_OFF[5:0] GEN3_FCOEF_LANE14_PRE_CURSOR
///< - GEN3_FCOEF_LANE15_14_OFF[11:6] GEN3_FCOEF_LANE14_POST_CURSOR  -
///< GEN3_FCOEF_LANE15_14_OFF[14:12] GEN6_FCOEF_LANE14_PRE_CURSOR_2  -
///< GEN3_FCOEF_LANE15_14_OFF[21:16] GEN3_FCOEF_LANE15_PRE_CURSOR  - GEN3_FCOEF_LANE15_14_OFF[27:22]
///< GEN3_FCOEF_LANE15_POST_CURSOR  - GEN3_FCOEF_LANE15_14_OFF[30:28] GEN6_FCOEF_LANE15_PRE_CURSOR_2
///< - GEN3_EQ_CONTROL_OFF[3:0] GEN3_EQ_FB_MODE  - GEN3_EQ_CONTROL_OFF[4]
///< GEN3_EQ_PHASE23_EXIT_MODE  - GEN3_EQ_CONTROL_OFF[5] GEN3_EQ_EVAL_2MS_DISABLE
///< - GEN3_EQ_CONTROL_OFF[7] GEN3_EQ_EVAL_2MS_EXTEND  - GEN3_EQ_CONTROL_OFF[23:8]
///< GEN3_EQ_PSET_REQ_VEC  - GEN3_EQ_CONTROL_OFF[24] GEN3_EQ_FOM_INC_INITIAL_EVAL
///< - GEN3_EQ_CONTROL_OFF[25] GEN3_EQ_PSET_REQ_AS_COEF  - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[4:0]
///< GEN3_EQ_FMDC_T_MIN_PHASE23  - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[9:5]
///< GEN3_EQ_FMDC_N_EVALS  - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[13:10] GEN3_EQ_FMDC_MAX_PRE_CUSROR_DELTA
///< - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[17:14] GEN3_EQ_FMDC_MAX_POST_CUSROR_DELTA
///< - GEN3_EQ_FB_MODE_DIR_CHANGE_OFF[21:18] GEN6_EQ_FMDC_MAX_PRE_CURSOR2_DELTA
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RATE_SHDW_SEL_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RATE_SHDW_SEL_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RATE_SHDW_SEL_BF_MSK (0x03000000)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_RATE_SHDW_SEL_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF register description at address offset 0x894
  *
  * Register default value:        0x00000FC3
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN3_EQ_LOCAL_FS_LF_OFF
  * Gen3 EQ FS and LF Register.
  */

typedef union {
  struct {
    uint32_t GEN3_EQ_LOCAL_LF : 6;
    ///< Low Frequency (LF) Value for Gen3/Gen4 Transmit Equalization. Used
    ///< when you enable the Programmable Table for Gen3 Equalization Presets
    ///< to Coefficients Mapping, by writing '1' to the GEN3_EQ_PSET_COEF_MAP_MODE_PROG
    ///< field of GEN3_RELATED_OFF register. Selects the FS and LF values used
    ///< by the local PHY. The values are needed in the controller for advertising
    ///< during Phase1, and for checking during  EQ Master  that the requested
    ///< coefficients are legal according to the rules in section  4.2.3.1
    ///< Rules for Transmitter Coefficients  of the PCI Express Base Specification.
    ///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
    ///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
    ///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
    ///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
    ///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
    ///< for Gen6 data rate.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x3"
    uint32_t GEN3_EQ_LOCAL_FS : 6;
    ///< Full Swing (FS) Value for Gen3/Gen4 Transmit Equalization.  Value
    ///< Range: 12 through 63 (decimal).  Used when you enable the Programmable
    ///< Table for Gen3 Equalization Presets to Coefficients Mapping, by writing
    ///< '1' to the GEN3_EQ_PSET_COEF_MAP_MODE_PROG field of GEN3_RELATED_OFF
    ///< register. Selects the FS and LF values used by the local PHY. The
    ///< values are needed in the controller for advertising during Phase1,
    ///< and for checking during  EQ Master  that the requested coefficients
    ///< are legal according to rules in section  4.2.3.1 Rules for Transmitter
    ///< Coefficients  of the PCI Express Base Specification.  Note:  - When
    ///< CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register is shadow
    ///< register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
    ///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
    ///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
    ///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
    ///< for Gen6 data rate.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="6" ResetValue="0x3F"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen3_eq_local_fs_lf_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_DEFAULT (0x00000fc3U)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_RD_MASK (0x00000fffU)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_WR_MASK (0x00000fffU)


///< Low Frequency (LF) Value for Gen3/Gen4 Transmit Equalization. Used
///< when you enable the Programmable Table for Gen3 Equalization Presets
///< to Coefficients Mapping, by writing '1' to the GEN3_EQ_PSET_COEF_MAP_MODE_PROG
///< field of GEN3_RELATED_OFF register. Selects the FS and LF values used
///< by the local PHY. The values are needed in the controller for advertising
///< during Phase1, and for checking during  EQ Master  that the requested
///< coefficients are legal according to the rules in section  4.2.3.1
///< Rules for Transmitter Coefficients  of the PCI Express Base Specification.
///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
///< for Gen6 data rate.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_LF_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_LF_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_LF_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_LF_BF_DEF (0x00000003)

///< Full Swing (FS) Value for Gen3/Gen4 Transmit Equalization.  Value
///< Range: 12 through 63 (decimal).  Used when you enable the Programmable
///< Table for Gen3 Equalization Presets to Coefficients Mapping, by writing
///< '1' to the GEN3_EQ_PSET_COEF_MAP_MODE_PROG field of GEN3_RELATED_OFF
///< register. Selects the FS and LF values used by the local PHY. The
///< values are needed in the controller for advertising during Phase1,
///< and for checking during  EQ Master  that the requested coefficients
///< are legal according to rules in section  4.2.3.1 Rules for Transmitter
///< Coefficients  of the PCI Express Base Specification.  Note:  - When
///< CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register is shadow
///< register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
///< for Gen6 data rate.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_FS_BF_OFF ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_FS_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_FS_BF_MSK (0x00000FC0)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_GEN3_EQ_LOCAL_FS_BF_DEF (0x00000FC0)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN3_EQ_PSET_COEF_MAP__0 register description at address offset 0x898
  *
  * Register default value:        0x00010BC0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN3_EQ_PSET_COEF_MAP__0
  * Gen3 EQ Presets to Coefficients Mapping Register.
  */

typedef union {
  struct {
    uint32_t GEN3_EQ_PRE_CURSOR_PSET : 6;
    ///< Pre-cursor (C-1) Coefficient. The default (DEFAULT_GEN3_EQ_PRECURSOR_PSETi)
    ///< is defined in the table in the  Programming Registers  section of
    ///< the  Gen3 Equalization Details and Example  appendix in the Databook.
    ///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
    ///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
    ///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
    ///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
    ///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
    ///< for Gen6 data rate, lower 4 bits only are used.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t GEN3_EQ_CURSOR_PSET : 6;
    ///< Cursor (C0) Coefficient.  Note:  Default is DEFAULT_GEN3_EQ_LOCAL_FS
    ///< -DEFAULT_GEN3_EQ_PRECURSOR_PSETi -DEFAULT_GEN3_EQ_POSTCURSOR_PSETi
    ///< that is, C0 =FS - abs(C-1) - abs(C+1)  Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
    ///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
    ///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="6" ResetValue="0x2F"
    uint32_t GEN3_EQ_POST_CURSOR_PSET : 6;
    ///< Post-cursor (C+1) Coefficient. The default (DEFAULT_GEN3_EQ_POSTCURSOR_PSETi)
    ///< is defined in the table in the  Programming Registers  section of
    ///< the  Gen3 Equalization Details and Example  appendix in the Databook.
    ///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
    ///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
    ///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
    ///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
    ///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
    ///< for Gen6 data rate, lower 5 bits only are used.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="12" ResetValue="0x10"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen3_eq_pset_coef__0_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_DEFAULT (0x00010bc0U)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_RD_MASK (0x0003ffffU)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_WR_MASK (0x0003ffffU)


///< Pre-cursor (C-1) Coefficient. The default (DEFAULT_GEN3_EQ_PRECURSOR_PSETi)
///< is defined in the table in the  Programming Registers  section of
///< the  Gen3 Equalization Details and Example  appendix in the Databook.
///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
///< for Gen6 data rate, lower 4 bits only are used.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_PRE_CURSOR_PSET_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_PRE_CURSOR_PSET_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_PRE_CURSOR_PSET_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_PRE_CURSOR_PSET_BF_DEF (0x00000000)

///< Cursor (C0) Coefficient.  Note:  Default is DEFAULT_GEN3_EQ_LOCAL_FS
///< -DEFAULT_GEN3_EQ_PRECURSOR_PSETi -DEFAULT_GEN3_EQ_POSTCURSOR_PSETi
///< that is, C0 =FS - abs(C-1) - abs(C+1)  Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_CURSOR_PSET_BF_OFF ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_CURSOR_PSET_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_CURSOR_PSET_BF_MSK (0x00000FC0)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_CURSOR_PSET_BF_DEF (0x00000BC0)

///< Post-cursor (C+1) Coefficient. The default (DEFAULT_GEN3_EQ_POSTCURSOR_PSETi)
///< is defined in the table in the  Programming Registers  section of
///< the  Gen3 Equalization Details and Example  appendix in the Databook.
///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
///< for Gen6 data rate, lower 5 bits only are used.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_POST_CURSOR_PSET_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_POST_CURSOR_PSET_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_POST_CURSOR_PSET_BF_MSK (0x0003F000)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_GEN3_EQ_POST_CURSOR_PSET_BF_DEF (0x00010000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF register description at address offset 0x89c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN3_EQ_PSET_INDEX_OFF
  * Gen3 EQ Preset Index Register.
  */

typedef union {
  struct {
    uint32_t GEN3_EQ_PSET_INDEX : 4;
    ///< Preset index i, where i =0, 1,2,..,10. This is the index used for
    ///< accessing (using register indirect addressing mode) the  Gen3 EQ Presets
    ///< to Coefficients Mapping Registers . This register is only used when
    ///< you enable the Programmable Table for Gen3 Equalization Presets to
    ///< Coefficients Mapping, by writing '1' to the GEN3_EQ_PSET_COEF_MAP_MODE_PROG
    ///< field of GEN3_RELATED_OFF register.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shared for Gen3 and Gen4/Gen5/Gen6 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen3_eq_pset_index_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_RD_MASK (0x0000000fU)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_WR_MASK (0x0000000fU)


///< Preset index i, where i =0, 1,2,..,10. This is the index used for
///< accessing (using register indirect addressing mode) the  Gen3 EQ Presets
///< to Coefficients Mapping Registers . This register is only used when
///< you enable the Programmable Table for Gen3 Equalization Presets to
///< Coefficients Mapping, by writing '1' to the GEN3_EQ_PSET_COEF_MAP_MODE_PROG
///< field of GEN3_RELATED_OFF register.  Note: When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shared for Gen3 and Gen4/Gen5/Gen6 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_GEN3_EQ_PSET_INDEX_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_GEN3_EQ_PSET_INDEX_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_GEN3_EQ_PSET_INDEX_BF_MSK (0x0000000F)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_GEN3_EQ_PSET_INDEX_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STATUS_OFF register description at address offset 0x8a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN3_EQ_COEFF_LEGALITY_STATUS_OFF
  * Gen3 EQ Status Register.
  */

typedef union {
  struct {
    uint32_t GEN3_EQ_VIOLATE_COEF_RULES : 1;
    ///< Programmable Coefficients Legality Status. This bit is only valid
    ///< after programming a coefficient into the mapping table. This bit is
    ///< set if the most recently programmed coefficient ( Gen3 EQ Presets
    ///< to Coefficients Mapping Registers  violate any of the following rules:
    ///< Rules for Gen3/4/5 speed  - abs(C-1) <= (FS/4)  - abs(C-1) + C0 +
    ///< abs(C+1) =FS  - abs(C0) - abs(C-1) - abs(C+1) >= LF Rules for Gen6
    ///< speed  - abs(C-1) <= (FS/4)  - abs(C-2) + abs(C-1) + C0 + abs(C+1)
    ///< =FS  - abs(C0) + abs(C-2) - abs(C-1) - abs(C+1) >= LF  - abs(C-2)
    ///< <= (FS/8) Your application should always check the status after it
    ///< programs each coefficient, so that it then knows which preset number
    ///< had the illegal coefficients.  Note: You should ignore the value in
    ///< this field until you have written/updated the programmable coefficients.
    ///< Although the value of this register field is '0' during reset, it
    ///< gets set to '1' almost immediately after the reset is removed. This
    ///< is because the current coefficient defaults to '0', which is always
    ///< illegal. So if this field is read before you program the coefficient
    ///< mapping table, then it is '1'.  This bit is automatically cleared
    ///< when you read it.   Note: This register field is sticky.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen3_eq_coeff_legality_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_RD_MASK (0x00000001U)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_WR_MASK (0x00000000U)


///< Programmable Coefficients Legality Status. This bit is only valid
///< after programming a coefficient into the mapping table. This bit is
///< set if the most recently programmed coefficient ( Gen3 EQ Presets
///< to Coefficients Mapping Registers  violate any of the following rules:
///< Rules for Gen3/4/5 speed  - abs(C-1) <= (FS/4)  - abs(C-1) + C0 +
///< abs(C+1) =FS  - abs(C0) - abs(C-1) - abs(C+1) >= LF Rules for Gen6
///< speed  - abs(C-1) <= (FS/4)  - abs(C-2) + abs(C-1) + C0 + abs(C+1)
///< =FS  - abs(C0) + abs(C-2) - abs(C-1) - abs(C+1) >= LF  - abs(C-2)
///< <= (FS/8) Your application should always check the status after it
///< programs each coefficient, so that it then knows which preset number
///< had the illegal coefficients.  Note: You should ignore the value in
///< this field until you have written/updated the programmable coefficients.
///< Although the value of this register field is '0' during reset, it
///< gets set to '1' almost immediately after the reset is removed. This
///< is because the current coefficient defaults to '0', which is always
///< illegal. So if this field is read before you program the coefficient
///< mapping table, then it is '1'.  This bit is automatically cleared
///< when you read it.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_GEN3_EQ_VIOLATE_COEF_RULES_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_GEN3_EQ_VIOLATE_COEF_RULES_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_GEN3_EQ_VIOLATE_COEF_RULES_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_GEN3_EQ_VIOLATE_COEF_RULES_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN3_EQ_CONTROL_OFF register description at address offset 0x8a8
  *
  * Register default value:        0x0D07FF61
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN3_EQ_CONTROL_OFF
  * Gen3 EQ Control Register.
  */

typedef union {
  struct {
    uint32_t GEN3_EQ_FB_MODE : 4;
    ///< Feedback Mode. Other values are reserved. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
    ///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
    ///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate. Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x1"
    uint32_t GEN3_EQ_PHASE23_EXIT_MODE : 1;
    ///< Behavior After 24 ms Timeout (when optimal settings are not found).
    ///< For a USP: Determine next LTSSM state from Phase2 after 24ms Timeout
    ///< - 0: Recovery.Speed  - 1: Recovery.Equalization.Phase3 When optimal
    ///< settings are not found then:  - Equalization Phase 2 Successful status
    ///< bit is not set in the  Link Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE
    ///< = 0  - Equalization Phase 2 Successful status bit is set in the  Link
    ///< Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE = 1  - Equalization
    ///< Phase 2 Complete status bit is set in the  Link Status Register 2
    ///< For a DSP: Determine next LTSSM state from Phase3 after 24ms Timeout
    ///< - 0: Recovery.Speed  - 1: Recovery.Equalization.RcvrLock When optimal
    ///< settings are not found then:  - Equalization Phase 3 Successful status
    ///< bit is not set in the  Link Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE
    ///< = 0  - Equalization Phase 3 Successful status bit is set in the  Link
    ///< Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE = 1  - Equalization
    ///< Phase 3 Complete status bit is set in the  Link Status Register 2
    ///< Note: GEN3_EQ_PHASE23_EXIT_MODE = 1 affects Direction Change feed
    ///< back mode. EQ requests for Figure Of Merit mode complete before 24ms
    ///< timeout. For more information, see GEN3_EQ_PSET_REQ_VEC Register.
    ///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
    ///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
    ///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
    ///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
    ///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
    ///< for Gen6 data rate.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint32_t GEN3_EQ_EVAL_2MS_DISABLE : 1;
    ///< Phase2_3 2 ms Timeout Disable. Determine behavior in Phase2 for USP
    ///< (Phase3 if DSP) when the PHY does not respond within 2ms to the assertion
    ///< of RxEqEval. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
    ///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
    ///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="5" ResetValue="0x1"
    uint32_t GEN3_LOWER_RATE_EQ_REDO_ENABLE : 1;
    ///< Support EQ redo and lower rate change. To access this field, RATE_SHADOW_SEL
    ///< should be set to 0. Note: Gen3 and Gen4 share the same register bit
    ///< and have the same feature.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x1"
    uint32_t GEN3_EQ_EVAL_2MS_EXTEND : 1;
    ///< Phase2_3 extend default Timeout from 2 ms to 4 ms. In Phase2 for USP
    ///< (Phase3 if DSP) when PHY require more response time to the assertion
    ///< of RxEqEval timeout is extended to 4 ms Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
    ///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
    ///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="7" ResetValue="0x0"
    uint32_t GEN3_EQ_PSET_REQ_VEC : 16;
    ///< Preset Request Vector. Requesting of Presets during the initial part
    ///< of the EQ Master Phase. Encoding scheme is as follows:   Bit [15:0]
    ///< =0x0: No preset is requested and evaluated in EQ Master Phase.   Bit
    ///< [i] =1:  Preset=i  is requested and evaluated in EQ Master Phase.
    ///< - 0x0000000000000000: No preset be requested and evaluated in EQ Master
    ///< Phase  - 0x000000xxxxxxxxx1: Preset 0 is requested and evaluated in
    ///< EQ Master Phase  - 0x000000xxxxxxxx1x: Preset 1 is requested and evaluated
    ///< in EQ Master Phase  - 0x000000xxxxxxx1xx: Preset 2 is requested and
    ///< evaluated in EQ Master Phase  - 0x000000xxxxxx1xxx: Preset 3 is requested
    ///< and evaluated in EQ Master Phase  - 0x000000xxxxx1xxxx: Preset 4 is
    ///< requested and evaluated in EQ Master Phase  - 0x000000xxxx1xxxxx:
    ///< Preset 5 is requested and evaluated in EQ Master Phase  - 0x000000xxx1xxxxxx:
    ///< Preset 6 is requested and evaluated in EQ Master Phase  - 0x000000xx1xxxxxxx:
    ///< Preset 7 is requested and evaluated in EQ Master Phase  - 0x000000x1xxxxxxxx:
    ///< Preset 8 is requested and evaluated in EQ Master Phase  - 0x00000x1xxxxxxxxx:
    ///< Preset 9 is requested and evaluated in EQ Master Phase  - 0x000001xxxxxxxxxx:
    ///< Preset 10 is requested and evaluated in EQ Master Phase  - All other
    ///< encodings: Reserved Note: You must contact your PHY vendor to ensure
    ///< 24 ms timeout does not occur in presets requests in EQ master phase,
    ///< that is, you must set a proper value to the GEN3_EQ_PSET_REQ_VEC register
    ///< so that the EQ tunning for Figure of Merit in the EQ master phase
    ///< completes before 24 ms timeout. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
    ///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
    ///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x7FF"
    uint32_t GEN3_EQ_FOM_INC_INITIAL_EVAL : 1;
    ///< Include Initial FOM. Include or not the FOM feedback from the initial
    ///< preset evaluation performed in the EQ Master, when finding the highest
    ///< FOM among all preset evaluations. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
    ///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
    ///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
    ///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
    ///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
    ///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate. Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="24" ResetValue="0x1"
    uint32_t GEN3_EQ_PSET_REQ_AS_COEF : 1;
    ///< GEN3_EQ_PSET_REQ_AS_COEF is an internally reserved field. Do not use.
    ///< Note: This register field is sticky.
    ///< AccessType="RW/V" BitOffset="25" ResetValue="0x0"
    uint32_t GEN3_REQ_SEND_CONSEC_EIEOS_FOR_PSET_MAP : 1;
    ///< Request controller to send back-to-back EIEOS in Recovery.RcvrLock
    ///< state until presets to coefficients mapping is complete. Note: Gen3
    ///< and Gen4 share the same register bit and have the same feature.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="26" ResetValue="0x1"
    uint32_t GEN3_EQ_REQ_NUM : 3;
    ///< The number of back-to-back equalization redo requests at a given Gen3,
    ///< Gen4 and Gen5 data rate for USP. After counting the EQ redo requests
    ///< which are equal to or larger than the number set, the USP stops any
    ///< EQ redo requests at the data rate. If changing speed, the USP controller
    ///< clears the counter to 0. Then re-start to count the requests after
    ///< changing speed back to the data rate for the USP. Note: Gen3, Gen4
    ///< and Gen5 share the same register bits and have the same feature.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="27" ResetValue="0x1"
    uint32_t GEN3_SUPPORT_FINITE_EQ_REQUEST : 1;
    ///< Support finite EQ requests for USP. Note: Gen3, Gen4 and Gen5 share
    ///< the same register bit and have the same feature.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen3_eq_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_DEFAULT (0x0d07ff61U)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_RD_MASK (0x7fffffffU)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_WR_MASK (0x7fffffffU)


///< Feedback Mode. Other values are reserved. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate. Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FB_MODE_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FB_MODE_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FB_MODE_BF_MSK (0x0000000F)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FB_MODE_BF_DEF (0x00000001)

///< Behavior After 24 ms Timeout (when optimal settings are not found).
///< For a USP: Determine next LTSSM state from Phase2 after 24ms Timeout
///< - 0: Recovery.Speed  - 1: Recovery.Equalization.Phase3 When optimal
///< settings are not found then:  - Equalization Phase 2 Successful status
///< bit is not set in the  Link Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE
///< = 0  - Equalization Phase 2 Successful status bit is set in the  Link
///< Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE = 1  - Equalization
///< Phase 2 Complete status bit is set in the  Link Status Register 2
///< For a DSP: Determine next LTSSM state from Phase3 after 24ms Timeout
///< - 0: Recovery.Speed  - 1: Recovery.Equalization.RcvrLock When optimal
///< settings are not found then:  - Equalization Phase 3 Successful status
///< bit is not set in the  Link Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE
///< = 0  - Equalization Phase 3 Successful status bit is set in the  Link
///< Status Register 2  when GEN3_EQ_PHASE23_EXIT_MODE = 1  - Equalization
///< Phase 3 Complete status bit is set in the  Link Status Register 2
///< Note: GEN3_EQ_PHASE23_EXIT_MODE = 1 affects Direction Change feed
///< back mode. EQ requests for Figure Of Merit mode complete before 24ms
///< timeout. For more information, see GEN3_EQ_PSET_REQ_VEC Register.
///< Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED, this register
///< is shadow register for Gen3 and Gen4/Gen5/Gen6 data rate.  - If RATE_SHADOW_SEL==00b,
///< this register is for Gen3 data rate.  - If RATE_SHADOW_SEL==01b, this
///< register is for Gen4 data rate.  - If RATE_SHADOW_SEL==10b, this register
///< is for Gen5 data rate.  - If RATE_SHADOW_SEL==11b, this register is
///< for Gen6 data rate.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PHASE23_EXIT_MODE_BF_OFF ( 4)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PHASE23_EXIT_MODE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PHASE23_EXIT_MODE_BF_MSK (0x00000010)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PHASE23_EXIT_MODE_BF_DEF (0x00000000)

///< Phase2_3 2 ms Timeout Disable. Determine behavior in Phase2 for USP
///< (Phase3 if DSP) when the PHY does not respond within 2ms to the assertion
///< of RxEqEval. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_DIS_BF_OFF ( 5)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_DIS_BF_MSK (0x00000020)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_DIS_BF_DEF (0x00000020)

///< Support EQ redo and lower rate change. To access this field, RATE_SHADOW_SEL
///< should be set to 0. Note: Gen3 and Gen4 share the same register bit
///< and have the same feature.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_LOWER_RATE_EQ_REDO_EN_BF_OFF ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_LOWER_RATE_EQ_REDO_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_LOWER_RATE_EQ_REDO_EN_BF_MSK (0x00000040)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_LOWER_RATE_EQ_REDO_EN_BF_DEF (0x00000040)

///< Phase2_3 extend default Timeout from 2 ms to 4 ms. In Phase2 for USP
///< (Phase3 if DSP) when PHY require more response time to the assertion
///< of RxEqEval timeout is extended to 4 ms Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_EXTEND_BF_OFF ( 7)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_EXTEND_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_EXTEND_BF_MSK (0x00000080)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_EVAL_2MS_EXTEND_BF_DEF (0x00000000)

///< Preset Request Vector. Requesting of Presets during the initial part
///< of the EQ Master Phase. Encoding scheme is as follows:   Bit [15:0]
///< =0x0: No preset is requested and evaluated in EQ Master Phase.   Bit
///< [i] =1:  Preset=i  is requested and evaluated in EQ Master Phase.
///< - 0x0000000000000000: No preset be requested and evaluated in EQ Master
///< Phase  - 0x000000xxxxxxxxx1: Preset 0 is requested and evaluated in
///< EQ Master Phase  - 0x000000xxxxxxxx1x: Preset 1 is requested and evaluated
///< in EQ Master Phase  - 0x000000xxxxxxx1xx: Preset 2 is requested and
///< evaluated in EQ Master Phase  - 0x000000xxxxxx1xxx: Preset 3 is requested
///< and evaluated in EQ Master Phase  - 0x000000xxxxx1xxxx: Preset 4 is
///< requested and evaluated in EQ Master Phase  - 0x000000xxxx1xxxxx:
///< Preset 5 is requested and evaluated in EQ Master Phase  - 0x000000xxx1xxxxxx:
///< Preset 6 is requested and evaluated in EQ Master Phase  - 0x000000xx1xxxxxxx:
///< Preset 7 is requested and evaluated in EQ Master Phase  - 0x000000x1xxxxxxxx:
///< Preset 8 is requested and evaluated in EQ Master Phase  - 0x00000x1xxxxxxxxx:
///< Preset 9 is requested and evaluated in EQ Master Phase  - 0x000001xxxxxxxxxx:
///< Preset 10 is requested and evaluated in EQ Master Phase  - All other
///< encodings: Reserved Note: You must contact your PHY vendor to ensure
///< 24 ms timeout does not occur in presets requests in EQ master phase,
///< that is, you must set a proper value to the GEN3_EQ_PSET_REQ_VEC register
///< so that the EQ tunning for Figure of Merit in the EQ master phase
///< completes before 24 ms timeout. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_VEC_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_VEC_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_VEC_BF_MSK (0x00FFFF00)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_VEC_BF_DEF (0x0007FF00)

///< Include Initial FOM. Include or not the FOM feedback from the initial
///< preset evaluation performed in the EQ Master, when finding the highest
///< FOM among all preset evaluations. Note:  - When CX_GEN4_SPEED/CX_GEN5_SPEED/CX_GEN6_SPEED,
///< this register is shadow register for Gen3 and Gen4/Gen5/Gen6 data
///< rate.  - If RATE_SHADOW_SEL==00b, this register is for Gen3 data rate.
///< - If RATE_SHADOW_SEL==01b, this register is for Gen4 data rate.  -
///< If RATE_SHADOW_SEL==10b, this register is for Gen5 data rate.  - If
///< RATE_SHADOW_SEL==11b, this register is for Gen6 data rate. Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FOM_INC_INITIAL_EVAL_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FOM_INC_INITIAL_EVAL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FOM_INC_INITIAL_EVAL_BF_MSK (0x01000000)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_FOM_INC_INITIAL_EVAL_BF_DEF (0x01000000)

///< GEN3_EQ_PSET_REQ_AS_COEF is an internally reserved field. Do not use.
///< Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_AS_COEF_BF_OFF (25)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_AS_COEF_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_AS_COEF_BF_MSK (0x02000000)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_PSET_REQ_AS_COEF_BF_DEF (0x00000000)

///< Request controller to send back-to-back EIEOS in Recovery.RcvrLock
///< state until presets to coefficients mapping is complete. Note: Gen3
///< and Gen4 share the same register bit and have the same feature.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_REQ_SEND_CONSEC_EIEOS_FOR_PSET_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_REQ_SEND_CONSEC_EIEOS_FOR_PSET_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_REQ_SEND_CONSEC_EIEOS_FOR_PSET_BF_MSK (0x04000000)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_REQ_SEND_CONSEC_EIEOS_FOR_PSET_BF_DEF (0x04000000)

///< The number of back-to-back equalization redo requests at a given Gen3,
///< Gen4 and Gen5 data rate for USP. After counting the EQ redo requests
///< which are equal to or larger than the number set, the USP stops any
///< EQ redo requests at the data rate. If changing speed, the USP controller
///< clears the counter to 0. Then re-start to count the requests after
///< changing speed back to the data rate for the USP. Note: Gen3, Gen4
///< and Gen5 share the same register bits and have the same feature.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_REQ_NUM_BF_OFF (27)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_REQ_NUM_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_REQ_NUM_BF_MSK (0x38000000)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_EQ_REQ_NUM_BF_DEF (0x08000000)

///< Support finite EQ requests for USP. Note: Gen3, Gen4 and Gen5 share
///< the same register bit and have the same feature.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_SUPPORT_FINITE_EQ_REQUEST_BF_OFF (30)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_SUPPORT_FINITE_EQ_REQUEST_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_SUPPORT_FINITE_EQ_REQUEST_BF_MSK (0x40000000)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_GEN3_SUPPORT_FINITE_EQ_REQUEST_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_ORDER_RULE_CTRL_OFF register description at address offset 0x8b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/ORDER_RULE_CTRL_OFF
  * Order Rule Control Register.
  */

typedef union {
  struct {
    uint32_t NP_PASS_P : 8;
    ///< Non-Posted Passing Posted Ordering Rule Control.   Determines if NP
    ///< can pass halted P queue.   TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CPL_PASS_P : 8;
    ///< Completion Passing Posted Ordering Rule Control.   Determines if CPL
    ///< can pass halted P queue.   TDISP Prot :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_order_rule_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_RD_MASK (0x0000ffffU)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_WR_MASK (0x0000ffffU)


///< Non-Posted Passing Posted Ordering Rule Control.   Determines if NP
///< can pass halted P queue.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_NP_PASS_P_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_NP_PASS_P_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_NP_PASS_P_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_NP_PASS_P_BF_DEF (0x00000000)

///< Completion Passing Posted Ordering Rule Control.   Determines if CPL
///< can pass halted P queue.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_CPL_PASS_P_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_CPL_PASS_P_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_CPL_PASS_P_BF_MSK (0x0000FF00)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_CPL_PASS_P_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PIPE_LOOPBACK_CONTROL_OFF register description at address offset 0x8b8
  *
  * Register default value:        0x00000003
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PIPE_LOOPBACK_CONTROL_OFF
  * PIPE Loopback Control Register.
  */

typedef union {
  struct {
    uint32_t LPBK_RXVALID : 16;
    ///< LPBK_RXVALID is an internally reserved field. Do not use.  Note: This
    ///< register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x3"
    uint32_t RXSTATUS_LANE : 6;
    ///< RXSTATUS_LANE is an internally reserved field. Do not use.  Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t RXSTATUS_VALUE : 3;
    ///< RXSTATUS_VALUE is an internally reserved field. Do not use.
    ///< AccessType="WS/V" BitOffset="24" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
    uint32_t PIPE_LOOPBACK : 1;
    ///< PIPE Loopback Enable.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pipe_loopback_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_DEFAULT (0x00000003U)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RD_MASK (0x803fffffU)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_WR_MASK (0x873fffffU)


///< LPBK_RXVALID is an internally reserved field. Do not use.  Note: This
///< register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_LPBK_RXVALID_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_LPBK_RXVALID_BF_WID (16)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_LPBK_RXVALID_BF_MSK (0x0000FFFF)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_LPBK_RXVALID_BF_DEF (0x00000003)

///< RXSTATUS_LANE is an internally reserved field. Do not use.  Note:
///< This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_LANE_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_LANE_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_LANE_BF_MSK (0x003F0000)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_LANE_BF_DEF (0x00000000)

///< RXSTATUS_VALUE is an internally reserved field. Do not use.
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_VAL_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_VAL_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_VAL_BF_MSK (0x07000000)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_RXSTAT_VAL_BF_DEF (0x00000000)

///< PIPE Loopback Enable.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_PIPE_LOOPBACK_BF_OFF (31)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_PIPE_LOOPBACK_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_PIPE_LOOPBACK_BF_MSK (0x80000000)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_PIPE_LOOPBACK_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_MISC_CONTROL_1_OFF register description at address offset 0x8bc
  *
  * Register default value:        0x02474048
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/MISC_CONTROL_1_OFF
  * DBI Read-Only Write Enable Register.
  */

typedef union {
  struct {
    uint32_t DBI_RO_WR_EN : 1;
    ///< Write to RO Registers Using DBI. For more information, see  Writing
    ///< to Read-Only Registers  in  Register Module, LBC, and DBI  section
    ///< in the  Controller Operations  chapter of the Databook.   Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t DEFAULT_TARGET : 1;
    ///< Default target for an IO or MEM request with UR/CA/CRS received. Based
    ///< on the value of this field the controller either drops or forwards
    ///< these requests to your application. For more information, see  ECRC
    ///< Handling  and  Request TLP Routing Rules  in  Receive Routing  section
    ///< of the  Controller Operations  chapter of the Databook.  Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t UR_CA_MASK_4_TRGT1 : 1;
    ///< When this field is set to '1', the controller suppresses error logging,
    ///< error message generation, and CPL generation for non-posted requests
    ///< TLPs (with UR filtering status) forwarded to your application (that
    ///< is, when DEFAULT_TARGET =1). For more information, see  Advanced Error
    ///< Handling For Received TLPs  chapter of the Databook.   Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t SIMPLIFIED_REPLAY_TIMER : 1;
    ///< Enables Simplified Replay Timer (Gen4). For more information, see
    ///< Transmit Replay  in  Transmit TLP Processing  section in the  Controller
    ///< Operations  chapter of the Databook. Simplified Replay Timer can have
    ///< the following Values:  - A value from 24,000 to 31,000 Symbol Times
    ///< when Extended Synch is 0b.  - A value from 80,000 to 100,000 Symbol
    ///< Times when Extended Synch is 1b. The Simplified Replay Timer value
    ///< must not be changed while the link is in use.   Note: This register
    ///< field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
    uint32_t ARI_DEVICE_NUMBER : 1;
    ///< When ARI is enabled, this field enables use of the device ID.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CPLQ_MNG_EN : 1;
    ///< This field enables the Completion Queue Management feature.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint32_t CFG_TLP_BYPASS_EN_REG : 1;
    ///< Setting of this field defines how to decide the destination of Configuration
    ///< requests. Note: When app_req_retry_en is asserted, the setting of
    ///< this field is ignored.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CONFIG_LIMIT_REG : 10;
    ///< Configuration requests are directed either to CDM or ELBI/RTRGT1 based
    ///< on the value of this field.  - Configuration requests with an address
    ///< less CONFIG_LIMIT_REG are directed to the CDM  - Configuration requests
    ///< with an address greater than CONFIG_LIMIT_REG are directed to either
    ///< ELBI or TRGT1 interface based on the setting of TARGET_ABOVE_CONFIG_LIMIT_REG
    ///< field. Your application must set a proper value for this field based
    ///< on your extended configuration registers. For more information, see
    ///< the  CDM/ELBI Register Space Access Through CFG Request  in  Register
    ///< Module, LBC, and DBI  section in the  Controller Operations  chapter
    ///< of the Databook.   Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x340"
    uint32_t TARGET_ABOVE_CONFIG_LIMIT_REG : 2;
    ///< Configuration requests with an address greater than CONFIG_LIMIT_REG
    ///< are directed to either ELBI or TRGT1 interface based on the setting
    ///< of this field. This field can have the following values:   Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint32_t P2P_TRACK_CPL_TO_REG : 1;
    ///< Determines whether to track completion of transmitted Non-Posted TLPs
    ///< in P2P mode.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t P2P_ERR_RPT_CTRL : 1;
    ///< Determines whether to enable Peer to Peer (P2P) error reporting.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t PORT_LOGIC_WR_DISABLE : 1;
    ///< Disable port logic register write from wire side.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R/W (sticky)  Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="22" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t RASDES_REG_PF0_ONLY : 1;
    ///< Allows only Physical Function 0 (PF0) to access the RAS DES Extended
    ///< Capability registers.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R (sticky)   - Dbi: R/W (sticky)  Note: This
    ///< register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t ERR_INJ_WR_DISABLE : 1;
    ///< Disable Error Injection enable bits write from wire side.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R (sticky)
    ///< - Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="25" ResetValue="0x1"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_misc_ctrl_1_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DEFAULT (0x02474048U)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_RD_MASK (0x037fffefU)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_WR_MASK (0x037fffefU)


///< Write to RO Registers Using DBI. For more information, see  Writing
///< to Read-Only Registers  in  Register Module, LBC, and DBI  section
///< in the  Controller Operations  chapter of the Databook.   Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DBI_RO_WR_EN_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DBI_RO_WR_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DBI_RO_WR_EN_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DBI_RO_WR_EN_BF_DEF (0x00000000)

///< Default target for an IO or MEM request with UR/CA/CRS received. Based
///< on the value of this field the controller either drops or forwards
///< these requests to your application. For more information, see  ECRC
///< Handling  and  Request TLP Routing Rules  in  Receive Routing  section
///< of the  Controller Operations  chapter of the Databook.  Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DEFAULT_TARGET_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DEFAULT_TARGET_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DEFAULT_TARGET_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_DEFAULT_TARGET_BF_DEF (0x00000000)

///< When this field is set to '1', the controller suppresses error logging,
///< error message generation, and CPL generation for non-posted requests
///< TLPs (with UR filtering status) forwarded to your application (that
///< is, when DEFAULT_TARGET =1). For more information, see  Advanced Error
///< Handling For Received TLPs  chapter of the Databook.   Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_UR_CA_MASK_4_TRGT1_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_UR_CA_MASK_4_TRGT1_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_UR_CA_MASK_4_TRGT1_BF_MSK (0x00000004)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_UR_CA_MASK_4_TRGT1_BF_DEF (0x00000000)

///< Enables Simplified Replay Timer (Gen4). For more information, see
///< Transmit Replay  in  Transmit TLP Processing  section in the  Controller
///< Operations  chapter of the Databook. Simplified Replay Timer can have
///< the following Values:  - A value from 24,000 to 31,000 Symbol Times
///< when Extended Synch is 0b.  - A value from 80,000 to 100,000 Symbol
///< Times when Extended Synch is 1b. The Simplified Replay Timer value
///< must not be changed while the link is in use.   Note: This register
///< field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_SIMPLIFIED_REPLAY_TIMER_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_SIMPLIFIED_REPLAY_TIMER_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_SIMPLIFIED_REPLAY_TIMER_BF_MSK (0x00000008)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_SIMPLIFIED_REPLAY_TIMER_BF_DEF (0x00000008)

///< When ARI is enabled, this field enables use of the device ID.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ARI_DEVICE_NUMBER_BF_OFF ( 5)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ARI_DEVICE_NUMBER_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ARI_DEVICE_NUMBER_BF_MSK (0x00000020)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ARI_DEVICE_NUMBER_BF_DEF (0x00000000)

///< This field enables the Completion Queue Management feature.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CPLQ_MNG_EN_BF_OFF ( 6)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CPLQ_MNG_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CPLQ_MNG_EN_BF_MSK (0x00000040)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CPLQ_MNG_EN_BF_DEF (0x00000040)

///< Setting of this field defines how to decide the destination of Configuration
///< requests. Note: When app_req_retry_en is asserted, the setting of
///< this field is ignored.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_TLP_BYP_EN_BF_OFF ( 7)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_TLP_BYP_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_TLP_BYP_EN_BF_MSK (0x00000080)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_TLP_BYP_EN_BF_DEF (0x00000000)

///< Configuration requests are directed either to CDM or ELBI/RTRGT1 based
///< on the value of this field.  - Configuration requests with an address
///< less CONFIG_LIMIT_REG are directed to the CDM  - Configuration requests
///< with an address greater than CONFIG_LIMIT_REG are directed to either
///< ELBI or TRGT1 interface based on the setting of TARGET_ABOVE_CONFIG_LIMIT_REG
///< field. Your application must set a proper value for this field based
///< on your extended configuration registers. For more information, see
///< the  CDM/ELBI Register Space Access Through CFG Request  in  Register
///< Module, LBC, and DBI  section in the  Controller Operations  chapter
///< of the Databook.   Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_LIMIT_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_LIMIT_BF_WID (10)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_LIMIT_BF_MSK (0x0003FF00)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_CFG_LIMIT_BF_DEF (0x00034000)

///< Configuration requests with an address greater than CONFIG_LIMIT_REG
///< are directed to either ELBI or TRGT1 interface based on the setting
///< of this field. This field can have the following values:   Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_TARGET_ABOVE_CFG_LIMIT_BF_OFF (18)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_TARGET_ABOVE_CFG_LIMIT_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_TARGET_ABOVE_CFG_LIMIT_BF_MSK (0x000C0000)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_TARGET_ABOVE_CFG_LIMIT_BF_DEF (0x00040000)

///< Determines whether to track completion of transmitted Non-Posted TLPs
///< in P2P mode.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_TRACK_CPL_TO_BF_OFF (20)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_TRACK_CPL_TO_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_TRACK_CPL_TO_BF_MSK (0x00100000)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_TRACK_CPL_TO_BF_DEF (0x00000000)

///< Determines whether to enable Peer to Peer (P2P) error reporting.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_ERR_RPT_CTRL_BF_OFF (21)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_ERR_RPT_CTRL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_ERR_RPT_CTRL_BF_MSK (0x00200000)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_P2P_ERR_RPT_CTRL_BF_DEF (0x00000000)

///< Disable port logic register write from wire side.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R/W (sticky)  Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_PORT_LOGIC_WR_DIS_BF_OFF (22)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_PORT_LOGIC_WR_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_PORT_LOGIC_WR_DIS_BF_MSK (0x00400000)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_PORT_LOGIC_WR_DIS_BF_DEF (0x00400000)

///< Allows only Physical Function 0 (PF0) to access the RAS DES Extended
///< Capability registers.   Note: The access attributes of this field
///< are as follows:  - Wire: R (sticky)   - Dbi: R/W (sticky)  Note: This
///< register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_RASDES_PF0_ONLY_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_RASDES_PF0_ONLY_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_RASDES_PF0_ONLY_BF_MSK (0x01000000)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_RASDES_PF0_ONLY_BF_DEF (0x00000000)

///< Disable Error Injection enable bits write from wire side.   Note:
///< The access attributes of this field are as follows:  - Wire: R (sticky)
///< - Dbi: R/W (sticky)  Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ERR_INJ_WR_DIS_BF_OFF (25)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ERR_INJ_WR_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ERR_INJ_WR_DIS_BF_MSK (0x02000000)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ERR_INJ_WR_DIS_BF_DEF (0x02000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_MULTI_LANE_CONTROL_OFF register description at address offset 0x8c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/MULTI_LANE_CONTROL_OFF
  * UpConfigure Multi-lane Control Register.
  */

typedef union {
  struct {
    uint32_t TARGET_LINK_WIDTH : 6;
    ///< Target Link Width.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DIRECT_LINK_WIDTH_CHANGE : 1;
    ///< Directed Link Width Change.  - If the upconfigure_capable variable
    ///< is '1' and the PCIE_CAP_HW_AUTO_WIDTH_DISABLE bit in LINK_CONTROL_LINK_STATUS_REG
    ///< is '0', the controller starts upconfigure or autonomous width downsizing
    ///< (to the TARGET_LINK_WIDTH value) in the Configuration state.  - If
    ///< TARGET_LINK_WIDTH value is 0x0, the controller does not start upconfigure
    ///< or autonomous width downsizing in the Configuration state. The controller
    ///< self-clears this field when the controller accepts this request.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t UPCONFIGURE_SUPPORT : 1;
    ///< Upconfigure Support. The controller sends this value as the Link Upconfigure
    ///< Capability in TS2 Ordered Sets in Configuration.Complete state.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t RELIABILITY_LINK_WIDTH_CHANGE_ENABLE : 1;
    ///< Reduce link width for reliability reasons. RELIABILITY_LINK_WIDTH_CHANGE_ENABLE
    ///< permits reducing link width for reliability reasons through DIRECT_LINK_WIDTH_CHANGE/TARGET_LINK_WIDTH,
    ///< irrespective of PCIE_CAP_HW_AUTO_WIDTH_DISABLE bit in LINK_CONTROL_LINK_STATUS_REG
    ///< and UPCONFIGURE_SUPPORT.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_multi_lane_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_RD_MASK (0x000001ffU)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_WR_MASK (0x000001ffU)


///< Target Link Width.   Note: The access attributes of this field are
///< as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_TARGET_LINK_WIDTH_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_TARGET_LINK_WIDTH_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_TARGET_LINK_WIDTH_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_TARGET_LINK_WIDTH_BF_DEF (0x00000000)

///< Directed Link Width Change.  - If the upconfigure_capable variable
///< is '1' and the PCIE_CAP_HW_AUTO_WIDTH_DISABLE bit in LINK_CONTROL_LINK_STATUS_REG
///< is '0', the controller starts upconfigure or autonomous width downsizing
///< (to the TARGET_LINK_WIDTH value) in the Configuration state.  - If
///< TARGET_LINK_WIDTH value is 0x0, the controller does not start upconfigure
///< or autonomous width downsizing in the Configuration state. The controller
///< self-clears this field when the controller accepts this request.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_DIRECT_LINK_WIDTH_CHANGE_BF_OFF ( 6)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_DIRECT_LINK_WIDTH_CHANGE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_DIRECT_LINK_WIDTH_CHANGE_BF_MSK (0x00000040)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_DIRECT_LINK_WIDTH_CHANGE_BF_DEF (0x00000000)

///< Upconfigure Support. The controller sends this value as the Link Upconfigure
///< Capability in TS2 Ordered Sets in Configuration.Complete state.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_UPCFGURE_SUPPORT_BF_OFF ( 7)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_UPCFGURE_SUPPORT_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_UPCFGURE_SUPPORT_BF_MSK (0x00000080)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_UPCFGURE_SUPPORT_BF_DEF (0x00000000)

///< Reduce link width for reliability reasons. RELIABILITY_LINK_WIDTH_CHANGE_ENABLE
///< permits reducing link width for reliability reasons through DIRECT_LINK_WIDTH_CHANGE/TARGET_LINK_WIDTH,
///< irrespective of PCIE_CAP_HW_AUTO_WIDTH_DISABLE bit in LINK_CONTROL_LINK_STATUS_REG
///< and UPCONFIGURE_SUPPORT.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_RELIABILITY_LINK_WIDTH_CHANGE_EN_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_RELIABILITY_LINK_WIDTH_CHANGE_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_RELIABILITY_LINK_WIDTH_CHANGE_EN_BF_MSK (0x00000100)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_RELIABILITY_LINK_WIDTH_CHANGE_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PHY_INTEROP_CTRL_OFF register description at address offset 0x8c4
  *
  * Register default value:        0x40064A7F
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PHY_INTEROP_CTRL_OFF
  * PHY Interoperability Control Register.
  */

typedef union {
  struct {
    uint32_t RXSTANDBY_CONTROL : 7;
    ///< Rxstandby Control. Bits 0..5 determine if the controller asserts the
    ///< RxStandby signal (mac_phy_rxstandby) in the indicated condition. Bit
    ///< 6 enables the controller to perform the RxStandby/RxStandbyStatus
    ///< handshake.  This field is reserved for internal use.  You should not
    ///< write to this field and change the default unless specifically instructed
    ///< by Synopsys support.  - [0]: Rx EIOS and subsequent T TX-IDLE-MIN
    ///< - [1]: Rate Change  - [2]: Inactive lane for upconfigure/downconfigure
    ///< - [3]: PowerDown=P1orP2  - [4]: RxL0s.Idle  - [5]: EI Infer in L0
    ///< - [6]: Execute RxStandby/RxStandbyStatus Handshake   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7F"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t L1_NOWAIT_P1 : 1;
    ///< L1 entry control bit.  This field is reserved for internal use.  You
    ///< should not write to this field and change the default unless specifically
    ///< instructed by Synopsys support.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RO" BitOffset="9" ResetValue="0x1"
    uint32_t L1_CLK_SEL : 1;
    ///< L1 Clock control bit.  This field is reserved for internal use.  You
    ///< should not write to this field and change the default unless specifically
    ///< instructed by Synopsys support.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t P2NOBEACON_ENABLE : 1;
    ///< P2.NoBeacon Enable bit. Note:This field is reserved (fixed to '0')
    ///< if CX_P2NOBEACON_ENABLE is not set.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="11" ResetValue="0x1"
    uint32_t PHY_RST_TIMER : 18;
    ///< Control the duration of the PHY reset (PIPE and PMA). Duration is
    ///< in aux clock cycles (0 to 262,142).   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="12" ResetValue="0x64"
    uint32_t PHY_PERST_ON_WARM_RESET : 1;
    ///< Control whether the Power Management Controller will drive pm_req_phy_perst
    ///< during a Warm Reset (PERST# assertion without cycling of power).
    ///< Note: This register field is sticky.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_phy_interop_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_DEFAULT (0x40064a7fU)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_RD_MASK (0x7ffffe7fU)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_WR_MASK (0x7ffffc7fU)


///< Rxstandby Control. Bits 0..5 determine if the controller asserts the
///< RxStandby signal (mac_phy_rxstandby) in the indicated condition. Bit
///< 6 enables the controller to perform the RxStandby/RxStandbyStatus
///< handshake.  This field is reserved for internal use.  You should not
///< write to this field and change the default unless specifically instructed
///< by Synopsys support.  - [0]: Rx EIOS and subsequent T TX-IDLE-MIN
///< - [1]: Rate Change  - [2]: Inactive lane for upconfigure/downconfigure
///< - [3]: PowerDown=P1orP2  - [4]: RxL0s.Idle  - [5]: EI Infer in L0
///< - [6]: Execute RxStandby/RxStandbyStatus Handshake   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CTRL_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CTRL_BF_WID ( 7)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CTRL_BF_MSK (0x0000007F)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CTRL_BF_DEF (0x0000007F)

///< L1 entry control bit.  This field is reserved for internal use.  You
///< should not write to this field and change the default unless specifically
///< instructed by Synopsys support.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W (sticky)   - Dbi: R/W (sticky)
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_NOWAIT_P1_BF_OFF ( 9)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_NOWAIT_P1_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_NOWAIT_P1_BF_MSK (0x00000200)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_NOWAIT_P1_BF_DEF (0x00000200)

///< L1 Clock control bit.  This field is reserved for internal use.  You
///< should not write to this field and change the default unless specifically
///< instructed by Synopsys support.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_CLK_SEL_BF_OFF (10)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_CLK_SEL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_CLK_SEL_BF_MSK (0x00000400)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_L1_CLK_SEL_BF_DEF (0x00000000)

///< P2.NoBeacon Enable bit. Note:This field is reserved (fixed to '0')
///< if CX_P2NOBEACON_ENABLE is not set.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_P2NOBEACON_EN_BF_OFF (11)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_P2NOBEACON_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_P2NOBEACON_EN_BF_MSK (0x00000800)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_P2NOBEACON_EN_BF_DEF (0x00000800)

///< Control the duration of the PHY reset (PIPE and PMA). Duration is
///< in aux clock cycles (0 to 262,142).   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_BF_WID (18)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_BF_MSK (0x3FFFF000)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_BF_DEF (0x00064000)

///< Control whether the Power Management Controller will drive pm_req_phy_perst
///< during a Warm Reset (PERST# assertion without cycling of power).
///< Note: This register field is sticky.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_PERST_ON_WARM_RST_BF_OFF (30)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_PERST_ON_WARM_RST_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_PERST_ON_WARM_RST_BF_MSK (0x40000000)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_PHY_PERST_ON_WARM_RST_BF_DEF (0x40000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF register description at address offset 0x8c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/TRGT_CPL_LUT_DELETE_ENTRY_OFF
  * TRGT_CPL_LUT Delete Entry Control register.
  */

typedef union {
  struct {
    uint32_t LOOK_UP_ID : 31;
    ///< This number selects one entry to delete of the TRGT_CPL_LUT.   TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DELETE_EN : 1;
    ///< This is a one-shot bit. This is a self-clearing register field. Reading
    ///< from this register field always returns a '0'.   TDISP Prot :WP
    ///< AccessType="WS/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_trgt_cpl_lut_delete_entry_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_RD_MASK (0x7fffffffU)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_WR_MASK (0xffffffffU)


///< This number selects one entry to delete of the TRGT_CPL_LUT.   TDISP
///< Prot :WP
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_BF_WID (31)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_BF_MSK (0x7FFFFFFF)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_BF_DEF (0x00000000)

///< This is a one-shot bit. This is a self-clearing register field. Reading
///< from this register field always returns a '0'.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DELETE_EN_BF_OFF (31)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DELETE_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DELETE_EN_BF_MSK (0x80000000)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DELETE_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_LINK_FLUSH_CONTROL_OFF register description at address offset 0x8cc
  *
  * Register default value:        0xFF000001
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/LINK_FLUSH_CONTROL_OFF
  * Link Reset Request Flush Control Register.
  */

typedef union {
  struct {
    uint32_t AUTO_FLUSH_EN : 1;
    ///< Enables automatic flushing of pending requests before sending the
    ///< reset request to the application logic to reset the PCIe controller
    ///< and the application. The flushing process is initiated if any of the
    ///< following events occur:  - Hot reset request. A downstream port (DSP)
    ///< can  hot reset  an upstream port (USP) by sending two consecutive
    ///< TS1 ordered sets with the hot reset bit asserted.  - Warm (Soft) reset
    ///< request. Generated when exiting from D3 to D0 and cfg_pm_no_soft_rst=0.
    ///< - Link down reset request. A high to low transition on smlh_req_rst_not
    ///< indicates the link has gone down and the controller is requesting
    ///< a reset. If you disable automatic flushing, your application is responsible
    ///< for resetting the PCIe controller, including the AXI Bridge (when
    ///< present). For more information see  Warm and Hot Resets  section in
    ///< the Architecture chapter of the Databook.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
    uint32_t AUTO_FLUSH_TIMEOUT : 8;
    ///< Timeout Value (ms) for automatic flushing. The timer acts as a watch
    ///< dog timer during the auto flushing. The timer counts when there are
    ///< pending outbound requests and the PCIe TX link is not transmitting
    ///< any of these requests. The timer is clocked by core_clk.   Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0xFF"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_link_flush_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_DEFAULT (0xff000001U)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_RD_MASK (0xff000001U)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_WR_MASK (0xff000001U)


///< Enables automatic flushing of pending requests before sending the
///< reset request to the application logic to reset the PCIe controller
///< and the application. The flushing process is initiated if any of the
///< following events occur:  - Hot reset request. A downstream port (DSP)
///< can  hot reset  an upstream port (USP) by sending two consecutive
///< TS1 ordered sets with the hot reset bit asserted.  - Warm (Soft) reset
///< request. Generated when exiting from D3 to D0 and cfg_pm_no_soft_rst=0.
///< - Link down reset request. A high to low transition on smlh_req_rst_not
///< indicates the link has gone down and the controller is requesting
///< a reset. If you disable automatic flushing, your application is responsible
///< for resetting the PCIe controller, including the AXI Bridge (when
///< present). For more information see  Warm and Hot Resets  section in
///< the Architecture chapter of the Databook.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_EN_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_EN_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_EN_BF_DEF (0x00000001)

///< Timeout Value (ms) for automatic flushing. The timer acts as a watch
///< dog timer during the auto flushing. The timer counts when there are
///< pending outbound requests and the PCIe TX link is not transmitting
///< any of these requests. The timer is clocked by core_clk.   Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_TIMEOUT_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_TIMEOUT_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_TIMEOUT_BF_MSK (0xFF000000)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_AUTO_FLUSH_TIMEOUT_BF_DEF (0xFF000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_AMBA_ERROR_RESPONSE_DEFAULT_OFF register description at address offset 0x8d0
  *
  * Register default value:        0x00009C00
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/AMBA_ERROR_RESPONSE_DEFAULT_OFF
  * AXI Bridge Subordinate Error Response Register.
  */

typedef union {
  struct {
    uint32_t AMBA_ERROR_RESPONSE_GLOBAL : 1;
    ///< Global Slave Error Response Mapping. Determines the AXI subordinate
    ///< response for all error scenarios on non-posted requests. For more
    ///< information see  Error Handling  in the AXI chapter of the Databook.
    ///< The error response mapping is not applicable to Non-existent Vendor
    ///< ID register reads.  Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
    uint32_t AMBA_ERROR_RESPONSE_VENDORID : 1;
    ///< Vendor ID Non-existent Slave Error Response Mapping. Determines the
    ///< AXI subordinate response for errors on reads to non-existent Vendor
    ///< ID register. For more information see  Error Handling  in the AXI
    ///< chapter of the Databook.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t AMBA_ERROR_RESPONSE_CRS : 2;
    ///< CRS Slave Error Response Mapping. Determines the AXI subordinate response
    ///< for CRS completions. For more information see  Error Handling  in
    ///< the AXI chapter of the Databook.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
    uint32_t AMBA_ERROR_RESPONSE_MAP : 6;
    ///< AXI Subordinate Response Error Map. Allows you to selectively map
    ///< the errors received from the PCIe completion (for non-posted requests)
    ///< to the AXI subordinate responses, slv_rresp or slv_bresp. The recommended
    ///< setting is SLVERR. CRS is always mapped to OKAY.  - 0  -- 0x0: UR
    ///< (unsupported request) -> DECERR  -- 0x1: UR (unsupported request)
    ///< -> SLVERR  - 1  -- 0x0: CRS (configuration retry status) -> DECERR
    ///< -- 0x1: CRS (configuration retry status) -> SLVERR  - 2  -- 0x0: CA
    ///< (completer abort) -> DECERR  -- 0x1: CA (completer abort) -> SLVERR
    ///< - 3: RESERVED (0x0)  - 4: RESERVED (0x0)  - 5  -- 0x0: Completion
    ///< Timeout -> DECERR  -- 0x1: Completion Timeout -> SLVERR. The AXI bridge
    ///< internally drops (processes internally but not passed to your application)
    ///< a completion that has been marked by the Rx filter as UC or MLF, and
    ///< does not pass its status directly down to the slave interface. It
    ///< waits for a timeout and then signals  Completion Timeout  to the slave
    ///< interface. The controller sets the AXI subordinate read databus to
    ///< 0xFFFF for all error responses.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="10" ResetValue="0x27"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_amba_err_rsp_default_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_DEFAULT (0x00009c00U)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_RD_MASK (0x0000fc1dU)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_WR_MASK (0x0000fc1dU)


///< Global Slave Error Response Mapping. Determines the AXI subordinate
///< response for all error scenarios on non-posted requests. For more
///< information see  Error Handling  in the AXI chapter of the Databook.
///< The error response mapping is not applicable to Non-existent Vendor
///< ID register reads.  Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_GLOBAL_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_GLOBAL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_GLOBAL_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_GLOBAL_BF_DEF (0x00000000)

///< Vendor ID Non-existent Slave Error Response Mapping. Determines the
///< AXI subordinate response for errors on reads to non-existent Vendor
///< ID register. For more information see  Error Handling  in the AXI
///< chapter of the Databook.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_VENDORID_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_VENDORID_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_VENDORID_BF_MSK (0x00000004)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_VENDORID_BF_DEF (0x00000000)

///< CRS Slave Error Response Mapping. Determines the AXI subordinate response
///< for CRS completions. For more information see  Error Handling  in
///< the AXI chapter of the Databook.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_CRS_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_CRS_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_CRS_BF_MSK (0x00000018)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_CRS_BF_DEF (0x00000000)

///< AXI Subordinate Response Error Map. Allows you to selectively map
///< the errors received from the PCIe completion (for non-posted requests)
///< to the AXI subordinate responses, slv_rresp or slv_bresp. The recommended
///< setting is SLVERR. CRS is always mapped to OKAY.  - 0  -- 0x0: UR
///< (unsupported request) -> DECERR  -- 0x1: UR (unsupported request)
///< -> SLVERR  - 1  -- 0x0: CRS (configuration retry status) -> DECERR
///< -- 0x1: CRS (configuration retry status) -> SLVERR  - 2  -- 0x0: CA
///< (completer abort) -> DECERR  -- 0x1: CA (completer abort) -> SLVERR
///< - 3: RESERVED (0x0)  - 4: RESERVED (0x0)  - 5  -- 0x0: Completion
///< Timeout -> DECERR  -- 0x1: Completion Timeout -> SLVERR. The AXI bridge
///< internally drops (processes internally but not passed to your application)
///< a completion that has been marked by the Rx filter as UC or MLF, and
///< does not pass its status directly down to the slave interface. It
///< waits for a timeout and then signals  Completion Timeout  to the slave
///< interface. The controller sets the AXI subordinate read databus to
///< 0xFFFF for all error responses.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_BF_OFF (10)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_BF_MSK (0x0000FC00)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_AMBA_ERR_RSP_BF_DEF (0x00009C00)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF register description at address offset 0x8d4
  *
  * Register default value:        0x00000032
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/AMBA_LINK_TIMEOUT_OFF
  * Link Down AXI Bridge Subordinate Timeout Register.
  */

typedef union {
  struct {
    uint32_t LINK_TIMEOUT_PERIOD_DEFAULT : 8;
    ///< Timeout Value (ms). The timer will timeout and then flush the bridge
    ///< TX request queues after this amount of time. The timer counts when
    ///< there are pending outbound AXI subordinate interface requests and
    ///< the PCIe TX link is not transmitting any of these requests. The timer
    ///< is clocked by core_clk.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x32"
    uint32_t LINK_TIMEOUT_ENABLE_DEFAULT : 1;
    ///< Disable Flush.   Note: This register field is sticky.  TDISP Prot
    ///< :WP
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_amba_link_timeout_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_DEFAULT (0x00000032U)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_RD_MASK (0x000001ffU)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_WR_MASK (0x000001ffU)


///< Timeout Value (ms). The timer will timeout and then flush the bridge
///< TX request queues after this amount of time. The timer counts when
///< there are pending outbound AXI subordinate interface requests and
///< the PCIe TX link is not transmitting any of these requests. The timer
///< is clocked by core_clk.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_BF_MSK (0x000000FF)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_BF_DEF (0x00000032)

///< Disable Flush.   Note: This register field is sticky.  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_EN_DEFAULT_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_EN_DEFAULT_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_EN_DEFAULT_BF_MSK (0x00000100)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_EN_DEFAULT_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF register description at address offset 0x8d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/AMBA_ORDERING_CTRL_OFF
  * AXI Bridge Ordering Control.
  */

typedef union {
  struct {
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t AX_SNP_EN : 1;
    ///< AXI Serialize Non-Posted Requests Enable. This field enables the AXI
    ///< Bridge to serialize same ID Non-Posted Read/Write Requests on the
    ///< wire. Serialization implies one outstanding same ID NP Read or Write
    ///< on the wire and used to avoid AXI RAR and WAW hazards at the remote
    ///< link partner. For more information, see the  Optional Serialization
    ///< of AXI Subordinate Non-posted Requests  section in the AXI chapter
    ///< of the Databook.   TDISP Prot :WP
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t AX_MSTR_ORDR_P_EVENT_SEL : 2;
    ///< AXI Manager Posted Ordering Event Selector.   This field selects how
    ///< the manager interface determines when a P write is completed when
    ///< enforcing the PCIe ordering rule,  NP must not pass P  at the AXI
    ///< Manager Interface. The AXI protocol does not support ordering between
    ///< channels. Therefore, NP reads can pass P on your AXI bus fabric. This
    ///< can result in an ordering violation when the read overtakes a P that
    ///< is going to the same address. Therefore, the bridge manager does not
    ///< issue any NP requests until all outstanding P writes reach their destination.
    ///< It does this by waiting for the all of the write responses on the
    ///< B channel. This can affect the performance of the manager read channel.
    ///< For scenarios where the interconnect serializes the AXI manager  AW
    ///< ,  W  and  AR  channels,you can increase the performance by reducing
    ///< the need to wait until the complete Posted transaction has effectively
    ///< reached the application slave.  Note: This setting will not affect:
    ///< - MSI interrupt catcher and P data ordering. This is always driven
    ///< by the B'last event.  - DMA read engine TLP ordering. This is always
    ///< driven by the B'last event.  - NP write transactions which are always
    ///< serialized with P write transactions. Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot
    ///< :WP
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
    uint32_t AX_MSTR_ZEROLREAD_FW : 1;
    ///< AXI Manager Zero Length Read Forward to the application.   The DW
    ///< PCIe controller AXI bridge is able to terminate in order with the
    ///< Posted transactions the zero length read, implementing the PCIe express
    ///< flush semantics of the Posted transactions.   TDISP Prot :WP
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_amba_ordering_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_RD_MASK (0x0000009aU)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_WR_MASK (0x0000009aU)


///< AXI Serialize Non-Posted Requests Enable. This field enables the AXI
///< Bridge to serialize same ID Non-Posted Read/Write Requests on the
///< wire. Serialization implies one outstanding same ID NP Read or Write
///< on the wire and used to avoid AXI RAR and WAW hazards at the remote
///< link partner. For more information, see the  Optional Serialization
///< of AXI Subordinate Non-posted Requests  section in the AXI chapter
///< of the Databook.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_SNP_EN_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_SNP_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_SNP_EN_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_SNP_EN_BF_DEF (0x00000000)

///< AXI Manager Posted Ordering Event Selector.   This field selects how
///< the manager interface determines when a P write is completed when
///< enforcing the PCIe ordering rule,  NP must not pass P  at the AXI
///< Manager Interface. The AXI protocol does not support ordering between
///< channels. Therefore, NP reads can pass P on your AXI bus fabric. This
///< can result in an ordering violation when the read overtakes a P that
///< is going to the same address. Therefore, the bridge manager does not
///< issue any NP requests until all outstanding P writes reach their destination.
///< It does this by waiting for the all of the write responses on the
///< B channel. This can affect the performance of the manager read channel.
///< For scenarios where the interconnect serializes the AXI manager  AW
///< ,  W  and  AR  channels,you can increase the performance by reducing
///< the need to wait until the complete Posted transaction has effectively
///< reached the application slave.  Note: This setting will not affect:
///< - MSI interrupt catcher and P data ordering. This is always driven
///< by the B'last event.  - DMA read engine TLP ordering. This is always
///< driven by the B'last event.  - NP write transactions which are always
///< serialized with P write transactions. Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W  TDISP Prot
///< :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_BF_WID ( 2)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_BF_MSK (0x00000018)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_BF_DEF (0x00000000)

///< AXI Manager Zero Length Read Forward to the application.   The DW
///< PCIe controller AXI bridge is able to terminate in order with the
///< Posted transactions the zero length read, implementing the PCIe express
///< flush semantics of the Posted transactions.   TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ZEROLREAD_FW_BF_OFF ( 7)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ZEROLREAD_FW_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ZEROLREAD_FW_BF_MSK (0x00000080)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ZEROLREAD_FW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_COHERENCY_CONTROL_1_OFF register description at address offset 0x8e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/COHERENCY_CONTROL_1_OFF
  * Cache Coherency Control Register 1.
  */

typedef union {
  struct {
    uint32_t CFG_MEMTYPE_VALUE : 1;
    ///< Sets the memory type for the lower and upper parts of the address
    ///< space:   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
    uint32_t CFG_MEMTYPE_BOUNDARY_LOW_ADDR : 30;
    ///< Boundary Lower Address For Memory Type. Bits [31:0] of dword-aligned
    ///< address of the boundary for Memory type. The two lower address LSBs
    ///< are '00'. Addresses up to but not including this value are in the
    ///< lower address space region; addresses equal or greater than this value
    ///< are in the upper address space region.   Note: This register field
    ///< is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_coherency_ctrl_1_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_RD_MASK (0xfffffffdU)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_WR_MASK (0xfffffffdU)


///< Sets the memory type for the lower and upper parts of the address
///< space:   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_VAL_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_VAL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_VAL_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_VAL_BF_DEF (0x00000000)

///< Boundary Lower Address For Memory Type. Bits [31:0] of dword-aligned
///< address of the boundary for Memory type. The two lower address LSBs
///< are '00'. Addresses up to but not including this value are in the
///< lower address space region; addresses equal or greater than this value
///< are in the upper address space region.   Note: This register field
///< is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_BF_WID (30)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_BF_MSK (0xFFFFFFFC)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_COHERENCY_CONTROL_3_OFF register description at address offset 0x8e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/COHERENCY_CONTROL_3_OFF
  * Cache Coherency Control Register 3.
  */

typedef union {
  struct {
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t CFG_MSTR_ARCACHE_MODE : 4;
    ///< Master Read CACHE Signal Behavior. Defines how the individual bits
    ///< in mstr_arcache are controlled.   Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t CFG_MSTR_AWCACHE_MODE : 4;
    ///< Master Write CACHE Signal Behavior. Defines how the individual bits
    ///< in mstr_awcache are controlled.  Note: for message requests the value
    ///< of mstr_awcache is always  0000  regardless of the value of this bit.
    ///< Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
    uint32_t CFG_MSTR_ARCACHE_VALUE : 4;
    ///< Master Read CACHE Signal Value. Value of the individual bits in mstr_arcache
    ///< when CFG_MSTR_ARCACHE_MODE is '1'.   Note: This register field is
    ///< sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t CFG_MSTR_AWCACHE_VALUE : 4;
    ///< Master Write CACHE Signal Value. Value of the individual bits in mstr_awcache
    ///< when CFG_MSTR_AWCACHE_MODE is '1'.  Note: Not applicable to message
    ///< requests; for message requests the value of mstr_awcache is always
    ///< '0000'.   Note: This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_coherency_ctrl_3_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_RD_MASK (0x78787878U)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_WR_MASK (0x78787878U)


///< Master Read CACHE Signal Behavior. Defines how the individual bits
///< in mstr_arcache are controlled.   Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_MODE_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_MODE_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_MODE_BF_MSK (0x00000078)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_MODE_BF_DEF (0x00000000)

///< Master Write CACHE Signal Behavior. Defines how the individual bits
///< in mstr_awcache are controlled.  Note: for message requests the value
///< of mstr_awcache is always  0000  regardless of the value of this bit.
///< Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_MODE_BF_OFF (11)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_MODE_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_MODE_BF_MSK (0x00007800)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_MODE_BF_DEF (0x00000000)

///< Master Read CACHE Signal Value. Value of the individual bits in mstr_arcache
///< when CFG_MSTR_ARCACHE_MODE is '1'.   Note: This register field is
///< sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_VAL_BF_OFF (19)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_VAL_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_VAL_BF_MSK (0x00780000)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_ARCACHE_VAL_BF_DEF (0x00000000)

///< Master Write CACHE Signal Value. Value of the individual bits in mstr_awcache
///< when CFG_MSTR_AWCACHE_MODE is '1'.  Note: Not applicable to message
///< requests; for message requests the value of mstr_awcache is always
///< '0000'.   Note: This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_VAL_BF_OFF (27)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_VAL_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_VAL_BF_MSK (0x78000000)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_CFG_MSTR_AWCACHE_VAL_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF register description at address offset 0x8f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/AXI_MSTR_MSG_ADDR_LOW_OFF
  * Lower 32-bits of the Programmable AXI Address.
  */

typedef union {
  struct {
    uint32_t CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED : 12;
    ///< Reserved for future use.   Note: This register field is sticky.  TDISP
    ///< Prot :WP
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_AXIMSTR_MSG_ADDR_LOW : 20;
    ///< Lower 20-bits of the programmable AXI address for Messages.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_axi_mstr_msg_addr_low_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_WR_MASK (0xfffff000U)


///< Reserved for future use.   Note: This register field is sticky.  TDISP
///< Prot :WP
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_BF_WID (12)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_BF_MSK (0x00000FFF)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_BF_DEF (0x00000000)

///< Lower 20-bits of the programmable AXI address for Messages.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_BF_WID (20)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_BF_MSK (0xFFFFF000)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF register description at address offset 0x8f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/AXI_MSTR_MSG_ADDR_HIGH_OFF
  * Upper 32-bits of the Programmable AXI Address.
  */

typedef union {
  struct {
    uint32_t CFG_AXIMSTR_MSG_ADDR_HIGH : 32;
    ///< Upper 32 bits of the programmable AXI address for Messages.   Note:
    ///< This register field is sticky.  TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_axi_mstr_msg_addr_high_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_WR_MASK (0xffffffffU)


///< Upper 32 bits of the programmable AXI address for Messages.   Note:
///< This register field is sticky.  TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PCIE_VERSION_NUMBER_OFF register description at address offset 0x8f8
  *
  * Register default value:        0x3631322A
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PCIE_VERSION_NUMBER_OFF
  * PCIe Controller IIP Release Version Number.
  */

typedef union {
  struct {
    uint32_t VERSION_NUMBER : 32;
    ///< Version Number.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x3631322A"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pcie_ver_number_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_DEFAULT (0x3631322aU)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_WR_MASK (0x00000000U)


///< Version Number.
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_VER_NUMBER_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_VER_NUMBER_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_VER_NUMBER_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_VER_NUMBER_BF_DEF (0x3631322A)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PCIE_VERSION_TYPE_OFF register description at address offset 0x8fc
  *
  * Register default value:        0x6C633031
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PCIE_VERSION_TYPE_OFF
  * PCIe Controller IIP Release Version Type.
  */

typedef union {
  struct {
    uint32_t VERSION_TYPE : 32;
    ///< Version Type.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x6C633031"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pcie_ver_type_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_DEFAULT (0x6c633031U)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_WR_MASK (0x00000000U)


///< Version Type.
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_VER_TYPE_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_VER_TYPE_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_VER_TYPE_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_VER_TYPE_BF_DEF (0x6C633031)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_MSIX_ADDRESS_MATCH_LOW_OFF register description at address offset 0x940
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/MSIX_ADDRESS_MATCH_LOW_OFF
  * MSI-X Address Match Low Register.
  */

typedef union {
  struct {
    uint32_t MSIX_ADDRESS_MATCH_EN : 1;
    ///< MSI-X Match Enable. Enable the MSI-X Address Match feature when the
    ///< AXI bridge is present.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MSIX_ADDRESS_MATCH_RESERVED_1 : 1;
    ///< Reserved.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t MSIX_ADDRESS_MATCH_LOW : 30;
    ///< MSI-X Address Match Low Address.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_msix_match_low_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_WR_MASK (0xfffffffdU)


///< MSI-X Match Enable. Enable the MSI-X Address Match feature when the
///< AXI bridge is present.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_EN_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_EN_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_EN_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_RESERVED_1_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_RESERVED_1_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_RESERVED_1_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_RESERVED_1_BF_DEF (0x00000000)

///< MSI-X Address Match Low Address.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_LOW_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_LOW_BF_WID (30)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_LOW_BF_MSK (0xFFFFFFFC)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_MSIX_MATCH_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_MSIX_ADDRESS_MATCH_HIGH_OFF register description at address offset 0x944
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/MSIX_ADDRESS_MATCH_HIGH_OFF
  * MSIX Address Match High Register.
  */

typedef union {
  struct {
    uint32_t MSIX_ADDRESS_MATCH_HIGH : 32;
    ///< MSI-X Address Match High Address.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_msix_match_high_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_WR_MASK (0xffffffffU)


///< MSI-X Address Match High Address.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_MSIX_MATCH_HIGH_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_MSIX_MATCH_HIGH_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_MSIX_MATCH_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_MSIX_MATCH_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_MSIX_DOORBELL_OFF register description at address offset 0x948
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/MSIX_DOORBELL_OFF
  * MSI-X Doorbell Register.
  */

typedef union {
  struct {
    uint32_t MSIX_DOORBELL_VECTOR : 11;
    ///< MSI-X Doorbell Vector. This register determines which vector to generate
    ///< the MSI-X transaction for.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint32_t MSIX_DOORBELL_RESERVED_11 : 1;
    ///< Reserved.
    ///< AccessType="WS" BitOffset="11" ResetValue="0x0"
    uint32_t MSIX_DOORBELL_TC : 3;
    ///< MSIX Doorbell Traffic Class. This register determines which traffic
    ///< class to generate the MSI-X transaction with.
    ///< AccessType="WS" BitOffset="12" ResetValue="0x0"
    uint32_t MSIX_DOORBELL_VF_ACTIVE : 1;
    ///< MSIX Doorbell Virtual Function Active. This register determines whether
    ///< a Virtual Function is used to generate the MSI-X transaction.
    ///< AccessType="WS" BitOffset="15" ResetValue="0x0"
    uint32_t MSIX_DOORBELL_VF : 8;
    ///< MSIX Doorbell Virtual Function. This register determines the Virtual
    ///< Function for the MSI-X transaction.
    ///< AccessType="WS" BitOffset="16" ResetValue="0x0"
    uint32_t MSIX_DOORBELL_PF : 5;
    ///< MSIX Doorbell Physical Function. This register determines the Physical
    ///< Function for the MSI-X transaction.
    ///< AccessType="WS" BitOffset="24" ResetValue="0x0"
    uint32_t MSIX_DOORBELL_RESERVED_29_31 : 3;
    ///< Reserved.
    ///< AccessType="WS" BitOffset="29" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_msix_doorbell_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_RD_MASK (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_WR_MASK (0xffffffffU)


///< MSI-X Doorbell Vector. This register determines which vector to generate
///< the MSI-X transaction for.
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VECTOR_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VECTOR_BF_WID (11)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VECTOR_BF_MSK (0x000007FF)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VECTOR_BF_DEF (0x00000000)

///< Reserved.
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_11_BF_OFF (11)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_11_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_11_BF_MSK (0x00000800)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_11_BF_DEF (0x00000000)

///< MSIX Doorbell Traffic Class. This register determines which traffic
///< class to generate the MSI-X transaction with.
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_TC_BF_OFF (12)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_TC_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_TC_BF_MSK (0x00007000)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_TC_BF_DEF (0x00000000)

///< MSIX Doorbell Virtual Function Active. This register determines whether
///< a Virtual Function is used to generate the MSI-X transaction.
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_ACTIVE_BF_OFF (15)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_ACTIVE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_ACTIVE_BF_MSK (0x00008000)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_ACTIVE_BF_DEF (0x00000000)

///< MSIX Doorbell Virtual Function. This register determines the Virtual
///< Function for the MSI-X transaction.
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_BF_MSK (0x00FF0000)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_VF_BF_DEF (0x00000000)

///< MSIX Doorbell Physical Function. This register determines the Physical
///< Function for the MSI-X transaction.
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_PF_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_PF_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_PF_BF_MSK (0x1F000000)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_PF_BF_DEF (0x00000000)

///< Reserved.
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_29_31_BF_OFF (29)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_29_31_BF_WID ( 3)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_29_31_BF_MSK (0xE0000000)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_MSIX_DOORBELL_RESERVED_29_31_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_MSIX_RAM_CTRL_OFF register description at address offset 0x94c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/MSIX_RAM_CTRL_OFF
  * MSI-X RAM power mode and debug control register.
  */

typedef union {
  struct {
    uint32_t MSIX_RAM_CTRL_TABLE_DS : 1;
    ///< MSIX Table RAM Deep Sleep.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_TABLE_SD : 1;
    ///< MSIX Table RAM Shut Down.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_RESERVED_2_7 : 6;
    ///< Reserved.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_PBA_DS : 1;
    ///< MSIX PBA RAM Deep Sleep.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_PBA_SD : 1;
    ///< MSIX PBA RAM Shut Down.   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_RESERVED_10_15 : 6;
    ///< Reserved.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_BYPASS : 1;
    ///< MSIX RAM Control Bypass. It is up to the application to ensure the
    ///< RAMs are in the proper power state before trying to access them. Moreover,
    ///< the application needs to observe all timing requirements of the RAM
    ///< low power signals before trying to use the MSIX functionality.   Note:
    ///< This register field is sticky.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_RESERVED_17_23 : 7;
    ///< Reserved.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="17" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_DBG_TABLE : 1;
    ///< MSIX Table RAM Debug Mode. You can also use the dbg_table input to
    ///< activate debug mode. Debug mode turns off the PF/VF/Offset-based addressing
    ///< into the RAM and maps the entire table linearly from the base address
    ///< of the BAR (indicated by the BIR) in function 0.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_DBG_PBA : 1;
    ///< MSIX PBA RAM Debug Mode. You can also use the dbg_pba input to activate
    ///< debug mode. Debug mode turns off the PF/VF/Offset-based addressing
    ///< into the RAM and maps the entire table linearly from the base address
    ///< of the BAR (indicated by the BIR) in function 0.   Note: This register
    ///< field is sticky.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t MSIX_RAM_CTRL_RESERVED_26_31 : 6;
    ///< Reserved.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="26" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_msix_ram_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_WR_MASK (0x03010303U)


///< MSIX Table RAM Deep Sleep.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_DS_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_DS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_DS_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_DS_BF_DEF (0x00000000)

///< MSIX Table RAM Shut Down.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_SD_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_SD_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_SD_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_TBL_SD_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_2_7_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_2_7_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_2_7_BF_MSK (0x000000FC)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_2_7_BF_DEF (0x00000000)

///< MSIX PBA RAM Deep Sleep.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_DS_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_DS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_DS_BF_MSK (0x00000100)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_DS_BF_DEF (0x00000000)

///< MSIX PBA RAM Shut Down.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_SD_BF_OFF ( 9)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_SD_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_SD_BF_MSK (0x00000200)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_PBA_SD_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_10_15_BF_OFF (10)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_10_15_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_10_15_BF_MSK (0x0000FC00)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_10_15_BF_DEF (0x00000000)

///< MSIX RAM Control Bypass. It is up to the application to ensure the
///< RAMs are in the proper power state before trying to access them. Moreover,
///< the application needs to observe all timing requirements of the RAM
///< low power signals before trying to use the MSIX functionality.   Note:
///< This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_BYP_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_BYP_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_BYP_BF_MSK (0x00010000)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_BYP_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_17_23_BF_OFF (17)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_17_23_BF_WID ( 7)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_17_23_BF_MSK (0x00FE0000)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_17_23_BF_DEF (0x00000000)

///< MSIX Table RAM Debug Mode. You can also use the dbg_table input to
///< activate debug mode. Debug mode turns off the PF/VF/Offset-based addressing
///< into the RAM and maps the entire table linearly from the base address
///< of the BAR (indicated by the BIR) in function 0.   Note: This register
///< field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_TBL_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_TBL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_TBL_BF_MSK (0x01000000)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_TBL_BF_DEF (0x00000000)

///< MSIX PBA RAM Debug Mode. You can also use the dbg_pba input to activate
///< debug mode. Debug mode turns off the PF/VF/Offset-based addressing
///< into the RAM and maps the entire table linearly from the base address
///< of the BAR (indicated by the BIR) in function 0.   Note: This register
///< field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_PBA_BF_OFF (25)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_PBA_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_PBA_BF_MSK (0x02000000)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_DBG_PBA_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_26_31_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_26_31_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_26_31_BF_MSK (0xFC000000)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_MSIX_RAM_CTRL_RESERVED_26_31_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STATUS_OFF register description at address offset 0xb10
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PL_APP_BUS_DEV_NUM_STATUS_OFF
  * Application driven bus and device number register.
  */

typedef union {
  struct {
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t RC_DSW_DEV_NUM : 5;
    ///< This field reflects the value of device number driven on app_device_num
    ///< input signal by your application.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t RC_DSW_BUS_NUM : 8;
    ///< This field reflects the value of bus number driven on app_bus_num
    ///< input signal by your application.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pl_app_bus_dev_num_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RD_MASK (0x0000fff8U)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_WR_MASK (0x00000000U)


///< This field reflects the value of device number driven on app_device_num
///< input signal by your application.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_DEV_NUM_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_DEV_NUM_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_DEV_NUM_BF_MSK (0x000000F8)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_DEV_NUM_BF_DEF (0x00000000)

///< This field reflects the value of bus number driven on app_bus_num
///< input signal by your application.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_BUS_NUM_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_BUS_NUM_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_BUS_NUM_BF_MSK (0x0000FF00)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_RC_DSW_BUS_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF register description at address offset 0xb1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PCIPM_TRAFFIC_CTRL_OFF
  * TLP Traffic during Non-D0 State Control Register.
  */

typedef union {
  struct {
    uint32_t PCIPM_VDM_TRAFFIC_BLOCKED : 1;
    ///< This field indicates that VDM Message TLPs are blocked during non-D0
    ///< states.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PCIPM_NEW_TLP_CLIENT0_BLOCKED : 1;
    ///< This field indicates that all TLPs transmitted by Client 0 interface
    ///< are blocked during non-D0 states.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t PCIPM_NEW_TLP_CLIENT1_BLOCKED : 1;
    ///< This field indicates that all TLPs transmitted by Client 1 interface
    ///< are blocked during non-D0 states.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t PCIPM_NEW_TLP_CLIENT2_BLOCKED : 1;
    ///< This field indicates that all TLPs transmitted by Client 2 interface
    ///< are blocked during non-D0 states.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t PCIPM_RESERVED_4_7 : 4;
    ///< Reserved.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pcipm_traffic_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_RD_MASK (0x000000ffU)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_WR_MASK (0x0000000fU)


///< This field indicates that VDM Message TLPs are blocked during non-D0
///< states.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_VDM_TRAFFIC_BLKED_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_VDM_TRAFFIC_BLKED_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_VDM_TRAFFIC_BLKED_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_VDM_TRAFFIC_BLKED_BF_DEF (0x00000000)

///< This field indicates that all TLPs transmitted by Client 0 interface
///< are blocked during non-D0 states.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT0_BLKED_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT0_BLKED_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT0_BLKED_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT0_BLKED_BF_DEF (0x00000000)

///< This field indicates that all TLPs transmitted by Client 1 interface
///< are blocked during non-D0 states.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT1_BLKED_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT1_BLKED_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT1_BLKED_BF_MSK (0x00000004)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT1_BLKED_BF_DEF (0x00000000)

///< This field indicates that all TLPs transmitted by Client 2 interface
///< are blocked during non-D0 states.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT2_BLKED_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT2_BLKED_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT2_BLKED_BF_MSK (0x00000008)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT2_BLKED_BF_DEF (0x00000000)

///< Reserved.   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_BF_OFF ( 4)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_BF_MSK (0x000000F0)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_AUX_CLK_FREQ_OFF register description at address offset 0xb40
  *
  * Register default value:        0x0000000A
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/AUX_CLK_FREQ_OFF
  * Auxiliary Clock Frequency Control Register.
  */

typedef union {
  struct {
    uint32_t AUX_CLK_FREQ : 10;
    ///< The aux_clk frequency in MHz. This value is used to provide a 1 us
    ///< reference for counting time during low-power states with aux_clk when
    ///< the PHY has removed the pipe_clk. Frequencies lower than 1 MHz are
    ///< possible but with a loss of accuracy in the time counted. If the actual
    ///< frequency (f) of aux_clk does not exactly match the programmed frequency
    ///< (f_prog), then there is an error in the time counted by the controller
    ///< that can be expressed in percentage as: err% = (f_prog/f-1)*100. For
    ///< example if f=2.5 MHz and f_prog=3 MHz, then err% =(3/2.5-1)*100 =20%,
    ///< meaning that the time counted by the controller on aux_clk will be
    ///< 20% greater than the time in us programmed in the corresponding time
    ///< register (for example T_POWER_ON).   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0xA"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_aux_clk_freq_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_DEFAULT (0x0000000aU)
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_RD_MASK (0x000003ffU)
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_WR_MASK (0x000003ffU)


///< The aux_clk frequency in MHz. This value is used to provide a 1 us
///< reference for counting time during low-power states with aux_clk when
///< the PHY has removed the pipe_clk. Frequencies lower than 1 MHz are
///< possible but with a loss of accuracy in the time counted. If the actual
///< frequency (f) of aux_clk does not exactly match the programmed frequency
///< (f_prog), then there is an error in the time counted by the controller
///< that can be expressed in percentage as: err% = (f_prog/f-1)*100. For
///< example if f=2.5 MHz and f_prog=3 MHz, then err% =(3/2.5-1)*100 =20%,
///< meaning that the time counted by the controller on aux_clk will be
///< 20% greater than the time in us programmed in the corresponding time
///< register (for example T_POWER_ON).   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_BF_WID (10)
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_BF_MSK (0x000003FF)
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_BF_DEF (0x0000000A)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_POWERDOWN_CTRL_STATUS_OFF register description at address offset 0xb48
  *
  * Register default value:        0x00000220
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/POWERDOWN_CTRL_STATUS_OFF
  * Powerdown Control and Status Register.
  */

typedef union {
  struct {
    uint32_t POWERDOWN_FORCE : 1;
    ///< This field is a one shot field. This field could be used for debug
    ///< purposes in event that the P2 Powerdown transition does not complete.
    ///< It will allow the controller to proceed with the transition to the
    ///< P1 Powerdown state. This field always reads back as 1'b0.   TDISP
    ///< Prot :WDB
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t POWERDOWN_VMAIN_ACK : 1;
    ///< Set this bit to 1 if you do not want to perform the handshake with
    ///< the power-switch after PERST# assertion. By default the controller
    ///< will perform the handshake with the power-switch if L1 power gating
    ///< is enabled   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t POWERDOWN_MAC_POWERDOWN : 4;
    ///< This field represents the Powerdown value driven by the controller
    ///< to the PHY.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x2"
    uint32_t POWERDOWN_PHY_POWERDOWN : 4;
    ///< This field represents the Powerdown value that has been acknowledged
    ///< by the PHY. It is updated with the value of Powerdown driven by the
    ///< controller, when the PHY has returned the Phystatus acknowledgment
    ///< for the Powerdown transition.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x2"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pwrdown_ctrl_stat_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_DEFAULT (0x00000220U)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_RD_MASK (0x00000ff2U)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_WR_MASK (0x00000003U)


///< This field is a one shot field. This field could be used for debug
///< purposes in event that the P2 Powerdown transition does not complete.
///< It will allow the controller to proceed with the transition to the
///< P1 Powerdown state. This field always reads back as 1'b0.   TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_FORCE_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_FORCE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_FORCE_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_FORCE_BF_DEF (0x00000000)

///< Set this bit to 1 if you do not want to perform the handshake with
///< the power-switch after PERST# assertion. By default the controller
///< will perform the handshake with the power-switch if L1 power gating
///< is enabled   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_VMAIN_ACK_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_VMAIN_ACK_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_VMAIN_ACK_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_VMAIN_ACK_BF_DEF (0x00000000)

///< This field represents the Powerdown value driven by the controller
///< to the PHY.
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_MAC_PWRDOWN_BF_OFF ( 4)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_MAC_PWRDOWN_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_MAC_PWRDOWN_BF_MSK (0x000000F0)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_MAC_PWRDOWN_BF_DEF (0x00000020)

///< This field represents the Powerdown value that has been acknowledged
///< by the PHY. It is updated with the value of Powerdown driven by the
///< controller, when the PHY has returned the Phystatus acknowledgment
///< for the Powerdown transition.
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_PHY_PWRDOWN_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_PHY_PWRDOWN_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_PHY_PWRDOWN_BF_MSK (0x00000F00)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_PWRDOWN_PHY_PWRDOWN_BF_DEF (0x00000200)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF register description at address offset 0xb4c
  *
  * Register default value:        0x00000010
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PHY_INTEROP_CTRL_2_OFF
  * PHY Interoperability Control 2 Register.
  */

typedef union {
  struct {
    uint32_t PMA_PIPE_RST_DELAY_TIMER : 6;
    ///< Control how long the controller should wait to release a PIPE reset
    ///< (pm_req_phy_rst) after releasing a PMA reset (pm_req_phy_perst). This
    ///< register should only be used to ensure a correct sequencing of the
    ///< resets into the PHY. If the application needs to delay the PIPE reset
    ///< arbitrarily, for example to configure the PHY firmware, Synopsys recommends
    ///< using the app_hold_phy_rst control signal. There is no need to modify
    ///< the value of this register when using Synopsys PHYs. Duration is in
    ///< aux clock cycles.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t DSP_PCIPM_L1_ENTER_DELAY : 4;
    ///< For a DSP component, this register field controls the delay between
    ///< the reception of PM_Enter_L1 DLLP and the start of PCI-PM L1 entry
    ///< negotiation in aux clock cycles (1 to 15). When using this feature
    ///< on legacy DMA configurations, the configured value must be greater
    ///< than three.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_phy_interop_ctrl_2_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_DEFAULT (0x00000010U)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_RD_MASK (0x00000f3fU)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_WR_MASK (0x00000f3fU)


///< Control how long the controller should wait to release a PIPE reset
///< (pm_req_phy_rst) after releasing a PMA reset (pm_req_phy_perst). This
///< register should only be used to ensure a correct sequencing of the
///< resets into the PHY. If the application needs to delay the PIPE reset
///< arbitrarily, for example to configure the PHY firmware, Synopsys recommends
///< using the app_hold_phy_rst control signal. There is no need to modify
///< the value of this register when using Synopsys PHYs. Duration is in
///< aux clock cycles.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_PMA_PIPE_RST_DELAY_TIMER_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_PMA_PIPE_RST_DELAY_TIMER_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_PMA_PIPE_RST_DELAY_TIMER_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_PMA_PIPE_RST_DELAY_TIMER_BF_DEF (0x00000010)

///< For a DSP component, this register field controls the delay between
///< the reception of PM_Enter_L1 DLLP and the start of PCI-PM L1 entry
///< negotiation in aux clock cycles (1 to 15). When using this feature
///< on legacy DMA configurations, the configured value must be greater
///< than three.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_DSP_PCIPM_L1_ENTER_DELAY_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_DSP_PCIPM_L1_ENTER_DELAY_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_DSP_PCIPM_L1_ENTER_DELAY_BF_MSK (0x00000F00)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_DSP_PCIPM_L1_ENTER_DELAY_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF register description at address offset 0xb80
  *
  * Register default value:        0x05201408
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN4_LANE_MARGINING_1_OFF
  * Gen4 Lane Margining 1 Register.
  */

typedef union {
  struct {
    uint32_t GEN4_MARGINING_NUM_TIMING_STEPS : 6;
    ///< MNumTimingSteps for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Number of time steps from default (to either left or right), range
    ///< must be at least +/-0.2 UI . Timing offset must increase monotonically.
    ///< The number of steps in both positive (toward the end of the unit interval)
    ///< and negative (toward the beginning of the unit interval) must be identical.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x8"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t GEN4_MARGINING_MAX_TIMING_OFFSET : 6;
    ///< MMaxTimingOffset for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Offset from default at maximum step value as percentage of a nominal
    ///< UI. A '0' value might be reported if the vendor chooses not to report
    ///< the offset.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x14"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t GEN4_MARGINING_NUM_VOLTAGE_STEPS : 7;
    ///< MNumVoltageSteps for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Number of voltage steps from default (either up or down), minimum
    ///< range +/-50mV as measured by the reference equalizer. Voltage offset
    ///< must increase monotonically. The number of steps in both positive
    ///< and negative direction from the default sample location must be identical.
    ///< This value is undefined if MVoltageSupported is 0b.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x20"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t GEN4_MARGINING_MAX_VOLTAGE_OFFSET : 6;
    ///< MMaxVoltageOffset for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Offset from default at maximum step value as percentage of one volt.
    ///< A '0' value might be reported if the vendor chooses not to report
    ///< the offset when MVoltageSupported is 1b. This value is undefined if
    ///< MVoltageSupported is 0b.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x5"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen4_lane_margining_1_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_DEFAULT (0x05201408U)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_RD_MASK (0x3f7f3f3fU)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_WR_MASK (0x3f7f3f3fU)


///< MNumTimingSteps for 16.0 GT/s for Lane Margining at the Receiver.
///< Number of time steps from default (to either left or right), range
///< must be at least +/-0.2 UI . Timing offset must increase monotonically.
///< The number of steps in both positive (toward the end of the unit interval)
///< and negative (toward the beginning of the unit interval) must be identical.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_TIMING_STEPS_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_TIMING_STEPS_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_TIMING_STEPS_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_TIMING_STEPS_BF_DEF (0x00000008)

///< MMaxTimingOffset for 16.0 GT/s for Lane Margining at the Receiver.
///< Offset from default at maximum step value as percentage of a nominal
///< UI. A '0' value might be reported if the vendor chooses not to report
///< the offset.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_TIMING_OFFSET_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_TIMING_OFFSET_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_TIMING_OFFSET_BF_MSK (0x00003F00)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_TIMING_OFFSET_BF_DEF (0x00001400)

///< MNumVoltageSteps for 16.0 GT/s for Lane Margining at the Receiver.
///< Number of voltage steps from default (either up or down), minimum
///< range +/-50mV as measured by the reference equalizer. Voltage offset
///< must increase monotonically. The number of steps in both positive
///< and negative direction from the default sample location must be identical.
///< This value is undefined if MVoltageSupported is 0b.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_VOLTAGE_STEPS_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_VOLTAGE_STEPS_BF_WID ( 7)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_VOLTAGE_STEPS_BF_MSK (0x007F0000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_NUM_VOLTAGE_STEPS_BF_DEF (0x00200000)

///< MMaxVoltageOffset for 16.0 GT/s for Lane Margining at the Receiver.
///< Offset from default at maximum step value as percentage of one volt.
///< A '0' value might be reported if the vendor chooses not to report
///< the offset when MVoltageSupported is 1b. This value is undefined if
///< MVoltageSupported is 0b.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_VOLTAGE_OFFSET_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_VOLTAGE_OFFSET_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_VOLTAGE_OFFSET_BF_MSK (0x3F000000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_GEN4_MARGINING_MAX_VOLTAGE_OFFSET_BF_DEF (0x05000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF register description at address offset 0xb84
  *
  * Register default value:        0x03011F1F
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN4_LANE_MARGINING_2_OFF
  * Gen4 Lane Margining 2 Register.
  */

typedef union {
  struct {
    uint32_t GEN4_MARGINING_SAMPLE_RATE_VOLTAGE : 6;
    ///< MSamplingRateVoltage for 16.0 GT/s for Lane Margining at the Receiver.
    ///< The ratio of bits tested to bits received during voltage margining.
    ///< Note:  This value is not used when MARGINING_IND_ERROR_SAMPLER is
    ///< 0b. The MSamplingRateVoltage is fixed to 63 internally.   Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1F"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t GEN4_MARGINING_SAMPLE_RATE_TIMING : 6;
    ///< MSamplingRateTiming for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This value is not used when MARGINING_IND_ERROR_SAMPLER is 0b.
    ///< The MSamplingRateTiming is fixed to 63 internally.  The ratio of bits
    ///< tested to bits received during timing margining.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1F"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t GEN4_MARGINING_MAXLANES : 5;
    ///< MMaxLanes for 16.0 GT/s for Lane Margining at the Receiver. Maximum
    ///< number of Lanes minus 1 that can be margined at the same time. It
    ///< is recommended that this value be greater than or equal to the number
    ///< of Lanes in the Link minus 1. Encoding Behavior is undefined if software
    ///< attempts to margin more than MMaxLanes+1 at the same time.  Note:
    ///< This value is permitted to exceed the number of Lanes in the Link
    ///< minus 1.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
    uint32_t GEN4_MARGINING_VOLTAGE_SUPPORTED : 1;
    ///< MVoltageSupported for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x1"
    uint32_t GEN4_MARGINING_IND_UP_DOWN_VOLTAGE : 1;
    ///< MIndUpDownVoltage for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="25" ResetValue="0x1"
    uint32_t GEN4_MARGINING_IND_LEFT_RIGHT_TIMING : 1;
    ///< MIndLeftRightTiming for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t GEN4_MARGINING_SAMPLE_REPORTING_METHOD : 1;
    ///< MSampleReportingMethod for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Indicates whether sampling rates or sample count is supported. One
    ///< of the two methods is supported by each device.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t GEN4_MARGINING_IND_ERROR_SAMPLER : 1;
    ///< MIndErrorSampler for 16.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen4_lane_margining_2_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_DEFAULT (0x03011f1fU)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_RD_MASK (0x1f1f3f3fU)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_WR_MASK (0x1f1f3f3fU)


///< MSamplingRateVoltage for 16.0 GT/s for Lane Margining at the Receiver.
///< The ratio of bits tested to bits received during voltage margining.
///< Note:  This value is not used when MARGINING_IND_ERROR_SAMPLER is
///< 0b. The MSamplingRateVoltage is fixed to 63 internally.   Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_VOLTAGE_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_VOLTAGE_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_VOLTAGE_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_VOLTAGE_BF_DEF (0x0000001F)

///< MSamplingRateTiming for 16.0 GT/s for Lane Margining at the Receiver.
///< Note: This value is not used when MARGINING_IND_ERROR_SAMPLER is 0b.
///< The MSamplingRateTiming is fixed to 63 internally.  The ratio of bits
///< tested to bits received during timing margining.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_TIMING_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_TIMING_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_TIMING_BF_MSK (0x00003F00)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RATE_TIMING_BF_DEF (0x00001F00)

///< MMaxLanes for 16.0 GT/s for Lane Margining at the Receiver. Maximum
///< number of Lanes minus 1 that can be margined at the same time. It
///< is recommended that this value be greater than or equal to the number
///< of Lanes in the Link minus 1. Encoding Behavior is undefined if software
///< attempts to margin more than MMaxLanes+1 at the same time.  Note:
///< This value is permitted to exceed the number of Lanes in the Link
///< minus 1.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_MAXLANES_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_MAXLANES_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_MAXLANES_BF_MSK (0x001F0000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_MAXLANES_BF_DEF (0x00010000)

///< MVoltageSupported for 16.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_VOLTAGE_SUPPORTED_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_VOLTAGE_SUPPORTED_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_VOLTAGE_SUPPORTED_BF_MSK (0x01000000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_VOLTAGE_SUPPORTED_BF_DEF (0x01000000)

///< MIndUpDownVoltage for 16.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_UP_DOWN_VOLTAGE_BF_OFF (25)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_UP_DOWN_VOLTAGE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_UP_DOWN_VOLTAGE_BF_MSK (0x02000000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_UP_DOWN_VOLTAGE_BF_DEF (0x02000000)

///< MIndLeftRightTiming for 16.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_LEFT_RIGHT_TIMING_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_LEFT_RIGHT_TIMING_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_LEFT_RIGHT_TIMING_BF_MSK (0x04000000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_LEFT_RIGHT_TIMING_BF_DEF (0x00000000)

///< MSampleReportingMethod for 16.0 GT/s for Lane Margining at the Receiver.
///< Indicates whether sampling rates or sample count is supported. One
///< of the two methods is supported by each device.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RPTING_METHOD_BF_OFF (27)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RPTING_METHOD_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RPTING_METHOD_BF_MSK (0x08000000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_SAMPLE_RPTING_METHOD_BF_DEF (0x00000000)

///< MIndErrorSampler for 16.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_ERR_SAMPLER_BF_OFF (28)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_ERR_SAMPLER_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_ERR_SAMPLER_BF_MSK (0x10000000)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_GEN4_MARGINING_IND_ERR_SAMPLER_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF register description at address offset 0xb88
  *
  * Register default value:        0x05201408
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN5_LANE_MARGINING_1_OFF
  * Gen5 Lane Margining 1 Register.
  */

typedef union {
  struct {
    uint32_t GEN5_MARGINING_NUM_TIMING_STEPS : 6;
    ///< MNumTimingSteps for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Number of time steps from default (to either left or right), range
    ///< must be at least +/-0.2 UI . Timing offset must increase monotonically.
    ///< The number of steps in both positive (toward the end of the unit interval)
    ///< and negative (toward the beginning of the unit interval) must be identical.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x8"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t GEN5_MARGINING_MAX_TIMING_OFFSET : 6;
    ///< MMaxTimingOffset for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Offset from default at maximum step value as percentage of a nominal
    ///< UI. A '0' value might be reported if the vendor chooses not to report
    ///< the offset.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x14"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t GEN5_MARGINING_NUM_VOLTAGE_STEPS : 7;
    ///< MNumVoltageSteps for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Number of voltage steps from default (either up or down), minimum
    ///< range +/-50mV as measured by the reference equalizer. Voltage offset
    ///< must increase monotonically. The number of steps in both positive
    ///< and negative direction from the default sample location must be identical.
    ///< This value is undefined if MVoltageSupported is 0b.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x20"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t GEN5_MARGINING_MAX_VOLTAGE_OFFSET : 6;
    ///< MMaxVoltageOffset for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Offset from default at maximum step value as percentage of one volt.
    ///< A '0' value might be reported if the vendor chooses not to report
    ///< the offset when MVoltageSupported is 1b. This value is undefined if
    ///< MVoltageSupported is 0b.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x5"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen5_lane_margining_1_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_DEFAULT (0x05201408U)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_RD_MASK (0x3f7f3f3fU)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_WR_MASK (0x3f7f3f3fU)


///< MNumTimingSteps for 32.0 GT/s for Lane Margining at the Receiver.
///< Number of time steps from default (to either left or right), range
///< must be at least +/-0.2 UI . Timing offset must increase monotonically.
///< The number of steps in both positive (toward the end of the unit interval)
///< and negative (toward the beginning of the unit interval) must be identical.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_TIMING_STEPS_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_TIMING_STEPS_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_TIMING_STEPS_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_TIMING_STEPS_BF_DEF (0x00000008)

///< MMaxTimingOffset for 32.0 GT/s for Lane Margining at the Receiver.
///< Offset from default at maximum step value as percentage of a nominal
///< UI. A '0' value might be reported if the vendor chooses not to report
///< the offset.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_TIMING_OFFSET_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_TIMING_OFFSET_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_TIMING_OFFSET_BF_MSK (0x00003F00)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_TIMING_OFFSET_BF_DEF (0x00001400)

///< MNumVoltageSteps for 32.0 GT/s for Lane Margining at the Receiver.
///< Number of voltage steps from default (either up or down), minimum
///< range +/-50mV as measured by the reference equalizer. Voltage offset
///< must increase monotonically. The number of steps in both positive
///< and negative direction from the default sample location must be identical.
///< This value is undefined if MVoltageSupported is 0b.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_VOLTAGE_STEPS_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_VOLTAGE_STEPS_BF_WID ( 7)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_VOLTAGE_STEPS_BF_MSK (0x007F0000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_NUM_VOLTAGE_STEPS_BF_DEF (0x00200000)

///< MMaxVoltageOffset for 32.0 GT/s for Lane Margining at the Receiver.
///< Offset from default at maximum step value as percentage of one volt.
///< A '0' value might be reported if the vendor chooses not to report
///< the offset when MVoltageSupported is 1b. This value is undefined if
///< MVoltageSupported is 0b.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_VOLTAGE_OFFSET_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_VOLTAGE_OFFSET_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_VOLTAGE_OFFSET_BF_MSK (0x3F000000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_GEN5_MARGINING_MAX_VOLTAGE_OFFSET_BF_DEF (0x05000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF register description at address offset 0xb8c
  *
  * Register default value:        0x03011F1F
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/GEN5_LANE_MARGINING_2_OFF
  * Gen5 Lane Margining 2 Register.
  */

typedef union {
  struct {
    uint32_t GEN5_MARGINING_SAMPLE_RATE_VOLTAGE : 6;
    ///< MSamplingRateVoltage for 32.0 GT/s for Lane Margining at the Receiver.
    ///< The ratio of bits tested to bits received during voltage margining.
    ///< Note:  This value is not used when MARGINING_IND_ERROR_SAMPLER is
    ///< 0b. The MSamplingRateVoltage is fixed to 63 internally.   Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1F"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t GEN5_MARGINING_SAMPLE_RATE_TIMING : 6;
    ///< MSamplingRateTiming for 32.0 GT/s for Lane Margining at the Receiver.
    ///< The ratio of bits tested to bits received during timing margining.
    ///< Note: This value is not used when MARGINING_IND_ERROR_SAMPLER is 0b.
    ///< The MSamplingRateTiming is fixed to 63 internally.    Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1F"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t GEN5_MARGINING_MAXLANES : 5;
    ///< MMaxLanes for 32.0 GT/s for Lane Margining at the Receiver.  Maximum
    ///< number of Lanes minus 1 that can be margined at the same time. It
    ///< is recommended that this value be greater than or equal to the number
    ///< of Lanes in the Link minus 1. Encoding Behavior is undefined if software
    ///< attempts to margin more than MMaxLanes+1 at the same time.  Note:
    ///< This value is permitted to exceed the number of Lanes in the Link
    ///< minus 1.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
    uint32_t GEN5_MARGINING_VOLTAGE_SUPPORTED : 1;
    ///< MVoltageSupported for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x1"
    uint32_t GEN5_MARGINING_IND_UP_DOWN_VOLTAGE : 1;
    ///< MIndUpDownVoltage for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="25" ResetValue="0x1"
    uint32_t GEN5_MARGINING_IND_LEFT_RIGHT_TIMING : 1;
    ///< MIndLeftRightTiming for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t GEN5_MARGINING_SAMPLE_REPORTING_METHOD : 1;
    ///< MSampleReportingMethod for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Indicates whether sampling rates or sample count is supported. One
    ///< of the two methods is supported by each device.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t GEN5_MARGINING_IND_ERROR_SAMPLER : 1;
    ///< MIndErrorSampler for 32.0 GT/s for Lane Margining at the Receiver.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_gen5_lane_margining_2_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_DEFAULT (0x03011f1fU)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_RD_MASK (0x1f1f3f3fU)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_WR_MASK (0x1f1f3f3fU)


///< MSamplingRateVoltage for 32.0 GT/s for Lane Margining at the Receiver.
///< The ratio of bits tested to bits received during voltage margining.
///< Note:  This value is not used when MARGINING_IND_ERROR_SAMPLER is
///< 0b. The MSamplingRateVoltage is fixed to 63 internally.   Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_VOLTAGE_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_VOLTAGE_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_VOLTAGE_BF_MSK (0x0000003F)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_VOLTAGE_BF_DEF (0x0000001F)

///< MSamplingRateTiming for 32.0 GT/s for Lane Margining at the Receiver.
///< The ratio of bits tested to bits received during timing margining.
///< Note: This value is not used when MARGINING_IND_ERROR_SAMPLER is 0b.
///< The MSamplingRateTiming is fixed to 63 internally.    Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_TIMING_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_TIMING_BF_WID ( 6)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_TIMING_BF_MSK (0x00003F00)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RATE_TIMING_BF_DEF (0x00001F00)

///< MMaxLanes for 32.0 GT/s for Lane Margining at the Receiver.  Maximum
///< number of Lanes minus 1 that can be margined at the same time. It
///< is recommended that this value be greater than or equal to the number
///< of Lanes in the Link minus 1. Encoding Behavior is undefined if software
///< attempts to margin more than MMaxLanes+1 at the same time.  Note:
///< This value is permitted to exceed the number of Lanes in the Link
///< minus 1.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_MAXLANES_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_MAXLANES_BF_WID ( 5)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_MAXLANES_BF_MSK (0x001F0000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_MAXLANES_BF_DEF (0x00010000)

///< MVoltageSupported for 32.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_VOLTAGE_SUPPORTED_BF_OFF (24)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_VOLTAGE_SUPPORTED_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_VOLTAGE_SUPPORTED_BF_MSK (0x01000000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_VOLTAGE_SUPPORTED_BF_DEF (0x01000000)

///< MIndUpDownVoltage for 32.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_UP_DOWN_VOLTAGE_BF_OFF (25)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_UP_DOWN_VOLTAGE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_UP_DOWN_VOLTAGE_BF_MSK (0x02000000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_UP_DOWN_VOLTAGE_BF_DEF (0x02000000)

///< MIndLeftRightTiming for 32.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_LEFT_RIGHT_TIMING_BF_OFF (26)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_LEFT_RIGHT_TIMING_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_LEFT_RIGHT_TIMING_BF_MSK (0x04000000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_LEFT_RIGHT_TIMING_BF_DEF (0x00000000)

///< MSampleReportingMethod for 32.0 GT/s for Lane Margining at the Receiver.
///< Indicates whether sampling rates or sample count is supported. One
///< of the two methods is supported by each device.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RPTING_METHOD_BF_OFF (27)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RPTING_METHOD_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RPTING_METHOD_BF_MSK (0x08000000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_SAMPLE_RPTING_METHOD_BF_DEF (0x00000000)

///< MIndErrorSampler for 32.0 GT/s for Lane Margining at the Receiver.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_ERR_SAMPLER_BF_OFF (28)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_ERR_SAMPLER_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_ERR_SAMPLER_BF_MSK (0x10000000)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_GEN5_MARGINING_IND_ERR_SAMPLER_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PIPE_RELATED_OFF register description at address offset 0xb90
  *
  * Register default value:        0x00000058
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PIPE_RELATED_OFF
  * PIPE Related Register.
  */

typedef union {
  struct {
    uint32_t RX_MESSAGE_BUS_WRITE_BUFFER_DEPTH : 4;
    ///< RXMessageBusWriteBufferDepth defined in the PIPE Specification. Indicates
    ///< the number of write buffer entries that the PHY has implemented to
    ///< receive writes from the controller. If the value is less than 2 for
    ///< PIPE 5.1.1 or 1 for PIPE 4.4.1, the controller issues only write_commited
    ///< commands, never write_uncommitted.   Note: This register field is
    ///< sticky.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x8"
    uint32_t TX_MESSAGE_BUS_MIN_WRITE_BUFFER_DEPTH : 4;
    ///< TXMessageBusMinWriteBufferDepth defined in the PIPE Specification.
    ///< Indicates the minimum number of write buffer entries that the PHY
    ///< expects the controller to implement to receive writes from it.   Note:
    ///< This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x5"
    uint32_t PIPE_GARBAGE_DATA_MODE : 1;
    ///< PIPE Garbage Data Mode.  - RxValid is de-asserted  - a valid RxStartBlock
    ///< is received at 128b/130b encoding  - a valid COM symbol is received
    ///< at 8b/10b encoding   Note: This register field is sticky.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pipe_related_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_DEFAULT (0x00000058U)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_RD_MASK (0x000001ffU)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_WR_MASK (0x0000010fU)


///< RXMessageBusWriteBufferDepth defined in the PIPE Specification. Indicates
///< the number of write buffer entries that the PHY has implemented to
///< receive writes from the controller. If the value is less than 2 for
///< PIPE 5.1.1 or 1 for PIPE 4.4.1, the controller issues only write_commited
///< commands, never write_uncommitted.   Note: This register field is
///< sticky.
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_RX_MSG_BUS_WRITE_BUFF_DEPTH_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_RX_MSG_BUS_WRITE_BUFF_DEPTH_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_RX_MSG_BUS_WRITE_BUFF_DEPTH_BF_MSK (0x0000000F)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_RX_MSG_BUS_WRITE_BUFF_DEPTH_BF_DEF (0x00000008)

///< TXMessageBusMinWriteBufferDepth defined in the PIPE Specification.
///< Indicates the minimum number of write buffer entries that the PHY
///< expects the controller to implement to receive writes from it.   Note:
///< This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_TX_MSG_BUS_MIN_WRITE_BUFF_DEPTH_BF_OFF ( 4)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_TX_MSG_BUS_MIN_WRITE_BUFF_DEPTH_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_TX_MSG_BUS_MIN_WRITE_BUFF_DEPTH_BF_MSK (0x000000F0)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_TX_MSG_BUS_MIN_WRITE_BUFF_DEPTH_BF_DEF (0x00000050)

///< PIPE Garbage Data Mode.  - RxValid is de-asserted  - a valid RxStartBlock
///< is received at 128b/130b encoding  - a valid COM symbol is received
///< at 8b/10b encoding   Note: This register field is sticky.
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_PIPE_GARBAGE_DATA_MODE_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_PIPE_GARBAGE_DATA_MODE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_PIPE_GARBAGE_DATA_MODE_BF_MSK (0x00000100)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_PIPE_GARBAGE_DATA_MODE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_REG_OFF register description at address offset 0xc7c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/DBI_FUNCTION_BANK_CTRL_REG_OFF
  * DBI Function Bank Control Register.
  */

typedef union {
  struct {
    uint32_t DBI_FUNCTION_BANK_CTRL_REG : 1;
    ///< DBI Function Bank Select.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R   - Dbi: R  TDISP Prot :WDB
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBI_FUNCTION_BANK_CTRL_REG_RSVD : 31;
    ///< Reserved.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_dbi_function_bank_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_WR_MASK (0x00000001U)


///< DBI Function Bank Select.   Note: The access attributes of this field
///< are as follows:  - Wire: R   - Dbi: R  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_BF_DEF (0x00000000)

///< Reserved.
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_RSVD_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_RSVD_BF_WID (31)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_RSVD_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_DBI_FUNCTION_BANK_CTRL_RSVD_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_UTILITY_OFF register description at address offset 0xc80
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/UTILITY_OFF
  * UTILITY register (Reserved).
  */

typedef union {
  struct {
    uint32_t UTILITY : 32;
    ///< Reserved.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_utility_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_WR_MASK (0xffffffffU)


///< Reserved.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_UTILITY_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_UTILITY_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_UTILITY_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_UTILITY_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PM_UTILITY_OFF register description at address offset 0xc88
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PM_UTILITY_OFF
  * PM Shadow of UTILITY register (Reserved).
  */

typedef union {
  struct {
    uint32_t PM_UTILITY : 32;
    ///< Reserved.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_pm_utility_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_RD_MASK (0xffffffffU)
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_WR_MASK (0x00000000U)


///< Reserved.
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_PM_UTILITY_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_PM_UTILITY_BF_WID (32)
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_PM_UTILITY_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_PM_UTILITY_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_IDE_CTRL_OFF register description at address offset 0xc8c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/IDE_CTRL_OFF
  * IDE Control register
  */

typedef union {
  struct {
    uint32_t IDE_CTRL_DISABLE : 1;
    ///< IDE Disable Control Field  Must not be toggled during operation.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WP
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t EARLY_TDISP_TIMEOUT_DISABLE : 1;
    ///< early timeout disable Control Field  Must not be toggled during operation.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_ide_ctrl_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_RD_MASK (0x00000003U)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_WR_MASK (0x00000003U)


///< IDE Disable Control Field  Must not be toggled during operation.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
///< TDISP Prot :WP
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_IDE_CTRL_DIS_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_IDE_CTRL_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_IDE_CTRL_DIS_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_IDE_CTRL_DIS_BF_DEF (0x00000000)

///< early timeout disable Control Field  Must not be toggled during operation.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R (sticky)   - Dbi: R/W (sticky)  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_EARLY_TDISP_TIMEOUT_DIS_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_EARLY_TDISP_TIMEOUT_DIS_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_EARLY_TDISP_TIMEOUT_DIS_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_EARLY_TDISP_TIMEOUT_DIS_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PORT_LOGIC_PRBS_LOOPBACK_TEST_REG_OFF register description at address offset 0xcac
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PORT_LOGIC/PRBS_LOOPBACK_TEST_REG_OFF
  * PRBS Loopback Test Control Register.
  */

typedef union {
  struct {
    uint32_t PRBS_LOOPBACK_TEST_ENABLE : 1;
    ///< PRBS Loopback Test Enable. When PRBS Loopback TEST is executed, this
    ///< needs to be set before PORT_LINK_CTRL_OFF.LOOPBACK_ENABLE   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PRBS_LOOPBACK_TEST_DONE : 1;
    ///< PRBS Loopback Test Done. Set to 1b by controller when exiting from
    ///< Loopback.Exit. This bit is cleared to 0b by writing it to 1, or re-entering
    ///< Loopback.Active state   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW/1C/V" BitOffset="1" ResetValue="0x0"
    uint32_t PRBS_LOOPBACK_TEST_FAILED : 1;
    ///< PRBS Loopback Test Failed.   When 0, the PRBS is done without any
    ///< error.   When 1, one or more of the following occurred on any lane.
    ///< Compare error(Error Counter !=0)      Unexpected Fail   This bit is
    ///< cleared when  PRBS test done  is cleared, or re-entering Loopback.Active
    ///< state)   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t PRBS_LOOPBACK_TEST_LANE_SELECT : 4;
    ///< Lane Select for PRBS Loopback Test Status. This register is used to
    ///< select status registers for laneX below.   PRBS_LOOPBACK_STARTED_LANEX
    ///< : PRBS Loopback started for laneX   PRBS_LOOPBACK_ERR_CNTR_LANEX :
    ///< PRBS Loopback comparison error counter for laneX   PRBS_LOOPBACK_TEST_UNEXP_FAIL_LANEX
    ///< : PRBS Loopback unexpected error status for laneX  When this register
    ///< is set to larger number than number of lanes, the selected status
    ///< are undefined.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t PRBS_LOOPBACK_TEST_STARTED_LANEX : 1;
    ///< PRBS Loopback Test Started of LaneX. The laneX is defined by  PRBS_LOOPBACK_TEST_LANE_SELECT
    ///< register. When a first idle data is detected and idle data comparison
    ///< is started, this register is set to 1. This bit is cleared when  PRBS
    ///< test done  is cleared, or re-entering Loopback.Active state.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t PRBS_LOOPBACK_TEST_ERROR_COUNTER_LANEX : 8;
    ///< PRBS Loopback Test Error Counter of LaneX. The laneX is defined by
    ///< PRBS_LOOPBACK_TEST_LANE_SELECT  register. When two or more errors
    ///< occur at one cycle, the counter counts up  1 , not  2  or more. These
    ///< bits are cleared when  PRBS test done  is cleared, or re-entering
    ///< Loopback.Active state.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t PRBS_LOOPBACK_TEST_UNEXPECTED_FAIL_LANEX : 1;
    ///< PRBS Loopback Test Unexpected Fail of LaneX. The laneX is defined
    ///< by  PRBS_LOOPBACK_TEST_LANE_SELECT  register. This will be set when
    ///< encountering the following cases.   Case1. RXVALID on pipe de-asserts
    ///< Case2. Looback finished without receiving idle   Case3. Looback finished
    ///< without receiving EIOS  This bit is cleared when  PRBS test done
    ///< is cleared, or re-entering Loopback.Active state.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_port_logic_prbs_loopback_test_off_reg_t;

#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_DEFAULT (0x00000000U)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_RD_MASK (0x0001ffffU)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_WR_MASK (0x0000007bU)


///< PRBS Loopback Test Enable. When PRBS Loopback TEST is executed, this
///< needs to be set before PORT_LINK_CTRL_OFF.LOOPBACK_ENABLE   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_EN_BF_OFF ( 0)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_EN_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_EN_BF_MSK (0x00000001)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_EN_BF_DEF (0x00000000)

///< PRBS Loopback Test Done. Set to 1b by controller when exiting from
///< Loopback.Exit. This bit is cleared to 0b by writing it to 1, or re-entering
///< Loopback.Active state   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_DONE_BF_OFF ( 1)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_DONE_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_DONE_BF_MSK (0x00000002)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_DONE_BF_DEF (0x00000000)

///< PRBS Loopback Test Failed.   When 0, the PRBS is done without any
///< error.   When 1, one or more of the following occurred on any lane.
///< Compare error(Error Counter !=0)      Unexpected Fail   This bit is
///< cleared when  PRBS test done  is cleared, or re-entering Loopback.Active
///< state)   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_FAILED_BF_OFF ( 2)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_FAILED_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_FAILED_BF_MSK (0x00000004)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_FAILED_BF_DEF (0x00000000)

///< Lane Select for PRBS Loopback Test Status. This register is used to
///< select status registers for laneX below.   PRBS_LOOPBACK_STARTED_LANEX
///< : PRBS Loopback started for laneX   PRBS_LOOPBACK_ERR_CNTR_LANEX :
///< PRBS Loopback comparison error counter for laneX   PRBS_LOOPBACK_TEST_UNEXP_FAIL_LANEX
///< : PRBS Loopback unexpected error status for laneX  When this register
///< is set to larger number than number of lanes, the selected status
///< are undefined.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_LANE_SEL_BF_OFF ( 3)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_LANE_SEL_BF_WID ( 4)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_LANE_SEL_BF_MSK (0x00000078)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_LANE_SEL_BF_DEF (0x00000000)

///< PRBS Loopback Test Started of LaneX. The laneX is defined by  PRBS_LOOPBACK_TEST_LANE_SELECT
///< register. When a first idle data is detected and idle data comparison
///< is started, this register is set to 1. This bit is cleared when  PRBS
///< test done  is cleared, or re-entering Loopback.Active state.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_STARTED_LANEX_BF_OFF ( 7)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_STARTED_LANEX_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_STARTED_LANEX_BF_MSK (0x00000080)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_STARTED_LANEX_BF_DEF (0x00000000)

///< PRBS Loopback Test Error Counter of LaneX. The laneX is defined by
///< PRBS_LOOPBACK_TEST_LANE_SELECT  register. When two or more errors
///< occur at one cycle, the counter counts up  1 , not  2  or more. These
///< bits are cleared when  PRBS test done  is cleared, or re-entering
///< Loopback.Active state.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_ERR_CNTER_LANEX_BF_OFF ( 8)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_ERR_CNTER_LANEX_BF_WID ( 8)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_ERR_CNTER_LANEX_BF_MSK (0x0000FF00)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_ERR_CNTER_LANEX_BF_DEF (0x00000000)

///< PRBS Loopback Test Unexpected Fail of LaneX. The laneX is defined
///< by  PRBS_LOOPBACK_TEST_LANE_SELECT  register. This will be set when
///< encountering the following cases.   Case1. RXVALID on pipe de-asserts
///< Case2. Looback finished without receiving idle   Case3. Looback finished
///< without receiving EIOS  This bit is cleared when  PRBS test done
///< is cleared, or re-entering Loopback.Active state.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_UNEXPECTED_FAIL_LANEX_BF_OFF (16)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_UNEXPECTED_FAIL_LANEX_BF_WID ( 1)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_UNEXPECTED_FAIL_LANEX_BF_MSK (0x00010000)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_PRBS_LOOPBACK_TEST_UNEXPECTED_FAIL_LANEX_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DBI2_BAR0_MASK_REG register description at address offset 0x100010
  *
  * Register default value:        0x07FFFFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR_DBI2/BAR0_MASK_REG
  * BAR$ Mask Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_BAR0_ENABLED : 1;
    ///< - BAR0 Mask Enabled.   Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x1"
    uint32_t PCI_TYPE0_BAR0_MASK : 31;
    ///< - BAR0 Mask.   Note: The access attributes of this field are as follows:
    ///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
    ///< register field is sticky.
    ///< AccessType="WS" BitOffset="1" ResetValue="0x3FFFFFF"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_dbi2_bar0_mask_reg_t;

#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_DEFAULT (0x07ffffffU)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_RD_MASK (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_WR_MASK (0xffffffffU)


///< - BAR0 Mask Enabled.   Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_END_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_END_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_END_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_END_BF_DEF (0x00000001)

///< - BAR0 Mask.   Note: The access attributes of this field are as follows:
///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
///< register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_MASK_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_MASK_BF_WID (31)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_MASK_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_PCI_TYPE0_BAR0_MASK_BF_DEF (0x07FFFFFE)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DBI2_BAR1_MASK_REG register description at address offset 0x100014
  *
  * Register default value:        0x0001FFFE
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR_DBI2/BAR1_MASK_REG
  * BAR1 Mask Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_BAR1_ENABLED : 1;
    ///< - BAR1 Mask Enabled.   Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint32_t PCI_TYPE0_BAR1_MASK : 31;
    ///< - BAR1 Mask.   Note: The access attributes of this field are as follows:
    ///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
    ///< register field is sticky.
    ///< AccessType="WS" BitOffset="1" ResetValue="0xFFFF"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_dbi2_bar1_mask_reg_t;

#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_DEFAULT (0x0001fffeU)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_RD_MASK (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_WR_MASK (0xffffffffU)


///< - BAR1 Mask Enabled.   Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_END_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_END_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_END_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_END_BF_DEF (0x00000000)

///< - BAR1 Mask.   Note: The access attributes of this field are as follows:
///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
///< register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_MASK_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_MASK_BF_WID (31)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_MASK_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_PCI_TYPE0_BAR1_MASK_BF_DEF (0x0001FFFE)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DBI2_BAR2_MASK_REG register description at address offset 0x100018
  *
  * Register default value:        0x07FFFFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR_DBI2/BAR2_MASK_REG
  * BAR2 Mask Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_BAR2_ENABLED : 1;
    ///< BAR2 Mask Enabled.   Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x1"
    uint32_t PCI_TYPE0_BAR2_MASK : 31;
    ///< BAR2 Mask.   Note: The access attributes of this field are as follows:
    ///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
    ///< register field is sticky.
    ///< AccessType="WS" BitOffset="1" ResetValue="0x3FFFFFF"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_dbi2_bar2_mask_reg_t;

#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_DEFAULT (0x07ffffffU)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_RD_MASK (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_WR_MASK (0xffffffffU)


///< BAR2 Mask Enabled.   Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_END_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_END_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_END_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_END_BF_DEF (0x00000001)

///< BAR2 Mask.   Note: The access attributes of this field are as follows:
///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
///< register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_MASK_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_MASK_BF_WID (31)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_MASK_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_PCI_TYPE0_BAR2_MASK_BF_DEF (0x07FFFFFE)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DBI2_BAR3_MASK_REG register description at address offset 0x10001c
  *
  * Register default value:        0x0001FFFE
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR_DBI2/BAR3_MASK_REG
  * BAR3 Mask Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_BAR3_ENABLED : 1;
    ///< BAR3 Mask Enabled.   Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint32_t PCI_TYPE0_BAR3_MASK : 31;
    ///< BAR3 Mask.   Note: The access attributes of this field are as follows:
    ///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
    ///< register field is sticky.
    ///< AccessType="WS" BitOffset="1" ResetValue="0xFFFF"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_dbi2_bar3_mask_reg_t;

#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_DEFAULT (0x0001fffeU)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_RD_MASK (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_WR_MASK (0xffffffffU)


///< BAR3 Mask Enabled.   Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_END_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_END_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_END_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_END_BF_DEF (0x00000000)

///< BAR3 Mask.   Note: The access attributes of this field are as follows:
///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
///< register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_MASK_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_MASK_BF_WID (31)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_MASK_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_PCI_TYPE0_BAR3_MASK_BF_DEF (0x0001FFFE)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DBI2_BAR4_MASK_REG register description at address offset 0x100020
  *
  * Register default value:        0x00007FFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR_DBI2/BAR4_MASK_REG
  * BAR4 Mask Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_BAR4_ENABLED : 1;
    ///< BAR4 Mask Enabled.   Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x1"
    uint32_t PCI_TYPE0_BAR4_MASK : 31;
    ///< BAR4 Mask.   Note: The access attributes of this field are as follows:
    ///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
    ///< register field is sticky.
    ///< AccessType="WS" BitOffset="1" ResetValue="0x3FFF"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_dbi2_bar4_mask_reg_t;

#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_DEFAULT (0x00007fffU)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_RD_MASK (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_WR_MASK (0xffffffffU)


///< BAR4 Mask Enabled.   Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_END_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_END_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_END_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_END_BF_DEF (0x00000001)

///< BAR4 Mask.   Note: The access attributes of this field are as follows:
///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
///< register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_MASK_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_MASK_BF_WID (31)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_MASK_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_PCI_TYPE0_BAR4_MASK_BF_DEF (0x00007FFE)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DBI2_BAR5_MASK_REG register description at address offset 0x100024
  *
  * Register default value:        0x00001FFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR_DBI2/BAR5_MASK_REG
  * BAR5 Mask Register.
  */

typedef union {
  struct {
    uint32_t PCI_TYPE0_BAR5_ENABLED : 1;
    ///< BAR5 Mask Enabled.   Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x1"
    uint32_t PCI_TYPE0_BAR5_MASK : 31;
    ///< BAR5 Mask.   Note: The access attributes of this field are as follows:
    ///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
    ///< register field is sticky.
    ///< AccessType="WS" BitOffset="1" ResetValue="0xFFF"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_dbi2_bar5_mask_reg_t;

#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_DEFAULT (0x00001fffU)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_RD_MASK (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_WR_MASK (0xffffffffU)


///< BAR5 Mask Enabled.   Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_END_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_END_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_END_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_END_BF_DEF (0x00000001)

///< BAR5 Mask.   Note: The access attributes of this field are as follows:
///< - Wire: No access   - Dbi: No access   - Dbi2: W (sticky) Note: This
///< register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_MASK_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_MASK_BF_WID (31)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_MASK_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_PCI_TYPE0_BAR5_MASK_BF_DEF (0x00001FFE)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_REG register description at address offset 0x100030
  *
  * Register default value:        0x0001FFFE
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_TYPE0_HDR_DBI2/EXP_ROM_BAR_MASK_REG
  * Expansion ROM BAR Mask Register.
  */

typedef union {
  struct {
    uint32_t ROM_BAR_ENABLED : 1;
    ///< Expansion ROM Bar Mask Register Enabled.   Note: The access attributes
    ///< of this field are as follows:  - Wire: No access   - Dbi: No access
    ///< - Dbi2: if ROM_MASK_WRITABLE then W Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint32_t ROM_MASK : 31;
    ///< Expansion ROM Mask.   Note: The access attributes of this field are
    ///< as follows:  - Wire: No access   - Dbi: No access   - Dbi2: if ROM_BAR_ENABLED
    ///< && ROM_MASK_WRITABLE then W Note: This register field is sticky.
    ///< AccessType="WS" BitOffset="1" ResetValue="0xFFFF"
  } ;
  uint32_t value;
} pcie_ctl_type0_hdr_dbi2_exp_rom_bar_mask_reg_t;

#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_DEFAULT (0x0001fffeU)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_RD_MASK (0x00000000U)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_WR_MASK (0xffffffffU)


///< Expansion ROM Bar Mask Register Enabled.   Note: The access attributes
///< of this field are as follows:  - Wire: No access   - Dbi: No access
///< - Dbi2: if ROM_MASK_WRITABLE then W Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_BAR_END_BF_OFF ( 0)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_BAR_END_BF_WID ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_BAR_END_BF_MSK (0x00000001)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_BAR_END_BF_DEF (0x00000000)

///< Expansion ROM Mask.   Note: The access attributes of this field are
///< as follows:  - Wire: No access   - Dbi: No access   - Dbi2: if ROM_BAR_ENABLED
///< && ROM_MASK_WRITABLE then W Note: This register field is sticky.
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_MASK_BF_OFF ( 1)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_MASK_BF_WID (31)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_MASK_BF_MSK (0xFFFFFFFE)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ROM_MASK_BF_DEF (0x0001FFFE)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_PCIE_CAP_DBI2_SHADOW_LINK_CAPABILITIES_REG register description at address offset 0x10007c
  *
  * Register default value:        0x00437C25
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_PCIE_CAP_DBI2/SHADOW_LINK_CAPABILITIES_REG
  * Shadow Link Capabilities Register.
  */

typedef union {
  struct {
    uint32_t PCIE_CAP_MAX_LINK_SPEED : 4;
    ///< Shadow Maximum Link Speed. This field indicates the maximum Link speed
    ///< of the associated Port. The encoded value specifies a bit location
    ///< in the Supported Link Speeds Vector (in the Link Capabilities 2 register)
    ///< that corresponds to the maximum Link speed. All encodings other than
    ///< the defined encodings are reserved.  Multi-Function Devices associated
    ///< with an Upstream Port must report the same value in this field for
    ///< all functions.   Note: The access attributes of this field are as
    ///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W else R  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x5"
    uint32_t PCIE_CAP_MAX_LINK_WIDTH : 6;
    ///< Shadow Maximum Link Width. This field indicates the maximum Link width
    ///< (xN - corresponding to N Lanes) implemented by the component. This
    ///< value is permitted to exceed the number of Lanes routed to the slot
    ///< (Downstream Port), adapter connector (Upstream Port), or in the case
    ///< of component-to-component connections, the actual wired connection
    ///< width. All encodings other than the defined encodings are reserved.
    ///< Multi-Function devices associated with an Upstream Port must report
    ///< the same value in this field for all functions.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x2"
    uint32_t PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT : 2;
    ///< Shadow Level of ASPM (Active State Power Management) Support. This
    ///< field indicates the level of ASPM supported on the given PCI Express
    ///< Link. For more information on ASPM support requirements, see section
    ///< 5.4.1 of PCI Express Base Specification. Multi-Function devices associated
    ///< with an Upstream Port must report the same value in this field for
    ///< all functions.  Note: The access attributes of this field are as follows:
    ///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
    ///< Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="10" ResetValue="0x3"
    uint32_t SHADOW_PCIE_CAP_L0S_EXIT_LATENCY : 3;
    ///< Shadow L0s Exit Latency. There are two each of these register fields,
    ///< this one and a shadow one at the same address. The Common Clock bit
    ///< (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control Register (LINK_CONTROL_LINK_STATUS_REG)
    ///< determines which one is used by the controller and which one is accessed
    ///< by a read request. Common Clock operation is enabled in the controller
    ///< when you set the Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of
    ///< the Link Control Register (LINK_CONTROL_LINK_STATUS_REG). The assertion
    ///< of CS2 (that is, assert the dbi_cs2 input, or the CS2 address bit
    ///< for the AXI bridge) is required to write to the shadow field at this
    ///< location.   Note: The access attributes of this field are as follows:
    ///< - Wire: R   - Dbi: R   - Dbi2: R/W
    ///< AccessType="RO" BitOffset="12" ResetValue="0x7"
    uint32_t SHADOW_PCIE_CAP_L1_EXIT_LATENCY : 3;
    ///< Shadow L1 Exit Latency. There are two each of these register fields,
    ///< this one and a shadow one at the same address. The Common Clock bit
    ///< (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control Register (LINK_CONTROL_LINK_STATUS_REG)
    ///< determines which one is used by the controller and which one is accessed
    ///< by a read request. Common Clock operation is enabled in the controller
    ///< when you set the Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of
    ///< the Link Control Register (LINK_CONTROL_LINK_STATUS_REG). The assertion
    ///< of CS2 (that is, assert the dbi_cs2 input, or the CS2 address bit
    ///< for the AXI bridge) is required to write to the shadow field at this
    ///< location.   Note: The access attributes of this field are as follows:
    ///< - Wire: R   - Dbi: R   - Dbi2: R/W
    ///< AccessType="RO" BitOffset="15" ResetValue="0x6"
    uint32_t PCIE_CAP_CLOCK_POWER_MAN : 1;
    ///< Shadow Clock Power Management. For Upstream Ports, a value of 1b in
    ///< this bit indicates that the component tolerates the removal of any
    ///< reference clock(s) through the  clock request  (CLKREQ#) mechanism
    ///< when the Link is in the L1 and L2/L3 Ready Link states. A value of
    ///< 0b indicates the component does not have this capability and that
    ///< reference clock(s) must not be removed in these Link states.  L1 PM
    ///< Substates defines other semantics for the CLKREQ# signal, which are
    ///< managed independently of Clock Power Management.  This Capability
    ///< is applicable only in form factors that support  clock request  (CLKREQ#)
    ///< capability.  For a Multi-Function device associated with an Upstream
    ///< Port, each Function indicates its capability independently. Power
    ///< Management configuration software must only permit reference clock
    ///< removal if all functions of the Multi-Function device indicate a 1b
    ///< in this bit. For ARI Devices, all Functions must indicate the same
    ///< value in this bit.  For Downstream Ports, the controller hardwires
    ///< this bit to 0b.   Note: The access attributes of this field are as
    ///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
    ///< R/W(sticky) else R(sticky)  Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
    uint32_t PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP : 1;
    ///< Shadow Surprise Down Error Reporting Capable. For a Downstream Port,
    ///< this bit must be set if the component supports the optional capability
    ///< of detecting and reporting a Surprise Down error condition.  For Upstream
    ///< Ports and components that do not support this optional capability,
    ///< the controller hardwires this bit to 0b.   Note: This register field
    ///< is sticky.
    ///< AccessType="RO" BitOffset="19" ResetValue="0x0"
    uint32_t PCIE_CAP_DLL_ACTIVE_REP_CAP : 1;
    ///< Shadow Data Link Layer Link Active Reporting Capable. For a Downstream
    ///< Port, the controller hardwires this bit to 1b if the component supports
    ///< the optional capability of reporting the DL_Active state of the Data
    ///< Link Control and Management State Machine. For a hot-plug capable
    ///< Downstream Port (as indicated by the Hot-Plug Capable bit of the Slot
    ///< Capabilities register) or a Downstream Port that supports Link speeds
    ///< greater than 5.0 GT/s, the controller hardwires this bit to 1b.  For
    ///< Upstream Ports and components that do not support this optional capability,
    ///< the controller hardwires this bit to 0b.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t PCIE_CAP_LINK_BW_NOT_CAP : 1;
    ///< Shadow Link Bandwidth Notification Capable. A value of 1b indicates
    ///< support for the Link Bandwidth Notification status and interrupt mechanisms.
    ///< This capability is required for all Root Ports and Switch Downstream
    ///< Ports supporting Links wider than x1 and/or multiple Link speeds.
    ///< This field is not applicable and is Reserved for Endpoints, PCI Express
    ///< to PCI/PCI-X bridges, and Upstream Ports of Switches.  For functions
    ///< that do not implement the Link Bandwidth Notification Capability the
    ///< controller hardwires this bit to 0b.   Note: This register field is
    ///< sticky.
    ///< AccessType="RO" BitOffset="21" ResetValue="0x0"
    uint32_t PCIE_CAP_ASPM_OPT_COMPLIANCE : 1;
    ///< Shadow ASPM Optionality Compliance. This field must be set to 1b in
    ///< all functions. Components implemented against certain earlier versions
    ///< of this specification will have this bit set to 0b.  Software is permitted
    ///< to use the value of this bit to help determine whether to enable ASPM
    ///< or whether to run ASPM compliance tests.   Note: The access attributes
    ///< of this field are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN
    ///< == 1) then R/W else R
    ///< AccessType="RO" BitOffset="22" ResetValue="0x1"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
    uint32_t PCIE_CAP_PORT_NUM : 8;
    ///< Shadow Port Number. This field indicates the PCI Express Port number
    ///< for the given PCI Express Link. Multi-Function Devices associated
    ///< with an Upstream Port must report the same value in this field for
    ///< all functions.   Note: The access attributes of this field are as
    ///< follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W
    ///< else R
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_pcie_cap_dbi2_shdw_link_capabilities_reg_t;

#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_DEFAULT (0x00437c25U)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_RD_MASK (0xff7fffffU)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_WR_MASK (0x00000000U)


///< Shadow Maximum Link Speed. This field indicates the maximum Link speed
///< of the associated Port. The encoded value specifies a bit location
///< in the Supported Link Speeds Vector (in the Link Capabilities 2 register)
///< that corresponds to the maximum Link speed. All encodings other than
///< the defined encodings are reserved.  Multi-Function Devices associated
///< with an Upstream Port must report the same value in this field for
///< all functions.   Note: The access attributes of this field are as
///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W else R  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_OFF ( 0)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_WID ( 4)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_MSK (0x0000000F)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_SPEED_BF_DEF (0x00000005)

///< Shadow Maximum Link Width. This field indicates the maximum Link width
///< (xN - corresponding to N Lanes) implemented by the component. This
///< value is permitted to exceed the number of Lanes routed to the slot
///< (Downstream Port), adapter connector (Upstream Port), or in the case
///< of component-to-component connections, the actual wired connection
///< width. All encodings other than the defined encodings are reserved.
///< Multi-Function devices associated with an Upstream Port must report
///< the same value in this field for all functions.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< if (DBI_RO_WR_EN == 1) then R/W else R  Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_OFF ( 4)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_WID ( 6)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_MSK (0x000003F0)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_MAX_LINK_WIDTH_BF_DEF (0x00000020)

///< Shadow Level of ASPM (Active State Power Management) Support. This
///< field indicates the level of ASPM supported on the given PCI Express
///< Link. For more information on ASPM support requirements, see section
///< 5.4.1 of PCI Express Base Specification. Multi-Function devices associated
///< with an Upstream Port must report the same value in this field for
///< all functions.  Note: The access attributes of this field are as follows:
///< - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then R/W else R
///< Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_OFF (10)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_WID ( 2)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_MSK (0x00000C00)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_BF_DEF (0x00000C00)

///< Shadow L0s Exit Latency. There are two each of these register fields,
///< this one and a shadow one at the same address. The Common Clock bit
///< (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control Register (LINK_CONTROL_LINK_STATUS_REG)
///< determines which one is used by the controller and which one is accessed
///< by a read request. Common Clock operation is enabled in the controller
///< when you set the Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of
///< the Link Control Register (LINK_CONTROL_LINK_STATUS_REG). The assertion
///< of CS2 (that is, assert the dbi_cs2 input, or the CS2 address bit
///< for the AXI bridge) is required to write to the shadow field at this
///< location.   Note: The access attributes of this field are as follows:
///< - Wire: R   - Dbi: R   - Dbi2: R/W
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L0S_EXIT_LATENCY_BF_OFF (12)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L0S_EXIT_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L0S_EXIT_LATENCY_BF_MSK (0x00007000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L0S_EXIT_LATENCY_BF_DEF (0x00007000)

///< Shadow L1 Exit Latency. There are two each of these register fields,
///< this one and a shadow one at the same address. The Common Clock bit
///< (PCIE_CAP_COMMON_CLK_CONFIG) of the Link Control Register (LINK_CONTROL_LINK_STATUS_REG)
///< determines which one is used by the controller and which one is accessed
///< by a read request. Common Clock operation is enabled in the controller
///< when you set the Common Clock bit (PCIE_CAP_COMMON_CLK_CONFIG) of
///< the Link Control Register (LINK_CONTROL_LINK_STATUS_REG). The assertion
///< of CS2 (that is, assert the dbi_cs2 input, or the CS2 address bit
///< for the AXI bridge) is required to write to the shadow field at this
///< location.   Note: The access attributes of this field are as follows:
///< - Wire: R   - Dbi: R   - Dbi2: R/W
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L1_EXIT_LATENCY_BF_OFF (15)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L1_EXIT_LATENCY_BF_WID ( 3)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L1_EXIT_LATENCY_BF_MSK (0x00038000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_SHDW_PCIE_CAP_L1_EXIT_LATENCY_BF_DEF (0x00030000)

///< Shadow Clock Power Management. For Upstream Ports, a value of 1b in
///< this bit indicates that the component tolerates the removal of any
///< reference clock(s) through the  clock request  (CLKREQ#) mechanism
///< when the Link is in the L1 and L2/L3 Ready Link states. A value of
///< 0b indicates the component does not have this capability and that
///< reference clock(s) must not be removed in these Link states.  L1 PM
///< Substates defines other semantics for the CLKREQ# signal, which are
///< managed independently of Clock Power Management.  This Capability
///< is applicable only in form factors that support  clock request  (CLKREQ#)
///< capability.  For a Multi-Function device associated with an Upstream
///< Port, each Function indicates its capability independently. Power
///< Management configuration software must only permit reference clock
///< removal if all functions of the Multi-Function device indicate a 1b
///< in this bit. For ARI Devices, all Functions must indicate the same
///< value in this bit.  For Downstream Ports, the controller hardwires
///< this bit to 0b.   Note: The access attributes of this field are as
///< follows:  - Wire: R (sticky)   - Dbi: if (DBI_RO_WR_EN == 1) then
///< R/W(sticky) else R(sticky)  Note: This register field is sticky.
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_OFF (18)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_MSK (0x00040000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_CLK_PWR_MAN_BF_DEF (0x00000000)

///< Shadow Surprise Down Error Reporting Capable. For a Downstream Port,
///< this bit must be set if the component supports the optional capability
///< of detecting and reporting a Surprise Down error condition.  For Upstream
///< Ports and components that do not support this optional capability,
///< the controller hardwires this bit to 0b.   Note: This register field
///< is sticky.
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_OFF (19)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_MSK (0x00080000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BF_DEF (0x00000000)

///< Shadow Data Link Layer Link Active Reporting Capable. For a Downstream
///< Port, the controller hardwires this bit to 1b if the component supports
///< the optional capability of reporting the DL_Active state of the Data
///< Link Control and Management State Machine. For a hot-plug capable
///< Downstream Port (as indicated by the Hot-Plug Capable bit of the Slot
///< Capabilities register) or a Downstream Port that supports Link speeds
///< greater than 5.0 GT/s, the controller hardwires this bit to 1b.  For
///< Upstream Ports and components that do not support this optional capability,
///< the controller hardwires this bit to 0b.
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_OFF (20)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_MSK (0x00100000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_DLL_ACTIVE_REP_CAP_BF_DEF (0x00000000)

///< Shadow Link Bandwidth Notification Capable. A value of 1b indicates
///< support for the Link Bandwidth Notification status and interrupt mechanisms.
///< This capability is required for all Root Ports and Switch Downstream
///< Ports supporting Links wider than x1 and/or multiple Link speeds.
///< This field is not applicable and is Reserved for Endpoints, PCI Express
///< to PCI/PCI-X bridges, and Upstream Ports of Switches.  For functions
///< that do not implement the Link Bandwidth Notification Capability the
///< controller hardwires this bit to 0b.   Note: This register field is
///< sticky.
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_OFF (21)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_MSK (0x00200000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_LINK_BW_NOT_CAP_BF_DEF (0x00000000)

///< Shadow ASPM Optionality Compliance. This field must be set to 1b in
///< all functions. Components implemented against certain earlier versions
///< of this specification will have this bit set to 0b.  Software is permitted
///< to use the value of this bit to help determine whether to enable ASPM
///< or whether to run ASPM compliance tests.   Note: The access attributes
///< of this field are as follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN
///< == 1) then R/W else R
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_OFF (22)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_WID ( 1)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_MSK (0x00400000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_ASPM_OPT_COMPLIANCE_BF_DEF (0x00400000)

///< Shadow Port Number. This field indicates the PCI Express Port number
///< for the given PCI Express Link. Multi-Function Devices associated
///< with an Upstream Port must report the same value in this field for
///< all functions.   Note: The access attributes of this field are as
///< follows:  - Wire: HWINIT   - Dbi: if (DBI_RO_WR_EN == 1) then R/W
///< else R
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_OFF (24)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_WID ( 8)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_MSK (0xFF000000)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_PCIE_CAP_PORT_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0 register description at address offset 0x300000
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_0
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0 register description at address offset 0x300004
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_0
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0 register description at address offset 0x300008
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0 register description at address offset 0x30000c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0 register description at address offset 0x300010
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_0
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0 register description at address offset 0x300014
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0 register description at address offset 0x300018
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0 register description at address offset 0x300100
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_0
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0 register description at address offset 0x300104
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_0
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0 register description at address offset 0x300108
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_0
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0 register description at address offset 0x30010c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_0
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0 register description at address offset 0x300110
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_0
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0 register description at address offset 0x300114
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_0
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_0_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1 register description at address offset 0x300200
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_1
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1 register description at address offset 0x300204
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_1
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1 register description at address offset 0x300208
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1 register description at address offset 0x30020c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1 register description at address offset 0x300210
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_1
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1 register description at address offset 0x300214
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1 register description at address offset 0x300218
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1 register description at address offset 0x300300
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_1
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1 register description at address offset 0x300304
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_1
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1 register description at address offset 0x300308
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_1
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1 register description at address offset 0x30030c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_1
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1 register description at address offset 0x300310
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_1
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1 register description at address offset 0x300314
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_1
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_1_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2 register description at address offset 0x300400
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_2
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2 register description at address offset 0x300404
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_2
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2 register description at address offset 0x300408
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2 register description at address offset 0x30040c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2 register description at address offset 0x300410
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_2
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2 register description at address offset 0x300414
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2 register description at address offset 0x300418
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2 register description at address offset 0x300500
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_2
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2 register description at address offset 0x300504
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_2
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2 register description at address offset 0x300508
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_2
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2 register description at address offset 0x30050c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_2
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2 register description at address offset 0x300510
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_2
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2 register description at address offset 0x300514
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_2
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_2_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3 register description at address offset 0x300600
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_3
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3 register description at address offset 0x300604
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_3
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3 register description at address offset 0x300608
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3 register description at address offset 0x30060c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3 register description at address offset 0x300610
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_3
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3 register description at address offset 0x300614
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3 register description at address offset 0x300618
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3 register description at address offset 0x300700
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_3
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3 register description at address offset 0x300704
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_3
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3 register description at address offset 0x300708
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_3
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3 register description at address offset 0x30070c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_3
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3 register description at address offset 0x300710
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_3
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3 register description at address offset 0x300714
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_3
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_3_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4 register description at address offset 0x300800
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_4
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4 register description at address offset 0x300804
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_4
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4 register description at address offset 0x300808
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4 register description at address offset 0x30080c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4 register description at address offset 0x300810
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_4
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4 register description at address offset 0x300814
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4 register description at address offset 0x300818
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4 register description at address offset 0x300900
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_4
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4 register description at address offset 0x300904
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_4
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4 register description at address offset 0x300908
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_4
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4 register description at address offset 0x30090c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_4
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4 register description at address offset 0x300910
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_4
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4 register description at address offset 0x300914
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_4
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_4_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5 register description at address offset 0x300a00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_5
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5 register description at address offset 0x300a04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_5
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5 register description at address offset 0x300a08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5 register description at address offset 0x300a0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5 register description at address offset 0x300a10
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_5
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5 register description at address offset 0x300a14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5 register description at address offset 0x300a18
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5 register description at address offset 0x300b00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_5
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5 register description at address offset 0x300b04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_5
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5 register description at address offset 0x300b08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_5
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5 register description at address offset 0x300b0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_5
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5 register description at address offset 0x300b10
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_5
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5 register description at address offset 0x300b14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_5
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_5_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6 register description at address offset 0x300c00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_6
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6 register description at address offset 0x300c04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_6
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6 register description at address offset 0x300c08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6 register description at address offset 0x300c0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6 register description at address offset 0x300c10
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_6
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6 register description at address offset 0x300c14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6 register description at address offset 0x300c18
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6 register description at address offset 0x300d00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_6
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6 register description at address offset 0x300d04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_6
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6 register description at address offset 0x300d08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_6
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6 register description at address offset 0x300d0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_6
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6 register description at address offset 0x300d10
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_6
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6 register description at address offset 0x300d14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_6
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_6_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7 register description at address offset 0x300e00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_7
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7 register description at address offset 0x300e04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_7
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7 register description at address offset 0x300e08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7 register description at address offset 0x300e0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7 register description at address offset 0x300e10
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_7
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7 register description at address offset 0x300e14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7 register description at address offset 0x300e18
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7 register description at address offset 0x300f00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_7
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7 register description at address offset 0x300f04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_7
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7 register description at address offset 0x300f08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_7
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7 register description at address offset 0x300f0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_7
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7 register description at address offset 0x300f10
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_7
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7 register description at address offset 0x300f14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_7
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_7_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8 register description at address offset 0x301000
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_8
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8 register description at address offset 0x301004
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_8
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8 register description at address offset 0x301008
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8 register description at address offset 0x30100c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8 register description at address offset 0x301010
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_8
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8 register description at address offset 0x301014
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8 register description at address offset 0x301018
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8 register description at address offset 0x301100
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_8
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8 register description at address offset 0x301104
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_8
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8 register description at address offset 0x301108
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_8
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8 register description at address offset 0x30110c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_8
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8 register description at address offset 0x301110
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_8
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8 register description at address offset 0x301114
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_8
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_8_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9 register description at address offset 0x301200
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_9
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9 register description at address offset 0x301204
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_9
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9 register description at address offset 0x301208
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9 register description at address offset 0x30120c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9 register description at address offset 0x301210
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_9
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9 register description at address offset 0x301214
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9 register description at address offset 0x301218
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9 register description at address offset 0x301300
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_9
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9 register description at address offset 0x301304
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_9
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9 register description at address offset 0x301308
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_9
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9 register description at address offset 0x30130c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_9
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9 register description at address offset 0x301310
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_9
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9 register description at address offset 0x301314
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_9
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_9_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10 register description at address offset 0x301400
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_10
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10 register description at address offset 0x301404
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_10
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10 register description at address offset 0x301408
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10 register description at address offset 0x30140c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10 register description at address offset 0x301410
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_10
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10 register description at address offset 0x301414
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10 register description at address offset 0x301418
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10 register description at address offset 0x301500
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_10
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10 register description at address offset 0x301504
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_10
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10 register description at address offset 0x301508
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_10
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10 register description at address offset 0x30150c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_10
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10 register description at address offset 0x301510
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_10
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10 register description at address offset 0x301514
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_10
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_10_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11 register description at address offset 0x301600
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_11
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11 register description at address offset 0x301604
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_11
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11 register description at address offset 0x301608
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11 register description at address offset 0x30160c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11 register description at address offset 0x301610
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_11
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11 register description at address offset 0x301614
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11 register description at address offset 0x301618
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11 register description at address offset 0x301700
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_11
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11 register description at address offset 0x301704
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_11
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11 register description at address offset 0x301708
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_11
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11 register description at address offset 0x30170c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_11
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11 register description at address offset 0x301710
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_11
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11 register description at address offset 0x301714
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_11
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_11_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12 register description at address offset 0x301800
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_12
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12 register description at address offset 0x301804
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_12
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12 register description at address offset 0x301808
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12 register description at address offset 0x30180c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12 register description at address offset 0x301810
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_12
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12 register description at address offset 0x301814
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12 register description at address offset 0x301818
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12 register description at address offset 0x301900
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_12
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12 register description at address offset 0x301904
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_12
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12 register description at address offset 0x301908
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_12
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12 register description at address offset 0x30190c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_12
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12 register description at address offset 0x301910
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_12
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12 register description at address offset 0x301914
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_12
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_12_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13 register description at address offset 0x301a00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_13
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13 register description at address offset 0x301a04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_13
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13 register description at address offset 0x301a08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13 register description at address offset 0x301a0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13 register description at address offset 0x301a10
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_13
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13 register description at address offset 0x301a14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13 register description at address offset 0x301a18
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13 register description at address offset 0x301b00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_13
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13 register description at address offset 0x301b04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_13
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13 register description at address offset 0x301b08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_13
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13 register description at address offset 0x301b0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_13
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13 register description at address offset 0x301b10
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_13
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13 register description at address offset 0x301b14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_13
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_13_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14 register description at address offset 0x301c00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_14
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14 register description at address offset 0x301c04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_14
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14 register description at address offset 0x301c08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14 register description at address offset 0x301c0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14 register description at address offset 0x301c10
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_14
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14 register description at address offset 0x301c14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14 register description at address offset 0x301c18
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14 register description at address offset 0x301d00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_14
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14 register description at address offset 0x301d04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_14
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14 register description at address offset 0x301d08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_14
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14 register description at address offset 0x301d0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_14
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14 register description at address offset 0x301d10
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_14
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14 register description at address offset 0x301d14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_14
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_14_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15 register description at address offset 0x301e00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_OUTBOUND_15
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TYPE field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the TC field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< This is a reserved field. Do not use.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the address of an outbound TLP is matched to this region, then
    ///< the ATTR field of the TLP is changed to the value in this register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  When the address of an outbound TLP is matched to
    ///< this region and the FUNC_BYPASS field in the  iATU Region Control
    ///< 2 Register  is '0', then the function number used in generating the
    ///< function part of the requester ID (RID) field of the TLP is taken
    ///< from this 5-bit register. The value in this register must be 0x0 unless
    ///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
    ///< When you are using the AXI Bridge, then this field is swapped before
    ///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
    ///< and  Max_Payload_Size  values are used.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_WR_MASK (0x007027ffU)


///< When the address of an outbound TLP is matched to this region, then
///< the TYPE field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TYPE_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the TC field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TC_BF_DEF (0x00000000)

///< This is a reserved field. Do not use.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_TD_BF_DEF (0x00000000)

///< When the address of an outbound TLP is matched to this region, then
///< the ATTR field of the TLP is changed to the value in this register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  When the address of an outbound TLP is matched to
///< this region and the FUNC_BYPASS field in the  iATU Region Control
///< 2 Register  is '0', then the function number used in generating the
///< function part of the requester ID (RID) field of the TLP is taken
///< from this 5-bit register. The value in this register must be 0x0 unless
///< multifunction operation in the controller is enabled (CX_NFUNC > 1).
///< When you are using the AXI Bridge, then this field is swapped before
///< AXI decomposition occurs so that the correct  Max_Read_Request_Size
///< and  Max_Payload_Size  values are used.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15 register description at address offset 0x301e04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_OUTBOUND_15
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
    ///< to this region, and the translated TLP TYPE field is Msg or MsgD;
    ///< then the message field of the TLP is changed to the value in this
    ///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< outbound TLP is matched to this region, and the translated TLP TYPE
    ///< field targets memory space; then the ST field of the TLP is changed
    ///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TAG : 8;
    ///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
    ///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TAG_SUBSTITUTE_EN : 1;
    ///< TAG Substitute Enable. When enabled and region address is matched,
    ///< the iATU substitutes the TAG field of the outbound TLP header with
    ///< the contents of the TAG field in this register. The expected usage
    ///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
    ///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
    ///< this field (byte 6) in the TLP header is the ST field. ST substitution
    ///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
    ///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
    ///< tags, TAG substitution only applies to the 8 least significant bits
    ///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
    ///< of the Header are notsubstitued.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MSB2BITS_TAG : 2;
    ///< Not used. Reserved for future use.   Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FUNC_BYPASS : 1;
    ///< Function Number Translation Bypass. In this mode, the function number
    ///< of the translated TLP is taken from your application transmit interface
    ///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
    ///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SNP : 1;
    ///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
    ///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
    ///< on the wire if there are no other same ID Non-Posted Requests outstanding.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t TLP_HEADER_FIELDS_BYPASS : 1;
    ///< TLP Header Fields Translation Bypass.  In this mode header fields
    ///< of the translated TLP is taken from your application transmit interface
    ///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
    ///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
    ///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
    ///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t INHIBIT_PAYLOAD : 1;
    ///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
    ///< region to be TLP without data. When enabled and region address is
    ///< matched, the iATU marks all TLPs as having no payload data by forcing
    ///< the TLP header Fmt[1] bit =0, regardless of the application inputs
    ///< such as slv_wstrb. Encoding are define as above.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HEADER_SUBSTITUTE_EN : 1;
    ///< Header Substitute Enable.  When enabled and region address is matched,
    ///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
    ///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
    ///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
    ///< Encodings are as above.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
    uint32_t DMA_BYPASS : 1;
    ///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
    ///< controller to pass through the iATU untranslated.  Note: This field
    ///< is reserved for the SW product. You must set it to '0'.  Note: This
    ///< register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
    ///< (on the XALI0/1/2 interface or AXI slave interface address) to form
    ///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
    ///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
    ///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
    ///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
    ///< mapped from memory space into any 256 MB region of the PCIe configuration
    ///< space.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode. When set the address matching region is inverted. Therefore,
    ///< an address match occurs when the untranslated address is in the region
    ///< outside the defined range (Base Address to Limit Address).  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_RD_MASK (0xb8ffffffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_WR_MASK (0xb8ffffffU)


///< MSG TLPs (Message Code). When the address of an outbound TLP is matched
///< to this region, and the translated TLP TYPE field is Msg or MsgD;
///< then the message field of the TLP is changed to the value in this
///< register.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< outbound TLP is matched to this region, and the translated TLP TYPE
///< field targets memory space; then the ST field of the TLP is changed
///< to the value in this register. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is 1.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSG_CODE_BF_DEF (0x00000000)

///< TAG.  The substituted TAG field (byte 6) in the outgoing TLP header
///< when TAG_SUBSTITUTE_EN is set.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_BF_MSK (0x0000FF00)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_BF_DEF (0x00000000)

///< TAG Substitute Enable. When enabled and region address is matched,
///< the iATU substitutes the TAG field of the outbound TLP header with
///< the contents of the TAG field in this register. The expected usage
///< scenario is translation from AXI MWr to Vendor Defined Msg/MsgD.
///< Note (CX_TPH_ENABLE=1): TAG substitution for MWr will not occur because
///< this field (byte 6) in the TLP header is the ST field. ST substitution
///< can still take place using the MSG_CODE field in IATU_REGION_CTRL_2_OFF_OUTBOUND_i.
///< Note (CX_10BITS_TAG=1 || CX_14BITS_TAG=1):  For 10-bit tags and 14-bit
///< tags, TAG substitution only applies to the 8 least significant bits
///< of the TAG field (bits 7:0 of Byte 4 of the TLP Header). T9 and T8
///< of the Header are notsubstitued.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_SUBSTITUTE_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_SUBSTITUTE_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TAG_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< Not used. Reserved for future use.   Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSB2BITS_TAG_BF_OFF (17)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSB2BITS_TAG_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSB2BITS_TAG_BF_MSK (0x00060000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_MSB2BITS_TAG_BF_DEF (0x00000000)

///< Function Number Translation Bypass. In this mode, the function number
///< of the translated TLP is taken from your application transmit interface
///< and not from the CTRL_1_FUNC_NUM field of the  iATU Region Control
///< 1 Register  or the VF_NUMBER field of the  iATU Control 3 Register.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_FUNC_BYP_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_FUNC_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_FUNC_BYP_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_FUNC_BYP_BF_DEF (0x00000000)

///< Serialize Non-Posted Requests. In this mode, when the AXI Bridge is
///< populated, same AXI ID Non-Posted Read/Write Requests are transmitted
///< on the wire if there are no other same ID Non-Posted Requests outstanding.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_SNP_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_SNP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_SNP_BF_MSK (0x00100000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_SNP_BF_DEF (0x00000000)

///< TLP Header Fields Translation Bypass.  In this mode header fields
///< of the translated TLP is taken from your application transmit interface
///< or, if AMBA is configured,  from the AMBA sideband bus (slv_awmisc_info)
///< and not from the corresponding fields of the IATU_REGION_CTRL_1_OFF_OUTBOUND_i
///< or IATU_REGION_CTRL_2_OFF_OUTBOUND_i registers. The header fields
///< are  - TC  - PH  - TH  - ST  - AT  - Attr (IDO, RO and NS).   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TLP_HEADER_FIELDS_BYP_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TLP_HEADER_FIELDS_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TLP_HEADER_FIELDS_BYP_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_TLP_HEADER_FIELDS_BYP_BF_DEF (0x00000000)

///< Inhibit TLP Payload Data for TLP's in Matched Region; assign iATU
///< region to be TLP without data. When enabled and region address is
///< matched, the iATU marks all TLPs as having no payload data by forcing
///< the TLP header Fmt[1] bit =0, regardless of the application inputs
///< such as slv_wstrb. Encoding are define as above.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INHIBIT_PAYLOAD_BF_OFF (22)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INHIBIT_PAYLOAD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INHIBIT_PAYLOAD_BF_MSK (0x00400000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INHIBIT_PAYLOAD_BF_DEF (0x00000000)

///< Header Substitute Enable.  When enabled and region address is matched,
///< the iATU fully substitutes bytes 8-11 (for 3 DWORD header) or bytes
///< 12-15 (for 4 DWORD header) of the outbound TLP header with the contents
///< of the LWR_TARGET_RW field in IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_i.
///< Encodings are as above.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_HEADER_SUBSTITUTE_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_HEADER_SUBSTITUTE_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_HEADER_SUBSTITUTE_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_HEADER_SUBSTITUTE_EN_BF_DEF (0x00000000)

///< DMA Bypass Mode. Allows request TLPs which are initiated by the DMA
///< controller to pass through the iATU untranslated.  Note: This field
///< is reserved for the SW product. You must set it to '0'.  Note: This
///< register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_DMA_BYP_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_DMA_BYP_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_DMA_BYP_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_DMA_BYP_BF_DEF (0x00000000)

///< CFG Shift Mode.  The iATU uses bits [27:12] of the untranslated address
///< (on the XALI0/1/2 interface or AXI slave interface address) to form
///< the BDF number of the outgoing CFG TLP.  This supports the Enhanced
///< Configuration Address Mapping (ECAM) mechanism (Section 7.2.2 of the
///< PCI Express Base 3.1 Specification, revision 1.0) by allowing all
///< outgoing I/O and MEM TLPs (that have been translated to CFG) to be
///< mapped from memory space into any 256 MB region of the PCIe configuration
///< space.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode. When set the address matching region is inverted. Therefore,
///< an address match occurs when the untranslated address is in the region
///< outside the defined range (Base Address to Limit Address).  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_INVERT_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15 register description at address offset 0x301e08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15 register description at address offset 0x301e0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated. In systems with a 32-bit address space, this register
    ///< is not used and therefore writing to this register has no effect.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated. In systems with a 32-bit address space, this register
///< is not used and therefore writing to this register has no effect.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15 register description at address offset 0x301e10
  *
  * Register default value:        0x0000FFFF
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_OUTBOUND_15
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. A write to this location is ignored
    ///< by the PCIe controller.   Note: This register field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_DEFAULT (0x0000ffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_WR_MASK (0xffff0000U)


///< Circular Buffer.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_CBUF_INCR_BF_DEF (0x0000000F)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. A write to this location is ignored
///< by the PCIe controller.   Note: This register field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15 register description at address offset 0x301e14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_RW_OUTBOUND : 32;
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
    ///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
    ///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
    ///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so the lower bits of the start address of the new address
    ///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
    ///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
    ///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
    ///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
    ///< scenarios include the transmission of Vendor Defined Messages where
    ///< the controller determines the content of bytes 12 to 15 of the TLP
    ///< header.   Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_WR_MASK (0xffffffffU)


///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_ is '0'
///< (normal operation):  - LWR_TARGET_RW[31:n] forms MSB's of the Lower
///< Target part of the new address of the translated region;  - LWR_TARGET_RW[n-1:0]
///< are not used. (The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so the lower bits of the start address of the new address
///< of the translated region (bits n-1:0) are always '0').  - n is log2(CX_ATU_MIN_REGION_SIZE).
///< When HEADER_SUBSTITUTE_EN in IATU_REGION_CTRL_2_OFF_OUTBOUND_i is
///< '1':  - LWR_TARGET_RW[31:0] forms bytes 8-11 (for 3 dword header)
///< or bytes 12-15 (for 4 dword header) of the outbound TLP header. Usage
///< scenarios include the transmission of Vendor Defined Messages where
///< the controller determines the content of bytes 12 to 15 of the TLP
///< header.   Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_LWR_TARGET_RW_OUTBOUND_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_LWR_TARGET_RW_OUTBOUND_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_LWR_TARGET_RW_OUTBOUND_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_LWR_TARGET_RW_OUTBOUND_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15 register description at address offset 0x301e18
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15
  * iATU Upper Target Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_TARGET_RW : 32;
    ///< Forms bits [63:32] of the start address (Upper Target part) of the
    ///< new address of the translated region.   Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start address (Upper Target part) of the
///< new address of the translated region.   Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_UPPER_TARGET_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_UPPER_TARGET_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_UPPER_TARGET_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_UPPER_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15 register description at address offset 0x301f00
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_15
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15 register description at address offset 0x301f04
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_15
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15 register description at address offset 0x301f08
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_15
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15 register description at address offset 0x301f0c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_15
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15 register description at address offset 0x301f10
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_15
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15 register description at address offset 0x301f14
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_15
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_15_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16 register description at address offset 0x302100
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_16
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_16_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16 register description at address offset 0x302104
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_16
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_16_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16 register description at address offset 0x302108
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_16
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_16_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16 register description at address offset 0x30210c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_16
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_16_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16 register description at address offset 0x302110
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_16
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_16_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16 register description at address offset 0x302114
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_16
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_16_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17 register description at address offset 0x302300
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_17
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_17_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17 register description at address offset 0x302304
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_17
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_17_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17 register description at address offset 0x302308
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_17
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_17_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17 register description at address offset 0x30230c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_17
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_17_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17 register description at address offset 0x302310
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_17
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_17_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17 register description at address offset 0x302314
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_17
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_17_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18 register description at address offset 0x302500
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_18
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_18_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18 register description at address offset 0x302504
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_18
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_18_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18 register description at address offset 0x302508
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_18
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_18_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18 register description at address offset 0x30250c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_18
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_18_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18 register description at address offset 0x302510
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_18
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_18_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18 register description at address offset 0x302514
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_18
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_18_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19 register description at address offset 0x302700
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_1_OFF_INBOUND_19
  * iATU Region Control 1 Register.
  */

typedef union {
  struct {
    uint32_t TYPE : 5;
    ///< When the TYPE field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful).   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TC : 3;
    ///< When the TC field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TC Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TD : 1;
    ///< When the TD field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  TD Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t ATTR : 2;
    ///< When the ATTR field of an inbound TLP is matched to this value, then
    ///< address translation proceeds (when all other enabled field-matches
    ///< are successful). This check is only performed if the  ATTR Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t INCREASE_REGION_SIZE : 1;
    ///< Increase the maximum ATU Region size. When set, the maximum ATU Region
    ///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
    ///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CTRL_1_FUNC_NUM : 3;
    ///< Function Number.  MEM-I/O: When the Address and BAR matching logic
    ///< in the controller indicate that a MEM-I/O transaction matches a BAR
    ///< in the function corresponding to this value, then address translation
    ///< proceeds. This check is only performed if the  Function Number Match
    ///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
    ///< When the destination function number as specified in the routing ID
    ///< of the TLP header matches the function, then address translation proceeds.
    ///< This check is only performed if the  Function Number Match Enable
    ///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_19_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_RD_MASK (0x007027ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_WR_MASK (0x007027ffU)


///< When the TYPE field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful).   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TYPE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TYPE_BF_WID ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TYPE_BF_MSK (0x0000001F)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TYPE_BF_DEF (0x00000000)

///< When the TC field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TC Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TC_BF_OFF ( 5)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TC_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TC_BF_MSK (0x000000E0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TC_BF_DEF (0x00000000)

///< When the TD field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  TD Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TD_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TD_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TD_BF_MSK (0x00000100)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_TD_BF_DEF (0x00000000)

///< When the ATTR field of an inbound TLP is matched to this value, then
///< address translation proceeds (when all other enabled field-matches
///< are successful). This check is only performed if the  ATTR Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_ATTR_BF_OFF ( 9)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_ATTR_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_ATTR_BF_MSK (0x00000600)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_ATTR_BF_DEF (0x00000000)

///< Increase the maximum ATU Region size. When set, the maximum ATU Region
///< size is determined by CX_ATU_MAX_REGION_SIZE. When clear, the maximum
///< ATU Region size is 4 GB (default).  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_INCREASE_REGION_SIZE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_INCREASE_REGION_SIZE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_INCREASE_REGION_SIZE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_INCREASE_REGION_SIZE_BF_DEF (0x00000000)

///< Function Number.  MEM-I/O: When the Address and BAR matching logic
///< in the controller indicate that a MEM-I/O transaction matches a BAR
///< in the function corresponding to this value, then address translation
///< proceeds. This check is only performed if the  Function Number Match
///< Enable  bit of the  iATU Region Control 2 Register  is set.  CFG0/CFG1:
///< When the destination function number as specified in the routing ID
///< of the TLP header matches the function, then address translation proceeds.
///< This check is only performed if the  Function Number Match Enable
///< bit of the  iATU Region Control 2 Register  is set.   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_CTRL_1_FUNC_NUM_BF_OFF (20)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_CTRL_1_FUNC_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_CTRL_1_FUNC_NUM_BF_MSK (0x00700000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_CTRL_1_FUNC_NUM_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19 register description at address offset 0x302704
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_REGION_CTRL_2_OFF_INBOUND_19
  * iATU Region Control 2 Register.
  */

typedef union {
  struct {
    uint32_t MSG_CODE : 8;
    ///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
    ///< TLP is matched to this value, then address translation proceeds (when
    ///< all other enabled field-matches are successful). This check is only
    ///< performed if the  Message Code Match Enable  bit of the  iATU Region
    ///< Control 2 Register  is set and the TYPE field of the inbound TLP is
    ///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
    ///< inbound TLP is matched to this value, then address translation proceeds.
    ///< This check is only performed if the  ST Match Enable  bit of the
    ///< iATU Region Control 2 Register  is set. The setting is independent
    ///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
    ///< configuration parameter is '1'.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAR_NUM : 3;
    ///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
    ///< is matched by the normal internal BAR address matching mechanism
    ///< is the same as this field, address translation proceeds (when all
    ///< other enabled field-matches are successful). This check is only performed
    ///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
    ///< set. IO translation would require either 00100b or 00101b in the inbound
    ///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
    ///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t MSG_TYPE_MATCH_MODE : 1;
    ///< Message Type Match Mode. When enabled, and if single address location
    ///< translate enable is set, then inbound TLPs of type MSG/MSGd which
    ///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
    ///< register (TYPE[4:3]=2'b10) will be translated. Message type match
    ///< mode overrides any value of MATCH_MODE field in this register. Usage
    ///< scenarios for this are translation of VDM or ATS messages when AXI
    ///< bridge is configured on client interface.  Note: This register field
    ///< is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TC_MATCH_EN : 1;
    ///< TC Match Enable. Ensures that a successful TC TLP field comparison
    ///< match (see TC field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TD_MATCH_EN : 1;
    ///< TD Match Enable. Ensures that a successful TD TLP field comparison
    ///< match (see TD field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t ATTR_MATCH_EN : 1;
    ///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
    ///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t FUNC_NUM_MATCH_EN : 1;
    ///< Function Number Match Enable. Ensures that a successful Function Number
    ///< TLP field comparison match (see Function Number field of the  iATU
    ///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
    ///< for address translation to proceed.  Note: This register field is
    ///< sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
    uint32_t MSG_CODE_MATCH_EN : 1;
    ///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
    ///< Code TLP field comparison match (see Message Code field of the  iATU
    ///< Region Control 2 Register ) occurs (in MSG transactions) for address
    ///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
    ///< a successful ST TLP field comparison match (see ST field of the  iATU
    ///< Region Control 2 Register ) occurs (in MEM transactions) for address
    ///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
    ///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
    uint32_t SINGLE_ADDR_LOC_TRANS_EN : 1;
    ///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
    ///< be translated to a single address location as determined by the target
    ///< address register of the iATU region. The main usage scenario is translation
    ///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
    ///< the AXI bridge is enabled.  Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t RESPONSE_CODE : 2;
    ///< Response Code. Defines the type of response to give for accesses matching
    ///< this region. This overrides the normal RADM filter response. Note
    ///< that this feature is not available for any region where Single Address
    ///< Location Translate is enabled.   Note: This register field is sticky.
    ///< TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t FUZZY_TYPE_MATCH_CODE : 1;
    ///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
    ///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
    ///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
    ///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
    ///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
    ///< identical. For example, CFG0 in the TYPE field in the  iATU Region
    ///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
    ///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CFG_SHIFT_MODE : 1;
    ///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
    ///< configuration mechanism maps bits [27:12] of the address to the bus/device
    ///< and function number. This allows a CFG configuration space to be located
    ///< in any 256MB window of your application memory space using a 28-bit
    ///< effective address. Shifts bits [31:16] of the untranslated address
    ///< to form bits [27:12] of the translated address.  Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t INVERT_MODE : 1;
    ///< Invert Mode Enable. When set the address matching region is inverted.
    ///< Therefore, an address match occurs when the untranslated address is
    ///< in the region outside the defined range (Base Address to Limit Address).
    ///< When set all regions of that type must use address match mode.  Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t MATCH_MODE : 1;
    ///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
    ///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
    ///< this field is interpreted as follows:  - 0: Address Match Mode. The
    ///< iATU operates using addresses as in the outbound direction. The Region
    ///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
    ///< matching is used. The  BAR Number  field is relevant. Not used for
    ///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
    ///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
    ///< TLP header) as an address. This corresponds to the upper 16 bits of
    ///< the address in MEM-I/O transactions. The Routing ID of the TLP must
    ///< be within the base and limit of the iATU region for matching to proceed.
    ///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
    ///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
    ///< as all received CFG0 TLPs should be processed regardless of the Bus
    ///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
    ///< - 0: Address Match Mode. The iATU treats the third dword and fourth
    ///< dword of the inbound MSG/MSGD TLP as an address and it is matched
    ///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
    ///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
    ///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
    ///< of the third dword of the TLP header, but matches against the Vendor
    ///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
    ///< of the Region Upper Base register should be programmed with the required
    ///< Vendor ID. The lower Base and Limit Register should be programmed
    ///< to translate TLPs based on vendor specific information in the fourth
    ///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
    ///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
    ///< This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t REGION_EN : 1;
    ///< Region Enable. This bit must be set to '1' for address translation
    ///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_19_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_RD_MASK (0xfba9e7ffU)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_WR_MASK (0xfba9e7ffU)


///< MSG TLPs: (Message Code). When the MSG_CODE field of an inbound Msg/MsgD
///< TLP is matched to this value, then address translation proceeds (when
///< all other enabled field-matches are successful). This check is only
///< performed if the  Message Code Match Enable  bit of the  iATU Region
///< Control 2 Register  is set and the TYPE field of the inbound TLP is
///< Msg/MsgD.  Memory TLPs: (ST: Steering Tag). When the ST field of an
///< inbound TLP is matched to this value, then address translation proceeds.
///< This check is only performed if the  ST Match Enable  bit of the
///< iATU Region Control 2 Register  is set. The setting is independent
///< of the setting of the TH field. Only Valid when the CX_TPH_ENABLE
///< configuration parameter is '1'.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_BF_WID ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_BF_MSK (0x000000FF)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_BF_DEF (0x00000000)

///< BAR Number. When the BAR number of an inbound MEM or IO TLP   that
///< is matched by the normal internal BAR address matching mechanism
///< is the same as this field, address translation proceeds (when all
///< other enabled field-matches are successful). This check is only performed
///< if the  Match Mode  bit of the  iATU Region Control 2 Register  is
///< set. IO translation would require either 00100b or 00101b in the inbound
///< TLP TYPE; the BAR Number set in the range 000b - 101b and that BAR
///< configured as an IO BAR.  Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_BAR_NUM_BF_OFF ( 8)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_BAR_NUM_BF_WID ( 3)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_BAR_NUM_BF_MSK (0x00000700)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_BAR_NUM_BF_DEF (0x00000000)

///< Message Type Match Mode. When enabled, and if single address location
///< translate enable is set, then inbound TLPs of type MSG/MSGd which
///< match the type field of the IATU_REGION_CTRL_1_VIEWPORT_OFF_INBOUND_i
///< register (TYPE[4:3]=2'b10) will be translated. Message type match
///< mode overrides any value of MATCH_MODE field in this register. Usage
///< scenarios for this are translation of VDM or ATS messages when AXI
///< bridge is configured on client interface.  Note: This register field
///< is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_TYPE_MATCH_MODE_BF_OFF (13)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_TYPE_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_TYPE_MATCH_MODE_BF_MSK (0x00002000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_TYPE_MATCH_MODE_BF_DEF (0x00000000)

///< TC Match Enable. Ensures that a successful TC TLP field comparison
///< match (see TC field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TC_MATCH_EN_BF_OFF (14)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TC_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TC_MATCH_EN_BF_MSK (0x00004000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TC_MATCH_EN_BF_DEF (0x00000000)

///< TD Match Enable. Ensures that a successful TD TLP field comparison
///< match (see TD field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TD_MATCH_EN_BF_OFF (15)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TD_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TD_MATCH_EN_BF_MSK (0x00008000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_TD_MATCH_EN_BF_DEF (0x00000000)

///< ATTR Match Enable. Ensures that a successful ATTR TLP field comparison
///< match (see ATTR field of the  iATU Region Control 1 Register ) occurs
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_ATTR_MATCH_EN_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_ATTR_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_ATTR_MATCH_EN_BF_MSK (0x00010000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_ATTR_MATCH_EN_BF_DEF (0x00000000)

///< Function Number Match Enable. Ensures that a successful Function Number
///< TLP field comparison match (see Function Number field of the  iATU
///< Region Control 1 Register ) occurs (in MEM-I/O and CFG0/CFG1 transactions)
///< for address translation to proceed.  Note: This register field is
///< sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUNC_NUM_MATCH_EN_BF_OFF (19)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUNC_NUM_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUNC_NUM_MATCH_EN_BF_MSK (0x00080000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUNC_NUM_MATCH_EN_BF_DEF (0x00000000)

///< Message Code Match Enable (Msg TLPS). Ensures that a successful message
///< Code TLP field comparison match (see Message Code field of the  iATU
///< Region Control 2 Register ) occurs (in MSG transactions) for address
///< translation to proceed.  ST Match Enable (Mem TLPs). Ensures that
///< a successful ST TLP field comparison match (see ST field of the  iATU
///< Region Control 2 Register ) occurs (in MEM transactions) for address
///< translation to proceed. Only Valid when the CX_TPH_ENABLE configuration
///< parameter is '1'.  Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_MATCH_EN_BF_OFF (21)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_MATCH_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_MATCH_EN_BF_MSK (0x00200000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MSG_CODE_MATCH_EN_BF_DEF (0x00000000)

///< Single Address Location Translate Enable.  When enabled, Rx TLPs can
///< be translated to a single address location as determined by the target
///< address register of the iATU region. The main usage scenario is translation
///< of Messages (such as Vendor Defined or ATS Messages) to MWr TLPs when
///< the AXI bridge is enabled.  Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_SINGLE_ADDR_LOC_TRANS_EN_BF_OFF (23)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_SINGLE_ADDR_LOC_TRANS_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_SINGLE_ADDR_LOC_TRANS_EN_BF_MSK (0x00800000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_SINGLE_ADDR_LOC_TRANS_EN_BF_DEF (0x00000000)

///< Response Code. Defines the type of response to give for accesses matching
///< this region. This overrides the normal RADM filter response. Note
///< that this feature is not available for any region where Single Address
///< Location Translate is enabled.   Note: This register field is sticky.
///< TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_RSP_CODE_BF_OFF (24)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_RSP_CODE_BF_WID ( 2)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_RSP_CODE_BF_MSK (0x03000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_RSP_CODE_BF_DEF (0x00000000)

///< Fuzzy Type Match Enable. When enabled, the iATU relaxes the matching
///< of the TLP TYPE field against the expected TYPE field so that  - CfgRd0
///< and CfgRd1 TLPs are seen as identical. Similarly with CfgWr0 and CfgWr1.
///< - MWr, MRd, and MRdLk TLPs are seen as identical  - The Routing field
///< of Msg/MsgD TLPs is ignored  - FetchAdd, Swap, and CAS are seen as
///< identical. For example, CFG0 in the TYPE field in the  iATU Region
///< Control 1 Register  matches against an inbound CfgRd0, CfgRd1, CfgWr0,
///< or CfgWr1 TLP.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUZZY_TYPE_MATCH_CODE_BF_OFF (27)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUZZY_TYPE_MATCH_CODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUZZY_TYPE_MATCH_CODE_BF_MSK (0x08000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_FUZZY_TYPE_MATCH_CODE_BF_DEF (0x00000000)

///< CFG Shift Enable. This is useful for CFG transactions where the PCIe
///< configuration mechanism maps bits [27:12] of the address to the bus/device
///< and function number. This allows a CFG configuration space to be located
///< in any 256MB window of your application memory space using a 28-bit
///< effective address. Shifts bits [31:16] of the untranslated address
///< to form bits [27:12] of the translated address.  Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_CFG_SHIFT_MODE_BF_OFF (28)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_CFG_SHIFT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_CFG_SHIFT_MODE_BF_MSK (0x10000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_CFG_SHIFT_MODE_BF_DEF (0x00000000)

///< Invert Mode Enable. When set the address matching region is inverted.
///< Therefore, an address match occurs when the untranslated address is
///< in the region outside the defined range (Base Address to Limit Address).
///< When set all regions of that type must use address match mode.  Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_INVERT_MODE_BF_OFF (29)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_INVERT_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_INVERT_MODE_BF_MSK (0x20000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_INVERT_MODE_BF_DEF (0x00000000)

///< Match Mode. Determines Inbound matching mode for TLPs. The mode depends
///< on the type of TLP that is received as follows:   For MEM I/O TLPs,
///< this field is interpreted as follows:  - 0: Address Match Mode. The
///< iATU operates using addresses as in the outbound direction. The Region
///< Base and Limit Registers must be setup.  - 1: BAR Match Mode. BAR
///< matching is used. The  BAR Number  field is relevant. Not used for
///< RC. For CFG0 TLPs, this field is interpreted as follows:  - 0: Routing
///< ID Match Mode. The iATU interprets the Routing ID (Bytes 8 to 11 of
///< TLP header) as an address. This corresponds to the upper 16 bits of
///< the address in MEM-I/O transactions. The Routing ID of the TLP must
///< be within the base and limit of the iATU region for matching to proceed.
///< - 1: Accept Mode. The iATU accepts all CFG0 transactions as address
///< matches. The routing ID in the CFG0 TLP is ignored. This is useful
///< as all received CFG0 TLPs should be processed regardless of the Bus
///< number. For MSG/MSGD TLPs, this field is interpreted as follows:
///< - 0: Address Match Mode. The iATU treats the third dword and fourth
///< dword of the inbound MSG/MSGD TLP as an address and it is matched
///< against the Region Base and Limit Registers.  - 1: Vendor ID Match
///< Mode. This mode is relevant for ID-routed Vendor Defined Messages.
///< The iATU ignores the Routing ID (Bus, Device, Function) in bits [31:16]
///< of the third dword of the TLP header, but matches against the Vendor
///< ID in bits [15:0] of the third dword of the TLP header. Bits [15:0]
///< of the Region Upper Base register should be programmed with the required
///< Vendor ID. The lower Base and Limit Register should be programmed
///< to translate TLPs based on vendor specific information in the fourth
///< dword of the TLP header.  - If SINGLE_ADDRESS_LOCATION_TRANSLATE_EN
///< = 1 AND MSG_TYPE_MATCH_MODE =1, then Match Mode is ignored.   Note:
///< This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MATCH_MODE_BF_OFF (30)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MATCH_MODE_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MATCH_MODE_BF_MSK (0x40000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_MATCH_MODE_BF_DEF (0x00000000)

///< Region Enable. This bit must be set to '1' for address translation
///< to take place.  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_REGION_EN_BF_OFF (31)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_REGION_EN_BF_WID ( 1)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_REGION_EN_BF_MSK (0x80000000)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_REGION_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19 register description at address offset 0x302708
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_BASE_ADDR_OFF_INBOUND_19
  * iATU Lower Base Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_BASE_HW : 16;
    ///< Forms bits [n-1:0] of the start address of the address region to be
    ///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary, so these bits are always 0. A write to this location
    ///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_BASE_RW : 16;
    ///< Forms bits [31:n] of the start address of the address region to be
    ///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
    ///< field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_19_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_WR_MASK (0xffff0000U)


///< Forms bits [n-1:0] of the start address of the address region to be
///< translated. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary, so these bits are always 0. A write to this location
///< is ignored by the PCIe controller.  n is log2(CX_ATU_MIN_REGION_SIZE)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_HW_BF_DEF (0x00000000)

///< Forms bits [31:n] of the start address of the address region to be
///< translated.  n is log2(CX_ATU_MIN_REGION_SIZE)   Note: This register
///< field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_LWR_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19 register description at address offset 0x30270c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_UPPER_BASE_ADDR_OFF_INBOUND_19
  * iATU Upper Base Address Register.
  */

typedef union {
  struct {
    uint32_t UPPER_BASE_RW : 32;
    ///< Forms bits [63:32] of the start (and end) address of the address region
    ///< to be translated.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_19_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_WR_MASK (0xffffffffU)


///< Forms bits [63:32] of the start (and end) address of the address region
///< to be translated.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_UPPER_BASE_RW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_UPPER_BASE_RW_BF_WID (32)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_UPPER_BASE_RW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_UPPER_BASE_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19 register description at address offset 0x302710
  *
  * Register default value:        0x0000FFF0
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LIMIT_ADDR_OFF_INBOUND_19
  * iATU Limit Address Register.
  */

typedef union {
  struct {
    uint32_t CBUF_INCR : 4;
    ///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
    ///< is Read-only and forms the lowest bits of the end address of the address
    ///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
    ///< is R/W and forms the upper bits of the Circular Buffer Increment size
    ///< (CBUF_INCR) field for Single Location Address translation. The increment
    ///< value (in bytes) is decoded as follows: Note: A write to any bit in
    ///< the CBUF_INCR field resets the circular buffer pointer - that is,
    ///< the next matched received Message will be translated to the start
    ///< address of the Circular Buffer. This field must be written to AFTER
    ///< the target and limit registers have been updated.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
    ///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LIMIT_ADDR_HW : 12;
    ///< Forms lower bits of the end address of the address region to be translated.
    ///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
    ///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
    ///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
    ///< lower bits of the limit address for the circular buffer. A write to
    ///< this location is ignored by the PCIe controller.   Note: This register
    ///< field is sticky.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xFFF"
    uint32_t LIMIT_ADDR_RW : 16;
    ///< Forms upper bits of the end address of the address region to be translated.
    ///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
    ///< > 0 then this field forms the upper bits of the limit address for
    ///< the circular buffer.   Note: This register field is sticky.  TDISP
    ///< Prot :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_19_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_DEFAULT (0x0000fff0U)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_WR_MASK (0xffff000fU)


///< Circular Buffer Increment. When CX_ATU_SLOC_CBUF = 0, then this field
///< is Read-only and forms the lowest bits of the end address of the address
///< region to be translated. When CX_ATU_SLOC_CBUF = 1, then this field
///< is R/W and forms the upper bits of the Circular Buffer Increment size
///< (CBUF_INCR) field for Single Location Address translation. The increment
///< value (in bytes) is decoded as follows: Note: A write to any bit in
///< the CBUF_INCR field resets the circular buffer pointer - that is,
///< the next matched received Message will be translated to the start
///< address of the Circular Buffer. This field must be written to AFTER
///< the target and limit registers have been updated.   Note: The access
///< attributes of this field are as follows:  - Wire: R (sticky)   - Dbi:
///< R (sticky)  Note: This register field is sticky.  TDISP Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_CBUF_INCR_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_CBUF_INCR_BF_WID ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_CBUF_INCR_BF_MSK (0x0000000F)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_CBUF_INCR_BF_DEF (0x00000000)

///< Forms lower bits of the end address of the address region to be translated.
///< The end address must be aligned to a CX_ATU_MIN_REGION_SIZE kB boundary,
///< so these bits are always all ones. When SINGLE_ADDR_LOC_TRANS_EN =
///< 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR > 0 then this field forms
///< lower bits of the limit address for the circular buffer. A write to
///< this location is ignored by the PCIe controller.   Note: This register
///< field is sticky.
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_HW_BF_OFF ( 4)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_HW_BF_WID (12)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_HW_BF_MSK (0x0000FFF0)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_HW_BF_DEF (0x0000FFF0)

///< Forms upper bits of the end address of the address region to be translated.
///< When SINGLE_ADDR_LOC_TRANS_EN = 1, MSG_TYPE_MATCH_MODE = 1, and CBUF_INCR
///< > 0 then this field forms the upper bits of the limit address for
///< the circular buffer.   Note: This register field is sticky.  TDISP
///< Prot :WDB
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_LIMIT_ADDR_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19 register description at address offset 0x302714
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_ATU_CAP/IATU_LWR_TARGET_ADDR_OFF_INBOUND_19
  * iATU Lower Target Address Register.
  */

typedef union {
  struct {
    uint32_t LWR_TARGET_HW : 16;
    ///< Forms the LSB's of the Lower Target part of the new address of the
    ///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
    ///< kB boundary (in address match mode); and to the Bar size boundary
    ///< (in BAR match mode) so that these bits are always '0'. If the BAR
    ///< is smaller than the iATU region size, then the iATU target address
    ///< must align to the iATU region size; otherwise it must align to the
    ///< BAR size.  A write to this location is ignored by the PCIe controller.
    ///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
    ///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t LWR_TARGET_RW : 16;
    ///< Forms MSB's of the Lower Target part of the new address of the translated
    ///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
    ///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
    ///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
    ///< :WDB
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_19_reg_t;

#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_DEFAULT (0x00000000U)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_RD_MASK (0xffffffffU)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_WR_MASK (0xffff0000U)


///< Forms the LSB's of the Lower Target part of the new address of the
///< translated region. The start address must be aligned to a CX_ATU_MIN_REGION_SIZE
///< kB boundary (in address match mode); and to the Bar size boundary
///< (in BAR match mode) so that these bits are always '0'. If the BAR
///< is smaller than the iATU region size, then the iATU target address
///< must align to the iATU region size; otherwise it must align to the
///< BAR size.  A write to this location is ignored by the PCIe controller.
///< - Field size depends on log2(CX_ATU_MIN_REGION_SIZE) in address match
///< mode.  - Field size depends on log2(BAR_MASK+1) in BAR match mode.
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_HW_BF_OFF ( 0)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_HW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_HW_BF_MSK (0x0000FFFF)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_HW_BF_DEF (0x00000000)

///< Forms MSB's of the Lower Target part of the new address of the translated
///< region. These bits are always '0'.  - Field size depends on log2(CX_ATU_MIN_REGION_SIZE)
///< in address match mode.  - Field size depends on log2(BAR_MASK+1) in
///< BAR match mode.   Note: This register field is sticky.  TDISP Prot
///< :WDB
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_RW_BF_OFF (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_RW_BF_WID (16)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_RW_BF_MSK (0xFFFF0000)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_LWR_TARGET_RW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_EN_OFF_WRCH_0 register description at address offset 0x380000
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_EN_OFF_WRCH_0
  * HDMA Write Channel Enable Register.
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< HDMA Write Channel Enable. The controller checks this field for power
    ///< management purposes. If this field is enabled for any one of the read,
    ///< or write channel, the controller exits low power state.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_en_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_RD_MASK (0x00000001U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_WR_MASK (0x00000001U)


///< HDMA Write Channel Enable. The controller checks this field for power
///< management purposes. If this field is enabled for any one of the read,
///< or write channel, the controller exits low power state.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_EN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_EN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_EN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0 register description at address offset 0x380004
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DOORBELL_OFF_WRCH_0
  * HDMA Write Channel Doorbell Register.
  */

typedef union {
  struct {
    uint32_t DB_START : 1;
    ///< HDMA Write Channel Doorbell Start. You must set this field to start
    ///< the write transfer for this channel.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t DB_STOP : 1;
    ///< HDMA Write Channel Doorbell Stop. You must set this field to stop
    ///< the write transfer for this channel. HDMA stops the write transfer
    ///< for this channel at the earliest when this field is set.  Note: Only
    ///< after the HDMA_STATUS_OFF_WRCH_i.STATUS =0x03, you can consider this
    ///< channel to be in stop state.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_doorbell_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_WR_MASK (0x00000003U)


///< HDMA Write Channel Doorbell Start. You must set this field to start
///< the write transfer for this channel.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_START_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_START_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_START_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_START_BF_DEF (0x00000000)

///< HDMA Write Channel Doorbell Stop. You must set this field to stop
///< the write transfer for this channel. HDMA stops the write transfer
///< for this channel at the earliest when this field is set.  Note: Only
///< after the HDMA_STATUS_OFF_WRCH_i.STATUS =0x03, you can consider this
///< channel to be in stop state.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_STOP_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_STOP_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_DB_STOP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0 register description at address offset 0x380008
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_ELEM_PF_OFF_WRCH_0
  * HDMA Write Channel Prefetch Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_PREFETCH : 7;
    ///< This field controls the number of linked list elements (descriptors)
    ///< this HDMA write channel prefetches. The linked list element pointer
    ///< loaded by HDMA updates this field.  Note: The actual prefetch value
    ///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
    ///< one descriptor is prefetched by this channel.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_elem_pf_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_WR_MASK (0x0000007fU)


///< This field controls the number of linked list elements (descriptors)
///< this HDMA write channel prefetches. The linked list element pointer
///< loaded by HDMA updates this field.  Note: The actual prefetch value
///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
///< one descriptor is prefetched by this channel.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_ELEMENT_PREFETCH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_ELEMENT_PREFETCH_BF_WID ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_ELEMENT_PREFETCH_BF_MSK (0x0000007F)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_ELEMENT_PREFETCH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0 register description at address offset 0x380010
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_LOW_OFF_WRCH_0
  * HDMA Write Channel Linked List Pointer Low Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_LOW : 32;
    ///< Lower 32 bits of the address of the transfer list in the local memory.
    ///< Used in linked list mode only.HDMA fetches descriptors from local
    ///< memory respecting the following patterns:  - When the current element
    ///< is a data element; HDMA increments this field by 6 DWORDs times the
    ///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_WRCH*
    ///< and HDMA_QOS_OFF_WRCH*  - When the current element is a link element;
    ///< HDMA overwrites this field with the LL Element Pointer of the next
    ///< LL element structure. The current fetched memory address pointer is
    ///< not directly visible in this register, instead HDMA updates this register
    ///< on the following occurrences:  - Watermark interrupt event  - Channel
    ///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
    ///< event this register points to the descriptor's address that triggered
    ///< it.A channel status STOP or ABORT events are end of transfer events
    ///< that makes this register point to the next data to transfer after
    ///< the event.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_low_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< Lower 32 bits of the address of the transfer list in the local memory.
///< Used in linked list mode only.HDMA fetches descriptors from local
///< memory respecting the following patterns:  - When the current element
///< is a data element; HDMA increments this field by 6 DWORDs times the
///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_WRCH*
///< and HDMA_QOS_OFF_WRCH*  - When the current element is a link element;
///< HDMA overwrites this field with the LL Element Pointer of the next
///< LL element structure. The current fetched memory address pointer is
///< not directly visible in this register, instead HDMA updates this register
///< on the following occurrences:  - Watermark interrupt event  - Channel
///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
///< event this register points to the descriptor's address that triggered
///< it.A channel status STOP or ABORT events are end of transfer events
///< that makes this register point to the next data to transfer after
///< the event.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_ELEMENT_LIST_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_ELEMENT_LIST_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_ELEMENT_LIST_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_ELEMENT_LIST_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0 register description at address offset 0x380014
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_HIGH_OFF_WRCH_0
  * HDMA Write Channel Linked List Pointer High Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_HIGH : 32;
    ///< Higher 32 bits of the address of the transfer list in the local memory.
    ///< HDMA fetches descriptors from local memory respecting the following
    ///< patterns:  - When the current element is a data element; HDMA increments
    ///< this field by 6 DWORDs times the prefetch depth. For more information,
    ///< see registers HDMA_ELEM_PF_OFF_WRCH* and HDMA_QOS_OFF_WRCH*  - When
    ///< the current element is a link element; HDMA overwrites this field
    ///< with the LL Element Pointer of the next LL element structure. The
    ///< current fetched memory address pointer is not directly visible in
    ///< this register, instead HDMA updates this register on the following
    ///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
    ///< event  - Channel Status STOP event On a watermark interrupt event
    ///< this register points to the descriptor's address that triggered it.
    ///< A channel status STOP or ABORT events are end of transfer events that
    ///< makes this register point to the next data to transfer after the event.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_high_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< Higher 32 bits of the address of the transfer list in the local memory.
///< HDMA fetches descriptors from local memory respecting the following
///< patterns:  - When the current element is a data element; HDMA increments
///< this field by 6 DWORDs times the prefetch depth. For more information,
///< see registers HDMA_ELEM_PF_OFF_WRCH* and HDMA_QOS_OFF_WRCH*  - When
///< the current element is a link element; HDMA overwrites this field
///< with the LL Element Pointer of the next LL element structure. The
///< current fetched memory address pointer is not directly visible in
///< this register, instead HDMA updates this register on the following
///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
///< event  - Channel Status STOP event On a watermark interrupt event
///< this register points to the descriptor's address that triggered it.
///< A channel status STOP or ABORT events are end of transfer events that
///< makes this register point to the next data to transfer after the event.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_ELEMENT_LIST_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_ELEMENT_LIST_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_ELEMENT_LIST_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_ELEMENT_LIST_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0 register description at address offset 0x380018
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CYCLE_OFF_WRCH_0
  * HDMA Write Channel Producer-Consumer Cycle Synchronization Register.
  */

typedef union {
  struct {
    uint32_t CYCLE_BIT : 1;
    ///< Toggle Cycle Bit.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t CYCLE_STATE : 1;
    ///< Consumer Cycle State. You must initialize this field.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_cycle_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_WR_MASK (0x00000003U)


///< Toggle Cycle Bit.   Note: The access attributes of this field are
///< as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_BIT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_BIT_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_BIT_BF_DEF (0x00000000)

///< Consumer Cycle State. You must initialize this field.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_STATE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_STATE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_STATE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_CYCLE_STATE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0 register description at address offset 0x38001c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_XFERSIZE_OFF_WRCH_0
  * HDMA Write Channel Transfer Size Register.
  */

typedef union {
  struct {
    uint32_t XFERSIZE : 32;
    ///< HDMA Write Channel Transfer Size. You program this register with the
    ///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
    ///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
    ///< the value of this field as the write channel transfer progresses.
    ///< This field indicates the number of bytes remaining to be requested.
    ///< When all bytes are requested the current transfer size is zero. In
    ///< LL mode, the HDMA overwrites this register with the corresponding
    ///< dword of the LL element.  You can read this register to monitor the
    ///< transfer progress, but it is not reliable for that specific usage,
    ///< as it is updated after read requests and not after write requests.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_xfersize_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< HDMA Write Channel Transfer Size. You program this register with the
///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
///< the value of this field as the write channel transfer progresses.
///< This field indicates the number of bytes remaining to be requested.
///< When all bytes are requested the current transfer size is zero. In
///< LL mode, the HDMA overwrites this register with the corresponding
///< dword of the LL element.  You can read this register to monitor the
///< transfer progress, but it is not reliable for that specific usage,
///< as it is updated after read requests and not after write requests.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_XFERSIZE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_XFERSIZE_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_XFERSIZE_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_XFERSIZE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0 register description at address offset 0x380020
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_LOW_OFF_WRCH_0
  * HDMA Write Channel SAR Low Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_LOW : 32;
    ///< Source Address Register (lower 32 bits). Indicates the address of
    ///< the local memory from which HDMA reads. The HDMA increments the SAR
    ///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
    ///< field with the corresponding dword of the LL element. The SAR is the
    ///< address of the local memory.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_low_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< Source Address Register (lower 32 bits). Indicates the address of
///< the local memory from which HDMA reads. The HDMA increments the SAR
///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
///< field with the corresponding dword of the LL element. The SAR is the
///< address of the local memory.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_SAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_SAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_SAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_SAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0 register description at address offset 0x380024
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_HIGH_OFF_WRCH_0
  * HDMA Write Channel SAR High Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_HIGH : 32;
    ///< Source Address Register (higher 32 bits).   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_high_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< Source Address Register (higher 32 bits).   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_SAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_SAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_SAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_SAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0 register description at address offset 0x380028
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_LOW_OFF_WRCH_0
  * HDMA Write Channel DAR Low Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_LOW : 32;
    ///< Destination Address Register (lower 32 bits). Indicates the address
    ///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
    ///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
    ///< dword of the LL element. The DAR is the address of the remote memory.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_low_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< Destination Address Register (lower 32 bits). Indicates the address
///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
///< dword of the LL element. The DAR is the address of the remote memory.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_DAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_DAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_DAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_DAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0 register description at address offset 0x38002c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_HIGH_OFF_WRCH_0
  * HDMA Write Channel DAR High Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_HIGH : 32;
    ///< Destination Address Register (higher 32 bits).   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_high_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< Destination Address Register (higher 32 bits).   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_DAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_DAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_DAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_DAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0 register description at address offset 0x380030
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_WATERMARK_EN_OFF_WRCH_0
  * HDMA Write Channel Linked-list Watermark Enable Register.
  */

typedef union {
  struct {
    uint32_t RWIE : 1;
    ///< Enables Remote Interrupts at watermark events (end of linked list
    ///< element) in an HDMA write channel.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t LWIE : 1;
    ///< Enables Local Interrupts at watermark events (end of linked list element)
    ///< in an HDMA write channel.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_watermark_en_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_WR_MASK (0x00000003U)


///< Enables Remote Interrupts at watermark events (end of linked list
///< element) in an HDMA write channel.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_RWIE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_RWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_RWIE_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_RWIE_BF_DEF (0x00000000)

///< Enables Local Interrupts at watermark events (end of linked list element)
///< in an HDMA write channel.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_LWIE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_LWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_LWIE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_LWIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CONTROL1_OFF_WRCH_0 register description at address offset 0x380034
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CONTROL1_OFF_WRCH_0
  * HDMA Write Channel Control Settings 1 Register.
  */

typedef union {
  struct {
    uint32_t LLEN : 1;
    ///< This field enables the HDMA write channel Linked List mode.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_TYPE : 1;
    ///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
    ///< write channel memory type of the address space of the data transfer
    ///< as follows: For more information, see  ACE-Lite Features and Limitations
    ///< section of the Databook. Irrespective of the value of this field,
    ///< Linked list descriptor requests have this attribute set to 0x1.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SRC_SNOOP : 1;
    ///< Source No Snoop TLP Header Bit. The HDMA write channel uses this TLP
    ///< header field when generating MRd (SAR addressing space) TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DST_SNOOP : 1;
    ///< Destination No Snoop TLP Header Bit. The HDMA write channel uses this
    ///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t RO : 1;
    ///< Relaxed Ordering TLP Header Bit. HDMA write channel uses this TLP
    ///< header field when generating MRd/MWr/IMWr TLPs.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t AT : 2;
    ///< Address Translation Services TLP Header Bit (AT). The HDMA write channel
    ///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t T_BIT : 1;
    ///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
    ///< that DMA TLP is part of a trusted execution environment. The HDMA
    ///< write channel uses this TLP header field when generating MRD/IMWr
    ///< TLP requests.   When T_BIT_SRC field is set to 0x1, the HDMA uses
    ///< this TLP header field when generating MWr TLP requests.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t T_BIT_SRC : 1;
    ///< Completion to Memory Write T-bit source. The HDMA Write channel uses
    ///< this field to overwrite the T-bit from the application completion
    ///< interface by the T_BIT field.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_ctrl1_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_RD_MASK (0x000001ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_WR_MASK (0x000001ffU)


///< This field enables the HDMA write channel Linked List mode.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_LLEN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_LLEN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_LLEN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_LLEN_BF_DEF (0x00000000)

///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
///< write channel memory type of the address space of the data transfer
///< as follows: For more information, see  ACE-Lite Features and Limitations
///< section of the Databook. Irrespective of the value of this field,
///< Linked list descriptor requests have this attribute set to 0x1.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_MEM_TYPE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_MEM_TYPE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_MEM_TYPE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_MEM_TYPE_BF_DEF (0x00000000)

///< Source No Snoop TLP Header Bit. The HDMA write channel uses this TLP
///< header field when generating MRd (SAR addressing space) TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_SRC_SNOOP_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_SRC_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_SRC_SNOOP_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_SRC_SNOOP_BF_DEF (0x00000000)

///< Destination No Snoop TLP Header Bit. The HDMA write channel uses this
///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_DST_SNOOP_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_DST_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_DST_SNOOP_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_DST_SNOOP_BF_DEF (0x00000000)

///< Relaxed Ordering TLP Header Bit. HDMA write channel uses this TLP
///< header field when generating MRd/MWr/IMWr TLPs.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_RO_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_RO_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_RO_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_RO_BF_DEF (0x00000000)

///< Address Translation Services TLP Header Bit (AT). The HDMA write channel
///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_AT_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_AT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_AT_BF_MSK (0x00000060)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_AT_BF_DEF (0x00000000)

///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
///< that DMA TLP is part of a trusted execution environment. The HDMA
///< write channel uses this TLP header field when generating MRD/IMWr
///< TLP requests.   When T_BIT_SRC field is set to 0x1, the HDMA uses
///< this TLP header field when generating MWr TLP requests.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_BF_OFF ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_BF_MSK (0x00000080)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_BF_DEF (0x00000000)

///< Completion to Memory Write T-bit source. The HDMA Write channel uses
///< this field to overwrite the T-bit from the application completion
///< interface by the T_BIT field.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_SRC_BF_OFF ( 8)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_SRC_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_SRC_BF_MSK (0x00000100)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_T_BIT_SRC_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0 register description at address offset 0x380038
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_FUNC_NUM_OFF_WRCH_0
  * HDMA Write Channel Function Number Register.
  */

typedef union {
  struct {
    uint32_t PF : 5;
    ///< DMA Channel Physical Function Number.  DMA channel wide physical function
    ///< of the generated TLP. The controller uses this field to form the requester
    ///< ID for requests. Function numbering starts at '0'. When you have enabled
    ///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
    ///< behavior is undefined if any value outside of the valid range is set
    ///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
    ///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_func_num_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_RD_MASK (0x0000001fU)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_WR_MASK (0x0000001fU)


///< DMA Channel Physical Function Number.  DMA channel wide physical function
///< of the generated TLP. The controller uses this field to form the requester
///< ID for requests. Function numbering starts at '0'. When you have enabled
///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
///< behavior is undefined if any value outside of the valid range is set
///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_PF_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_PF_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_PF_BF_MSK (0x0000001F)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_PF_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_QOS_OFF_WRCH_0 register description at address offset 0x38003c
  *
  * Register default value:        0x00030008
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_QOS_OFF_WRCH_0
  * HDMA Write Channel QoS Settings Register.
  */

typedef union {
  struct {
    uint32_t TC : 3;
    ///< Traffic Class TLP Header Field (TC). The HDMA write channel uses this
    ///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t WEIGHT : 5;
    ///< Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t PF_DEPTH : 10;
    ///< This field controls the linked list prefetch allocation space for
    ///< an HDMA write channel. Each write channel stores PF_DEPTH plus '1'
    ///< linked list elements. For example, if PF_DEPTH =0, the write channel
    ///< stores one linked list element. This field must be within the range:
    ///< [ 0 : floor(CX_DMA_WR_LLQ * CC_NUM_DMA_WR_CHAN / number_of_active_channels)
    ///< - 1 ].  Note:  If this field is set to a value outside the specified
    ///< range, data corruption or channel crosstalk may happen.  If PF_DEPTH
    ///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
    ///< - 1 ] can be doorbelled.  This field cannot be changed while any write
    ///< engine channel is in doorbell state. Doing so might yield undefined
    ///< results.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="16" ResetValue="0x3"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_qos_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_DEFAULT (0x00030008U)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_RD_MASK (0x03ff00ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_WR_MASK (0x03ff00ffU)


///< Traffic Class TLP Header Field (TC). The HDMA write channel uses this
///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_TC_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_TC_BF_WID ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_TC_BF_MSK (0x00000007)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_TC_BF_DEF (0x00000000)

///< Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_WEIGHT_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_WEIGHT_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_WEIGHT_BF_MSK (0x000000F8)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_WEIGHT_BF_DEF (0x00000008)

///< This field controls the linked list prefetch allocation space for
///< an HDMA write channel. Each write channel stores PF_DEPTH plus '1'
///< linked list elements. For example, if PF_DEPTH =0, the write channel
///< stores one linked list element. This field must be within the range:
///< [ 0 : floor(CX_DMA_WR_LLQ * CC_NUM_DMA_WR_CHAN / number_of_active_channels)
///< - 1 ].  Note:  If this field is set to a value outside the specified
///< range, data corruption or channel crosstalk may happen.  If PF_DEPTH
///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
///< - 1 ] can be doorbelled.  This field cannot be changed while any write
///< engine channel is in doorbell state. Doing so might yield undefined
///< results.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_PF_DEPTH_BF_OFF (16)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_PF_DEPTH_BF_WID (10)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_PF_DEPTH_BF_MSK (0x03FF0000)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_PF_DEPTH_BF_DEF (0x00030000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_STATUS_OFF_WRCH_0 register description at address offset 0x380080
  *
  * Register default value:        0x00000003
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_STATUS_OFF_WRCH_0
  * HDMA Write Channel Status Register.
  */

typedef union {
  struct {
    uint32_t STATUS : 2;
    ///< HDMA Write Channel Status.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x3"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_stat_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_DEFAULT (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_WR_MASK (0x00000000U)


///< HDMA Write Channel Status.
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_STAT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_STAT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_STAT_BF_DEF (0x00000003)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_STATUS_OFF_WRCH_0 register description at address offset 0x380084
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_STATUS_OFF_WRCH_0
  * HDMA Write Channel Interrupt Status Register.
  */

typedef union {
  struct {
    uint32_t STOP : 1;
    ///< HDMA Write Channel Stop Interrupt Status. STOP and ABORT register
    ///< fields are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK : 1;
    ///< HDMA Write Channel Watermark Interrupt Status.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT : 1;
    ///< HDMA Write Channel Abort Interrupt Status. ABORT and STOP register
    ///< fields are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t ERROR : 4;
    ///< HDMA Write Channel Interrupt Error Status. Specifies the error that
    ///< caused the HDMA to change HDMA_STATUS_OFF_WRCH_i.STATUS to ABORTED
    ///< state.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_stat_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_WR_MASK (0x00000000U)


///< HDMA Write Channel Stop Interrupt Status. STOP and ABORT register
///< fields are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_STOP_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_STOP_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_STOP_BF_DEF (0x00000000)

///< HDMA Write Channel Watermark Interrupt Status.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_WATERMARK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_WATERMARK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_WATERMARK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_WATERMARK_BF_DEF (0x00000000)

///< HDMA Write Channel Abort Interrupt Status. ABORT and STOP register
///< fields are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ABORT_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ABORT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ABORT_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ABORT_BF_DEF (0x00000000)

///< HDMA Write Channel Interrupt Error Status. Specifies the error that
///< caused the HDMA to change HDMA_STATUS_OFF_WRCH_i.STATUS to ABORTED
///< state.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ERR_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ERR_BF_WID ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ERR_BF_MSK (0x00000078)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ERR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0 register description at address offset 0x380088
  *
  * Register default value:        0x00000007
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_SETUP_OFF_WRCH_0
  * HDMA Write Channel Interrupt Setup Register.
  */

typedef union {
  struct {
    uint32_t STOP_MASK : 1;
    ///< HDMA Write Channel Stop Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t WATERMARK_MASK : 1;
    ///< HDMA Write Channel Watermark Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t ABORT_MASK : 1;
    ///< HDMA Write Channel Abort Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t RSIE : 1;
    ///< HDMA Write Channel Remote Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LSIE : 1;
    ///< HDMA Write Channel Local Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t RAIE : 1;
    ///< HDMA Write Channel Remote Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t LAIE : 1;
    ///< HDMA Write Channel Local Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_setup_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_DEFAULT (0x00000007U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_WR_MASK (0x0000007fU)


///< HDMA Write Channel Stop Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_STOP_MASK_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_STOP_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_STOP_MASK_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_STOP_MASK_BF_DEF (0x00000001)

///< HDMA Write Channel Watermark Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_WATERMARK_MASK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_WATERMARK_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_WATERMARK_MASK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_WATERMARK_MASK_BF_DEF (0x00000002)

///< HDMA Write Channel Abort Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_ABORT_MASK_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_ABORT_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_ABORT_MASK_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_ABORT_MASK_BF_DEF (0x00000004)

///< HDMA Write Channel Remote Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RSIE_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RSIE_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RSIE_BF_DEF (0x00000000)

///< HDMA Write Channel Local Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LSIE_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LSIE_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LSIE_BF_DEF (0x00000000)

///< HDMA Write Channel Remote Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RAIE_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RAIE_BF_MSK (0x00000020)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_RAIE_BF_DEF (0x00000000)

///< HDMA Write Channel Local Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LAIE_BF_OFF ( 6)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LAIE_BF_MSK (0x00000040)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_LAIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_CLEAR_OFF_WRCH_0 register description at address offset 0x38008c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_CLEAR_OFF_WRCH_0
  * HDMA Write Channel Interrupt Clear Register.
  */

typedef union {
  struct {
    uint32_t STOP_CLEAR : 1;
    ///< HDMA Write Channel Stop Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK_CLEAR : 1;
    ///< HDMA Write Channel Watermark Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT_CLEAR : 1;
    ///< HDMA Abort Channel Abort Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_clr_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_WR_MASK (0x00000007U)


///< HDMA Write Channel Stop Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_STOP_CLR_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_STOP_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_STOP_CLR_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_STOP_CLR_BF_DEF (0x00000000)

///< HDMA Write Channel Watermark Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_WATERMARK_CLR_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_WATERMARK_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_WATERMARK_CLR_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_WATERMARK_CLR_BF_DEF (0x00000000)

///< HDMA Abort Channel Abort Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_ABORT_CLR_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_ABORT_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_ABORT_CLR_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_ABORT_CLR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0 register description at address offset 0x380090
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_LOW_OFF_WRCH_0
  * HDMA Write Stop Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_low_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_MSI_STOP_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_MSI_STOP_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_MSI_STOP_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_MSI_STOP_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0 register description at address offset 0x380094
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_HIGH_OFF_WRCH_0
  * HDMA Write Stop Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_high_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_MSI_STOP_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_MSI_STOP_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_MSI_STOP_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_MSI_STOP_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0 register description at address offset 0x380098
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0
  * HDMA Write Watermark Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
    ///< address must be dword aligned.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
///< address must be dword aligned.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_MSI_WATERMARK_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_MSI_WATERMARK_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_MSI_WATERMARK_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_MSI_WATERMARK_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0 register description at address offset 0x38009c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0
  * HDMA Write Watermark Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_MSI_WATERMARK_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_MSI_WATERMARK_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_MSI_WATERMARK_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_MSI_WATERMARK_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0 register description at address offset 0x3800a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_LOW_OFF_WRCH_0
  * HDMA Write Abort Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_low_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_MSI_ABORT_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_MSI_ABORT_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_MSI_ABORT_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_MSI_ABORT_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0 register description at address offset 0x3800a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_HIGH_OFF_WRCH_0
  * HDMA Write Abort Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_high_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_MSI_ABORT_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_MSI_ABORT_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_MSI_ABORT_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_MSI_ABORT_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0 register description at address offset 0x3800a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_MSGD_OFF_WRCH_0
  * HDMA Write Channel Remote Interrupt Data Register.
  */

typedef union {
  struct {
    uint32_t MSI_MESSAGE : 16;
    ///< The HDMA write channel uses this field to generate the data field
    ///< for every IMWr TLPs it generates.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_msgd_off_wrch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_RD_MASK (0x0000ffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_WR_MASK (0x0000ffffU)


///< The HDMA write channel uses this field to generate the data field
///< for every IMWr TLPs it generates.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_MSI_MSG_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_MSI_MSG_BF_WID (16)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_MSI_MSG_BF_MSK (0x0000FFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_MSI_MSG_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_EN_OFF_RDCH_0 register description at address offset 0x380100
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_EN_OFF_RDCH_0
  * HDMA Read Channel Enable.
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< HDMA Read Channel Enable. The controller checks this field for power
    ///< management purposes. If this field is enabled for any one of the read,
    ///< or write channel, the controller exits low power state.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_en_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_RD_MASK (0x00000001U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_WR_MASK (0x00000001U)


///< HDMA Read Channel Enable. The controller checks this field for power
///< management purposes. If this field is enabled for any one of the read,
///< or write channel, the controller exits low power state.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_EN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_EN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_EN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0 register description at address offset 0x380104
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DOORBELL_OFF_RDCH_0
  * HDMA Read Channel Doorbell Register.
  */

typedef union {
  struct {
    uint32_t DB_START : 1;
    ///< HDMA Read Channel Doorbell Start. You must set this field to start
    ///< the read transfer for this channel.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t DB_STOP : 1;
    ///< HDMA Read Channel Doorbell Stop. You must set this field to stop the
    ///< read transfer for this channel. HDMA stops the read transfer for this
    ///< channel at the earliest when this field is set.  Note: Only after
    ///< the HDMA_STATUS_OFF_RDCH_i.STATUS =0x03, you can consider this channel
    ///< to be in stop state.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_doorbell_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_WR_MASK (0x00000003U)


///< HDMA Read Channel Doorbell Start. You must set this field to start
///< the read transfer for this channel.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_START_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_START_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_START_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_START_BF_DEF (0x00000000)

///< HDMA Read Channel Doorbell Stop. You must set this field to stop the
///< read transfer for this channel. HDMA stops the read transfer for this
///< channel at the earliest when this field is set.  Note: Only after
///< the HDMA_STATUS_OFF_RDCH_i.STATUS =0x03, you can consider this channel
///< to be in stop state.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_STOP_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_STOP_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_DB_STOP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0 register description at address offset 0x380108
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_ELEM_PF_OFF_RDCH_0
  * HDMA Read Channel Prefetch Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_PREFETCH : 7;
    ///< This field controls the number of linked list elements (descriptors)
    ///< this HDMA read channel prefetches. The linked list element pointer
    ///< loaded by HDMA updates this field.  Note: The actual prefetch value
    ///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
    ///< one descriptor is prefetched by this channel.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_elem_pf_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_WR_MASK (0x0000007fU)


///< This field controls the number of linked list elements (descriptors)
///< this HDMA read channel prefetches. The linked list element pointer
///< loaded by HDMA updates this field.  Note: The actual prefetch value
///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
///< one descriptor is prefetched by this channel.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_ELEMENT_PREFETCH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_ELEMENT_PREFETCH_BF_WID ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_ELEMENT_PREFETCH_BF_MSK (0x0000007F)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_ELEMENT_PREFETCH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0 register description at address offset 0x380110
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_LOW_OFF_RDCH_0
  * HDMA Read Channel Linked List Pointer Low Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_LOW : 32;
    ///< Lower 32 bits of the address of the transfer list in the local memory.
    ///< Used in linked list mode only. HDMA fetches descriptors from local
    ///< memory respecting the following patterns:  - When the current element
    ///< is a data element; HDMA increments this field by 6 DWORDs times the
    ///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_RDCH*
    ///< and HDMA_QOS_OFF_RDCH*  - When the current element is a link element;
    ///< HDMA overwrites this field with the LL Element Pointer of the next
    ///< LL element structure. The current fetched memory address pointer is
    ///< not directly visible in this register, instead HDMA updates this register
    ///< on the following occurrences:  - Watermark interrupt event  - Channel
    ///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
    ///< event this register points to the descriptor's address that triggered
    ///< it.A channel status STOP or ABORT events are end of transfer events
    ///< that makes this register point to the next data to transfer after
    ///< the event   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_low_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< Lower 32 bits of the address of the transfer list in the local memory.
///< Used in linked list mode only. HDMA fetches descriptors from local
///< memory respecting the following patterns:  - When the current element
///< is a data element; HDMA increments this field by 6 DWORDs times the
///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_RDCH*
///< and HDMA_QOS_OFF_RDCH*  - When the current element is a link element;
///< HDMA overwrites this field with the LL Element Pointer of the next
///< LL element structure. The current fetched memory address pointer is
///< not directly visible in this register, instead HDMA updates this register
///< on the following occurrences:  - Watermark interrupt event  - Channel
///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
///< event this register points to the descriptor's address that triggered
///< it.A channel status STOP or ABORT events are end of transfer events
///< that makes this register point to the next data to transfer after
///< the event   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_ELEMENT_LIST_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_ELEMENT_LIST_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_ELEMENT_LIST_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_ELEMENT_LIST_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0 register description at address offset 0x380114
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_HIGH_OFF_RDCH_0
  * HDMA Read Channel Linked List Pointer High Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_HIGH : 32;
    ///< Higher 32 bits of the address of the transfer list in the local memory.
    ///< HDMA fetches descriptors from local memory respecting the following
    ///< patterns:  - When the current element is a data element; HDMA increments
    ///< this field by 6 DWORDs times the prefetch depth. For more information,
    ///< see registers HDMA_ELEM_PF_OFF_RDCH* and HDMA_QOS_OFF_RDCH*  - When
    ///< the current element is a link element; HDMA overwrites this field
    ///< with the LL Element Pointer of the next LL element structure. The
    ///< current fetched memory address pointer is not directly visible in
    ///< this register, instead HDMA updates this register on the following
    ///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
    ///< event  - Channel Status STOP event On a watermark interrupt event
    ///< this register points to the descriptor's address that triggered it.
    ///< A channel status STOP or ABORT events are end of transfer events that
    ///< makes this register point to the next data to transfer after the event.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_high_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< Higher 32 bits of the address of the transfer list in the local memory.
///< HDMA fetches descriptors from local memory respecting the following
///< patterns:  - When the current element is a data element; HDMA increments
///< this field by 6 DWORDs times the prefetch depth. For more information,
///< see registers HDMA_ELEM_PF_OFF_RDCH* and HDMA_QOS_OFF_RDCH*  - When
///< the current element is a link element; HDMA overwrites this field
///< with the LL Element Pointer of the next LL element structure. The
///< current fetched memory address pointer is not directly visible in
///< this register, instead HDMA updates this register on the following
///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
///< event  - Channel Status STOP event On a watermark interrupt event
///< this register points to the descriptor's address that triggered it.
///< A channel status STOP or ABORT events are end of transfer events that
///< makes this register point to the next data to transfer after the event.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_ELEMENT_LIST_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_ELEMENT_LIST_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_ELEMENT_LIST_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_ELEMENT_LIST_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0 register description at address offset 0x380118
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CYCLE_OFF_RDCH_0
  * HDMA Read Channel Producer-Consumer Cycle Synchronization Register.
  */

typedef union {
  struct {
    uint32_t CYCLE_BIT : 1;
    ///< Toggle Cycle Bit.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t CYCLE_STATE : 1;
    ///< Consumer Cycle State. You must initialize this field.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_cycle_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_WR_MASK (0x00000003U)


///< Toggle Cycle Bit.   Note: The access attributes of this field are
///< as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_BIT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_BIT_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_BIT_BF_DEF (0x00000000)

///< Consumer Cycle State. You must initialize this field.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_STATE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_STATE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_STATE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_CYCLE_STATE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0 register description at address offset 0x38011c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_XFERSIZE_OFF_RDCH_0
  * HDMA Read Channel Transfer Size Register.
  */

typedef union {
  struct {
    uint32_t XFERSIZE : 32;
    ///< HDMA Read Channel Transfer Size. You program this register with the
    ///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
    ///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
    ///< the value of this field as the read channel transfer progresses. This
    ///< field indicates the number of bytes remaining to be requested. When
    ///< all bytes are requested the current transfer size is zero. In LL mode,
    ///< the HDMA overwrites this register with the corresponding dword of
    ///< the LL element.  You can read this register to monitor the transfer
    ///< progress, but it is not reliable for that specific usage, as it is
    ///< updated after read requests and not after write requests.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_xfersize_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< HDMA Read Channel Transfer Size. You program this register with the
///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
///< the value of this field as the read channel transfer progresses. This
///< field indicates the number of bytes remaining to be requested. When
///< all bytes are requested the current transfer size is zero. In LL mode,
///< the HDMA overwrites this register with the corresponding dword of
///< the LL element.  You can read this register to monitor the transfer
///< progress, but it is not reliable for that specific usage, as it is
///< updated after read requests and not after write requests.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_XFERSIZE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_XFERSIZE_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_XFERSIZE_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_XFERSIZE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0 register description at address offset 0x380120
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_LOW_OFF_RDCH_0
  * HDMA Read Channel SAR Low Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_LOW : 32;
    ///< Source Address Register (lower 32 bits). Indicates the address of
    ///< the local memory from which HDMA reads. The HDMA increments the SAR
    ///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
    ///< field with the corresponding dword of the LL element. The SAR is the
    ///< address of the remote memory.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_low_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< Source Address Register (lower 32 bits). Indicates the address of
///< the local memory from which HDMA reads. The HDMA increments the SAR
///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
///< field with the corresponding dword of the LL element. The SAR is the
///< address of the remote memory.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_SAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_SAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_SAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_SAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0 register description at address offset 0x380124
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_HIGH_OFF_RDCH_0
  * HDMA Read Channel SAR High Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_HIGH : 32;
    ///< Source Address Register (higher 32 bits).   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_high_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< Source Address Register (higher 32 bits).   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_SAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_SAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_SAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_SAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0 register description at address offset 0x380128
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_LOW_OFF_RDCH_0
  * HDMA Read Channel DAR Low Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_LOW : 32;
    ///< Destination Address Register (lower 32 bits). Indicates the address
    ///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
    ///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
    ///< dword of the LL element. The DAR is the address of the local memory.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_low_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< Destination Address Register (lower 32 bits). Indicates the address
///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
///< dword of the LL element. The DAR is the address of the local memory.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_DAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_DAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_DAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_DAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0 register description at address offset 0x38012c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_HIGH_OFF_RDCH_0
  * HDMA Read Channel DAR High Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_HIGH : 32;
    ///< Destination Address Register (higher 32 bits).   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_high_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< Destination Address Register (higher 32 bits).   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_DAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_DAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_DAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_DAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0 register description at address offset 0x380130
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_WATERMARK_EN_OFF_RDCH_0
  * HDMA Read Channel Linked-list Watermark Enable Register.
  */

typedef union {
  struct {
    uint32_t RWIE : 1;
    ///< Enables Remote Interrupts at watermark events (end of linked list
    ///< element) in an HDMA read channel.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t LWIE : 1;
    ///< Enables Local Interrupts at watermark events (end of linked list element)
    ///< in an HDMA read channel.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_watermark_en_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_WR_MASK (0x00000003U)


///< Enables Remote Interrupts at watermark events (end of linked list
///< element) in an HDMA read channel.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_RWIE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_RWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_RWIE_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_RWIE_BF_DEF (0x00000000)

///< Enables Local Interrupts at watermark events (end of linked list element)
///< in an HDMA read channel.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_LWIE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_LWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_LWIE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_LWIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CONTROL1_OFF_RDCH_0 register description at address offset 0x380134
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CONTROL1_OFF_RDCH_0
  * HDMA Read Channel Control Settings 1 Register.
  */

typedef union {
  struct {
    uint32_t LLEN : 1;
    ///< This field enables the HDMA read channel Linked List mode.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_TYPE : 1;
    ///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
    ///< read channel memory type of the address space of the data transfer
    ///< as follows: For more information, see  ACE-Lite Features and Limitations
    ///< section of the Databook. Irrespective of the value of this field,
    ///< Linked list descriptor requests have this attribute set to 0x1.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SRC_SNOOP : 1;
    ///< Source No Snoop TLP Header Bit. The HDMA read channel uses this TLP
    ///< header field when generating MRd (SAR addressing space) TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DST_SNOOP : 1;
    ///< Destination No Snoop TLP Header Bit. The HDMA read channel uses this
    ///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t RO : 1;
    ///< Relaxed Ordering TLP Header Bit. HDMA read channel uses this TLP header
    ///< field when generating MRd/MWr/IMWr TLPs.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t AT : 2;
    ///< Address Translation Services TLP Header Bit (AT). The HDMA read channel
    ///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t T_BIT : 1;
    ///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
    ///< that DMA TLP is part of a trusted execution environment. The HDMA
    ///< read channel uses this TLP header field when generating MRd/IMWr TLP
    ///< requests.  When T_BIT_SRC field is set to 0x1, the HDMA uses this
    ///< TLP header field when generating MWr TLP requests.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t T_BIT_SRC : 1;
    ///< Completion to Memory Write T-bit source. The HDMA read channel uses
    ///< this field to overwrite the T field of the IDE prefix from the core
    ///< completions by the T_BIT field.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_ctrl1_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_RD_MASK (0x000001ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_WR_MASK (0x000001ffU)


///< This field enables the HDMA read channel Linked List mode.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_LLEN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_LLEN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_LLEN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_LLEN_BF_DEF (0x00000000)

///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
///< read channel memory type of the address space of the data transfer
///< as follows: For more information, see  ACE-Lite Features and Limitations
///< section of the Databook. Irrespective of the value of this field,
///< Linked list descriptor requests have this attribute set to 0x1.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_MEM_TYPE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_MEM_TYPE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_MEM_TYPE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_MEM_TYPE_BF_DEF (0x00000000)

///< Source No Snoop TLP Header Bit. The HDMA read channel uses this TLP
///< header field when generating MRd (SAR addressing space) TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_SRC_SNOOP_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_SRC_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_SRC_SNOOP_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_SRC_SNOOP_BF_DEF (0x00000000)

///< Destination No Snoop TLP Header Bit. The HDMA read channel uses this
///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_DST_SNOOP_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_DST_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_DST_SNOOP_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_DST_SNOOP_BF_DEF (0x00000000)

///< Relaxed Ordering TLP Header Bit. HDMA read channel uses this TLP header
///< field when generating MRd/MWr/IMWr TLPs.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_RO_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_RO_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_RO_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_RO_BF_DEF (0x00000000)

///< Address Translation Services TLP Header Bit (AT). The HDMA read channel
///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_AT_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_AT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_AT_BF_MSK (0x00000060)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_AT_BF_DEF (0x00000000)

///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
///< that DMA TLP is part of a trusted execution environment. The HDMA
///< read channel uses this TLP header field when generating MRd/IMWr TLP
///< requests.  When T_BIT_SRC field is set to 0x1, the HDMA uses this
///< TLP header field when generating MWr TLP requests.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_BF_OFF ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_BF_MSK (0x00000080)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_BF_DEF (0x00000000)

///< Completion to Memory Write T-bit source. The HDMA read channel uses
///< this field to overwrite the T field of the IDE prefix from the core
///< completions by the T_BIT field.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_SRC_BF_OFF ( 8)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_SRC_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_SRC_BF_MSK (0x00000100)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_T_BIT_SRC_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0 register description at address offset 0x380138
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_FUNC_NUM_OFF_RDCH_0
  * HDMA Read Channel Function Number Register.
  */

typedef union {
  struct {
    uint32_t PF : 5;
    ///< DMA Channel Physical Function Number.  DMA channel wide physical function
    ///< of the generated TLP. The controller uses this field to form the requester
    ///< ID for requests. Function numbering starts at '0'. When you have enabled
    ///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
    ///< behavior is undefined if any value outside of the valid range is set
    ///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
    ///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_func_num_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_RD_MASK (0x0000001fU)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_WR_MASK (0x0000001fU)


///< DMA Channel Physical Function Number.  DMA channel wide physical function
///< of the generated TLP. The controller uses this field to form the requester
///< ID for requests. Function numbering starts at '0'. When you have enabled
///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
///< behavior is undefined if any value outside of the valid range is set
///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_PF_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_PF_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_PF_BF_MSK (0x0000001F)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_PF_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_QOS_OFF_RDCH_0 register description at address offset 0x38013c
  *
  * Register default value:        0x00030008
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_QOS_OFF_RDCH_0
  * HDMA Read Channel QoS Settings Register.
  */

typedef union {
  struct {
    uint32_t TC : 3;
    ///< Traffic Class TLP Header Field (TC). The HDMA read channel uses this
    ///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t WEIGHT : 5;
    ///< Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t PF_DEPTH : 10;
    ///< This field controls the linked list prefetch allocation space for
    ///< an HDMA read channel. Each read channel stores PF_DEPTH plus '1' linked
    ///< list elements. For example, if PF_DEPTH =0, the read channel stores
    ///< one linked list element. This field must be within the range: [ 0
    ///< : floor(CX_DMA_RD_LLQ * CC_NUM_DMA_RD_CHAN / number_of_active_channels)
    ///< - 1 ].  Note:  - If this field is set to a value outside the specified
    ///< range, data corruption or channel crosstalk may happen.  - If PF_DEPTH
    ///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
    ///< - 1 ] can be doorbelled.  - This field cannot be changed while any
    ///< read engine channel is in doorbell state. Doing so might yield undefined
    ///< results.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="16" ResetValue="0x3"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_qos_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_DEFAULT (0x00030008U)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_RD_MASK (0x03ff00ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_WR_MASK (0x03ff00ffU)


///< Traffic Class TLP Header Field (TC). The HDMA read channel uses this
///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_TC_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_TC_BF_WID ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_TC_BF_MSK (0x00000007)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_TC_BF_DEF (0x00000000)

///< Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_WEIGHT_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_WEIGHT_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_WEIGHT_BF_MSK (0x000000F8)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_WEIGHT_BF_DEF (0x00000008)

///< This field controls the linked list prefetch allocation space for
///< an HDMA read channel. Each read channel stores PF_DEPTH plus '1' linked
///< list elements. For example, if PF_DEPTH =0, the read channel stores
///< one linked list element. This field must be within the range: [ 0
///< : floor(CX_DMA_RD_LLQ * CC_NUM_DMA_RD_CHAN / number_of_active_channels)
///< - 1 ].  Note:  - If this field is set to a value outside the specified
///< range, data corruption or channel crosstalk may happen.  - If PF_DEPTH
///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
///< - 1 ] can be doorbelled.  - This field cannot be changed while any
///< read engine channel is in doorbell state. Doing so might yield undefined
///< results.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_PF_DEPTH_BF_OFF (16)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_PF_DEPTH_BF_WID (10)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_PF_DEPTH_BF_MSK (0x03FF0000)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_PF_DEPTH_BF_DEF (0x00030000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_STATUS_OFF_RDCH_0 register description at address offset 0x380180
  *
  * Register default value:        0x00000003
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_STATUS_OFF_RDCH_0
  * HDMA Read Channel Status Register.
  */

typedef union {
  struct {
    uint32_t STATUS : 2;
    ///< HDMA Read Channel Status.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x3"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_stat_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_DEFAULT (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_WR_MASK (0x00000000U)


///< HDMA Read Channel Status.
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_STAT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_STAT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_STAT_BF_DEF (0x00000003)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_STATUS_OFF_RDCH_0 register description at address offset 0x380184
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_STATUS_OFF_RDCH_0
  * HDMA Read Channel Interrupt Status Register.
  */

typedef union {
  struct {
    uint32_t STOP : 1;
    ///< HDMA Read Channel Stop Interrupt Status. STOP and ABORT register fields
    ///< are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK : 1;
    ///< HDMA Read Channel Watermark Interrupt Status.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT : 1;
    ///< HDMA Read Channel Abort Interrupt Status. ABORT and STOP register
    ///< fields are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t ERROR : 4;
    ///< HDMA Read Channel Error Interrupt Status. Specifies the error that
    ///< caused the HDMA to change HDMA_STATUS_OFF_RDCH_i.STATUS to ABORTED
    ///< state.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_stat_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_WR_MASK (0x00000000U)


///< HDMA Read Channel Stop Interrupt Status. STOP and ABORT register fields
///< are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_STOP_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_STOP_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_STOP_BF_DEF (0x00000000)

///< HDMA Read Channel Watermark Interrupt Status.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_WATERMARK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_WATERMARK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_WATERMARK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_WATERMARK_BF_DEF (0x00000000)

///< HDMA Read Channel Abort Interrupt Status. ABORT and STOP register
///< fields are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ABORT_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ABORT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ABORT_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ABORT_BF_DEF (0x00000000)

///< HDMA Read Channel Error Interrupt Status. Specifies the error that
///< caused the HDMA to change HDMA_STATUS_OFF_RDCH_i.STATUS to ABORTED
///< state.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ERR_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ERR_BF_WID ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ERR_BF_MSK (0x00000078)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ERR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0 register description at address offset 0x380188
  *
  * Register default value:        0x00000007
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_SETUP_OFF_RDCH_0
  * HDMA Read Channel Interrupt Setup Register.
  */

typedef union {
  struct {
    uint32_t STOP_MASK : 1;
    ///< HDMA Read Channel Stop Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t WATERMARK_MASK : 1;
    ///< HDMA Read Channel Watermark Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t ABORT_MASK : 1;
    ///< HDMA Read Channel Abort Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t RSIE : 1;
    ///< HDMA Read Channel Remote Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LSIE : 1;
    ///< HDMA Read Channel Local Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t RAIE : 1;
    ///< HDMA Read Channel Remote Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t LAIE : 1;
    ///< HDMA Read Channel Local Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_setup_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_DEFAULT (0x00000007U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_WR_MASK (0x0000007fU)


///< HDMA Read Channel Stop Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_STOP_MASK_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_STOP_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_STOP_MASK_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_STOP_MASK_BF_DEF (0x00000001)

///< HDMA Read Channel Watermark Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_WATERMARK_MASK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_WATERMARK_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_WATERMARK_MASK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_WATERMARK_MASK_BF_DEF (0x00000002)

///< HDMA Read Channel Abort Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_ABORT_MASK_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_ABORT_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_ABORT_MASK_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_ABORT_MASK_BF_DEF (0x00000004)

///< HDMA Read Channel Remote Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RSIE_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RSIE_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RSIE_BF_DEF (0x00000000)

///< HDMA Read Channel Local Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LSIE_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LSIE_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LSIE_BF_DEF (0x00000000)

///< HDMA Read Channel Remote Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RAIE_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RAIE_BF_MSK (0x00000020)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_RAIE_BF_DEF (0x00000000)

///< HDMA Read Channel Local Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LAIE_BF_OFF ( 6)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LAIE_BF_MSK (0x00000040)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_LAIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_CLEAR_OFF_RDCH_0 register description at address offset 0x38018c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_CLEAR_OFF_RDCH_0
  * HDMA Read Channel Interrupt Clear Register.
  */

typedef union {
  struct {
    uint32_t STOP_CLEAR : 1;
    ///< HDMA Read Channel Stop Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK_CLEAR : 1;
    ///< HDMA Read Channel Watermark Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT_CLEAR : 1;
    ///< HDMA Abort Channel Abort Interrupt Clear. Setting this field clears
    ///< the ABORT and ERROR fields.
    ///< AccessType="WS/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_clr_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_WR_MASK (0x00000007U)


///< HDMA Read Channel Stop Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_STOP_CLR_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_STOP_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_STOP_CLR_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_STOP_CLR_BF_DEF (0x00000000)

///< HDMA Read Channel Watermark Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_WATERMARK_CLR_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_WATERMARK_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_WATERMARK_CLR_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_WATERMARK_CLR_BF_DEF (0x00000000)

///< HDMA Abort Channel Abort Interrupt Clear. Setting this field clears
///< the ABORT and ERROR fields.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_ABORT_CLR_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_ABORT_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_ABORT_CLR_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_ABORT_CLR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0 register description at address offset 0x380190
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_LOW_OFF_RDCH_0
  * HDMA Read Stop Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_low_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_MSI_STOP_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_MSI_STOP_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_MSI_STOP_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_MSI_STOP_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0 register description at address offset 0x380194
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_HIGH_OFF_RDCH_0
  * HDMA Read Stop Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_high_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_MSI_STOP_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_MSI_STOP_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_MSI_STOP_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_MSI_STOP_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0 register description at address offset 0x380198
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0
  * HDMA Read Watermark Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
    ///< address must be dword aligned.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
///< address must be dword aligned.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_MSI_WATERMARK_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_MSI_WATERMARK_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_MSI_WATERMARK_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_MSI_WATERMARK_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0 register description at address offset 0x38019c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0
  * HDMA Read Watermark Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_MSI_WATERMARK_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_MSI_WATERMARK_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_MSI_WATERMARK_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_MSI_WATERMARK_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0 register description at address offset 0x3801a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_LOW_OFF_RDCH_0
  * HDMA Read Abort Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_low_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_MSI_ABORT_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_MSI_ABORT_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_MSI_ABORT_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_MSI_ABORT_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0 register description at address offset 0x3801a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_HIGH_OFF_RDCH_0
  * HDMA Read Abort Remote Interrupt Address High.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_high_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_MSI_ABORT_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_MSI_ABORT_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_MSI_ABORT_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_MSI_ABORT_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0 register description at address offset 0x3801a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_MSGD_OFF_RDCH_0
  * HDMA Read Channel Remote Interrupt Data Register.
  */

typedef union {
  struct {
    uint32_t MSI_MESSAGE : 16;
    ///< The HDMA read channel uses this field to generate the data field for
    ///< every IMWr TLPs it generates.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_msgd_off_rdch_0_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_RD_MASK (0x0000ffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_WR_MASK (0x0000ffffU)


///< The HDMA read channel uses this field to generate the data field for
///< every IMWr TLPs it generates.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_MSI_MSG_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_MSI_MSG_BF_WID (16)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_MSI_MSG_BF_MSK (0x0000FFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_MSI_MSG_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_EN_OFF_WRCH_1 register description at address offset 0x380200
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_EN_OFF_WRCH_1
  * HDMA Write Channel Enable Register.
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< HDMA Write Channel Enable. The controller checks this field for power
    ///< management purposes. If this field is enabled for any one of the read,
    ///< or write channel, the controller exits low power state.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_en_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_RD_MASK (0x00000001U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_WR_MASK (0x00000001U)


///< HDMA Write Channel Enable. The controller checks this field for power
///< management purposes. If this field is enabled for any one of the read,
///< or write channel, the controller exits low power state.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_EN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_EN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_EN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1 register description at address offset 0x380204
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DOORBELL_OFF_WRCH_1
  * HDMA Write Channel Doorbell Register.
  */

typedef union {
  struct {
    uint32_t DB_START : 1;
    ///< HDMA Write Channel Doorbell Start. You must set this field to start
    ///< the write transfer for this channel.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t DB_STOP : 1;
    ///< HDMA Write Channel Doorbell Stop. You must set this field to stop
    ///< the write transfer for this channel. HDMA stops the write transfer
    ///< for this channel at the earliest when this field is set.  Note: Only
    ///< after the HDMA_STATUS_OFF_WRCH_i.STATUS =0x03, you can consider this
    ///< channel to be in stop state.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_doorbell_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_WR_MASK (0x00000003U)


///< HDMA Write Channel Doorbell Start. You must set this field to start
///< the write transfer for this channel.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_START_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_START_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_START_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_START_BF_DEF (0x00000000)

///< HDMA Write Channel Doorbell Stop. You must set this field to stop
///< the write transfer for this channel. HDMA stops the write transfer
///< for this channel at the earliest when this field is set.  Note: Only
///< after the HDMA_STATUS_OFF_WRCH_i.STATUS =0x03, you can consider this
///< channel to be in stop state.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_STOP_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_STOP_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_DB_STOP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1 register description at address offset 0x380208
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_ELEM_PF_OFF_WRCH_1
  * HDMA Write Channel Prefetch Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_PREFETCH : 7;
    ///< This field controls the number of linked list elements (descriptors)
    ///< this HDMA write channel prefetches. The linked list element pointer
    ///< loaded by HDMA updates this field.  Note: The actual prefetch value
    ///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
    ///< one descriptor is prefetched by this channel.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_elem_pf_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_WR_MASK (0x0000007fU)


///< This field controls the number of linked list elements (descriptors)
///< this HDMA write channel prefetches. The linked list element pointer
///< loaded by HDMA updates this field.  Note: The actual prefetch value
///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
///< one descriptor is prefetched by this channel.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_ELEMENT_PREFETCH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_ELEMENT_PREFETCH_BF_WID ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_ELEMENT_PREFETCH_BF_MSK (0x0000007F)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_ELEMENT_PREFETCH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1 register description at address offset 0x380210
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_LOW_OFF_WRCH_1
  * HDMA Write Channel Linked List Pointer Low Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_LOW : 32;
    ///< Lower 32 bits of the address of the transfer list in the local memory.
    ///< Used in linked list mode only.HDMA fetches descriptors from local
    ///< memory respecting the following patterns:  - When the current element
    ///< is a data element; HDMA increments this field by 6 DWORDs times the
    ///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_WRCH*
    ///< and HDMA_QOS_OFF_WRCH*  - When the current element is a link element;
    ///< HDMA overwrites this field with the LL Element Pointer of the next
    ///< LL element structure. The current fetched memory address pointer is
    ///< not directly visible in this register, instead HDMA updates this register
    ///< on the following occurrences:  - Watermark interrupt event  - Channel
    ///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
    ///< event this register points to the descriptor's address that triggered
    ///< it.A channel status STOP or ABORT events are end of transfer events
    ///< that makes this register point to the next data to transfer after
    ///< the event.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_low_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< Lower 32 bits of the address of the transfer list in the local memory.
///< Used in linked list mode only.HDMA fetches descriptors from local
///< memory respecting the following patterns:  - When the current element
///< is a data element; HDMA increments this field by 6 DWORDs times the
///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_WRCH*
///< and HDMA_QOS_OFF_WRCH*  - When the current element is a link element;
///< HDMA overwrites this field with the LL Element Pointer of the next
///< LL element structure. The current fetched memory address pointer is
///< not directly visible in this register, instead HDMA updates this register
///< on the following occurrences:  - Watermark interrupt event  - Channel
///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
///< event this register points to the descriptor's address that triggered
///< it.A channel status STOP or ABORT events are end of transfer events
///< that makes this register point to the next data to transfer after
///< the event.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_ELEMENT_LIST_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_ELEMENT_LIST_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_ELEMENT_LIST_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_ELEMENT_LIST_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1 register description at address offset 0x380214
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_HIGH_OFF_WRCH_1
  * HDMA Write Channel Linked List Pointer High Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_HIGH : 32;
    ///< Higher 32 bits of the address of the transfer list in the local memory.
    ///< HDMA fetches descriptors from local memory respecting the following
    ///< patterns:  - When the current element is a data element; HDMA increments
    ///< this field by 6 DWORDs times the prefetch depth. For more information,
    ///< see registers HDMA_ELEM_PF_OFF_WRCH* and HDMA_QOS_OFF_WRCH*  - When
    ///< the current element is a link element; HDMA overwrites this field
    ///< with the LL Element Pointer of the next LL element structure. The
    ///< current fetched memory address pointer is not directly visible in
    ///< this register, instead HDMA updates this register on the following
    ///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
    ///< event  - Channel Status STOP event On a watermark interrupt event
    ///< this register points to the descriptor's address that triggered it.
    ///< A channel status STOP or ABORT events are end of transfer events that
    ///< makes this register point to the next data to transfer after the event.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_high_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< Higher 32 bits of the address of the transfer list in the local memory.
///< HDMA fetches descriptors from local memory respecting the following
///< patterns:  - When the current element is a data element; HDMA increments
///< this field by 6 DWORDs times the prefetch depth. For more information,
///< see registers HDMA_ELEM_PF_OFF_WRCH* and HDMA_QOS_OFF_WRCH*  - When
///< the current element is a link element; HDMA overwrites this field
///< with the LL Element Pointer of the next LL element structure. The
///< current fetched memory address pointer is not directly visible in
///< this register, instead HDMA updates this register on the following
///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
///< event  - Channel Status STOP event On a watermark interrupt event
///< this register points to the descriptor's address that triggered it.
///< A channel status STOP or ABORT events are end of transfer events that
///< makes this register point to the next data to transfer after the event.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_ELEMENT_LIST_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_ELEMENT_LIST_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_ELEMENT_LIST_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_ELEMENT_LIST_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1 register description at address offset 0x380218
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CYCLE_OFF_WRCH_1
  * HDMA Write Channel Producer-Consumer Cycle Synchronization Register.
  */

typedef union {
  struct {
    uint32_t CYCLE_BIT : 1;
    ///< Toggle Cycle Bit.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t CYCLE_STATE : 1;
    ///< Consumer Cycle State. You must initialize this field.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_cycle_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_WR_MASK (0x00000003U)


///< Toggle Cycle Bit.   Note: The access attributes of this field are
///< as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_BIT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_BIT_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_BIT_BF_DEF (0x00000000)

///< Consumer Cycle State. You must initialize this field.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_STATE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_STATE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_STATE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_CYCLE_STATE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1 register description at address offset 0x38021c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_XFERSIZE_OFF_WRCH_1
  * HDMA Write Channel Transfer Size Register.
  */

typedef union {
  struct {
    uint32_t XFERSIZE : 32;
    ///< HDMA Write Channel Transfer Size. You program this register with the
    ///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
    ///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
    ///< the value of this field as the write channel transfer progresses.
    ///< This field indicates the number of bytes remaining to be requested.
    ///< When all bytes are requested the current transfer size is zero. In
    ///< LL mode, the HDMA overwrites this register with the corresponding
    ///< dword of the LL element.  You can read this register to monitor the
    ///< transfer progress, but it is not reliable for that specific usage,
    ///< as it is updated after read requests and not after write requests.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_xfersize_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< HDMA Write Channel Transfer Size. You program this register with the
///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
///< the value of this field as the write channel transfer progresses.
///< This field indicates the number of bytes remaining to be requested.
///< When all bytes are requested the current transfer size is zero. In
///< LL mode, the HDMA overwrites this register with the corresponding
///< dword of the LL element.  You can read this register to monitor the
///< transfer progress, but it is not reliable for that specific usage,
///< as it is updated after read requests and not after write requests.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_XFERSIZE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_XFERSIZE_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_XFERSIZE_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_XFERSIZE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1 register description at address offset 0x380220
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_LOW_OFF_WRCH_1
  * HDMA Write Channel SAR Low Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_LOW : 32;
    ///< Source Address Register (lower 32 bits). Indicates the address of
    ///< the local memory from which HDMA reads. The HDMA increments the SAR
    ///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
    ///< field with the corresponding dword of the LL element. The SAR is the
    ///< address of the local memory.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_low_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< Source Address Register (lower 32 bits). Indicates the address of
///< the local memory from which HDMA reads. The HDMA increments the SAR
///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
///< field with the corresponding dword of the LL element. The SAR is the
///< address of the local memory.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_SAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_SAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_SAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_SAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1 register description at address offset 0x380224
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_HIGH_OFF_WRCH_1
  * HDMA Write Channel SAR High Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_HIGH : 32;
    ///< Source Address Register (higher 32 bits).   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_high_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< Source Address Register (higher 32 bits).   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_SAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_SAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_SAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_SAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1 register description at address offset 0x380228
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_LOW_OFF_WRCH_1
  * HDMA Write Channel DAR Low Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_LOW : 32;
    ///< Destination Address Register (lower 32 bits). Indicates the address
    ///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
    ///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
    ///< dword of the LL element. The DAR is the address of the remote memory.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_low_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< Destination Address Register (lower 32 bits). Indicates the address
///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
///< dword of the LL element. The DAR is the address of the remote memory.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_DAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_DAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_DAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_DAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1 register description at address offset 0x38022c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_HIGH_OFF_WRCH_1
  * HDMA Write Channel DAR High Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_HIGH : 32;
    ///< Destination Address Register (higher 32 bits).   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_high_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< Destination Address Register (higher 32 bits).   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_DAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_DAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_DAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_DAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1 register description at address offset 0x380230
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_WATERMARK_EN_OFF_WRCH_1
  * HDMA Write Channel Linked-list Watermark Enable Register.
  */

typedef union {
  struct {
    uint32_t RWIE : 1;
    ///< Enables Remote Interrupts at watermark events (end of linked list
    ///< element) in an HDMA write channel.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t LWIE : 1;
    ///< Enables Local Interrupts at watermark events (end of linked list element)
    ///< in an HDMA write channel.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_watermark_en_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_WR_MASK (0x00000003U)


///< Enables Remote Interrupts at watermark events (end of linked list
///< element) in an HDMA write channel.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_RWIE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_RWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_RWIE_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_RWIE_BF_DEF (0x00000000)

///< Enables Local Interrupts at watermark events (end of linked list element)
///< in an HDMA write channel.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_LWIE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_LWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_LWIE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_LWIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CONTROL1_OFF_WRCH_1 register description at address offset 0x380234
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CONTROL1_OFF_WRCH_1
  * HDMA Write Channel Control Settings 1 Register.
  */

typedef union {
  struct {
    uint32_t LLEN : 1;
    ///< This field enables the HDMA write channel Linked List mode.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_TYPE : 1;
    ///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
    ///< write channel memory type of the address space of the data transfer
    ///< as follows: For more information, see  ACE-Lite Features and Limitations
    ///< section of the Databook. Irrespective of the value of this field,
    ///< Linked list descriptor requests have this attribute set to 0x1.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SRC_SNOOP : 1;
    ///< Source No Snoop TLP Header Bit. The HDMA write channel uses this TLP
    ///< header field when generating MRd (SAR addressing space) TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DST_SNOOP : 1;
    ///< Destination No Snoop TLP Header Bit. The HDMA write channel uses this
    ///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t RO : 1;
    ///< Relaxed Ordering TLP Header Bit. HDMA write channel uses this TLP
    ///< header field when generating MRd/MWr/IMWr TLPs.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t AT : 2;
    ///< Address Translation Services TLP Header Bit (AT). The HDMA write channel
    ///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t T_BIT : 1;
    ///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
    ///< that DMA TLP is part of a trusted execution environment. The HDMA
    ///< write channel uses this TLP header field when generating MRD/IMWr
    ///< TLP requests.   When T_BIT_SRC field is set to 0x1, the HDMA uses
    ///< this TLP header field when generating MWr TLP requests.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t T_BIT_SRC : 1;
    ///< Completion to Memory Write T-bit source. The HDMA Write channel uses
    ///< this field to overwrite the T-bit from the application completion
    ///< interface by the T_BIT field.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_ctrl1_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_RD_MASK (0x000001ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_WR_MASK (0x000001ffU)


///< This field enables the HDMA write channel Linked List mode.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_LLEN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_LLEN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_LLEN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_LLEN_BF_DEF (0x00000000)

///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
///< write channel memory type of the address space of the data transfer
///< as follows: For more information, see  ACE-Lite Features and Limitations
///< section of the Databook. Irrespective of the value of this field,
///< Linked list descriptor requests have this attribute set to 0x1.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_MEM_TYPE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_MEM_TYPE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_MEM_TYPE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_MEM_TYPE_BF_DEF (0x00000000)

///< Source No Snoop TLP Header Bit. The HDMA write channel uses this TLP
///< header field when generating MRd (SAR addressing space) TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_SRC_SNOOP_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_SRC_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_SRC_SNOOP_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_SRC_SNOOP_BF_DEF (0x00000000)

///< Destination No Snoop TLP Header Bit. The HDMA write channel uses this
///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_DST_SNOOP_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_DST_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_DST_SNOOP_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_DST_SNOOP_BF_DEF (0x00000000)

///< Relaxed Ordering TLP Header Bit. HDMA write channel uses this TLP
///< header field when generating MRd/MWr/IMWr TLPs.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_RO_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_RO_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_RO_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_RO_BF_DEF (0x00000000)

///< Address Translation Services TLP Header Bit (AT). The HDMA write channel
///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_AT_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_AT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_AT_BF_MSK (0x00000060)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_AT_BF_DEF (0x00000000)

///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
///< that DMA TLP is part of a trusted execution environment. The HDMA
///< write channel uses this TLP header field when generating MRD/IMWr
///< TLP requests.   When T_BIT_SRC field is set to 0x1, the HDMA uses
///< this TLP header field when generating MWr TLP requests.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_BF_OFF ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_BF_MSK (0x00000080)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_BF_DEF (0x00000000)

///< Completion to Memory Write T-bit source. The HDMA Write channel uses
///< this field to overwrite the T-bit from the application completion
///< interface by the T_BIT field.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_SRC_BF_OFF ( 8)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_SRC_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_SRC_BF_MSK (0x00000100)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_T_BIT_SRC_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1 register description at address offset 0x380238
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_FUNC_NUM_OFF_WRCH_1
  * HDMA Write Channel Function Number Register.
  */

typedef union {
  struct {
    uint32_t PF : 5;
    ///< DMA Channel Physical Function Number.  DMA channel wide physical function
    ///< of the generated TLP. The controller uses this field to form the requester
    ///< ID for requests. Function numbering starts at '0'. When you have enabled
    ///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
    ///< behavior is undefined if any value outside of the valid range is set
    ///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
    ///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_func_num_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_RD_MASK (0x0000001fU)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_WR_MASK (0x0000001fU)


///< DMA Channel Physical Function Number.  DMA channel wide physical function
///< of the generated TLP. The controller uses this field to form the requester
///< ID for requests. Function numbering starts at '0'. When you have enabled
///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
///< behavior is undefined if any value outside of the valid range is set
///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_PF_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_PF_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_PF_BF_MSK (0x0000001F)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_PF_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_QOS_OFF_WRCH_1 register description at address offset 0x38023c
  *
  * Register default value:        0x00030008
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_QOS_OFF_WRCH_1
  * HDMA Write Channel QoS Settings Register.
  */

typedef union {
  struct {
    uint32_t TC : 3;
    ///< Traffic Class TLP Header Field (TC). The HDMA write channel uses this
    ///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t WEIGHT : 5;
    ///< Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t PF_DEPTH : 10;
    ///< This field controls the linked list prefetch allocation space for
    ///< an HDMA write channel. Each write channel stores PF_DEPTH plus '1'
    ///< linked list elements. For example, if PF_DEPTH =0, the write channel
    ///< stores one linked list element. This field must be within the range:
    ///< [ 0 : floor(CX_DMA_WR_LLQ * CC_NUM_DMA_WR_CHAN / number_of_active_channels)
    ///< - 1 ].  Note:  If this field is set to a value outside the specified
    ///< range, data corruption or channel crosstalk may happen.  If PF_DEPTH
    ///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
    ///< - 1 ] can be doorbelled.  This field cannot be changed while any write
    ///< engine channel is in doorbell state. Doing so might yield undefined
    ///< results.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="16" ResetValue="0x3"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_qos_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_DEFAULT (0x00030008U)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_RD_MASK (0x03ff00ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_WR_MASK (0x03ff00ffU)


///< Traffic Class TLP Header Field (TC). The HDMA write channel uses this
///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_TC_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_TC_BF_WID ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_TC_BF_MSK (0x00000007)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_TC_BF_DEF (0x00000000)

///< Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_WEIGHT_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_WEIGHT_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_WEIGHT_BF_MSK (0x000000F8)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_WEIGHT_BF_DEF (0x00000008)

///< This field controls the linked list prefetch allocation space for
///< an HDMA write channel. Each write channel stores PF_DEPTH plus '1'
///< linked list elements. For example, if PF_DEPTH =0, the write channel
///< stores one linked list element. This field must be within the range:
///< [ 0 : floor(CX_DMA_WR_LLQ * CC_NUM_DMA_WR_CHAN / number_of_active_channels)
///< - 1 ].  Note:  If this field is set to a value outside the specified
///< range, data corruption or channel crosstalk may happen.  If PF_DEPTH
///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
///< - 1 ] can be doorbelled.  This field cannot be changed while any write
///< engine channel is in doorbell state. Doing so might yield undefined
///< results.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_PF_DEPTH_BF_OFF (16)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_PF_DEPTH_BF_WID (10)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_PF_DEPTH_BF_MSK (0x03FF0000)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_PF_DEPTH_BF_DEF (0x00030000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_STATUS_OFF_WRCH_1 register description at address offset 0x380280
  *
  * Register default value:        0x00000003
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_STATUS_OFF_WRCH_1
  * HDMA Write Channel Status Register.
  */

typedef union {
  struct {
    uint32_t STATUS : 2;
    ///< HDMA Write Channel Status.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x3"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_stat_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_DEFAULT (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_WR_MASK (0x00000000U)


///< HDMA Write Channel Status.
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_STAT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_STAT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_STAT_BF_DEF (0x00000003)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_STATUS_OFF_WRCH_1 register description at address offset 0x380284
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_STATUS_OFF_WRCH_1
  * HDMA Write Channel Interrupt Status Register.
  */

typedef union {
  struct {
    uint32_t STOP : 1;
    ///< HDMA Write Channel Stop Interrupt Status. STOP and ABORT register
    ///< fields are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK : 1;
    ///< HDMA Write Channel Watermark Interrupt Status.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT : 1;
    ///< HDMA Write Channel Abort Interrupt Status. ABORT and STOP register
    ///< fields are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t ERROR : 4;
    ///< HDMA Write Channel Interrupt Error Status. Specifies the error that
    ///< caused the HDMA to change HDMA_STATUS_OFF_WRCH_i.STATUS to ABORTED
    ///< state.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_stat_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_WR_MASK (0x00000000U)


///< HDMA Write Channel Stop Interrupt Status. STOP and ABORT register
///< fields are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_STOP_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_STOP_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_STOP_BF_DEF (0x00000000)

///< HDMA Write Channel Watermark Interrupt Status.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_WATERMARK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_WATERMARK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_WATERMARK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_WATERMARK_BF_DEF (0x00000000)

///< HDMA Write Channel Abort Interrupt Status. ABORT and STOP register
///< fields are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ABORT_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ABORT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ABORT_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ABORT_BF_DEF (0x00000000)

///< HDMA Write Channel Interrupt Error Status. Specifies the error that
///< caused the HDMA to change HDMA_STATUS_OFF_WRCH_i.STATUS to ABORTED
///< state.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ERR_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ERR_BF_WID ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ERR_BF_MSK (0x00000078)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ERR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1 register description at address offset 0x380288
  *
  * Register default value:        0x00000007
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_SETUP_OFF_WRCH_1
  * HDMA Write Channel Interrupt Setup Register.
  */

typedef union {
  struct {
    uint32_t STOP_MASK : 1;
    ///< HDMA Write Channel Stop Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t WATERMARK_MASK : 1;
    ///< HDMA Write Channel Watermark Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t ABORT_MASK : 1;
    ///< HDMA Write Channel Abort Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t RSIE : 1;
    ///< HDMA Write Channel Remote Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LSIE : 1;
    ///< HDMA Write Channel Local Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t RAIE : 1;
    ///< HDMA Write Channel Remote Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t LAIE : 1;
    ///< HDMA Write Channel Local Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_setup_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_DEFAULT (0x00000007U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_WR_MASK (0x0000007fU)


///< HDMA Write Channel Stop Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_STOP_MASK_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_STOP_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_STOP_MASK_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_STOP_MASK_BF_DEF (0x00000001)

///< HDMA Write Channel Watermark Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_WATERMARK_MASK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_WATERMARK_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_WATERMARK_MASK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_WATERMARK_MASK_BF_DEF (0x00000002)

///< HDMA Write Channel Abort Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_ABORT_MASK_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_ABORT_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_ABORT_MASK_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_ABORT_MASK_BF_DEF (0x00000004)

///< HDMA Write Channel Remote Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RSIE_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RSIE_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RSIE_BF_DEF (0x00000000)

///< HDMA Write Channel Local Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LSIE_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LSIE_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LSIE_BF_DEF (0x00000000)

///< HDMA Write Channel Remote Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RAIE_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RAIE_BF_MSK (0x00000020)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_RAIE_BF_DEF (0x00000000)

///< HDMA Write Channel Local Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LAIE_BF_OFF ( 6)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LAIE_BF_MSK (0x00000040)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_LAIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_CLEAR_OFF_WRCH_1 register description at address offset 0x38028c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_CLEAR_OFF_WRCH_1
  * HDMA Write Channel Interrupt Clear Register.
  */

typedef union {
  struct {
    uint32_t STOP_CLEAR : 1;
    ///< HDMA Write Channel Stop Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK_CLEAR : 1;
    ///< HDMA Write Channel Watermark Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT_CLEAR : 1;
    ///< HDMA Abort Channel Abort Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_clr_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_WR_MASK (0x00000007U)


///< HDMA Write Channel Stop Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_STOP_CLR_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_STOP_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_STOP_CLR_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_STOP_CLR_BF_DEF (0x00000000)

///< HDMA Write Channel Watermark Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_WATERMARK_CLR_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_WATERMARK_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_WATERMARK_CLR_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_WATERMARK_CLR_BF_DEF (0x00000000)

///< HDMA Abort Channel Abort Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_ABORT_CLR_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_ABORT_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_ABORT_CLR_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_ABORT_CLR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1 register description at address offset 0x380290
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_LOW_OFF_WRCH_1
  * HDMA Write Stop Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_low_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_MSI_STOP_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_MSI_STOP_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_MSI_STOP_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_MSI_STOP_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1 register description at address offset 0x380294
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_HIGH_OFF_WRCH_1
  * HDMA Write Stop Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_high_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_MSI_STOP_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_MSI_STOP_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_MSI_STOP_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_MSI_STOP_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1 register description at address offset 0x380298
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1
  * HDMA Write Watermark Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
    ///< address must be dword aligned.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
///< address must be dword aligned.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_MSI_WATERMARK_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_MSI_WATERMARK_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_MSI_WATERMARK_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_MSI_WATERMARK_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1 register description at address offset 0x38029c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1
  * HDMA Write Watermark Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_MSI_WATERMARK_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_MSI_WATERMARK_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_MSI_WATERMARK_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_MSI_WATERMARK_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1 register description at address offset 0x3802a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_LOW_OFF_WRCH_1
  * HDMA Write Abort Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_low_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_MSI_ABORT_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_MSI_ABORT_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_MSI_ABORT_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_MSI_ABORT_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1 register description at address offset 0x3802a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_HIGH_OFF_WRCH_1
  * HDMA Write Abort Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_high_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_MSI_ABORT_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_MSI_ABORT_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_MSI_ABORT_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_MSI_ABORT_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1 register description at address offset 0x3802a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_MSGD_OFF_WRCH_1
  * HDMA Write Channel Remote Interrupt Data Register.
  */

typedef union {
  struct {
    uint32_t MSI_MESSAGE : 16;
    ///< The HDMA write channel uses this field to generate the data field
    ///< for every IMWr TLPs it generates.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_msgd_off_wrch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_RD_MASK (0x0000ffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_WR_MASK (0x0000ffffU)


///< The HDMA write channel uses this field to generate the data field
///< for every IMWr TLPs it generates.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_MSI_MSG_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_MSI_MSG_BF_WID (16)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_MSI_MSG_BF_MSK (0x0000FFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_MSI_MSG_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_EN_OFF_RDCH_1 register description at address offset 0x380300
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_EN_OFF_RDCH_1
  * HDMA Read Channel Enable.
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< HDMA Read Channel Enable. The controller checks this field for power
    ///< management purposes. If this field is enabled for any one of the read,
    ///< or write channel, the controller exits low power state.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_en_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_RD_MASK (0x00000001U)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_WR_MASK (0x00000001U)


///< HDMA Read Channel Enable. The controller checks this field for power
///< management purposes. If this field is enabled for any one of the read,
///< or write channel, the controller exits low power state.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_EN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_EN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_EN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_EN_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1 register description at address offset 0x380304
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DOORBELL_OFF_RDCH_1
  * HDMA Read Channel Doorbell Register.
  */

typedef union {
  struct {
    uint32_t DB_START : 1;
    ///< HDMA Read Channel Doorbell Start. You must set this field to start
    ///< the read transfer for this channel.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t DB_STOP : 1;
    ///< HDMA Read Channel Doorbell Stop. You must set this field to stop the
    ///< read transfer for this channel. HDMA stops the read transfer for this
    ///< channel at the earliest when this field is set.  Note: Only after
    ///< the HDMA_STATUS_OFF_RDCH_i.STATUS =0x03, you can consider this channel
    ///< to be in stop state.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_doorbell_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_WR_MASK (0x00000003U)


///< HDMA Read Channel Doorbell Start. You must set this field to start
///< the read transfer for this channel.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_START_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_START_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_START_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_START_BF_DEF (0x00000000)

///< HDMA Read Channel Doorbell Stop. You must set this field to stop the
///< read transfer for this channel. HDMA stops the read transfer for this
///< channel at the earliest when this field is set.  Note: Only after
///< the HDMA_STATUS_OFF_RDCH_i.STATUS =0x03, you can consider this channel
///< to be in stop state.
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_STOP_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_STOP_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_DB_STOP_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1 register description at address offset 0x380308
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_ELEM_PF_OFF_RDCH_1
  * HDMA Read Channel Prefetch Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_PREFETCH : 7;
    ///< This field controls the number of linked list elements (descriptors)
    ///< this HDMA read channel prefetches. The linked list element pointer
    ///< loaded by HDMA updates this field.  Note: The actual prefetch value
    ///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
    ///< one descriptor is prefetched by this channel.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_elem_pf_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_WR_MASK (0x0000007fU)


///< This field controls the number of linked list elements (descriptors)
///< this HDMA read channel prefetches. The linked list element pointer
///< loaded by HDMA updates this field.  Note: The actual prefetch value
///< is ELEMENT_PREFETCH plus '1'. For example, if ELEMENT_PREFETCH =0,
///< one descriptor is prefetched by this channel.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_ELEMENT_PREFETCH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_ELEMENT_PREFETCH_BF_WID ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_ELEMENT_PREFETCH_BF_MSK (0x0000007F)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_ELEMENT_PREFETCH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1 register description at address offset 0x380310
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_LOW_OFF_RDCH_1
  * HDMA Read Channel Linked List Pointer Low Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_LOW : 32;
    ///< Lower 32 bits of the address of the transfer list in the local memory.
    ///< Used in linked list mode only. HDMA fetches descriptors from local
    ///< memory respecting the following patterns:  - When the current element
    ///< is a data element; HDMA increments this field by 6 DWORDs times the
    ///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_RDCH*
    ///< and HDMA_QOS_OFF_RDCH*  - When the current element is a link element;
    ///< HDMA overwrites this field with the LL Element Pointer of the next
    ///< LL element structure. The current fetched memory address pointer is
    ///< not directly visible in this register, instead HDMA updates this register
    ///< on the following occurrences:  - Watermark interrupt event  - Channel
    ///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
    ///< event this register points to the descriptor's address that triggered
    ///< it.A channel status STOP or ABORT events are end of transfer events
    ///< that makes this register point to the next data to transfer after
    ///< the event   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_low_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< Lower 32 bits of the address of the transfer list in the local memory.
///< Used in linked list mode only. HDMA fetches descriptors from local
///< memory respecting the following patterns:  - When the current element
///< is a data element; HDMA increments this field by 6 DWORDs times the
///< prefetch depth. For more information, see registers HDMA_ELEM_PF_OFF_RDCH*
///< and HDMA_QOS_OFF_RDCH*  - When the current element is a link element;
///< HDMA overwrites this field with the LL Element Pointer of the next
///< LL element structure. The current fetched memory address pointer is
///< not directly visible in this register, instead HDMA updates this register
///< on the following occurrences:  - Watermark interrupt event  - Channel
///< Status ABORT event  - Channel Status STOP event On a watermark interrupt
///< event this register points to the descriptor's address that triggered
///< it.A channel status STOP or ABORT events are end of transfer events
///< that makes this register point to the next data to transfer after
///< the event   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_ELEMENT_LIST_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_ELEMENT_LIST_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_ELEMENT_LIST_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_ELEMENT_LIST_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1 register description at address offset 0x380314
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_LLP_HIGH_OFF_RDCH_1
  * HDMA Read Channel Linked List Pointer High Register.
  */

typedef union {
  struct {
    uint32_t ELEMENT_LIST_PTR_HIGH : 32;
    ///< Higher 32 bits of the address of the transfer list in the local memory.
    ///< HDMA fetches descriptors from local memory respecting the following
    ///< patterns:  - When the current element is a data element; HDMA increments
    ///< this field by 6 DWORDs times the prefetch depth. For more information,
    ///< see registers HDMA_ELEM_PF_OFF_RDCH* and HDMA_QOS_OFF_RDCH*  - When
    ///< the current element is a link element; HDMA overwrites this field
    ///< with the LL Element Pointer of the next LL element structure. The
    ///< current fetched memory address pointer is not directly visible in
    ///< this register, instead HDMA updates this register on the following
    ///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
    ///< event  - Channel Status STOP event On a watermark interrupt event
    ///< this register points to the descriptor's address that triggered it.
    ///< A channel status STOP or ABORT events are end of transfer events that
    ///< makes this register point to the next data to transfer after the event.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_llp_high_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< Higher 32 bits of the address of the transfer list in the local memory.
///< HDMA fetches descriptors from local memory respecting the following
///< patterns:  - When the current element is a data element; HDMA increments
///< this field by 6 DWORDs times the prefetch depth. For more information,
///< see registers HDMA_ELEM_PF_OFF_RDCH* and HDMA_QOS_OFF_RDCH*  - When
///< the current element is a link element; HDMA overwrites this field
///< with the LL Element Pointer of the next LL element structure. The
///< current fetched memory address pointer is not directly visible in
///< this register, instead HDMA updates this register on the following
///< occurrences:  - Watermark interrupt event  - Channel Status ABORT
///< event  - Channel Status STOP event On a watermark interrupt event
///< this register points to the descriptor's address that triggered it.
///< A channel status STOP or ABORT events are end of transfer events that
///< makes this register point to the next data to transfer after the event.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_ELEMENT_LIST_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_ELEMENT_LIST_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_ELEMENT_LIST_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_ELEMENT_LIST_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1 register description at address offset 0x380318
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CYCLE_OFF_RDCH_1
  * HDMA Read Channel Producer-Consumer Cycle Synchronization Register.
  */

typedef union {
  struct {
    uint32_t CYCLE_BIT : 1;
    ///< Toggle Cycle Bit.   Note: The access attributes of this field are
    ///< as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t CYCLE_STATE : 1;
    ///< Consumer Cycle State. You must initialize this field.   Note: The
    ///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
    ///< R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_cycle_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_WR_MASK (0x00000003U)


///< Toggle Cycle Bit.   Note: The access attributes of this field are
///< as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_BIT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_BIT_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_BIT_BF_DEF (0x00000000)

///< Consumer Cycle State. You must initialize this field.   Note: The
///< access attributes of this field are as follows:  - Wire: R/W   - Dbi:
///< R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_STATE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_STATE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_STATE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_CYCLE_STATE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1 register description at address offset 0x38031c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_XFERSIZE_OFF_RDCH_1
  * HDMA Read Channel Transfer Size Register.
  */

typedef union {
  struct {
    uint32_t XFERSIZE : 32;
    ///< HDMA Read Channel Transfer Size. You program this register with the
    ///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
    ///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
    ///< the value of this field as the read channel transfer progresses. This
    ///< field indicates the number of bytes remaining to be requested. When
    ///< all bytes are requested the current transfer size is zero. In LL mode,
    ///< the HDMA overwrites this register with the corresponding dword of
    ///< the LL element.  You can read this register to monitor the transfer
    ///< progress, but it is not reliable for that specific usage, as it is
    ///< updated after read requests and not after write requests.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_xfersize_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< HDMA Read Channel Transfer Size. You program this register with the
///< size of the HDMA transfer. The maximum HDMA transfer size is 4Gbytes.
///< The minimum transfer size is one byte (0x1). HDMA automatically decrements
///< the value of this field as the read channel transfer progresses. This
///< field indicates the number of bytes remaining to be requested. When
///< all bytes are requested the current transfer size is zero. In LL mode,
///< the HDMA overwrites this register with the corresponding dword of
///< the LL element.  You can read this register to monitor the transfer
///< progress, but it is not reliable for that specific usage, as it is
///< updated after read requests and not after write requests.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_XFERSIZE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_XFERSIZE_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_XFERSIZE_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_XFERSIZE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1 register description at address offset 0x380320
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_LOW_OFF_RDCH_1
  * HDMA Read Channel SAR Low Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_LOW : 32;
    ///< Source Address Register (lower 32 bits). Indicates the address of
    ///< the local memory from which HDMA reads. The HDMA increments the SAR
    ///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
    ///< field with the corresponding dword of the LL element. The SAR is the
    ///< address of the remote memory.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_low_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< Source Address Register (lower 32 bits). Indicates the address of
///< the local memory from which HDMA reads. The HDMA increments the SAR
///< as the HDMA transfer progresses. In LL mode, the HDMA overwrites this
///< field with the corresponding dword of the LL element. The SAR is the
///< address of the remote memory.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_SAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_SAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_SAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_SAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1 register description at address offset 0x380324
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_SAR_HIGH_OFF_RDCH_1
  * HDMA Read Channel SAR High Register.
  */

typedef union {
  struct {
    uint32_t SAR_PTR_HIGH : 32;
    ///< Source Address Register (higher 32 bits).   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_sar_high_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< Source Address Register (higher 32 bits).   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_SAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_SAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_SAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_SAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1 register description at address offset 0x380328
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_LOW_OFF_RDCH_1
  * HDMA Read Channel DAR Low Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_LOW : 32;
    ///< Destination Address Register (lower 32 bits). Indicates the address
    ///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
    ///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
    ///< dword of the LL element. The DAR is the address of the local memory.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_low_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< Destination Address Register (lower 32 bits). Indicates the address
///< to which HDMA writes. The HDMA increments the DAR as the HDMA transfer
///< progresses. In LL mode, the HDMA overwrites this field with the corresponding
///< dword of the LL element. The DAR is the address of the local memory.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_DAR_PTR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_DAR_PTR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_DAR_PTR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_DAR_PTR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1 register description at address offset 0x38032c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_DAR_HIGH_OFF_RDCH_1
  * HDMA Read Channel DAR High Register.
  */

typedef union {
  struct {
    uint32_t DAR_PTR_HIGH : 32;
    ///< Destination Address Register (higher 32 bits).   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_dar_high_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< Destination Address Register (higher 32 bits).   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_DAR_PTR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_DAR_PTR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_DAR_PTR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_DAR_PTR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1 register description at address offset 0x380330
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_WATERMARK_EN_OFF_RDCH_1
  * HDMA Read Channel Linked-list Watermark Enable Register.
  */

typedef union {
  struct {
    uint32_t RWIE : 1;
    ///< Enables Remote Interrupts at watermark events (end of linked list
    ///< element) in an HDMA read channel.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t LWIE : 1;
    ///< Enables Local Interrupts at watermark events (end of linked list element)
    ///< in an HDMA read channel.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_watermark_en_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_WR_MASK (0x00000003U)


///< Enables Remote Interrupts at watermark events (end of linked list
///< element) in an HDMA read channel.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_RWIE_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_RWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_RWIE_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_RWIE_BF_DEF (0x00000000)

///< Enables Local Interrupts at watermark events (end of linked list element)
///< in an HDMA read channel.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_LWIE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_LWIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_LWIE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_LWIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_CONTROL1_OFF_RDCH_1 register description at address offset 0x380334
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_CONTROL1_OFF_RDCH_1
  * HDMA Read Channel Control Settings 1 Register.
  */

typedef union {
  struct {
    uint32_t LLEN : 1;
    ///< This field enables the HDMA read channel Linked List mode.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MEM_TYPE : 1;
    ///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
    ///< read channel memory type of the address space of the data transfer
    ///< as follows: For more information, see  ACE-Lite Features and Limitations
    ///< section of the Databook. Irrespective of the value of this field,
    ///< Linked list descriptor requests have this attribute set to 0x1.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SRC_SNOOP : 1;
    ///< Source No Snoop TLP Header Bit. The HDMA read channel uses this TLP
    ///< header field when generating MRd (SAR addressing space) TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DST_SNOOP : 1;
    ///< Destination No Snoop TLP Header Bit. The HDMA read channel uses this
    ///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
    ///< Note: The access attributes of this field are as follows:  - Wire:
    ///< R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t RO : 1;
    ///< Relaxed Ordering TLP Header Bit. HDMA read channel uses this TLP header
    ///< field when generating MRd/MWr/IMWr TLPs.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t AT : 2;
    ///< Address Translation Services TLP Header Bit (AT). The HDMA read channel
    ///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t T_BIT : 1;
    ///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
    ///< that DMA TLP is part of a trusted execution environment. The HDMA
    ///< read channel uses this TLP header field when generating MRd/IMWr TLP
    ///< requests.  When T_BIT_SRC field is set to 0x1, the HDMA uses this
    ///< TLP header field when generating MWr TLP requests.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t T_BIT_SRC : 1;
    ///< Completion to Memory Write T-bit source. The HDMA read channel uses
    ///< this field to overwrite the T field of the IDE prefix from the core
    ///< completions by the T_BIT field.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_ctrl1_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_RD_MASK (0x000001ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_WR_MASK (0x000001ffU)


///< This field enables the HDMA read channel Linked List mode.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_LLEN_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_LLEN_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_LLEN_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_LLEN_BF_DEF (0x00000000)

///< Master AXI ACE-Lite Cache Coherency Control. This field sets the HDMA
///< read channel memory type of the address space of the data transfer
///< as follows: For more information, see  ACE-Lite Features and Limitations
///< section of the Databook. Irrespective of the value of this field,
///< Linked list descriptor requests have this attribute set to 0x1.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_MEM_TYPE_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_MEM_TYPE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_MEM_TYPE_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_MEM_TYPE_BF_DEF (0x00000000)

///< Source No Snoop TLP Header Bit. The HDMA read channel uses this TLP
///< header field when generating MRd (SAR addressing space) TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_SRC_SNOOP_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_SRC_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_SRC_SNOOP_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_SRC_SNOOP_BF_DEF (0x00000000)

///< Destination No Snoop TLP Header Bit. The HDMA read channel uses this
///< TLP header field when generating MWr/IMWr (DAR addressing space) TLPs.
///< Note: The access attributes of this field are as follows:  - Wire:
///< R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_DST_SNOOP_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_DST_SNOOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_DST_SNOOP_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_DST_SNOOP_BF_DEF (0x00000000)

///< Relaxed Ordering TLP Header Bit. HDMA read channel uses this TLP header
///< field when generating MRd/MWr/IMWr TLPs.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_RO_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_RO_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_RO_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_RO_BF_DEF (0x00000000)

///< Address Translation Services TLP Header Bit (AT). The HDMA read channel
///< uses this TLP header field when generating MRd/MWr/IMWr TLPs.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_AT_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_AT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_AT_BF_MSK (0x00000060)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_AT_BF_DEF (0x00000000)

///< T-bit TLP Header Bit. Used in the IDE Prefix for IDE TLPs to indicate
///< that DMA TLP is part of a trusted execution environment. The HDMA
///< read channel uses this TLP header field when generating MRd/IMWr TLP
///< requests.  When T_BIT_SRC field is set to 0x1, the HDMA uses this
///< TLP header field when generating MWr TLP requests.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_BF_OFF ( 7)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_BF_MSK (0x00000080)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_BF_DEF (0x00000000)

///< Completion to Memory Write T-bit source. The HDMA read channel uses
///< this field to overwrite the T field of the IDE prefix from the core
///< completions by the T_BIT field.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_SRC_BF_OFF ( 8)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_SRC_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_SRC_BF_MSK (0x00000100)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_T_BIT_SRC_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1 register description at address offset 0x380338
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_FUNC_NUM_OFF_RDCH_1
  * HDMA Read Channel Function Number Register.
  */

typedef union {
  struct {
    uint32_t PF : 5;
    ///< DMA Channel Physical Function Number.  DMA channel wide physical function
    ///< of the generated TLP. The controller uses this field to form the requester
    ///< ID for requests. Function numbering starts at '0'. When you have enabled
    ///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
    ///< behavior is undefined if any value outside of the valid range is set
    ///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
    ///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
    ///< The access attributes of this field are as follows:  - Wire: R/W
    ///< - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_func_num_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_RD_MASK (0x0000001fU)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_WR_MASK (0x0000001fU)


///< DMA Channel Physical Function Number.  DMA channel wide physical function
///< of the generated TLP. The controller uses this field to form the requester
///< ID for requests. Function numbering starts at '0'. When you have enabled
///< SR-IOV, refer to VF and VF_EN fields of this register as well. The
///< behavior is undefined if any value outside of the valid range is set
///< to this field.  At the signal interfaces, DMA drives the XADM / RADM
///< signals d_client[0|1]_tlp_func_num / d_radm_trgt1_func_num.   Note:
///< The access attributes of this field are as follows:  - Wire: R/W
///< - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_PF_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_PF_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_PF_BF_MSK (0x0000001F)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_PF_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_QOS_OFF_RDCH_1 register description at address offset 0x38033c
  *
  * Register default value:        0x00030008
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_QOS_OFF_RDCH_1
  * HDMA Read Channel QoS Settings Register.
  */

typedef union {
  struct {
    uint32_t TC : 3;
    ///< Traffic Class TLP Header Field (TC). The HDMA read channel uses this
    ///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t WEIGHT : 5;
    ///< Reserved.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t PF_DEPTH : 10;
    ///< This field controls the linked list prefetch allocation space for
    ///< an HDMA read channel. Each read channel stores PF_DEPTH plus '1' linked
    ///< list elements. For example, if PF_DEPTH =0, the read channel stores
    ///< one linked list element. This field must be within the range: [ 0
    ///< : floor(CX_DMA_RD_LLQ * CC_NUM_DMA_RD_CHAN / number_of_active_channels)
    ///< - 1 ].  Note:  - If this field is set to a value outside the specified
    ///< range, data corruption or channel crosstalk may happen.  - If PF_DEPTH
    ///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
    ///< - 1 ] can be doorbelled.  - This field cannot be changed while any
    ///< read engine channel is in doorbell state. Doing so might yield undefined
    ///< results.   Note: The access attributes of this field are as follows:
    ///< - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="16" ResetValue="0x3"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_qos_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_DEFAULT (0x00030008U)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_RD_MASK (0x03ff00ffU)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_WR_MASK (0x03ff00ffU)


///< Traffic Class TLP Header Field (TC). The HDMA read channel uses this
///< TLP header field when generating MRd/MWr/IMWr TLPs.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_TC_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_TC_BF_WID ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_TC_BF_MSK (0x00000007)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_TC_BF_DEF (0x00000000)

///< Reserved.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_WEIGHT_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_WEIGHT_BF_WID ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_WEIGHT_BF_MSK (0x000000F8)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_WEIGHT_BF_DEF (0x00000008)

///< This field controls the linked list prefetch allocation space for
///< an HDMA read channel. Each read channel stores PF_DEPTH plus '1' linked
///< list elements. For example, if PF_DEPTH =0, the read channel stores
///< one linked list element. This field must be within the range: [ 0
///< : floor(CX_DMA_RD_LLQ * CC_NUM_DMA_RD_CHAN / number_of_active_channels)
///< - 1 ].  Note:  - If this field is set to a value outside the specified
///< range, data corruption or channel crosstalk may happen.  - If PF_DEPTH
///< is changed at run time, only channels in the range: [ 0 : number_of_active_channels
///< - 1 ] can be doorbelled.  - This field cannot be changed while any
///< read engine channel is in doorbell state. Doing so might yield undefined
///< results.   Note: The access attributes of this field are as follows:
///< - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_PF_DEPTH_BF_OFF (16)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_PF_DEPTH_BF_WID (10)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_PF_DEPTH_BF_MSK (0x03FF0000)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_PF_DEPTH_BF_DEF (0x00030000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_STATUS_OFF_RDCH_1 register description at address offset 0x380380
  *
  * Register default value:        0x00000003
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_STATUS_OFF_RDCH_1
  * HDMA Read Channel Status Register.
  */

typedef union {
  struct {
    uint32_t STATUS : 2;
    ///< HDMA Read Channel Status.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x3"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_stat_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_DEFAULT (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_RD_MASK (0x00000003U)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_WR_MASK (0x00000000U)


///< HDMA Read Channel Status.
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_STAT_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_STAT_BF_WID ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_STAT_BF_MSK (0x00000003)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_STAT_BF_DEF (0x00000003)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_STATUS_OFF_RDCH_1 register description at address offset 0x380384
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_STATUS_OFF_RDCH_1
  * HDMA Read Channel Interrupt Status Register.
  */

typedef union {
  struct {
    uint32_t STOP : 1;
    ///< HDMA Read Channel Stop Interrupt Status. STOP and ABORT register fields
    ///< are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK : 1;
    ///< HDMA Read Channel Watermark Interrupt Status.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT : 1;
    ///< HDMA Read Channel Abort Interrupt Status. ABORT and STOP register
    ///< fields are mutually exclusive.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t ERROR : 4;
    ///< HDMA Read Channel Error Interrupt Status. Specifies the error that
    ///< caused the HDMA to change HDMA_STATUS_OFF_RDCH_i.STATUS to ABORTED
    ///< state.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_stat_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_WR_MASK (0x00000000U)


///< HDMA Read Channel Stop Interrupt Status. STOP and ABORT register fields
///< are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_STOP_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_STOP_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_STOP_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_STOP_BF_DEF (0x00000000)

///< HDMA Read Channel Watermark Interrupt Status.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_WATERMARK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_WATERMARK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_WATERMARK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_WATERMARK_BF_DEF (0x00000000)

///< HDMA Read Channel Abort Interrupt Status. ABORT and STOP register
///< fields are mutually exclusive.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ABORT_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ABORT_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ABORT_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ABORT_BF_DEF (0x00000000)

///< HDMA Read Channel Error Interrupt Status. Specifies the error that
///< caused the HDMA to change HDMA_STATUS_OFF_RDCH_i.STATUS to ABORTED
///< state.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ERR_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ERR_BF_WID ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ERR_BF_MSK (0x00000078)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ERR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1 register description at address offset 0x380388
  *
  * Register default value:        0x00000007
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_SETUP_OFF_RDCH_1
  * HDMA Read Channel Interrupt Setup Register.
  */

typedef union {
  struct {
    uint32_t STOP_MASK : 1;
    ///< HDMA Read Channel Stop Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t WATERMARK_MASK : 1;
    ///< HDMA Read Channel Watermark Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t ABORT_MASK : 1;
    ///< HDMA Read Channel Abort Interrupt Mask.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t RSIE : 1;
    ///< HDMA Read Channel Remote Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LSIE : 1;
    ///< HDMA Read Channel Local Stop Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t RAIE : 1;
    ///< HDMA Read Channel Remote Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t LAIE : 1;
    ///< HDMA Read Channel Local Abort Interrupt Enable.   Note: The access
    ///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_setup_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_DEFAULT (0x00000007U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RD_MASK (0x0000007fU)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_WR_MASK (0x0000007fU)


///< HDMA Read Channel Stop Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_STOP_MASK_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_STOP_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_STOP_MASK_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_STOP_MASK_BF_DEF (0x00000001)

///< HDMA Read Channel Watermark Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_WATERMARK_MASK_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_WATERMARK_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_WATERMARK_MASK_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_WATERMARK_MASK_BF_DEF (0x00000002)

///< HDMA Read Channel Abort Interrupt Mask.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_ABORT_MASK_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_ABORT_MASK_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_ABORT_MASK_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_ABORT_MASK_BF_DEF (0x00000004)

///< HDMA Read Channel Remote Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RSIE_BF_OFF ( 3)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RSIE_BF_MSK (0x00000008)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RSIE_BF_DEF (0x00000000)

///< HDMA Read Channel Local Stop Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LSIE_BF_OFF ( 4)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LSIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LSIE_BF_MSK (0x00000010)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LSIE_BF_DEF (0x00000000)

///< HDMA Read Channel Remote Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RAIE_BF_OFF ( 5)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RAIE_BF_MSK (0x00000020)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_RAIE_BF_DEF (0x00000000)

///< HDMA Read Channel Local Abort Interrupt Enable.   Note: The access
///< attributes of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LAIE_BF_OFF ( 6)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LAIE_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LAIE_BF_MSK (0x00000040)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_LAIE_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_INT_CLEAR_OFF_RDCH_1 register description at address offset 0x38038c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_INT_CLEAR_OFF_RDCH_1
  * HDMA Read Channel Interrupt Clear Register.
  */

typedef union {
  struct {
    uint32_t STOP_CLEAR : 1;
    ///< HDMA Read Channel Stop Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="0" ResetValue="0x0"
    uint32_t WATERMARK_CLEAR : 1;
    ///< HDMA Read Channel Watermark Interrupt Clear.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint32_t ABORT_CLEAR : 1;
    ///< HDMA Abort Channel Abort Interrupt Clear. Setting this field clears
    ///< the ABORT and ERROR fields.
    ///< AccessType="WS/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_int_clr_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_RD_MASK (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_WR_MASK (0x00000007U)


///< HDMA Read Channel Stop Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_STOP_CLR_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_STOP_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_STOP_CLR_BF_MSK (0x00000001)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_STOP_CLR_BF_DEF (0x00000000)

///< HDMA Read Channel Watermark Interrupt Clear.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_WATERMARK_CLR_BF_OFF ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_WATERMARK_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_WATERMARK_CLR_BF_MSK (0x00000002)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_WATERMARK_CLR_BF_DEF (0x00000000)

///< HDMA Abort Channel Abort Interrupt Clear. Setting this field clears
///< the ABORT and ERROR fields.
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_ABORT_CLR_BF_OFF ( 2)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_ABORT_CLR_BF_WID ( 1)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_ABORT_CLR_BF_MSK (0x00000004)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_ABORT_CLR_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1 register description at address offset 0x380390
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_LOW_OFF_RDCH_1
  * HDMA Read Stop Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_low_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Stop Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_MSI_STOP_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_MSI_STOP_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_MSI_STOP_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_MSI_STOP_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1 register description at address offset 0x380394
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_STOP_HIGH_OFF_RDCH_1
  * HDMA Read Stop Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_STOP_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_stop_high_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Stop Interrupt MWr TLP.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_MSI_STOP_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_MSI_STOP_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_MSI_STOP_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_MSI_STOP_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1 register description at address offset 0x380398
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1
  * HDMA Read Watermark Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
    ///< address must be dword aligned.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Watermark Interrupt MWr TLP. Bits [1:0] must be '00' as this
///< address must be dword aligned.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_MSI_WATERMARK_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_MSI_WATERMARK_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_MSI_WATERMARK_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_MSI_WATERMARK_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1 register description at address offset 0x38039c
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1
  * HDMA Read Watermark Remote Interrupt Address High Register.
  */

typedef union {
  struct {
    uint32_t MSI_WATERMARK_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
    ///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Watermark Interrupt MWr TLP.   Note: The access attributes
///< of this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_MSI_WATERMARK_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_MSI_WATERMARK_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_MSI_WATERMARK_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_MSI_WATERMARK_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1 register description at address offset 0x3803a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_LOW_OFF_RDCH_1
  * HDMA Read Abort Remote Interrupt Address Low Register.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_LOW : 32;
    ///< The HDMA uses this field to generate bits [31:0] of the address field
    ///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
    ///< must be dword aligned.   Note: The access attributes of this field
    ///< are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_low_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [31:0] of the address field
///< for the Abort Interrupt MWr TLP. Bits [1:0] must be '00' as this address
///< must be dword aligned.   Note: The access attributes of this field
///< are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_MSI_ABORT_ADDR_LOW_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_MSI_ABORT_ADDR_LOW_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_MSI_ABORT_ADDR_LOW_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_MSI_ABORT_ADDR_LOW_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1 register description at address offset 0x3803a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_ABORT_HIGH_OFF_RDCH_1
  * HDMA Read Abort Remote Interrupt Address High.
  */

typedef union {
  struct {
    uint32_t MSI_ABORT_ADDR_HIGH : 32;
    ///< The HDMA uses this field to generate bits [63:32] of the address field
    ///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
    ///< this field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_abort_high_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_RD_MASK (0xffffffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_WR_MASK (0xffffffffU)


///< The HDMA uses this field to generate bits [63:32] of the address field
///< for the Abort Interrupt MWr TLP.   Note: The access attributes of
///< this field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_MSI_ABORT_ADDR_HIGH_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_MSI_ABORT_ADDR_HIGH_BF_WID (32)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_MSI_ABORT_ADDR_HIGH_BF_MSK (0xFFFFFFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_MSI_ABORT_ADDR_HIGH_BF_DEF (0x00000000)


/** @brief ABC_DWC_PCIE_CTL_DBI_SLAVE_DWC_PCIE_USP_PF0_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1 register description at address offset 0x3803a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: abc_DWC_pcie_ctl/DWC_PCIE_USP/PF0_HDMA_CAP/HDMA_MSI_MSGD_OFF_RDCH_1
  * HDMA Read Channel Remote Interrupt Data Register.
  */

typedef union {
  struct {
    uint32_t MSI_MESSAGE : 16;
    ///< The HDMA read channel uses this field to generate the data field for
    ///< every IMWr TLPs it generates.   Note: The access attributes of this
    ///< field are as follows:  - Wire: R/W   - Dbi: R/W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pcie_ctl_hdma_cap_hdma_msi_msgd_off_rdch_1_reg_t;

#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_DEFAULT (0x00000000U)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_RD_MASK (0x0000ffffU)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_WR_MASK (0x0000ffffU)


///< The HDMA read channel uses this field to generate the data field for
///< every IMWr TLPs it generates.   Note: The access attributes of this
///< field are as follows:  - Wire: R/W   - Dbi: R/W
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_MSI_MSG_BF_OFF ( 0)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_MSI_MSG_BF_WID (16)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_MSI_MSG_BF_MSK (0x0000FFFF)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_MSI_MSG_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_REG ((pcie_ctl_type0_hdr_device_id_vendor_id_reg_t*) PCIE_CTL_TYPE0_HDR_DEVICE_ID_VENDOR_ID_ADR)
#define PCIE_CTL_TYPE0_HDR_STAT_CMD_REG ((pcie_ctl_type0_hdr_stat_cmd_reg_t*) PCIE_CTL_TYPE0_HDR_STAT_CMD_ADR)
#define PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_REG ((pcie_ctl_type0_hdr_class_code_revision_id_reg_t*) PCIE_CTL_TYPE0_HDR_CLASS_CODE_REVISION_ID_ADR)
#define PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG ((pcie_ctl_type0_hdr_bist_header_type_latency_cache_line_size_reg_t*) PCIE_CTL_TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_ADR)
#define PCIE_CTL_TYPE0_HDR_BAR0_REG ((pcie_ctl_type0_hdr_bar0_reg_t*) PCIE_CTL_TYPE0_HDR_BAR0_ADR)
#define PCIE_CTL_TYPE0_HDR_BAR1_REG ((pcie_ctl_type0_hdr_bar1_reg_t*) PCIE_CTL_TYPE0_HDR_BAR1_ADR)
#define PCIE_CTL_TYPE0_HDR_BAR2_REG ((pcie_ctl_type0_hdr_bar2_reg_t*) PCIE_CTL_TYPE0_HDR_BAR2_ADR)
#define PCIE_CTL_TYPE0_HDR_BAR3_REG ((pcie_ctl_type0_hdr_bar3_reg_t*) PCIE_CTL_TYPE0_HDR_BAR3_ADR)
#define PCIE_CTL_TYPE0_HDR_BAR4_REG ((pcie_ctl_type0_hdr_bar4_reg_t*) PCIE_CTL_TYPE0_HDR_BAR4_ADR)
#define PCIE_CTL_TYPE0_HDR_BAR5_REG ((pcie_ctl_type0_hdr_bar5_reg_t*) PCIE_CTL_TYPE0_HDR_BAR5_ADR)
#define PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_REG ((pcie_ctl_type0_hdr_cardbus_cis_ptr_reg_t*) PCIE_CTL_TYPE0_HDR_CARDBUS_CIS_PTR_ADR)
#define PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_REG ((pcie_ctl_type0_hdr_subsys_id_subsys_vendor_id_reg_t*) PCIE_CTL_TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID_ADR)
#define PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_REG ((pcie_ctl_type0_hdr_exp_rom_base_addr_reg_t*) PCIE_CTL_TYPE0_HDR_EXP_ROM_BASE_ADDR_ADR)
#define PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_REG ((pcie_ctl_type0_hdr_pci_cap_ptr_reg_t*) PCIE_CTL_TYPE0_HDR_PCI_CAP_PTR_ADR)
#define PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_REG ((pcie_ctl_type0_hdr_max_latency_min_grant_intr_pin_intr_line_reg_t*) PCIE_CTL_TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE_ADR)
#define PCIE_CTL_PM_CAP_ID_NXT_PTR_REG ((pcie_ctl_pm_cap_id_nxt_ptr_reg_t*) PCIE_CTL_PM_CAP_ID_NXT_PTR_ADR)
#define PCIE_CTL_PM_CAP_CON_STAT_REG ((pcie_ctl_pm_cap_con_stat_reg_t*) PCIE_CTL_PM_CAP_CON_STAT_ADR)
#define PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_REG ((pcie_ctl_msi_cap_pci_msi_cap_id_next_ctrl_reg_t*) PCIE_CTL_MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL_ADR)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_REG ((pcie_ctl_msi_cap_msi_cap_off_04h_reg_t*) PCIE_CTL_MSI_CAP_MSI_CAP_OFF_04H_ADR)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_REG ((pcie_ctl_msi_cap_msi_cap_off_08h_reg_t*) PCIE_CTL_MSI_CAP_MSI_CAP_OFF_08H_ADR)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_REG ((pcie_ctl_msi_cap_msi_cap_off_0ch_reg_t*) PCIE_CTL_MSI_CAP_MSI_CAP_OFF_0CH_ADR)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_REG ((pcie_ctl_msi_cap_msi_cap_off_10h_reg_t*) PCIE_CTL_MSI_CAP_MSI_CAP_OFF_10H_ADR)
#define PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_REG ((pcie_ctl_msi_cap_msi_cap_off_14h_reg_t*) PCIE_CTL_MSI_CAP_MSI_CAP_OFF_14H_ADR)
#define PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG ((pcie_ctl_pcie_cap_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_t*) PCIE_CTL_PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_ADR)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_REG ((pcie_ctl_pcie_cap_device_capabilities_reg_t*) PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES_ADR)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_REG ((pcie_ctl_pcie_cap_device_ctrl_device_stat_reg_t*) PCIE_CTL_PCIE_CAP_DEVICE_CTRL_DEVICE_STAT_ADR)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_REG ((pcie_ctl_pcie_cap_link_capabilities_reg_t*) PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES_ADR)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_REG ((pcie_ctl_pcie_cap_link_ctrl_link_stat_reg_t*) PCIE_CTL_PCIE_CAP_LINK_CTRL_LINK_STAT_ADR)
#define PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_REG ((pcie_ctl_pcie_cap_device_capabilities2_reg_t*) PCIE_CTL_PCIE_CAP_DEVICE_CAPABILITIES2_ADR)
#define PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_REG ((pcie_ctl_pcie_cap_device_ctrl2_device_stat2_reg_t*) PCIE_CTL_PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2_ADR)
#define PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_REG ((pcie_ctl_pcie_cap_link_capabilities2_reg_t*) PCIE_CTL_PCIE_CAP_LINK_CAPABILITIES2_ADR)
#define PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_REG ((pcie_ctl_pcie_cap_link_ctrl2_link_stat2_reg_t*) PCIE_CTL_PCIE_CAP_LINK_CTRL2_LINK_STAT2_ADR)
#define PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_REG ((pcie_ctl_msix_cap_pci_msix_cap_id_next_ctrl_reg_t*) PCIE_CTL_MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL_ADR)
#define PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_REG ((pcie_ctl_msix_cap_msix_tbl_offset_reg_t*) PCIE_CTL_MSIX_CAP_MSIX_TBL_OFFSET_ADR)
#define PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_REG ((pcie_ctl_msix_cap_msix_pba_offset_reg_t*) PCIE_CTL_MSIX_CAP_MSIX_PBA_OFFSET_ADR)
#define PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_REG ((pcie_ctl_aer_cap_aer_ext_cap_hdr_off_reg_t*) PCIE_CTL_AER_CAP_AER_EXT_CAP_HDR_OFF_ADR)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_REG ((pcie_ctl_aer_cap_uncorr_err_stat_off_reg_t*) PCIE_CTL_AER_CAP_UNCORR_ERR_STAT_OFF_ADR)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_REG ((pcie_ctl_aer_cap_uncorr_err_mask_off_reg_t*) PCIE_CTL_AER_CAP_UNCORR_ERR_MASK_OFF_ADR)
#define PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_REG ((pcie_ctl_aer_cap_uncorr_err_sev_off_reg_t*) PCIE_CTL_AER_CAP_UNCORR_ERR_SEV_OFF_ADR)
#define PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_REG ((pcie_ctl_aer_cap_corr_err_stat_off_reg_t*) PCIE_CTL_AER_CAP_CORR_ERR_STAT_OFF_ADR)
#define PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_REG ((pcie_ctl_aer_cap_corr_err_mask_off_reg_t*) PCIE_CTL_AER_CAP_CORR_ERR_MASK_OFF_ADR)
#define PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_REG ((pcie_ctl_aer_cap_adv_err_cap_ctrl_off_reg_t*) PCIE_CTL_AER_CAP_ADV_ERR_CAP_CTRL_OFF_ADR)
#define PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_REG ((pcie_ctl_aer_cap_hdr_log_0_off_reg_t*) PCIE_CTL_AER_CAP_HDR_LOG_0_OFF_ADR)
#define PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_REG ((pcie_ctl_aer_cap_hdr_log_1_off_reg_t*) PCIE_CTL_AER_CAP_HDR_LOG_1_OFF_ADR)
#define PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_REG ((pcie_ctl_aer_cap_hdr_log_2_off_reg_t*) PCIE_CTL_AER_CAP_HDR_LOG_2_OFF_ADR)
#define PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_REG ((pcie_ctl_aer_cap_hdr_log_3_off_reg_t*) PCIE_CTL_AER_CAP_HDR_LOG_3_OFF_ADR)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_REG ((pcie_ctl_aer_cap_tlp_prefix_log_1_off_reg_t*) PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_1_OFF_ADR)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_REG ((pcie_ctl_aer_cap_tlp_prefix_log_2_off_reg_t*) PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_2_OFF_ADR)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_REG ((pcie_ctl_aer_cap_tlp_prefix_log_3_off_reg_t*) PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_3_OFF_ADR)
#define PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_REG ((pcie_ctl_aer_cap_tlp_prefix_log_4_off_reg_t*) PCIE_CTL_AER_CAP_TLP_PREFIX_LOG_4_OFF_ADR)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_REG ((pcie_ctl_spcie_cap_spcie_cap_header_reg_t*) PCIE_CTL_SPCIE_CAP_SPCIE_CAP_HEADER_ADR)
#define PCIE_CTL_SPCIE_CAP_LINK_CTRL3_REG ((pcie_ctl_spcie_cap_link_ctrl3_reg_t*) PCIE_CTL_SPCIE_CAP_LINK_CTRL3_ADR)
#define PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_REG ((pcie_ctl_spcie_cap_lane_err_stat_reg_t*) PCIE_CTL_SPCIE_CAP_LANE_ERR_STAT_ADR)
#define PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_REG ((pcie_ctl_spcie_cap_spcie_cap_off_0ch_reg_t*) PCIE_CTL_SPCIE_CAP_SPCIE_CAP_OFF_0CH_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_REG ((pcie_ctl_pl16g_cap_pl16g_ext_cap_hdr_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_EXT_CAP_HDR_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_REG ((pcie_ctl_pl16g_cap_pl16g_capability_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_CAPABILITY_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_CTRL_REG ((pcie_ctl_pl16g_cap_pl16g_ctrl_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_CTRL_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_STAT_REG ((pcie_ctl_pl16g_cap_pl16g_stat_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_STAT_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_REG ((pcie_ctl_pl16g_cap_pl16g_lc_dpar_stat_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_LC_DPAR_STAT_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_REG ((pcie_ctl_pl16g_cap_pl16g_first_retimer_dpar_stat_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_REG ((pcie_ctl_pl16g_cap_pl16g_second_retimer_dpar_stat_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT_ADR)
#define PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_REG ((pcie_ctl_pl16g_cap_pl16g_cap_off_20h_reg_t*) PCIE_CTL_PL16G_CAP_PL16G_CAP_OFF_20H_ADR)
#define PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_REG ((pcie_ctl_margin_cap_margin_ext_cap_hdr_reg_t*) PCIE_CTL_MARGIN_CAP_MARGIN_EXT_CAP_HDR_ADR)
#define PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_REG ((pcie_ctl_margin_cap_margin_port_capabilities_stat_reg_t*) PCIE_CTL_MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT_ADR)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_REG ((pcie_ctl_margin_cap_margin_lane_cntrl_stat0_reg_t*) PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0_ADR)
#define PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_REG ((pcie_ctl_margin_cap_margin_lane_cntrl_stat1_reg_t*) PCIE_CTL_MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_REG ((pcie_ctl_pl32g_cap_pl32g_ext_cap_hdr_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_EXT_CAP_HDR_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_REG ((pcie_ctl_pl32g_cap_pl32g_capability_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_CAPABILITY_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_CTRL_REG ((pcie_ctl_pl32g_cap_pl32g_ctrl_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_CTRL_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_STAT_REG ((pcie_ctl_pl32g_cap_pl32g_stat_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_STAT_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_REG ((pcie_ctl_pl32g_cap_pl32g_rcvd_mod_ts_data1_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_REG ((pcie_ctl_pl32g_cap_pl32g_rcvd_mod_ts_data2_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_REG ((pcie_ctl_pl32g_cap_pl32g_tx_mod_ts_data1_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA1_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_REG ((pcie_ctl_pl32g_cap_pl32g_tx_mod_ts_data2_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_TX_MOD_TS_DATA2_ADR)
#define PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_REG ((pcie_ctl_pl32g_cap_pl32g_cap_off_20h_reg_t*) PCIE_CTL_PL32G_CAP_PL32G_CAP_OFF_20H_ADR)
#define PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_REG ((pcie_ctl_ras_des_cap_ras_des_cap_header_reg_t*) PCIE_CTL_RAS_DES_CAP_RAS_DES_CAP_HEADER_ADR)
#define PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_REG ((pcie_ctl_ras_des_cap_vendor_specific_header_reg_t*) PCIE_CTL_RAS_DES_CAP_VENDOR_SPECIFIC_HEADER_ADR)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_REG ((pcie_ctl_ras_des_cap_event_cnter_ctrl_reg_t*) PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_CTRL_ADR)
#define PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_REG ((pcie_ctl_ras_des_cap_event_cnter_data_reg_t*) PCIE_CTL_RAS_DES_CAP_EVENT_CNTER_DATA_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ_EN_REG ((pcie_ctl_ras_des_cap_einj_en_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ_EN_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_REG ((pcie_ctl_ras_des_cap_einj0_crc_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ0_CRC_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_REG ((pcie_ctl_ras_des_cap_einj1_seqnum_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ1_SEQNUM_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_REG ((pcie_ctl_ras_des_cap_einj2_dllp_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ2_DLLP_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_REG ((pcie_ctl_ras_des_cap_einj3_symbol_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ3_SYMBOL_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ4_FC_REG ((pcie_ctl_ras_des_cap_einj4_fc_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ4_FC_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_REG ((pcie_ctl_ras_des_cap_einj5_sp_tlp_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ5_SP_TLP_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_REG ((pcie_ctl_ras_des_cap_einj6_cmp_point_h0_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H0_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_REG ((pcie_ctl_ras_des_cap_einj6_cmp_point_h1_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H1_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_REG ((pcie_ctl_ras_des_cap_einj6_cmp_point_h2_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H2_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_REG ((pcie_ctl_ras_des_cap_einj6_cmp_point_h3_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_POINT_H3_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_REG ((pcie_ctl_ras_des_cap_einj6_cmp_val_h0_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H0_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_REG ((pcie_ctl_ras_des_cap_einj6_cmp_val_h1_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H1_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_REG ((pcie_ctl_ras_des_cap_einj6_cmp_val_h2_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H2_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_REG ((pcie_ctl_ras_des_cap_einj6_cmp_val_h3_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CMP_VAL_H3_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_REG ((pcie_ctl_ras_des_cap_einj6_change_point_h0_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H0_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_REG ((pcie_ctl_ras_des_cap_einj6_change_point_h1_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H1_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_REG ((pcie_ctl_ras_des_cap_einj6_change_point_h2_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H2_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_REG ((pcie_ctl_ras_des_cap_einj6_change_point_h3_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_POINT_H3_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_REG ((pcie_ctl_ras_des_cap_einj6_change_val_h0_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H0_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_REG ((pcie_ctl_ras_des_cap_einj6_change_val_h1_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H1_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_REG ((pcie_ctl_ras_des_cap_einj6_change_val_h2_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H2_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_REG ((pcie_ctl_ras_des_cap_einj6_change_val_h3_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_CHANGE_VAL_H3_ADR)
#define PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_REG ((pcie_ctl_ras_des_cap_einj6_tlp_reg_t*) PCIE_CTL_RAS_DES_CAP_EINJ6_TLP_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL1_REG ((pcie_ctl_ras_des_cap_sd_ctrl1_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_CTRL1_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_CTRL2_REG ((pcie_ctl_ras_des_cap_sd_ctrl2_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_CTRL2_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_REG ((pcie_ctl_ras_des_cap_sd_stat_l1lane_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LANE_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_REG ((pcie_ctl_ras_des_cap_sd_stat_l1ltssm_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_STAT_L1LTSSM_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_REG ((pcie_ctl_ras_des_cap_sd_stat_pm_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_STAT_PM_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_REG ((pcie_ctl_ras_des_cap_sd_stat_l2_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_STAT_L2_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_REG ((pcie_ctl_ras_des_cap_sd_stat_l3fc_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_STAT_L3FC_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_REG ((pcie_ctl_ras_des_cap_sd_stat_l3_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_STAT_L3_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_REG ((pcie_ctl_ras_des_cap_sd_eq_ctrl1_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL1_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_REG ((pcie_ctl_ras_des_cap_sd_eq_ctrl2_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL2_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_REG ((pcie_ctl_ras_des_cap_sd_eq_ctrl3_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_EQ_CTRL3_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_REG ((pcie_ctl_ras_des_cap_sd_eq_stat1_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT1_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_REG ((pcie_ctl_ras_des_cap_sd_eq_stat2_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT2_ADR)
#define PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_REG ((pcie_ctl_ras_des_cap_sd_eq_stat3_reg_t*) PCIE_CTL_RAS_DES_CAP_SD_EQ_STAT3_ADR)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_REG ((pcie_ctl_dlink_cap_data_link_feature_ext_hdr_off_reg_t*) PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF_ADR)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_REG ((pcie_ctl_dlink_cap_data_link_feature_cap_off_reg_t*) PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF_ADR)
#define PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_REG ((pcie_ctl_dlink_cap_data_link_feature_stat_off_reg_t*) PCIE_CTL_DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF_ADR)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_REG ((pcie_ctl_vsecdma_cap_vsecdma_ext_cap_hdr_off_reg_t*) PCIE_CTL_VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF_ADR)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_REG ((pcie_ctl_vsecdma_cap_vsecdma_vendor_specific_hdr_off_reg_t*) PCIE_CTL_VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADR)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_REG ((pcie_ctl_vsecdma_cap_vsecdma_device_information_off_reg_t*) PCIE_CTL_VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF_ADR)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_REG ((pcie_ctl_vsecdma_cap_vsecdma_num_chan_off_reg_t*) PCIE_CTL_VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF_ADR)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_REG ((pcie_ctl_vsecdma_cap_vsecdma_unroll_addr_offset_low_off_reg_t*) PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_ADR)
#define PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_REG ((pcie_ctl_vsecdma_cap_vsecdma_unroll_addr_offset_high_off_reg_t*) PCIE_CTL_VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_REG ((pcie_ctl_port_logic_ack_latency_timer_off_reg_t*) PCIE_CTL_PORT_LOGIC_ACK_LATENCY_TIMER_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_REG ((pcie_ctl_port_logic_vendor_spec_dllp_off_reg_t*) PCIE_CTL_PORT_LOGIC_VENDOR_SPEC_DLLP_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_REG ((pcie_ctl_port_logic_port_force_off_reg_t*) PCIE_CTL_PORT_LOGIC_PORT_FORCE_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_REG ((pcie_ctl_port_logic_ack_f_aspm_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_ACK_F_ASPM_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_REG ((pcie_ctl_port_logic_port_link_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_PORT_LINK_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_REG ((pcie_ctl_port_logic_lane_skew_off_reg_t*) PCIE_CTL_PORT_LOGIC_LANE_SKEW_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_REG ((pcie_ctl_port_logic_timer_ctrl_max_func_num_off_reg_t*) PCIE_CTL_PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_REG ((pcie_ctl_port_logic_symbol_timer_filter_1_off_reg_t*) PCIE_CTL_PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_REG ((pcie_ctl_port_logic_filter_mask_2_off_reg_t*) PCIE_CTL_PORT_LOGIC_FILTER_MASK_2_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_REG ((pcie_ctl_port_logic_pl_dbg0_off_reg_t*) PCIE_CTL_PORT_LOGIC_PL_DBG0_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_REG ((pcie_ctl_port_logic_pl_dbg1_off_reg_t*) PCIE_CTL_PORT_LOGIC_PL_DBG1_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_REG ((pcie_ctl_port_logic_tx_p_fc_credit_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_REG ((pcie_ctl_port_logic_tx_np_fc_credit_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_REG ((pcie_ctl_port_logic_tx_cpl_fc_credit_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_REG ((pcie_ctl_port_logic_que_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_QUE_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_REG ((pcie_ctl_port_logic_vc_tx_arbi_1_off_reg_t*) PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_1_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_REG ((pcie_ctl_port_logic_vc_tx_arbi_2_off_reg_t*) PCIE_CTL_PORT_LOGIC_VC_TX_ARBI_2_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_REG ((pcie_ctl_port_logic_vc0_p_rx_q_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_REG ((pcie_ctl_port_logic_vc0_np_rx_q_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_REG ((pcie_ctl_port_logic_vc0_cpl_rx_q_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_REG ((pcie_ctl_port_logic_gen2_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN2_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_REG ((pcie_ctl_port_logic_phy_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_PHY_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_REG ((pcie_ctl_port_logic_phy_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_PHY_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_REG ((pcie_ctl_port_logic_trgt_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_TRGT_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_REG ((pcie_ctl_port_logic_clk_gating_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_CLK_GATING_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_REG ((pcie_ctl_port_logic_gen3_related_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN3_RELATED_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_REG ((pcie_ctl_port_logic_gen3_eq_local_fs_lf_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_REG ((pcie_ctl_port_logic_gen3_eq_pset_coef__0_reg_t*) PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_COEF__0_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_REG ((pcie_ctl_port_logic_gen3_eq_pset_index_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_REG ((pcie_ctl_port_logic_gen3_eq_coeff_legality_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_REG ((pcie_ctl_port_logic_gen3_eq_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN3_EQ_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_REG ((pcie_ctl_port_logic_order_rule_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_ORDER_RULE_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_REG ((pcie_ctl_port_logic_pipe_loopback_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_REG ((pcie_ctl_port_logic_misc_ctrl_1_off_reg_t*) PCIE_CTL_PORT_LOGIC_MISC_CTRL_1_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_REG ((pcie_ctl_port_logic_multi_lane_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_MULTI_LANE_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_REG ((pcie_ctl_port_logic_phy_interop_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_REG ((pcie_ctl_port_logic_trgt_cpl_lut_delete_entry_off_reg_t*) PCIE_CTL_PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_REG ((pcie_ctl_port_logic_link_flush_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_LINK_FLUSH_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_REG ((pcie_ctl_port_logic_amba_err_rsp_default_off_reg_t*) PCIE_CTL_PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_REG ((pcie_ctl_port_logic_amba_link_timeout_off_reg_t*) PCIE_CTL_PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_REG ((pcie_ctl_port_logic_amba_ordering_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_AMBA_ORDERING_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_REG ((pcie_ctl_port_logic_coherency_ctrl_1_off_reg_t*) PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_1_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_REG ((pcie_ctl_port_logic_coherency_ctrl_3_off_reg_t*) PCIE_CTL_PORT_LOGIC_COHERENCY_CTRL_3_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_REG ((pcie_ctl_port_logic_axi_mstr_msg_addr_low_off_reg_t*) PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_REG ((pcie_ctl_port_logic_axi_mstr_msg_addr_high_off_reg_t*) PCIE_CTL_PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_REG ((pcie_ctl_port_logic_pcie_ver_number_off_reg_t*) PCIE_CTL_PORT_LOGIC_PCIE_VER_NUMBER_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_REG ((pcie_ctl_port_logic_pcie_ver_type_off_reg_t*) PCIE_CTL_PORT_LOGIC_PCIE_VER_TYPE_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_REG ((pcie_ctl_port_logic_msix_match_low_off_reg_t*) PCIE_CTL_PORT_LOGIC_MSIX_MATCH_LOW_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_REG ((pcie_ctl_port_logic_msix_match_high_off_reg_t*) PCIE_CTL_PORT_LOGIC_MSIX_MATCH_HIGH_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_REG ((pcie_ctl_port_logic_msix_doorbell_off_reg_t*) PCIE_CTL_PORT_LOGIC_MSIX_DOORBELL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_REG ((pcie_ctl_port_logic_msix_ram_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_MSIX_RAM_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_REG ((pcie_ctl_port_logic_pl_app_bus_dev_num_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_REG ((pcie_ctl_port_logic_pcipm_traffic_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_REG ((pcie_ctl_port_logic_aux_clk_freq_off_reg_t*) PCIE_CTL_PORT_LOGIC_AUX_CLK_FREQ_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_REG ((pcie_ctl_port_logic_pwrdown_ctrl_stat_off_reg_t*) PCIE_CTL_PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_REG ((pcie_ctl_port_logic_phy_interop_ctrl_2_off_reg_t*) PCIE_CTL_PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_REG ((pcie_ctl_port_logic_gen4_lane_margining_1_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_REG ((pcie_ctl_port_logic_gen4_lane_margining_2_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_REG ((pcie_ctl_port_logic_gen5_lane_margining_1_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_REG ((pcie_ctl_port_logic_gen5_lane_margining_2_off_reg_t*) PCIE_CTL_PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_REG ((pcie_ctl_port_logic_pipe_related_off_reg_t*) PCIE_CTL_PORT_LOGIC_PIPE_RELATED_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_REG ((pcie_ctl_port_logic_dbi_function_bank_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_UTILITY_OFF_REG ((pcie_ctl_port_logic_utility_off_reg_t*) PCIE_CTL_PORT_LOGIC_UTILITY_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_REG ((pcie_ctl_port_logic_pm_utility_off_reg_t*) PCIE_CTL_PORT_LOGIC_PM_UTILITY_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_REG ((pcie_ctl_port_logic_ide_ctrl_off_reg_t*) PCIE_CTL_PORT_LOGIC_IDE_CTRL_OFF_ADR)
#define PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_REG ((pcie_ctl_port_logic_prbs_loopback_test_off_reg_t*) PCIE_CTL_PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF_ADR)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_REG ((pcie_ctl_type0_hdr_dbi2_bar0_mask_reg_t*) PCIE_CTL_TYPE0_HDR_DBI2_BAR0_MASK_ADR)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_REG ((pcie_ctl_type0_hdr_dbi2_bar1_mask_reg_t*) PCIE_CTL_TYPE0_HDR_DBI2_BAR1_MASK_ADR)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_REG ((pcie_ctl_type0_hdr_dbi2_bar2_mask_reg_t*) PCIE_CTL_TYPE0_HDR_DBI2_BAR2_MASK_ADR)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_REG ((pcie_ctl_type0_hdr_dbi2_bar3_mask_reg_t*) PCIE_CTL_TYPE0_HDR_DBI2_BAR3_MASK_ADR)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_REG ((pcie_ctl_type0_hdr_dbi2_bar4_mask_reg_t*) PCIE_CTL_TYPE0_HDR_DBI2_BAR4_MASK_ADR)
#define PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_REG ((pcie_ctl_type0_hdr_dbi2_bar5_mask_reg_t*) PCIE_CTL_TYPE0_HDR_DBI2_BAR5_MASK_ADR)
#define PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_REG ((pcie_ctl_type0_hdr_dbi2_exp_rom_bar_mask_reg_t*) PCIE_CTL_TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK_ADR)
#define PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_REG ((pcie_ctl_pcie_cap_dbi2_shdw_link_capabilities_reg_t*) PCIE_CTL_PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_0_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_1_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_2_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_3_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_4_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_5_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_6_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_7_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_8_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_9_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_10_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_11_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_12_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_13_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_14_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_REG ((pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_15_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_16_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_16_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_16_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_16_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_16_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_16_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_17_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_17_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_17_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_17_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_17_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_17_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_18_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_18_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_18_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_18_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_18_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_18_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_19_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19_ADR)
#define PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_REG ((pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_19_reg_t*) PCIE_CTL_ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_REG ((pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_19_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19_ADR)
#define PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_REG ((pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_19_reg_t*) PCIE_CTL_ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_REG ((pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_19_reg_t*) PCIE_CTL_ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19_ADR)
#define PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_REG ((pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_19_reg_t*) PCIE_CTL_ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_en_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_doorbell_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_elem_pf_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_llp_low_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_llp_high_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_cycle_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_xfersize_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_sar_low_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_sar_high_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_dar_low_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_dar_high_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_watermark_en_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_ctrl1_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_func_num_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_qos_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_stat_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_int_stat_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_int_setup_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_int_clr_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_low_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_high_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_low_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_high_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_msgd_off_wrch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_en_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_doorbell_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_elem_pf_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_llp_low_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_llp_high_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_cycle_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_xfersize_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_sar_low_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_sar_high_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_dar_low_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_dar_high_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_watermark_en_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_ctrl1_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_func_num_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_qos_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_stat_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_int_stat_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_int_setup_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_int_clr_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_low_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_high_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_low_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_high_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_REG ((pcie_ctl_hdma_cap_hdma_msi_msgd_off_rdch_0_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_en_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_doorbell_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_elem_pf_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_llp_low_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_llp_high_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_cycle_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_xfersize_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_sar_low_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_sar_high_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_dar_low_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_dar_high_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_watermark_en_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_ctrl1_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_func_num_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_qos_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_stat_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_int_stat_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_int_setup_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_int_clr_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_low_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_high_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_low_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_high_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_msgd_off_wrch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_en_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_EN_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_doorbell_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_elem_pf_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_llp_low_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_llp_high_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_cycle_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_xfersize_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_sar_low_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_sar_high_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_dar_low_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_dar_high_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_watermark_en_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_ctrl1_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_func_num_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_qos_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_QOS_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_stat_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_STAT_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_int_stat_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_int_setup_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_int_clr_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_low_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_stop_high_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_low_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_abort_high_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1_ADR)
#define PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_REG ((pcie_ctl_hdma_cap_hdma_msi_msgd_off_rdch_1_reg_t*) PCIE_CTL_HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1_ADR)

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    pcie_ctl_type0_hdr_device_id_vendor_id_reg_t TYPE0_HDR_DEVICE_ID_VENDOR_ID; /*< Address offset = 0x0 */
    pcie_ctl_type0_hdr_stat_cmd_reg_t TYPE0_HDR_STAT_CMD; /*< Address offset = 0x4 */
    pcie_ctl_type0_hdr_class_code_revision_id_reg_t TYPE0_HDR_CLASS_CODE_REVISION_ID; /*< Address offset = 0x8 */
    pcie_ctl_type0_hdr_bist_header_type_latency_cache_line_size_reg_t TYPE0_HDR_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE; /*< Address offset = 0xc */
    pcie_ctl_type0_hdr_bar0_reg_t TYPE0_HDR_BAR0; /*< Address offset = 0x10 */
    pcie_ctl_type0_hdr_bar1_reg_t TYPE0_HDR_BAR1; /*< Address offset = 0x14 */
    pcie_ctl_type0_hdr_bar2_reg_t TYPE0_HDR_BAR2; /*< Address offset = 0x18 */
    pcie_ctl_type0_hdr_bar3_reg_t TYPE0_HDR_BAR3; /*< Address offset = 0x1c */
    pcie_ctl_type0_hdr_bar4_reg_t TYPE0_HDR_BAR4; /*< Address offset = 0x20 */
    pcie_ctl_type0_hdr_bar5_reg_t TYPE0_HDR_BAR5; /*< Address offset = 0x24 */
    pcie_ctl_type0_hdr_cardbus_cis_ptr_reg_t TYPE0_HDR_CARDBUS_CIS_PTR; /*< Address offset = 0x28 */
    pcie_ctl_type0_hdr_subsys_id_subsys_vendor_id_reg_t TYPE0_HDR_SUBSYS_ID_SUBSYS_VENDOR_ID; /*< Address offset = 0x2c */
    pcie_ctl_type0_hdr_exp_rom_base_addr_reg_t TYPE0_HDR_EXP_ROM_BASE_ADDR; /*< Address offset = 0x30 */
    pcie_ctl_type0_hdr_pci_cap_ptr_reg_t TYPE0_HDR_PCI_CAP_PTR; /*< Address offset = 0x34 */
    const uint8_t        reservedArea0 [4];   /*< Address offset = 0x38 */
    pcie_ctl_type0_hdr_max_latency_min_grant_intr_pin_intr_line_reg_t TYPE0_HDR_MAX_LATENCY_MIN_GRANT_INTR_PIN_INTR_LINE; /*< Address offset = 0x3c */
    pcie_ctl_pm_cap_id_nxt_ptr_reg_t PM_CAP_ID_NXT_PTR; /*< Address offset = 0x40 */
    pcie_ctl_pm_cap_con_stat_reg_t PM_CAP_CON_STAT; /*< Address offset = 0x44 */
    const uint8_t        reservedArea1 [8];   /*< Address offset = 0x48 */
    pcie_ctl_msi_cap_pci_msi_cap_id_next_ctrl_reg_t MSI_CAP_PCI_MSI_CAP_ID_NEXT_CTRL; /*< Address offset = 0x50 */
    pcie_ctl_msi_cap_msi_cap_off_04h_reg_t MSI_CAP_MSI_CAP_OFF_04H; /*< Address offset = 0x54 */
    pcie_ctl_msi_cap_msi_cap_off_08h_reg_t MSI_CAP_MSI_CAP_OFF_08H; /*< Address offset = 0x58 */
    pcie_ctl_msi_cap_msi_cap_off_0ch_reg_t MSI_CAP_MSI_CAP_OFF_0CH; /*< Address offset = 0x5c */
    pcie_ctl_msi_cap_msi_cap_off_10h_reg_t MSI_CAP_MSI_CAP_OFF_10H; /*< Address offset = 0x60 */
    pcie_ctl_msi_cap_msi_cap_off_14h_reg_t MSI_CAP_MSI_CAP_OFF_14H; /*< Address offset = 0x64 */
    const uint8_t        reservedArea2 [8];   /*< Address offset = 0x68 */
    pcie_ctl_pcie_cap_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_t PCIE_CAP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP; /*< Address offset = 0x70 */
    pcie_ctl_pcie_cap_device_capabilities_reg_t PCIE_CAP_DEVICE_CAPABILITIES; /*< Address offset = 0x74 */
    pcie_ctl_pcie_cap_device_ctrl_device_stat_reg_t PCIE_CAP_DEVICE_CTRL_DEVICE_STAT; /*< Address offset = 0x78 */
    pcie_ctl_pcie_cap_link_capabilities_reg_t PCIE_CAP_LINK_CAPABILITIES; /*< Address offset = 0x7c */
    pcie_ctl_pcie_cap_link_ctrl_link_stat_reg_t PCIE_CAP_LINK_CTRL_LINK_STAT; /*< Address offset = 0x80 */
    const uint8_t        reservedArea3 [16];  /*< Address offset = 0x84 */
    pcie_ctl_pcie_cap_device_capabilities2_reg_t PCIE_CAP_DEVICE_CAPABILITIES2; /*< Address offset = 0x94 */
    pcie_ctl_pcie_cap_device_ctrl2_device_stat2_reg_t PCIE_CAP_DEVICE_CTRL2_DEVICE_STAT2; /*< Address offset = 0x98 */
    pcie_ctl_pcie_cap_link_capabilities2_reg_t PCIE_CAP_LINK_CAPABILITIES2; /*< Address offset = 0x9c */
    pcie_ctl_pcie_cap_link_ctrl2_link_stat2_reg_t PCIE_CAP_LINK_CTRL2_LINK_STAT2; /*< Address offset = 0xa0 */
    const uint8_t        reservedArea4 [12];  /*< Address offset = 0xa4 */
    pcie_ctl_msix_cap_pci_msix_cap_id_next_ctrl_reg_t MSIX_CAP_PCI_MSIX_CAP_ID_NEXT_CTRL; /*< Address offset = 0xb0 */
    pcie_ctl_msix_cap_msix_tbl_offset_reg_t MSIX_CAP_MSIX_TBL_OFFSET; /*< Address offset = 0xb4 */
    pcie_ctl_msix_cap_msix_pba_offset_reg_t MSIX_CAP_MSIX_PBA_OFFSET; /*< Address offset = 0xb8 */
    const uint8_t        reservedArea5 [68];  /*< Address offset = 0xbc */
    pcie_ctl_aer_cap_aer_ext_cap_hdr_off_reg_t AER_CAP_AER_EXT_CAP_HDR_OFF; /*< Address offset = 0x100 */
    pcie_ctl_aer_cap_uncorr_err_stat_off_reg_t AER_CAP_UNCORR_ERR_STAT_OFF; /*< Address offset = 0x104 */
    pcie_ctl_aer_cap_uncorr_err_mask_off_reg_t AER_CAP_UNCORR_ERR_MASK_OFF; /*< Address offset = 0x108 */
    pcie_ctl_aer_cap_uncorr_err_sev_off_reg_t AER_CAP_UNCORR_ERR_SEV_OFF; /*< Address offset = 0x10c */
    pcie_ctl_aer_cap_corr_err_stat_off_reg_t AER_CAP_CORR_ERR_STAT_OFF; /*< Address offset = 0x110 */
    pcie_ctl_aer_cap_corr_err_mask_off_reg_t AER_CAP_CORR_ERR_MASK_OFF; /*< Address offset = 0x114 */
    pcie_ctl_aer_cap_adv_err_cap_ctrl_off_reg_t AER_CAP_ADV_ERR_CAP_CTRL_OFF; /*< Address offset = 0x118 */
    pcie_ctl_aer_cap_hdr_log_0_off_reg_t AER_CAP_HDR_LOG_0_OFF; /*< Address offset = 0x11c */
    pcie_ctl_aer_cap_hdr_log_1_off_reg_t AER_CAP_HDR_LOG_1_OFF; /*< Address offset = 0x120 */
    pcie_ctl_aer_cap_hdr_log_2_off_reg_t AER_CAP_HDR_LOG_2_OFF; /*< Address offset = 0x124 */
    pcie_ctl_aer_cap_hdr_log_3_off_reg_t AER_CAP_HDR_LOG_3_OFF; /*< Address offset = 0x128 */
    const uint8_t        reservedArea6 [12];  /*< Address offset = 0x12c */
    pcie_ctl_aer_cap_tlp_prefix_log_1_off_reg_t AER_CAP_TLP_PREFIX_LOG_1_OFF; /*< Address offset = 0x138 */
    pcie_ctl_aer_cap_tlp_prefix_log_2_off_reg_t AER_CAP_TLP_PREFIX_LOG_2_OFF; /*< Address offset = 0x13c */
    pcie_ctl_aer_cap_tlp_prefix_log_3_off_reg_t AER_CAP_TLP_PREFIX_LOG_3_OFF; /*< Address offset = 0x140 */
    pcie_ctl_aer_cap_tlp_prefix_log_4_off_reg_t AER_CAP_TLP_PREFIX_LOG_4_OFF; /*< Address offset = 0x144 */
    pcie_ctl_spcie_cap_spcie_cap_header_reg_t SPCIE_CAP_SPCIE_CAP_HEADER; /*< Address offset = 0x148 */
    pcie_ctl_spcie_cap_link_ctrl3_reg_t SPCIE_CAP_LINK_CTRL3; /*< Address offset = 0x14c */
    pcie_ctl_spcie_cap_lane_err_stat_reg_t SPCIE_CAP_LANE_ERR_STAT; /*< Address offset = 0x150 */
    pcie_ctl_spcie_cap_spcie_cap_off_0ch_reg_t SPCIE_CAP_SPCIE_CAP_OFF_0CH; /*< Address offset = 0x154 */
    pcie_ctl_pl16g_cap_pl16g_ext_cap_hdr_reg_t PL16G_CAP_PL16G_EXT_CAP_HDR; /*< Address offset = 0x158 */
    pcie_ctl_pl16g_cap_pl16g_capability_reg_t PL16G_CAP_PL16G_CAPABILITY; /*< Address offset = 0x15c */
    pcie_ctl_pl16g_cap_pl16g_ctrl_reg_t PL16G_CAP_PL16G_CTRL; /*< Address offset = 0x160 */
    pcie_ctl_pl16g_cap_pl16g_stat_reg_t PL16G_CAP_PL16G_STAT; /*< Address offset = 0x164 */
    pcie_ctl_pl16g_cap_pl16g_lc_dpar_stat_reg_t PL16G_CAP_PL16G_LC_DPAR_STAT; /*< Address offset = 0x168 */
    pcie_ctl_pl16g_cap_pl16g_first_retimer_dpar_stat_reg_t PL16G_CAP_PL16G_FIRST_RETIMER_DPAR_STAT; /*< Address offset = 0x16c */
    pcie_ctl_pl16g_cap_pl16g_second_retimer_dpar_stat_reg_t PL16G_CAP_PL16G_SECOND_RETIMER_DPAR_STAT; /*< Address offset = 0x170 */
    const uint8_t        reservedArea7 [4];   /*< Address offset = 0x174 */
    pcie_ctl_pl16g_cap_pl16g_cap_off_20h_reg_t PL16G_CAP_PL16G_CAP_OFF_20H; /*< Address offset = 0x178 */
    pcie_ctl_margin_cap_margin_ext_cap_hdr_reg_t MARGIN_CAP_MARGIN_EXT_CAP_HDR; /*< Address offset = 0x17c */
    pcie_ctl_margin_cap_margin_port_capabilities_stat_reg_t MARGIN_CAP_MARGIN_PORT_CAPABILITIES_STAT; /*< Address offset = 0x180 */
    pcie_ctl_margin_cap_margin_lane_cntrl_stat0_reg_t MARGIN_CAP_MARGIN_LANE_CNTRL_STAT0; /*< Address offset = 0x184 */
    pcie_ctl_margin_cap_margin_lane_cntrl_stat1_reg_t MARGIN_CAP_MARGIN_LANE_CNTRL_STAT1; /*< Address offset = 0x188 */
    pcie_ctl_pl32g_cap_pl32g_ext_cap_hdr_reg_t PL32G_CAP_PL32G_EXT_CAP_HDR; /*< Address offset = 0x18c */
    pcie_ctl_pl32g_cap_pl32g_capability_reg_t PL32G_CAP_PL32G_CAPABILITY; /*< Address offset = 0x190 */
    pcie_ctl_pl32g_cap_pl32g_ctrl_reg_t PL32G_CAP_PL32G_CTRL; /*< Address offset = 0x194 */
    pcie_ctl_pl32g_cap_pl32g_stat_reg_t PL32G_CAP_PL32G_STAT; /*< Address offset = 0x198 */
    pcie_ctl_pl32g_cap_pl32g_rcvd_mod_ts_data1_reg_t PL32G_CAP_PL32G_RCVD_MOD_TS_DATA1; /*< Address offset = 0x19c */
    pcie_ctl_pl32g_cap_pl32g_rcvd_mod_ts_data2_reg_t PL32G_CAP_PL32G_RCVD_MOD_TS_DATA2; /*< Address offset = 0x1a0 */
    pcie_ctl_pl32g_cap_pl32g_tx_mod_ts_data1_reg_t PL32G_CAP_PL32G_TX_MOD_TS_DATA1; /*< Address offset = 0x1a4 */
    pcie_ctl_pl32g_cap_pl32g_tx_mod_ts_data2_reg_t PL32G_CAP_PL32G_TX_MOD_TS_DATA2; /*< Address offset = 0x1a8 */
    pcie_ctl_pl32g_cap_pl32g_cap_off_20h_reg_t PL32G_CAP_PL32G_CAP_OFF_20H; /*< Address offset = 0x1ac */
    pcie_ctl_ras_des_cap_ras_des_cap_header_reg_t RAS_DES_CAP_RAS_DES_CAP_HEADER; /*< Address offset = 0x1b0 */
    pcie_ctl_ras_des_cap_vendor_specific_header_reg_t RAS_DES_CAP_VENDOR_SPECIFIC_HEADER; /*< Address offset = 0x1b4 */
    pcie_ctl_ras_des_cap_event_cnter_ctrl_reg_t RAS_DES_CAP_EVENT_CNTER_CTRL; /*< Address offset = 0x1b8 */
    pcie_ctl_ras_des_cap_event_cnter_data_reg_t RAS_DES_CAP_EVENT_CNTER_DATA; /*< Address offset = 0x1bc */
    const uint8_t        reservedArea8 [32];  /*< Address offset = 0x1c0 */
    pcie_ctl_ras_des_cap_einj_en_reg_t RAS_DES_CAP_EINJ_EN; /*< Address offset = 0x1e0 */
    pcie_ctl_ras_des_cap_einj0_crc_reg_t RAS_DES_CAP_EINJ0_CRC; /*< Address offset = 0x1e4 */
    pcie_ctl_ras_des_cap_einj1_seqnum_reg_t RAS_DES_CAP_EINJ1_SEQNUM; /*< Address offset = 0x1e8 */
    pcie_ctl_ras_des_cap_einj2_dllp_reg_t RAS_DES_CAP_EINJ2_DLLP; /*< Address offset = 0x1ec */
    pcie_ctl_ras_des_cap_einj3_symbol_reg_t RAS_DES_CAP_EINJ3_SYMBOL; /*< Address offset = 0x1f0 */
    pcie_ctl_ras_des_cap_einj4_fc_reg_t RAS_DES_CAP_EINJ4_FC; /*< Address offset = 0x1f4 */
    pcie_ctl_ras_des_cap_einj5_sp_tlp_reg_t RAS_DES_CAP_EINJ5_SP_TLP; /*< Address offset = 0x1f8 */
    pcie_ctl_ras_des_cap_einj6_cmp_point_h0_reg_t RAS_DES_CAP_EINJ6_CMP_POINT_H0; /*< Address offset = 0x1fc */
    pcie_ctl_ras_des_cap_einj6_cmp_point_h1_reg_t RAS_DES_CAP_EINJ6_CMP_POINT_H1; /*< Address offset = 0x200 */
    pcie_ctl_ras_des_cap_einj6_cmp_point_h2_reg_t RAS_DES_CAP_EINJ6_CMP_POINT_H2; /*< Address offset = 0x204 */
    pcie_ctl_ras_des_cap_einj6_cmp_point_h3_reg_t RAS_DES_CAP_EINJ6_CMP_POINT_H3; /*< Address offset = 0x208 */
    pcie_ctl_ras_des_cap_einj6_cmp_val_h0_reg_t RAS_DES_CAP_EINJ6_CMP_VAL_H0; /*< Address offset = 0x20c */
    pcie_ctl_ras_des_cap_einj6_cmp_val_h1_reg_t RAS_DES_CAP_EINJ6_CMP_VAL_H1; /*< Address offset = 0x210 */
    pcie_ctl_ras_des_cap_einj6_cmp_val_h2_reg_t RAS_DES_CAP_EINJ6_CMP_VAL_H2; /*< Address offset = 0x214 */
    pcie_ctl_ras_des_cap_einj6_cmp_val_h3_reg_t RAS_DES_CAP_EINJ6_CMP_VAL_H3; /*< Address offset = 0x218 */
    pcie_ctl_ras_des_cap_einj6_change_point_h0_reg_t RAS_DES_CAP_EINJ6_CHANGE_POINT_H0; /*< Address offset = 0x21c */
    pcie_ctl_ras_des_cap_einj6_change_point_h1_reg_t RAS_DES_CAP_EINJ6_CHANGE_POINT_H1; /*< Address offset = 0x220 */
    pcie_ctl_ras_des_cap_einj6_change_point_h2_reg_t RAS_DES_CAP_EINJ6_CHANGE_POINT_H2; /*< Address offset = 0x224 */
    pcie_ctl_ras_des_cap_einj6_change_point_h3_reg_t RAS_DES_CAP_EINJ6_CHANGE_POINT_H3; /*< Address offset = 0x228 */
    pcie_ctl_ras_des_cap_einj6_change_val_h0_reg_t RAS_DES_CAP_EINJ6_CHANGE_VAL_H0; /*< Address offset = 0x22c */
    pcie_ctl_ras_des_cap_einj6_change_val_h1_reg_t RAS_DES_CAP_EINJ6_CHANGE_VAL_H1; /*< Address offset = 0x230 */
    pcie_ctl_ras_des_cap_einj6_change_val_h2_reg_t RAS_DES_CAP_EINJ6_CHANGE_VAL_H2; /*< Address offset = 0x234 */
    pcie_ctl_ras_des_cap_einj6_change_val_h3_reg_t RAS_DES_CAP_EINJ6_CHANGE_VAL_H3; /*< Address offset = 0x238 */
    pcie_ctl_ras_des_cap_einj6_tlp_reg_t RAS_DES_CAP_EINJ6_TLP; /*< Address offset = 0x23c */
    const uint8_t        reservedArea9 [16];  /*< Address offset = 0x240 */
    pcie_ctl_ras_des_cap_sd_ctrl1_reg_t RAS_DES_CAP_SD_CTRL1; /*< Address offset = 0x250 */
    pcie_ctl_ras_des_cap_sd_ctrl2_reg_t RAS_DES_CAP_SD_CTRL2; /*< Address offset = 0x254 */
    const uint8_t        reservedArea10 [8];  /*< Address offset = 0x258 */
    pcie_ctl_ras_des_cap_sd_stat_l1lane_reg_t RAS_DES_CAP_SD_STAT_L1LANE; /*< Address offset = 0x260 */
    pcie_ctl_ras_des_cap_sd_stat_l1ltssm_reg_t RAS_DES_CAP_SD_STAT_L1LTSSM; /*< Address offset = 0x264 */
    pcie_ctl_ras_des_cap_sd_stat_pm_reg_t RAS_DES_CAP_SD_STAT_PM; /*< Address offset = 0x268 */
    pcie_ctl_ras_des_cap_sd_stat_l2_reg_t RAS_DES_CAP_SD_STAT_L2; /*< Address offset = 0x26c */
    pcie_ctl_ras_des_cap_sd_stat_l3fc_reg_t RAS_DES_CAP_SD_STAT_L3FC; /*< Address offset = 0x270 */
    pcie_ctl_ras_des_cap_sd_stat_l3_reg_t RAS_DES_CAP_SD_STAT_L3; /*< Address offset = 0x274 */
    const uint8_t        reservedArea11 [8];  /*< Address offset = 0x278 */
    pcie_ctl_ras_des_cap_sd_eq_ctrl1_reg_t RAS_DES_CAP_SD_EQ_CTRL1; /*< Address offset = 0x280 */
    pcie_ctl_ras_des_cap_sd_eq_ctrl2_reg_t RAS_DES_CAP_SD_EQ_CTRL2; /*< Address offset = 0x284 */
    pcie_ctl_ras_des_cap_sd_eq_ctrl3_reg_t RAS_DES_CAP_SD_EQ_CTRL3; /*< Address offset = 0x288 */
    const uint8_t        reservedArea12 [4];  /*< Address offset = 0x28c */
    pcie_ctl_ras_des_cap_sd_eq_stat1_reg_t RAS_DES_CAP_SD_EQ_STAT1; /*< Address offset = 0x290 */
    pcie_ctl_ras_des_cap_sd_eq_stat2_reg_t RAS_DES_CAP_SD_EQ_STAT2; /*< Address offset = 0x294 */
    pcie_ctl_ras_des_cap_sd_eq_stat3_reg_t RAS_DES_CAP_SD_EQ_STAT3; /*< Address offset = 0x298 */
    const uint8_t        reservedArea13 [20]; /*< Address offset = 0x29c */
    pcie_ctl_dlink_cap_data_link_feature_ext_hdr_off_reg_t DLINK_CAP_DATA_LINK_FEATURE_EXT_HDR_OFF; /*< Address offset = 0x2b0 */
    pcie_ctl_dlink_cap_data_link_feature_cap_off_reg_t DLINK_CAP_DATA_LINK_FEATURE_CAP_OFF; /*< Address offset = 0x2b4 */
    pcie_ctl_dlink_cap_data_link_feature_stat_off_reg_t DLINK_CAP_DATA_LINK_FEATURE_STAT_OFF; /*< Address offset = 0x2b8 */
    pcie_ctl_vsecdma_cap_vsecdma_ext_cap_hdr_off_reg_t VSECDMA_CAP_VSECDMA_EXT_CAP_HDR_OFF; /*< Address offset = 0x2bc */
    pcie_ctl_vsecdma_cap_vsecdma_vendor_specific_hdr_off_reg_t VSECDMA_CAP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF; /*< Address offset = 0x2c0 */
    pcie_ctl_vsecdma_cap_vsecdma_device_information_off_reg_t VSECDMA_CAP_VSECDMA_DEVICE_INFORMATION_OFF; /*< Address offset = 0x2c4 */
    pcie_ctl_vsecdma_cap_vsecdma_num_chan_off_reg_t VSECDMA_CAP_VSECDMA_NUM_CHAN_OFF; /*< Address offset = 0x2c8 */
    pcie_ctl_vsecdma_cap_vsecdma_unroll_addr_offset_low_off_reg_t VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF; /*< Address offset = 0x2cc */
    pcie_ctl_vsecdma_cap_vsecdma_unroll_addr_offset_high_off_reg_t VSECDMA_CAP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF; /*< Address offset = 0x2d0 */
    const uint8_t        reservedArea14 [1068]; /*< Address offset = 0x2d4 */
    pcie_ctl_port_logic_ack_latency_timer_off_reg_t PORT_LOGIC_ACK_LATENCY_TIMER_OFF; /*< Address offset = 0x700 */
    pcie_ctl_port_logic_vendor_spec_dllp_off_reg_t PORT_LOGIC_VENDOR_SPEC_DLLP_OFF; /*< Address offset = 0x704 */
    pcie_ctl_port_logic_port_force_off_reg_t PORT_LOGIC_PORT_FORCE_OFF; /*< Address offset = 0x708 */
    pcie_ctl_port_logic_ack_f_aspm_ctrl_off_reg_t PORT_LOGIC_ACK_F_ASPM_CTRL_OFF; /*< Address offset = 0x70c */
    pcie_ctl_port_logic_port_link_ctrl_off_reg_t PORT_LOGIC_PORT_LINK_CTRL_OFF; /*< Address offset = 0x710 */
    pcie_ctl_port_logic_lane_skew_off_reg_t PORT_LOGIC_LANE_SKEW_OFF; /*< Address offset = 0x714 */
    pcie_ctl_port_logic_timer_ctrl_max_func_num_off_reg_t PORT_LOGIC_TIMER_CTRL_MAX_FUNC_NUM_OFF; /*< Address offset = 0x718 */
    pcie_ctl_port_logic_symbol_timer_filter_1_off_reg_t PORT_LOGIC_SYMBOL_TIMER_FILTER_1_OFF; /*< Address offset = 0x71c */
    pcie_ctl_port_logic_filter_mask_2_off_reg_t PORT_LOGIC_FILTER_MASK_2_OFF; /*< Address offset = 0x720 */
    const uint8_t        reservedArea15 [4];  /*< Address offset = 0x724 */
    pcie_ctl_port_logic_pl_dbg0_off_reg_t PORT_LOGIC_PL_DBG0_OFF; /*< Address offset = 0x728 */
    pcie_ctl_port_logic_pl_dbg1_off_reg_t PORT_LOGIC_PL_DBG1_OFF; /*< Address offset = 0x72c */
    pcie_ctl_port_logic_tx_p_fc_credit_stat_off_reg_t PORT_LOGIC_TX_P_FC_CREDIT_STAT_OFF; /*< Address offset = 0x730 */
    pcie_ctl_port_logic_tx_np_fc_credit_stat_off_reg_t PORT_LOGIC_TX_NP_FC_CREDIT_STAT_OFF; /*< Address offset = 0x734 */
    pcie_ctl_port_logic_tx_cpl_fc_credit_stat_off_reg_t PORT_LOGIC_TX_CPL_FC_CREDIT_STAT_OFF; /*< Address offset = 0x738 */
    pcie_ctl_port_logic_que_stat_off_reg_t PORT_LOGIC_QUE_STAT_OFF; /*< Address offset = 0x73c */
    pcie_ctl_port_logic_vc_tx_arbi_1_off_reg_t PORT_LOGIC_VC_TX_ARBI_1_OFF; /*< Address offset = 0x740 */
    pcie_ctl_port_logic_vc_tx_arbi_2_off_reg_t PORT_LOGIC_VC_TX_ARBI_2_OFF; /*< Address offset = 0x744 */
    pcie_ctl_port_logic_vc0_p_rx_q_ctrl_off_reg_t PORT_LOGIC_VC0_P_RX_Q_CTRL_OFF; /*< Address offset = 0x748 */
    pcie_ctl_port_logic_vc0_np_rx_q_ctrl_off_reg_t PORT_LOGIC_VC0_NP_RX_Q_CTRL_OFF; /*< Address offset = 0x74c */
    pcie_ctl_port_logic_vc0_cpl_rx_q_ctrl_off_reg_t PORT_LOGIC_VC0_CPL_RX_Q_CTRL_OFF; /*< Address offset = 0x750 */
    const uint8_t        reservedArea16 [184]; /*< Address offset = 0x754 */
    pcie_ctl_port_logic_gen2_ctrl_off_reg_t PORT_LOGIC_GEN2_CTRL_OFF; /*< Address offset = 0x80c */
    pcie_ctl_port_logic_phy_stat_off_reg_t PORT_LOGIC_PHY_STAT_OFF; /*< Address offset = 0x810 */
    pcie_ctl_port_logic_phy_ctrl_off_reg_t PORT_LOGIC_PHY_CTRL_OFF; /*< Address offset = 0x814 */
    const uint8_t        reservedArea17 [4];  /*< Address offset = 0x818 */
    pcie_ctl_port_logic_trgt_ctrl_off_reg_t PORT_LOGIC_TRGT_CTRL_OFF; /*< Address offset = 0x81c */
    const uint8_t        reservedArea18 [108]; /*< Address offset = 0x820 */
    pcie_ctl_port_logic_clk_gating_ctrl_off_reg_t PORT_LOGIC_CLK_GATING_CTRL_OFF; /*< Address offset = 0x88c */
    pcie_ctl_port_logic_gen3_related_off_reg_t PORT_LOGIC_GEN3_RELATED_OFF; /*< Address offset = 0x890 */
    pcie_ctl_port_logic_gen3_eq_local_fs_lf_off_reg_t PORT_LOGIC_GEN3_EQ_LOCAL_FS_LF_OFF; /*< Address offset = 0x894 */
    pcie_ctl_port_logic_gen3_eq_pset_coef__0_reg_t PORT_LOGIC_GEN3_EQ_PSET_COEF__0; /*< Address offset = 0x898 */
    pcie_ctl_port_logic_gen3_eq_pset_index_off_reg_t PORT_LOGIC_GEN3_EQ_PSET_INDEX_OFF; /*< Address offset = 0x89c */
    const uint8_t        reservedArea19 [4];  /*< Address offset = 0x8a0 */
    pcie_ctl_port_logic_gen3_eq_coeff_legality_stat_off_reg_t PORT_LOGIC_GEN3_EQ_COEFF_LEGALITY_STAT_OFF; /*< Address offset = 0x8a4 */
    pcie_ctl_port_logic_gen3_eq_ctrl_off_reg_t PORT_LOGIC_GEN3_EQ_CTRL_OFF; /*< Address offset = 0x8a8 */
    const uint8_t        reservedArea20 [8];  /*< Address offset = 0x8ac */
    pcie_ctl_port_logic_order_rule_ctrl_off_reg_t PORT_LOGIC_ORDER_RULE_CTRL_OFF; /*< Address offset = 0x8b4 */
    pcie_ctl_port_logic_pipe_loopback_ctrl_off_reg_t PORT_LOGIC_PIPE_LOOPBACK_CTRL_OFF; /*< Address offset = 0x8b8 */
    pcie_ctl_port_logic_misc_ctrl_1_off_reg_t PORT_LOGIC_MISC_CTRL_1_OFF; /*< Address offset = 0x8bc */
    pcie_ctl_port_logic_multi_lane_ctrl_off_reg_t PORT_LOGIC_MULTI_LANE_CTRL_OFF; /*< Address offset = 0x8c0 */
    pcie_ctl_port_logic_phy_interop_ctrl_off_reg_t PORT_LOGIC_PHY_INTEROP_CTRL_OFF; /*< Address offset = 0x8c4 */
    pcie_ctl_port_logic_trgt_cpl_lut_delete_entry_off_reg_t PORT_LOGIC_TRGT_CPL_LUT_DELETE_ENTRY_OFF; /*< Address offset = 0x8c8 */
    pcie_ctl_port_logic_link_flush_ctrl_off_reg_t PORT_LOGIC_LINK_FLUSH_CTRL_OFF; /*< Address offset = 0x8cc */
    pcie_ctl_port_logic_amba_err_rsp_default_off_reg_t PORT_LOGIC_AMBA_ERR_RSP_DEFAULT_OFF; /*< Address offset = 0x8d0 */
    pcie_ctl_port_logic_amba_link_timeout_off_reg_t PORT_LOGIC_AMBA_LINK_TIMEOUT_OFF; /*< Address offset = 0x8d4 */
    pcie_ctl_port_logic_amba_ordering_ctrl_off_reg_t PORT_LOGIC_AMBA_ORDERING_CTRL_OFF; /*< Address offset = 0x8d8 */
    const uint8_t        reservedArea21 [4];  /*< Address offset = 0x8dc */
    pcie_ctl_port_logic_coherency_ctrl_1_off_reg_t PORT_LOGIC_COHERENCY_CTRL_1_OFF; /*< Address offset = 0x8e0 */
    const uint8_t        reservedArea22 [4];  /*< Address offset = 0x8e4 */
    pcie_ctl_port_logic_coherency_ctrl_3_off_reg_t PORT_LOGIC_COHERENCY_CTRL_3_OFF; /*< Address offset = 0x8e8 */
    const uint8_t        reservedArea23 [4];  /*< Address offset = 0x8ec */
    pcie_ctl_port_logic_axi_mstr_msg_addr_low_off_reg_t PORT_LOGIC_AXI_MSTR_MSG_ADDR_LOW_OFF; /*< Address offset = 0x8f0 */
    pcie_ctl_port_logic_axi_mstr_msg_addr_high_off_reg_t PORT_LOGIC_AXI_MSTR_MSG_ADDR_HIGH_OFF; /*< Address offset = 0x8f4 */
    pcie_ctl_port_logic_pcie_ver_number_off_reg_t PORT_LOGIC_PCIE_VER_NUMBER_OFF; /*< Address offset = 0x8f8 */
    pcie_ctl_port_logic_pcie_ver_type_off_reg_t PORT_LOGIC_PCIE_VER_TYPE_OFF; /*< Address offset = 0x8fc */
    const uint8_t        reservedArea24 [64]; /*< Address offset = 0x900 */
    pcie_ctl_port_logic_msix_match_low_off_reg_t PORT_LOGIC_MSIX_MATCH_LOW_OFF; /*< Address offset = 0x940 */
    pcie_ctl_port_logic_msix_match_high_off_reg_t PORT_LOGIC_MSIX_MATCH_HIGH_OFF; /*< Address offset = 0x944 */
    pcie_ctl_port_logic_msix_doorbell_off_reg_t PORT_LOGIC_MSIX_DOORBELL_OFF; /*< Address offset = 0x948 */
    pcie_ctl_port_logic_msix_ram_ctrl_off_reg_t PORT_LOGIC_MSIX_RAM_CTRL_OFF; /*< Address offset = 0x94c */
    const uint8_t        reservedArea25 [448]; /*< Address offset = 0x950 */
    pcie_ctl_port_logic_pl_app_bus_dev_num_stat_off_reg_t PORT_LOGIC_PL_APP_BUS_DEV_NUM_STAT_OFF; /*< Address offset = 0xb10 */
    const uint8_t        reservedArea26 [8];  /*< Address offset = 0xb14 */
    pcie_ctl_port_logic_pcipm_traffic_ctrl_off_reg_t PORT_LOGIC_PCIPM_TRAFFIC_CTRL_OFF; /*< Address offset = 0xb1c */
    const uint8_t        reservedArea27 [32]; /*< Address offset = 0xb20 */
    pcie_ctl_port_logic_aux_clk_freq_off_reg_t PORT_LOGIC_AUX_CLK_FREQ_OFF; /*< Address offset = 0xb40 */
    const uint8_t        reservedArea28 [4];  /*< Address offset = 0xb44 */
    pcie_ctl_port_logic_pwrdown_ctrl_stat_off_reg_t PORT_LOGIC_PWRDOWN_CTRL_STAT_OFF; /*< Address offset = 0xb48 */
    pcie_ctl_port_logic_phy_interop_ctrl_2_off_reg_t PORT_LOGIC_PHY_INTEROP_CTRL_2_OFF; /*< Address offset = 0xb4c */
    const uint8_t        reservedArea29 [48]; /*< Address offset = 0xb50 */
    pcie_ctl_port_logic_gen4_lane_margining_1_off_reg_t PORT_LOGIC_GEN4_LANE_MARGINING_1_OFF; /*< Address offset = 0xb80 */
    pcie_ctl_port_logic_gen4_lane_margining_2_off_reg_t PORT_LOGIC_GEN4_LANE_MARGINING_2_OFF; /*< Address offset = 0xb84 */
    pcie_ctl_port_logic_gen5_lane_margining_1_off_reg_t PORT_LOGIC_GEN5_LANE_MARGINING_1_OFF; /*< Address offset = 0xb88 */
    pcie_ctl_port_logic_gen5_lane_margining_2_off_reg_t PORT_LOGIC_GEN5_LANE_MARGINING_2_OFF; /*< Address offset = 0xb8c */
    pcie_ctl_port_logic_pipe_related_off_reg_t PORT_LOGIC_PIPE_RELATED_OFF; /*< Address offset = 0xb90 */
    const uint8_t        reservedArea30 [232]; /*< Address offset = 0xb94 */
    pcie_ctl_port_logic_dbi_function_bank_ctrl_off_reg_t PORT_LOGIC_DBI_FUNCTION_BANK_CTRL_OFF; /*< Address offset = 0xc7c */
    pcie_ctl_port_logic_utility_off_reg_t PORT_LOGIC_UTILITY_OFF; /*< Address offset = 0xc80 */
    const uint8_t        reservedArea31 [4];  /*< Address offset = 0xc84 */
    pcie_ctl_port_logic_pm_utility_off_reg_t PORT_LOGIC_PM_UTILITY_OFF; /*< Address offset = 0xc88 */
    pcie_ctl_port_logic_ide_ctrl_off_reg_t PORT_LOGIC_IDE_CTRL_OFF; /*< Address offset = 0xc8c */
    const uint8_t        reservedArea32 [28]; /*< Address offset = 0xc90 */
    pcie_ctl_port_logic_prbs_loopback_test_off_reg_t PORT_LOGIC_PRBS_LOOPBACK_TEST_OFF; /*< Address offset = 0xcac */
    const uint8_t        reservedArea33 [1045344]; /*< Address offset = 0xcb0 */
    pcie_ctl_type0_hdr_dbi2_bar0_mask_reg_t TYPE0_HDR_DBI2_BAR0_MASK; /*< Address offset = 0x100010 */
    pcie_ctl_type0_hdr_dbi2_bar1_mask_reg_t TYPE0_HDR_DBI2_BAR1_MASK; /*< Address offset = 0x100014 */
    pcie_ctl_type0_hdr_dbi2_bar2_mask_reg_t TYPE0_HDR_DBI2_BAR2_MASK; /*< Address offset = 0x100018 */
    pcie_ctl_type0_hdr_dbi2_bar3_mask_reg_t TYPE0_HDR_DBI2_BAR3_MASK; /*< Address offset = 0x10001c */
    pcie_ctl_type0_hdr_dbi2_bar4_mask_reg_t TYPE0_HDR_DBI2_BAR4_MASK; /*< Address offset = 0x100020 */
    pcie_ctl_type0_hdr_dbi2_bar5_mask_reg_t TYPE0_HDR_DBI2_BAR5_MASK; /*< Address offset = 0x100024 */
    const uint8_t        reservedArea34 [8];  /*< Address offset = 0x100028 */
    pcie_ctl_type0_hdr_dbi2_exp_rom_bar_mask_reg_t TYPE0_HDR_DBI2_EXP_ROM_BAR_MASK; /*< Address offset = 0x100030 */
    const uint8_t        reservedArea35 [72]; /*< Address offset = 0x100034 */
    pcie_ctl_pcie_cap_dbi2_shdw_link_capabilities_reg_t PCIE_CAP_DBI2_SHDW_LINK_CAPABILITIES; /*< Address offset = 0x10007c */
    const uint8_t        reservedArea36 [2097024]; /*< Address offset = 0x100080 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_0_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0; /*< Address offset = 0x300000 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_0_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0; /*< Address offset = 0x300004 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_0_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0; /*< Address offset = 0x300008 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_0_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0; /*< Address offset = 0x30000c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_0_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0; /*< Address offset = 0x300010 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_0_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0; /*< Address offset = 0x300014 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_0_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0; /*< Address offset = 0x300018 */
    const uint8_t        reservedArea37 [228]; /*< Address offset = 0x30001c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_0_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_0; /*< Address offset = 0x300100 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_0_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_0; /*< Address offset = 0x300104 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_0_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0; /*< Address offset = 0x300108 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_0_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0; /*< Address offset = 0x30010c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_0_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_0; /*< Address offset = 0x300110 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_0_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0; /*< Address offset = 0x300114 */
    const uint8_t        reservedArea38 [232]; /*< Address offset = 0x300118 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_1_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1; /*< Address offset = 0x300200 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_1_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1; /*< Address offset = 0x300204 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_1_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1; /*< Address offset = 0x300208 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_1_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1; /*< Address offset = 0x30020c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_1_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1; /*< Address offset = 0x300210 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_1_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1; /*< Address offset = 0x300214 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_1_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1; /*< Address offset = 0x300218 */
    const uint8_t        reservedArea39 [228]; /*< Address offset = 0x30021c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_1_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_1; /*< Address offset = 0x300300 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_1_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_1; /*< Address offset = 0x300304 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_1_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1; /*< Address offset = 0x300308 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_1_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1; /*< Address offset = 0x30030c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_1_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_1; /*< Address offset = 0x300310 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_1_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1; /*< Address offset = 0x300314 */
    const uint8_t        reservedArea40 [232]; /*< Address offset = 0x300318 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_2_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_2; /*< Address offset = 0x300400 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_2_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_2; /*< Address offset = 0x300404 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_2_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_2; /*< Address offset = 0x300408 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_2_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_2; /*< Address offset = 0x30040c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_2_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_2; /*< Address offset = 0x300410 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_2_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_2; /*< Address offset = 0x300414 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_2_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_2; /*< Address offset = 0x300418 */
    const uint8_t        reservedArea41 [228]; /*< Address offset = 0x30041c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_2_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_2; /*< Address offset = 0x300500 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_2_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_2; /*< Address offset = 0x300504 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_2_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_2; /*< Address offset = 0x300508 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_2_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_2; /*< Address offset = 0x30050c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_2_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_2; /*< Address offset = 0x300510 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_2_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_2; /*< Address offset = 0x300514 */
    const uint8_t        reservedArea42 [232]; /*< Address offset = 0x300518 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_3_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_3; /*< Address offset = 0x300600 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_3_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_3; /*< Address offset = 0x300604 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_3_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_3; /*< Address offset = 0x300608 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_3_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_3; /*< Address offset = 0x30060c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_3_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_3; /*< Address offset = 0x300610 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_3_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_3; /*< Address offset = 0x300614 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_3_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_3; /*< Address offset = 0x300618 */
    const uint8_t        reservedArea43 [228]; /*< Address offset = 0x30061c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_3_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_3; /*< Address offset = 0x300700 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_3_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_3; /*< Address offset = 0x300704 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_3_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_3; /*< Address offset = 0x300708 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_3_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_3; /*< Address offset = 0x30070c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_3_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_3; /*< Address offset = 0x300710 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_3_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_3; /*< Address offset = 0x300714 */
    const uint8_t        reservedArea44 [232]; /*< Address offset = 0x300718 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_4_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_4; /*< Address offset = 0x300800 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_4_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_4; /*< Address offset = 0x300804 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_4_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_4; /*< Address offset = 0x300808 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_4_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_4; /*< Address offset = 0x30080c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_4_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_4; /*< Address offset = 0x300810 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_4_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_4; /*< Address offset = 0x300814 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_4_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_4; /*< Address offset = 0x300818 */
    const uint8_t        reservedArea45 [228]; /*< Address offset = 0x30081c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_4_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_4; /*< Address offset = 0x300900 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_4_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_4; /*< Address offset = 0x300904 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_4_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_4; /*< Address offset = 0x300908 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_4_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_4; /*< Address offset = 0x30090c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_4_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_4; /*< Address offset = 0x300910 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_4_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_4; /*< Address offset = 0x300914 */
    const uint8_t        reservedArea46 [232]; /*< Address offset = 0x300918 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_5_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_5; /*< Address offset = 0x300a00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_5_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_5; /*< Address offset = 0x300a04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_5_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_5; /*< Address offset = 0x300a08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_5_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_5; /*< Address offset = 0x300a0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_5_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_5; /*< Address offset = 0x300a10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_5_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_5; /*< Address offset = 0x300a14 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_5_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_5; /*< Address offset = 0x300a18 */
    const uint8_t        reservedArea47 [228]; /*< Address offset = 0x300a1c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_5_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_5; /*< Address offset = 0x300b00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_5_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_5; /*< Address offset = 0x300b04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_5_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_5; /*< Address offset = 0x300b08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_5_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_5; /*< Address offset = 0x300b0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_5_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_5; /*< Address offset = 0x300b10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_5_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_5; /*< Address offset = 0x300b14 */
    const uint8_t        reservedArea48 [232]; /*< Address offset = 0x300b18 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_6_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_6; /*< Address offset = 0x300c00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_6_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_6; /*< Address offset = 0x300c04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_6_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_6; /*< Address offset = 0x300c08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_6_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_6; /*< Address offset = 0x300c0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_6_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_6; /*< Address offset = 0x300c10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_6_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_6; /*< Address offset = 0x300c14 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_6_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_6; /*< Address offset = 0x300c18 */
    const uint8_t        reservedArea49 [228]; /*< Address offset = 0x300c1c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_6_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_6; /*< Address offset = 0x300d00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_6_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_6; /*< Address offset = 0x300d04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_6_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_6; /*< Address offset = 0x300d08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_6_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_6; /*< Address offset = 0x300d0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_6_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_6; /*< Address offset = 0x300d10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_6_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_6; /*< Address offset = 0x300d14 */
    const uint8_t        reservedArea50 [232]; /*< Address offset = 0x300d18 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_7_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_7; /*< Address offset = 0x300e00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_7_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_7; /*< Address offset = 0x300e04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_7_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_7; /*< Address offset = 0x300e08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_7_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_7; /*< Address offset = 0x300e0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_7_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_7; /*< Address offset = 0x300e10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_7_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_7; /*< Address offset = 0x300e14 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_7_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_7; /*< Address offset = 0x300e18 */
    const uint8_t        reservedArea51 [228]; /*< Address offset = 0x300e1c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_7_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_7; /*< Address offset = 0x300f00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_7_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_7; /*< Address offset = 0x300f04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_7_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_7; /*< Address offset = 0x300f08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_7_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_7; /*< Address offset = 0x300f0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_7_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_7; /*< Address offset = 0x300f10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_7_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_7; /*< Address offset = 0x300f14 */
    const uint8_t        reservedArea52 [232]; /*< Address offset = 0x300f18 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_8_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_8; /*< Address offset = 0x301000 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_8_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_8; /*< Address offset = 0x301004 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_8_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_8; /*< Address offset = 0x301008 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_8_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_8; /*< Address offset = 0x30100c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_8_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_8; /*< Address offset = 0x301010 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_8_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_8; /*< Address offset = 0x301014 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_8_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_8; /*< Address offset = 0x301018 */
    const uint8_t        reservedArea53 [228]; /*< Address offset = 0x30101c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_8_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_8; /*< Address offset = 0x301100 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_8_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_8; /*< Address offset = 0x301104 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_8_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_8; /*< Address offset = 0x301108 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_8_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_8; /*< Address offset = 0x30110c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_8_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_8; /*< Address offset = 0x301110 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_8_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_8; /*< Address offset = 0x301114 */
    const uint8_t        reservedArea54 [232]; /*< Address offset = 0x301118 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_9_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_9; /*< Address offset = 0x301200 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_9_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_9; /*< Address offset = 0x301204 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_9_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_9; /*< Address offset = 0x301208 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_9_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_9; /*< Address offset = 0x30120c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_9_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_9; /*< Address offset = 0x301210 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_9_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_9; /*< Address offset = 0x301214 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_9_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_9; /*< Address offset = 0x301218 */
    const uint8_t        reservedArea55 [228]; /*< Address offset = 0x30121c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_9_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_9; /*< Address offset = 0x301300 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_9_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_9; /*< Address offset = 0x301304 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_9_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_9; /*< Address offset = 0x301308 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_9_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_9; /*< Address offset = 0x30130c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_9_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_9; /*< Address offset = 0x301310 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_9_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_9; /*< Address offset = 0x301314 */
    const uint8_t        reservedArea56 [232]; /*< Address offset = 0x301318 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_10_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_10; /*< Address offset = 0x301400 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_10_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_10; /*< Address offset = 0x301404 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_10_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_10; /*< Address offset = 0x301408 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_10_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_10; /*< Address offset = 0x30140c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_10_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_10; /*< Address offset = 0x301410 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_10_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_10; /*< Address offset = 0x301414 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_10_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_10; /*< Address offset = 0x301418 */
    const uint8_t        reservedArea57 [228]; /*< Address offset = 0x30141c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_10_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_10; /*< Address offset = 0x301500 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_10_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_10; /*< Address offset = 0x301504 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_10_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_10; /*< Address offset = 0x301508 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_10_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_10; /*< Address offset = 0x30150c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_10_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_10; /*< Address offset = 0x301510 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_10_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_10; /*< Address offset = 0x301514 */
    const uint8_t        reservedArea58 [232]; /*< Address offset = 0x301518 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_11_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_11; /*< Address offset = 0x301600 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_11_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_11; /*< Address offset = 0x301604 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_11_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_11; /*< Address offset = 0x301608 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_11_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_11; /*< Address offset = 0x30160c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_11_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_11; /*< Address offset = 0x301610 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_11_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_11; /*< Address offset = 0x301614 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_11_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_11; /*< Address offset = 0x301618 */
    const uint8_t        reservedArea59 [228]; /*< Address offset = 0x30161c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_11_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_11; /*< Address offset = 0x301700 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_11_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_11; /*< Address offset = 0x301704 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_11_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_11; /*< Address offset = 0x301708 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_11_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_11; /*< Address offset = 0x30170c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_11_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_11; /*< Address offset = 0x301710 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_11_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_11; /*< Address offset = 0x301714 */
    const uint8_t        reservedArea60 [232]; /*< Address offset = 0x301718 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_12_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_12; /*< Address offset = 0x301800 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_12_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_12; /*< Address offset = 0x301804 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_12_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_12; /*< Address offset = 0x301808 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_12_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_12; /*< Address offset = 0x30180c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_12_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_12; /*< Address offset = 0x301810 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_12_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_12; /*< Address offset = 0x301814 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_12_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_12; /*< Address offset = 0x301818 */
    const uint8_t        reservedArea61 [228]; /*< Address offset = 0x30181c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_12_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_12; /*< Address offset = 0x301900 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_12_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_12; /*< Address offset = 0x301904 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_12_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_12; /*< Address offset = 0x301908 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_12_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_12; /*< Address offset = 0x30190c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_12_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_12; /*< Address offset = 0x301910 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_12_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_12; /*< Address offset = 0x301914 */
    const uint8_t        reservedArea62 [232]; /*< Address offset = 0x301918 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_13_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_13; /*< Address offset = 0x301a00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_13_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_13; /*< Address offset = 0x301a04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_13_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_13; /*< Address offset = 0x301a08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_13_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_13; /*< Address offset = 0x301a0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_13_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_13; /*< Address offset = 0x301a10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_13_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_13; /*< Address offset = 0x301a14 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_13_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_13; /*< Address offset = 0x301a18 */
    const uint8_t        reservedArea63 [228]; /*< Address offset = 0x301a1c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_13_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_13; /*< Address offset = 0x301b00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_13_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_13; /*< Address offset = 0x301b04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_13_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_13; /*< Address offset = 0x301b08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_13_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_13; /*< Address offset = 0x301b0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_13_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_13; /*< Address offset = 0x301b10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_13_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_13; /*< Address offset = 0x301b14 */
    const uint8_t        reservedArea64 [232]; /*< Address offset = 0x301b18 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_14_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_14; /*< Address offset = 0x301c00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_14_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_14; /*< Address offset = 0x301c04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_14_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_14; /*< Address offset = 0x301c08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_14_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_14; /*< Address offset = 0x301c0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_14_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_14; /*< Address offset = 0x301c10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_14_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_14; /*< Address offset = 0x301c14 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_14_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_14; /*< Address offset = 0x301c18 */
    const uint8_t        reservedArea65 [228]; /*< Address offset = 0x301c1c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_14_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_14; /*< Address offset = 0x301d00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_14_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_14; /*< Address offset = 0x301d04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_14_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_14; /*< Address offset = 0x301d08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_14_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_14; /*< Address offset = 0x301d0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_14_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_14; /*< Address offset = 0x301d10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_14_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_14; /*< Address offset = 0x301d14 */
    const uint8_t        reservedArea66 [232]; /*< Address offset = 0x301d18 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_outbound_15_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_OUTBOUND_15; /*< Address offset = 0x301e00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_outbound_15_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_OUTBOUND_15; /*< Address offset = 0x301e04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_outbound_15_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_15; /*< Address offset = 0x301e08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_outbound_15_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_15; /*< Address offset = 0x301e0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_outbound_15_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_OUTBOUND_15; /*< Address offset = 0x301e10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_outbound_15_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_15; /*< Address offset = 0x301e14 */
    pcie_ctl_atu_cap_iatu_upper_target_addr_off_outbound_15_reg_t ATU_CAP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_15; /*< Address offset = 0x301e18 */
    const uint8_t        reservedArea67 [228]; /*< Address offset = 0x301e1c */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_15_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_15; /*< Address offset = 0x301f00 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_15_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_15; /*< Address offset = 0x301f04 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_15_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_15; /*< Address offset = 0x301f08 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_15_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_15; /*< Address offset = 0x301f0c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_15_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_15; /*< Address offset = 0x301f10 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_15_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_15; /*< Address offset = 0x301f14 */
    const uint8_t        reservedArea68 [488]; /*< Address offset = 0x301f18 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_16_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_16; /*< Address offset = 0x302100 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_16_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_16; /*< Address offset = 0x302104 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_16_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_16; /*< Address offset = 0x302108 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_16_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_16; /*< Address offset = 0x30210c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_16_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_16; /*< Address offset = 0x302110 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_16_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_16; /*< Address offset = 0x302114 */
    const uint8_t        reservedArea69 [488]; /*< Address offset = 0x302118 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_17_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_17; /*< Address offset = 0x302300 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_17_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_17; /*< Address offset = 0x302304 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_17_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_17; /*< Address offset = 0x302308 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_17_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_17; /*< Address offset = 0x30230c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_17_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_17; /*< Address offset = 0x302310 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_17_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_17; /*< Address offset = 0x302314 */
    const uint8_t        reservedArea70 [488]; /*< Address offset = 0x302318 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_18_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_18; /*< Address offset = 0x302500 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_18_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_18; /*< Address offset = 0x302504 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_18_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_18; /*< Address offset = 0x302508 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_18_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_18; /*< Address offset = 0x30250c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_18_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_18; /*< Address offset = 0x302510 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_18_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_18; /*< Address offset = 0x302514 */
    const uint8_t        reservedArea71 [488]; /*< Address offset = 0x302518 */
    pcie_ctl_atu_cap_iatu_region_ctrl_1_off_inbound_19_reg_t ATU_CAP_IATU_REGION_CTRL_1_OFF_INBOUND_19; /*< Address offset = 0x302700 */
    pcie_ctl_atu_cap_iatu_region_ctrl_2_off_inbound_19_reg_t ATU_CAP_IATU_REGION_CTRL_2_OFF_INBOUND_19; /*< Address offset = 0x302704 */
    pcie_ctl_atu_cap_iatu_lwr_base_addr_off_inbound_19_reg_t ATU_CAP_IATU_LWR_BASE_ADDR_OFF_INBOUND_19; /*< Address offset = 0x302708 */
    pcie_ctl_atu_cap_iatu_upper_base_addr_off_inbound_19_reg_t ATU_CAP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_19; /*< Address offset = 0x30270c */
    pcie_ctl_atu_cap_iatu_limit_addr_off_inbound_19_reg_t ATU_CAP_IATU_LIMIT_ADDR_OFF_INBOUND_19; /*< Address offset = 0x302710 */
    pcie_ctl_atu_cap_iatu_lwr_target_addr_off_inbound_19_reg_t ATU_CAP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_19; /*< Address offset = 0x302714 */
    const uint8_t        reservedArea72 [514280]; /*< Address offset = 0x302718 */
    pcie_ctl_hdma_cap_hdma_en_off_wrch_0_reg_t HDMA_CAP_HDMA_EN_OFF_WRCH_0; /*< Address offset = 0x380000 */
    pcie_ctl_hdma_cap_hdma_doorbell_off_wrch_0_reg_t HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_0; /*< Address offset = 0x380004 */
    pcie_ctl_hdma_cap_hdma_elem_pf_off_wrch_0_reg_t HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_0; /*< Address offset = 0x380008 */
    const uint8_t        reservedArea73 [4];  /*< Address offset = 0x38000c */
    pcie_ctl_hdma_cap_hdma_llp_low_off_wrch_0_reg_t HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_0; /*< Address offset = 0x380010 */
    pcie_ctl_hdma_cap_hdma_llp_high_off_wrch_0_reg_t HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_0; /*< Address offset = 0x380014 */
    pcie_ctl_hdma_cap_hdma_cycle_off_wrch_0_reg_t HDMA_CAP_HDMA_CYCLE_OFF_WRCH_0; /*< Address offset = 0x380018 */
    pcie_ctl_hdma_cap_hdma_xfersize_off_wrch_0_reg_t HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_0; /*< Address offset = 0x38001c */
    pcie_ctl_hdma_cap_hdma_sar_low_off_wrch_0_reg_t HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_0; /*< Address offset = 0x380020 */
    pcie_ctl_hdma_cap_hdma_sar_high_off_wrch_0_reg_t HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_0; /*< Address offset = 0x380024 */
    pcie_ctl_hdma_cap_hdma_dar_low_off_wrch_0_reg_t HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_0; /*< Address offset = 0x380028 */
    pcie_ctl_hdma_cap_hdma_dar_high_off_wrch_0_reg_t HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_0; /*< Address offset = 0x38002c */
    pcie_ctl_hdma_cap_hdma_watermark_en_off_wrch_0_reg_t HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_0; /*< Address offset = 0x380030 */
    pcie_ctl_hdma_cap_hdma_ctrl1_off_wrch_0_reg_t HDMA_CAP_HDMA_CTRL1_OFF_WRCH_0; /*< Address offset = 0x380034 */
    pcie_ctl_hdma_cap_hdma_func_num_off_wrch_0_reg_t HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_0; /*< Address offset = 0x380038 */
    pcie_ctl_hdma_cap_hdma_qos_off_wrch_0_reg_t HDMA_CAP_HDMA_QOS_OFF_WRCH_0; /*< Address offset = 0x38003c */
    const uint8_t        reservedArea74 [64]; /*< Address offset = 0x380040 */
    pcie_ctl_hdma_cap_hdma_stat_off_wrch_0_reg_t HDMA_CAP_HDMA_STAT_OFF_WRCH_0; /*< Address offset = 0x380080 */
    pcie_ctl_hdma_cap_hdma_int_stat_off_wrch_0_reg_t HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_0; /*< Address offset = 0x380084 */
    pcie_ctl_hdma_cap_hdma_int_setup_off_wrch_0_reg_t HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_0; /*< Address offset = 0x380088 */
    pcie_ctl_hdma_cap_hdma_int_clr_off_wrch_0_reg_t HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_0; /*< Address offset = 0x38008c */
    pcie_ctl_hdma_cap_hdma_msi_stop_low_off_wrch_0_reg_t HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_0; /*< Address offset = 0x380090 */
    pcie_ctl_hdma_cap_hdma_msi_stop_high_off_wrch_0_reg_t HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_0; /*< Address offset = 0x380094 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_wrch_0_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_0; /*< Address offset = 0x380098 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_wrch_0_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_0; /*< Address offset = 0x38009c */
    pcie_ctl_hdma_cap_hdma_msi_abort_low_off_wrch_0_reg_t HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_0; /*< Address offset = 0x3800a0 */
    pcie_ctl_hdma_cap_hdma_msi_abort_high_off_wrch_0_reg_t HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_0; /*< Address offset = 0x3800a4 */
    pcie_ctl_hdma_cap_hdma_msi_msgd_off_wrch_0_reg_t HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_0; /*< Address offset = 0x3800a8 */
    const uint8_t        reservedArea75 [84]; /*< Address offset = 0x3800ac */
    pcie_ctl_hdma_cap_hdma_en_off_rdch_0_reg_t HDMA_CAP_HDMA_EN_OFF_RDCH_0; /*< Address offset = 0x380100 */
    pcie_ctl_hdma_cap_hdma_doorbell_off_rdch_0_reg_t HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_0; /*< Address offset = 0x380104 */
    pcie_ctl_hdma_cap_hdma_elem_pf_off_rdch_0_reg_t HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_0; /*< Address offset = 0x380108 */
    const uint8_t        reservedArea76 [4];  /*< Address offset = 0x38010c */
    pcie_ctl_hdma_cap_hdma_llp_low_off_rdch_0_reg_t HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_0; /*< Address offset = 0x380110 */
    pcie_ctl_hdma_cap_hdma_llp_high_off_rdch_0_reg_t HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_0; /*< Address offset = 0x380114 */
    pcie_ctl_hdma_cap_hdma_cycle_off_rdch_0_reg_t HDMA_CAP_HDMA_CYCLE_OFF_RDCH_0; /*< Address offset = 0x380118 */
    pcie_ctl_hdma_cap_hdma_xfersize_off_rdch_0_reg_t HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_0; /*< Address offset = 0x38011c */
    pcie_ctl_hdma_cap_hdma_sar_low_off_rdch_0_reg_t HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_0; /*< Address offset = 0x380120 */
    pcie_ctl_hdma_cap_hdma_sar_high_off_rdch_0_reg_t HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_0; /*< Address offset = 0x380124 */
    pcie_ctl_hdma_cap_hdma_dar_low_off_rdch_0_reg_t HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_0; /*< Address offset = 0x380128 */
    pcie_ctl_hdma_cap_hdma_dar_high_off_rdch_0_reg_t HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_0; /*< Address offset = 0x38012c */
    pcie_ctl_hdma_cap_hdma_watermark_en_off_rdch_0_reg_t HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_0; /*< Address offset = 0x380130 */
    pcie_ctl_hdma_cap_hdma_ctrl1_off_rdch_0_reg_t HDMA_CAP_HDMA_CTRL1_OFF_RDCH_0; /*< Address offset = 0x380134 */
    pcie_ctl_hdma_cap_hdma_func_num_off_rdch_0_reg_t HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_0; /*< Address offset = 0x380138 */
    pcie_ctl_hdma_cap_hdma_qos_off_rdch_0_reg_t HDMA_CAP_HDMA_QOS_OFF_RDCH_0; /*< Address offset = 0x38013c */
    const uint8_t        reservedArea77 [64]; /*< Address offset = 0x380140 */
    pcie_ctl_hdma_cap_hdma_stat_off_rdch_0_reg_t HDMA_CAP_HDMA_STAT_OFF_RDCH_0; /*< Address offset = 0x380180 */
    pcie_ctl_hdma_cap_hdma_int_stat_off_rdch_0_reg_t HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_0; /*< Address offset = 0x380184 */
    pcie_ctl_hdma_cap_hdma_int_setup_off_rdch_0_reg_t HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_0; /*< Address offset = 0x380188 */
    pcie_ctl_hdma_cap_hdma_int_clr_off_rdch_0_reg_t HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_0; /*< Address offset = 0x38018c */
    pcie_ctl_hdma_cap_hdma_msi_stop_low_off_rdch_0_reg_t HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_0; /*< Address offset = 0x380190 */
    pcie_ctl_hdma_cap_hdma_msi_stop_high_off_rdch_0_reg_t HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_0; /*< Address offset = 0x380194 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_rdch_0_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_0; /*< Address offset = 0x380198 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_rdch_0_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_0; /*< Address offset = 0x38019c */
    pcie_ctl_hdma_cap_hdma_msi_abort_low_off_rdch_0_reg_t HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_0; /*< Address offset = 0x3801a0 */
    pcie_ctl_hdma_cap_hdma_msi_abort_high_off_rdch_0_reg_t HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_0; /*< Address offset = 0x3801a4 */
    pcie_ctl_hdma_cap_hdma_msi_msgd_off_rdch_0_reg_t HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_0; /*< Address offset = 0x3801a8 */
    const uint8_t        reservedArea78 [84]; /*< Address offset = 0x3801ac */
    pcie_ctl_hdma_cap_hdma_en_off_wrch_1_reg_t HDMA_CAP_HDMA_EN_OFF_WRCH_1; /*< Address offset = 0x380200 */
    pcie_ctl_hdma_cap_hdma_doorbell_off_wrch_1_reg_t HDMA_CAP_HDMA_DOORBELL_OFF_WRCH_1; /*< Address offset = 0x380204 */
    pcie_ctl_hdma_cap_hdma_elem_pf_off_wrch_1_reg_t HDMA_CAP_HDMA_ELEM_PF_OFF_WRCH_1; /*< Address offset = 0x380208 */
    const uint8_t        reservedArea79 [4];  /*< Address offset = 0x38020c */
    pcie_ctl_hdma_cap_hdma_llp_low_off_wrch_1_reg_t HDMA_CAP_HDMA_LLP_LOW_OFF_WRCH_1; /*< Address offset = 0x380210 */
    pcie_ctl_hdma_cap_hdma_llp_high_off_wrch_1_reg_t HDMA_CAP_HDMA_LLP_HIGH_OFF_WRCH_1; /*< Address offset = 0x380214 */
    pcie_ctl_hdma_cap_hdma_cycle_off_wrch_1_reg_t HDMA_CAP_HDMA_CYCLE_OFF_WRCH_1; /*< Address offset = 0x380218 */
    pcie_ctl_hdma_cap_hdma_xfersize_off_wrch_1_reg_t HDMA_CAP_HDMA_XFERSIZE_OFF_WRCH_1; /*< Address offset = 0x38021c */
    pcie_ctl_hdma_cap_hdma_sar_low_off_wrch_1_reg_t HDMA_CAP_HDMA_SAR_LOW_OFF_WRCH_1; /*< Address offset = 0x380220 */
    pcie_ctl_hdma_cap_hdma_sar_high_off_wrch_1_reg_t HDMA_CAP_HDMA_SAR_HIGH_OFF_WRCH_1; /*< Address offset = 0x380224 */
    pcie_ctl_hdma_cap_hdma_dar_low_off_wrch_1_reg_t HDMA_CAP_HDMA_DAR_LOW_OFF_WRCH_1; /*< Address offset = 0x380228 */
    pcie_ctl_hdma_cap_hdma_dar_high_off_wrch_1_reg_t HDMA_CAP_HDMA_DAR_HIGH_OFF_WRCH_1; /*< Address offset = 0x38022c */
    pcie_ctl_hdma_cap_hdma_watermark_en_off_wrch_1_reg_t HDMA_CAP_HDMA_WATERMARK_EN_OFF_WRCH_1; /*< Address offset = 0x380230 */
    pcie_ctl_hdma_cap_hdma_ctrl1_off_wrch_1_reg_t HDMA_CAP_HDMA_CTRL1_OFF_WRCH_1; /*< Address offset = 0x380234 */
    pcie_ctl_hdma_cap_hdma_func_num_off_wrch_1_reg_t HDMA_CAP_HDMA_FUNC_NUM_OFF_WRCH_1; /*< Address offset = 0x380238 */
    pcie_ctl_hdma_cap_hdma_qos_off_wrch_1_reg_t HDMA_CAP_HDMA_QOS_OFF_WRCH_1; /*< Address offset = 0x38023c */
    const uint8_t        reservedArea80 [64]; /*< Address offset = 0x380240 */
    pcie_ctl_hdma_cap_hdma_stat_off_wrch_1_reg_t HDMA_CAP_HDMA_STAT_OFF_WRCH_1; /*< Address offset = 0x380280 */
    pcie_ctl_hdma_cap_hdma_int_stat_off_wrch_1_reg_t HDMA_CAP_HDMA_INT_STAT_OFF_WRCH_1; /*< Address offset = 0x380284 */
    pcie_ctl_hdma_cap_hdma_int_setup_off_wrch_1_reg_t HDMA_CAP_HDMA_INT_SETUP_OFF_WRCH_1; /*< Address offset = 0x380288 */
    pcie_ctl_hdma_cap_hdma_int_clr_off_wrch_1_reg_t HDMA_CAP_HDMA_INT_CLR_OFF_WRCH_1; /*< Address offset = 0x38028c */
    pcie_ctl_hdma_cap_hdma_msi_stop_low_off_wrch_1_reg_t HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_WRCH_1; /*< Address offset = 0x380290 */
    pcie_ctl_hdma_cap_hdma_msi_stop_high_off_wrch_1_reg_t HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_WRCH_1; /*< Address offset = 0x380294 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_wrch_1_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_WRCH_1; /*< Address offset = 0x380298 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_wrch_1_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_WRCH_1; /*< Address offset = 0x38029c */
    pcie_ctl_hdma_cap_hdma_msi_abort_low_off_wrch_1_reg_t HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_WRCH_1; /*< Address offset = 0x3802a0 */
    pcie_ctl_hdma_cap_hdma_msi_abort_high_off_wrch_1_reg_t HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_WRCH_1; /*< Address offset = 0x3802a4 */
    pcie_ctl_hdma_cap_hdma_msi_msgd_off_wrch_1_reg_t HDMA_CAP_HDMA_MSI_MSGD_OFF_WRCH_1; /*< Address offset = 0x3802a8 */
    const uint8_t        reservedArea81 [84]; /*< Address offset = 0x3802ac */
    pcie_ctl_hdma_cap_hdma_en_off_rdch_1_reg_t HDMA_CAP_HDMA_EN_OFF_RDCH_1; /*< Address offset = 0x380300 */
    pcie_ctl_hdma_cap_hdma_doorbell_off_rdch_1_reg_t HDMA_CAP_HDMA_DOORBELL_OFF_RDCH_1; /*< Address offset = 0x380304 */
    pcie_ctl_hdma_cap_hdma_elem_pf_off_rdch_1_reg_t HDMA_CAP_HDMA_ELEM_PF_OFF_RDCH_1; /*< Address offset = 0x380308 */
    const uint8_t        reservedArea82 [4];  /*< Address offset = 0x38030c */
    pcie_ctl_hdma_cap_hdma_llp_low_off_rdch_1_reg_t HDMA_CAP_HDMA_LLP_LOW_OFF_RDCH_1; /*< Address offset = 0x380310 */
    pcie_ctl_hdma_cap_hdma_llp_high_off_rdch_1_reg_t HDMA_CAP_HDMA_LLP_HIGH_OFF_RDCH_1; /*< Address offset = 0x380314 */
    pcie_ctl_hdma_cap_hdma_cycle_off_rdch_1_reg_t HDMA_CAP_HDMA_CYCLE_OFF_RDCH_1; /*< Address offset = 0x380318 */
    pcie_ctl_hdma_cap_hdma_xfersize_off_rdch_1_reg_t HDMA_CAP_HDMA_XFERSIZE_OFF_RDCH_1; /*< Address offset = 0x38031c */
    pcie_ctl_hdma_cap_hdma_sar_low_off_rdch_1_reg_t HDMA_CAP_HDMA_SAR_LOW_OFF_RDCH_1; /*< Address offset = 0x380320 */
    pcie_ctl_hdma_cap_hdma_sar_high_off_rdch_1_reg_t HDMA_CAP_HDMA_SAR_HIGH_OFF_RDCH_1; /*< Address offset = 0x380324 */
    pcie_ctl_hdma_cap_hdma_dar_low_off_rdch_1_reg_t HDMA_CAP_HDMA_DAR_LOW_OFF_RDCH_1; /*< Address offset = 0x380328 */
    pcie_ctl_hdma_cap_hdma_dar_high_off_rdch_1_reg_t HDMA_CAP_HDMA_DAR_HIGH_OFF_RDCH_1; /*< Address offset = 0x38032c */
    pcie_ctl_hdma_cap_hdma_watermark_en_off_rdch_1_reg_t HDMA_CAP_HDMA_WATERMARK_EN_OFF_RDCH_1; /*< Address offset = 0x380330 */
    pcie_ctl_hdma_cap_hdma_ctrl1_off_rdch_1_reg_t HDMA_CAP_HDMA_CTRL1_OFF_RDCH_1; /*< Address offset = 0x380334 */
    pcie_ctl_hdma_cap_hdma_func_num_off_rdch_1_reg_t HDMA_CAP_HDMA_FUNC_NUM_OFF_RDCH_1; /*< Address offset = 0x380338 */
    pcie_ctl_hdma_cap_hdma_qos_off_rdch_1_reg_t HDMA_CAP_HDMA_QOS_OFF_RDCH_1; /*< Address offset = 0x38033c */
    const uint8_t        reservedArea83 [64]; /*< Address offset = 0x380340 */
    pcie_ctl_hdma_cap_hdma_stat_off_rdch_1_reg_t HDMA_CAP_HDMA_STAT_OFF_RDCH_1; /*< Address offset = 0x380380 */
    pcie_ctl_hdma_cap_hdma_int_stat_off_rdch_1_reg_t HDMA_CAP_HDMA_INT_STAT_OFF_RDCH_1; /*< Address offset = 0x380384 */
    pcie_ctl_hdma_cap_hdma_int_setup_off_rdch_1_reg_t HDMA_CAP_HDMA_INT_SETUP_OFF_RDCH_1; /*< Address offset = 0x380388 */
    pcie_ctl_hdma_cap_hdma_int_clr_off_rdch_1_reg_t HDMA_CAP_HDMA_INT_CLR_OFF_RDCH_1; /*< Address offset = 0x38038c */
    pcie_ctl_hdma_cap_hdma_msi_stop_low_off_rdch_1_reg_t HDMA_CAP_HDMA_MSI_STOP_LOW_OFF_RDCH_1; /*< Address offset = 0x380390 */
    pcie_ctl_hdma_cap_hdma_msi_stop_high_off_rdch_1_reg_t HDMA_CAP_HDMA_MSI_STOP_HIGH_OFF_RDCH_1; /*< Address offset = 0x380394 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_low_off_rdch_1_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_LOW_OFF_RDCH_1; /*< Address offset = 0x380398 */
    pcie_ctl_hdma_cap_hdma_msi_watermark_high_off_rdch_1_reg_t HDMA_CAP_HDMA_MSI_WATERMARK_HIGH_OFF_RDCH_1; /*< Address offset = 0x38039c */
    pcie_ctl_hdma_cap_hdma_msi_abort_low_off_rdch_1_reg_t HDMA_CAP_HDMA_MSI_ABORT_LOW_OFF_RDCH_1; /*< Address offset = 0x3803a0 */
    pcie_ctl_hdma_cap_hdma_msi_abort_high_off_rdch_1_reg_t HDMA_CAP_HDMA_MSI_ABORT_HIGH_OFF_RDCH_1; /*< Address offset = 0x3803a4 */
    pcie_ctl_hdma_cap_hdma_msi_msgd_off_rdch_1_reg_t HDMA_CAP_HDMA_MSI_MSGD_OFF_RDCH_1; /*< Address offset = 0x3803a8 */
} dwc_pcie_ctldbi_slavememspace_1_t;     // size: 0x0860

// AddressSpace struct pointer
//
#define DLNK_PCIE_DWC_DBI_USP  ((dwc_pcie_ctldbi_slavememspace_1_t*) DLNK_PCIE_DWC_DBI_USP_BASE)

// ******************************************* /Address Space

#endif      // _DWC_PCIE_CTLDBI_SLAVEMEMSPACE_1_H_

