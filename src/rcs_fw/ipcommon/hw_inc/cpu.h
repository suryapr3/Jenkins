#ifndef _CPU_H_
#define _CPU_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#if (CPU_ANA) // from ADC view
#include "adc_addr_offset.h"
#define ANT0_CPU_BASE         ( 0x049f0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT0_OFFSET + WRP_ADC_DIGRF_OFFSET )
#define ANT1_CPU_BASE         ( 0x04bf0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT1_OFFSET + WRP_ADC_DIGRF_OFFSET )
#define ANT2_CPU_BASE         ( 0x04df0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT2_OFFSET + WRP_ADC_DIGRF_OFFSET )
#define ANT3_CPU_BASE         ( 0x04ff0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT3_OFFSET + WRP_ADC_DIGRF_OFFSET )
#else // from digRF view
#define ANT0_CPU_BASE         ( 0x049f0000 )
#define ANT1_CPU_BASE         ( 0x04bf0000 )
#define ANT2_CPU_BASE         ( 0x04df0000 )
#define ANT3_CPU_BASE         ( 0x04ff0000 )
#endif // CPU_ANA

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define CPU_SCRATCH_OFFSET   ( 0x00000000U )
#define CPU_ADC_CPU_CTRL_OFFSET ( 0x00000004U )
#define CPU_ADC_CPU_DBG_CTRL_OFFSET ( 0x00000008U )
#define CPU_ADC_CPU_TP_PDBG_EN_OFFSET ( 0x0000000cU )
#define CPU_RCS_START_CAL_OFFSET ( 0x00000010U )
#define CPU_ATSA_START_CAL_OFFSET ( 0x00000014U )
#define CPU_CPU2RCS_MAILBOX_OFFSET ( 0x00000018U )
#define CPU_RCS2CPU_MAILBOX_OFFSET ( 0x0000001cU )
#define CPU_ADC_CAL_TIME_INT0_OFFSET ( 0x00000020U )
#define CPU_ADC_CAL_TIME_INT1_OFFSET ( 0x00000024U )
#define CPU_ADC_CAL_TIME_INT2_OFFSET ( 0x00000028U )
#define CPU_ADC_CAL_TIME_INT3_OFFSET ( 0x0000002cU )
#define CPU_ADC_CPU_STAT_OFFSET ( 0x00000040U )
#define CPU_ADC_CPU_DBG_STAT_OFFSET ( 0x00000044U )
#define CPU_ADC_CPU_TP_PDBG_DATA_OFFSET ( 0x00000048U )
#define CPU_ADC_CPU_TP_PDBG_INST_OFFSET ( 0x0000004cU )
#define CPU_ADC_CPU_TP_PDBG_INBPIF_OFFSET ( 0x00000050U )
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_OFFSET ( 0x00000054U )
#define CPU_ADC_CPU_TP_PDBG_PC_OFFSET ( 0x00000058U )
#define CPU_ADC_CPU_TP_PDBG_STAT_OFFSET ( 0x0000005cU )
#define CPU_ADC_CPU_PFAULT_INFO_MSB_OFFSET ( 0x00000060U )
#define CPU_ADC_CPU_PFAULT_INFO_LSB_OFFSET ( 0x00000064U )
#define CPU_ADC_CPU_MEM_ERR_STAT_OFFSET ( 0x00000068U )
#define CPU_ADC_CPU_MEM_ERR_CLR_OFFSET ( 0x0000006cU )
#define CPU_APB_BRDG_STAT_OFFSET ( 0x00000070U )
#define CPU_ANT_INT_STAT_OFFSET ( 0x00000074U )
#define CPU_ANT_INT_HIGH_EN_OFFSET ( 0x00000078U )
#define CPU_ANT_INT_LOW_EN_OFFSET ( 0x0000007cU )
#define CPU_ANT_INT_CLR_OFFSET ( 0x00000080U )
#define CPU_ANT_INT_FORCE_OFFSET ( 0x00000084U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define CPU_SCRATCH_ADR(_BASE)      (( ( _BASE ) + ( CPU_SCRATCH_OFFSET ) ))
#define CPU_ADC_CPU_CTRL_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_CTRL_OFFSET ) ))
#define CPU_ADC_CPU_DBG_CTRL_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_DBG_CTRL_OFFSET ) ))
#define CPU_ADC_CPU_TP_PDBG_EN_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_TP_PDBG_EN_OFFSET ) ))
#define CPU_RCS_START_CAL_ADR(_BASE) (( ( _BASE ) + ( CPU_RCS_START_CAL_OFFSET ) ))
#define CPU_ATSA_START_CAL_ADR(_BASE) (( ( _BASE ) + ( CPU_ATSA_START_CAL_OFFSET ) ))
#define CPU_CPU2RCS_MAILBOX_ADR(_BASE) (( ( _BASE ) + ( CPU_CPU2RCS_MAILBOX_OFFSET ) ))
#define CPU_RCS2CPU_MAILBOX_ADR(_BASE) (( ( _BASE ) + ( CPU_RCS2CPU_MAILBOX_OFFSET ) ))
#define CPU_ADC_CAL_TIME_INT0_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CAL_TIME_INT0_OFFSET ) ))
#define CPU_ADC_CAL_TIME_INT1_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CAL_TIME_INT1_OFFSET ) ))
#define CPU_ADC_CAL_TIME_INT2_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CAL_TIME_INT2_OFFSET ) ))
#define CPU_ADC_CAL_TIME_INT3_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CAL_TIME_INT3_OFFSET ) ))
#define CPU_ADC_CPU_STAT_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_STAT_OFFSET ) ))
#define CPU_ADC_CPU_DBG_STAT_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_DBG_STAT_OFFSET ) ))
#define CPU_ADC_CPU_TP_PDBG_DATA_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_TP_PDBG_DATA_OFFSET ) ))
#define CPU_ADC_CPU_TP_PDBG_INST_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_TP_PDBG_INST_OFFSET ) ))
#define CPU_ADC_CPU_TP_PDBG_INBPIF_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_TP_PDBG_INBPIF_OFFSET ) ))
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_TP_PDBG_LS0STAT_OFFSET ) ))
#define CPU_ADC_CPU_TP_PDBG_PC_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_TP_PDBG_PC_OFFSET ) ))
#define CPU_ADC_CPU_TP_PDBG_STAT_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_TP_PDBG_STAT_OFFSET ) ))
#define CPU_ADC_CPU_PFAULT_INFO_MSB_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_PFAULT_INFO_MSB_OFFSET ) ))
#define CPU_ADC_CPU_PFAULT_INFO_LSB_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_PFAULT_INFO_LSB_OFFSET ) ))
#define CPU_ADC_CPU_MEM_ERR_STAT_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_MEM_ERR_STAT_OFFSET ) ))
#define CPU_ADC_CPU_MEM_ERR_CLR_ADR(_BASE) (( ( _BASE ) + ( CPU_ADC_CPU_MEM_ERR_CLR_OFFSET ) ))
#define CPU_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( CPU_APB_BRDG_STAT_OFFSET ) ))
#define CPU_ANT_INT_STAT_ADR(_BASE) (( ( _BASE ) + ( CPU_ANT_INT_STAT_OFFSET ) ))
#define CPU_ANT_INT_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( CPU_ANT_INT_HIGH_EN_OFFSET ) ))
#define CPU_ANT_INT_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( CPU_ANT_INT_LOW_EN_OFFSET ) ))
#define CPU_ANT_INT_CLR_ADR(_BASE) (( ( _BASE ) + ( CPU_ANT_INT_CLR_OFFSET ) ))
#define CPU_ANT_INT_FORCE_ADR(_BASE) (( ( _BASE ) + ( CPU_ANT_INT_FORCE_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief CPU_REG_MAP_REG_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/SCRATCH
  * ANT_CSR Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCH : 32;
    ///< Scratch register for software to use.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_scratch_reg_t;

#define CPU_SCRATCH_DEFAULT (0x00000000U)
#define CPU_SCRATCH_RD_MASK (0xffffffffU)
#define CPU_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch register for software to use.
#define CPU_SCRATCH_BF_OFF ( 0)
#define CPU_SCRATCH_BF_WID (32)
#define CPU_SCRATCH_BF_MSK (0xFFFFFFFF)
#define CPU_SCRATCH_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_CONTROL register description at address offset 0x4
  *
  * Register default value:        0x00000001
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_control
  * ADC_CPU Control Register
  */

typedef union {
  struct {
    uint32_t RUN_STALL : 1;
    ///< RunStall - 1. Allows PIFD to load IRAM and DRAM after System reset
    ///< is released, so reset default has been set to 1 (Stall cpu). 2. The
    ///< RunStall signal can be used to save power without using interrupts,
    ///< as is done in wait mode.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t STATVECTORSEL : 1;
    ///< Selects between one of two stationary vector bases (0: default, 1:
    ///< alternative).  The reset vector and the memory error exception handler
    ///< vector addresses are fixed offsets from the stationary vector base.
    ///< The two stationary vector bases are configurable. The StatVectorSel
    ///< pin must be held stable for at least 10 CLK cycles before the falling
    ///< edge of BReset, and for 10 CLK cycles after the falling edge of BReset.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_ctrl_reg_t;

#define CPU_ADC_CPU_CTRL_DEFAULT (0x00000001U)
#define CPU_ADC_CPU_CTRL_RD_MASK (0x00000003U)
#define CPU_ADC_CPU_CTRL_WR_MASK (0x00000003U)


///< RunStall - 1. Allows PIFD to load IRAM and DRAM after System reset
///< is released, so reset default has been set to 1 (Stall cpu). 2. The
///< RunStall signal can be used to save power without using interrupts,
///< as is done in wait mode.
#define CPU_ADC_CPU_CTRL_RUN_STALL_BF_OFF ( 0)
#define CPU_ADC_CPU_CTRL_RUN_STALL_BF_WID ( 1)
#define CPU_ADC_CPU_CTRL_RUN_STALL_BF_MSK (0x00000001)
#define CPU_ADC_CPU_CTRL_RUN_STALL_BF_DEF (0x00000001)

///< Selects between one of two stationary vector bases (0: default, 1:
///< alternative).  The reset vector and the memory error exception handler
///< vector addresses are fixed offsets from the stationary vector base.
///< The two stationary vector bases are configurable. The StatVectorSel
///< pin must be held stable for at least 10 CLK cycles before the falling
///< edge of BReset, and for 10 CLK cycles after the falling edge of BReset.
#define CPU_ADC_CPU_CTRL_STATVECTORSEL_BF_OFF ( 1)
#define CPU_ADC_CPU_CTRL_STATVECTORSEL_BF_WID ( 1)
#define CPU_ADC_CPU_CTRL_STATVECTORSEL_BF_MSK (0x00000002)
#define CPU_ADC_CPU_CTRL_STATVECTORSEL_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_DEBUG_CTRL register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_debug_ctrl
  * ADC_CPU Debug Control
  */

typedef union {
  struct {
    uint32_t DEBUG_RESET : 1;
    ///< ADC CPU Debug Reset: Resets Debug  CPU's Debug logic. Active High.
    ///< Deafult keeps Dbug logic in reset.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t OCD_HALT_ON_RESET : 1;
    ///< OCDHaltOnReset - Enter On Chip Debug (OCD) mode if this signal is
    ///< sampled asserted on reset.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_dbg_ctrl_reg_t;

#define CPU_ADC_CPU_DBG_CTRL_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_DBG_CTRL_RD_MASK (0x00000003U)
#define CPU_ADC_CPU_DBG_CTRL_WR_MASK (0x00000003U)


///< ADC CPU Debug Reset: Resets Debug  CPU's Debug logic. Active High.
///< Deafult keeps Dbug logic in reset.
#define CPU_ADC_CPU_DBG_CTRL_DBG_RST_BF_OFF ( 0)
#define CPU_ADC_CPU_DBG_CTRL_DBG_RST_BF_WID ( 1)
#define CPU_ADC_CPU_DBG_CTRL_DBG_RST_BF_MSK (0x00000001)
#define CPU_ADC_CPU_DBG_CTRL_DBG_RST_BF_DEF (0x00000000)

///< OCDHaltOnReset - Enter On Chip Debug (OCD) mode if this signal is
///< sampled asserted on reset.
#define CPU_ADC_CPU_DBG_CTRL_OCD_HALT_ON_RST_BF_OFF ( 1)
#define CPU_ADC_CPU_DBG_CTRL_OCD_HALT_ON_RST_BF_WID ( 1)
#define CPU_ADC_CPU_DBG_CTRL_OCD_HALT_ON_RST_BF_MSK (0x00000002)
#define CPU_ADC_CPU_DBG_CTRL_OCD_HALT_ON_RST_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_TP_PDEBUG_ENABLE register description at address offset 0xc
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_tp_pdebug_enable
  * ADC_CPU TP Enable
  */

typedef union {
  struct {
    uint32_t PDEBUG_ENABLE : 1;
    ///< Enables CPU Trace Port when asserted high. Once enabled the trace
    ///< port will report the status of the various trace point items.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_tp_pdbg_en_reg_t;

#define CPU_ADC_CPU_TP_PDBG_EN_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_TP_PDBG_EN_RD_MASK (0x00000001U)
#define CPU_ADC_CPU_TP_PDBG_EN_WR_MASK (0x00000001U)


///< Enables CPU Trace Port when asserted high. Once enabled the trace
///< port will report the status of the various trace point items.
#define CPU_ADC_CPU_TP_PDBG_EN_PDBG_EN_BF_OFF ( 0)
#define CPU_ADC_CPU_TP_PDBG_EN_PDBG_EN_BF_WID ( 1)
#define CPU_ADC_CPU_TP_PDBG_EN_PDBG_EN_BF_MSK (0x00000001)
#define CPU_ADC_CPU_TP_PDBG_EN_PDBG_EN_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_RCS_START_CAL register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/rcs_start_cal
  * RCS starts Calibration
  */

typedef union {
  struct {
    uint32_t RCS_CAL_START : 1;
    ///< This field contains a message from the ADC CPU to the RCS.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} cpu_rcs_start_cal_reg_t;

#define CPU_RCS_START_CAL_DEFAULT (0x00000000U)
#define CPU_RCS_START_CAL_RD_MASK (0x00000001U)
#define CPU_RCS_START_CAL_WR_MASK (0x00000001U)


///< This field contains a message from the ADC CPU to the RCS.
#define CPU_RCS_START_CAL_RCS_CAL_START_BF_OFF ( 0)
#define CPU_RCS_START_CAL_RCS_CAL_START_BF_WID ( 1)
#define CPU_RCS_START_CAL_RCS_CAL_START_BF_MSK (0x00000001)
#define CPU_RCS_START_CAL_RCS_CAL_START_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ATSA_START_CAL register description at address offset 0x14
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/atsa_start_cal
  * ATSA Triggered Calibration
  */

typedef union {
  struct {
    uint32_t ATSA_TS0 : 1;
    ///< ATSA Temperture Alarm 0
    ///< AccessType="RW/1C/V" BitOffset="0" ResetValue="0x0"
    uint32_t ATSA_TS1 : 1;
    ///< ATSA Temperture Alarm 1
    ///< AccessType="RW/1C/V" BitOffset="1" ResetValue="0x0"
    uint32_t ATSA_TS2 : 1;
    ///< ATSA Temperture Alarm 2
    ///< AccessType="RW/1C/V" BitOffset="2" ResetValue="0x0"
    uint32_t ATSA_FAULT : 1;
    ///< ATSA Fault has occurred.  The Fault is an interrupt from the ABC DTS
    ///< monitor. So, it is cleared by software at the DTS Monitor. The low
    ///< to high transition ofthe fault signal qualifies, latches and validated
    ///< the SFN value.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t ATSA_SFN : 3;
    ///< Number of  the temperature sensor that failed. Software select the
    ///< eight temperature sensors for use in ATSA monitoring in the ABC DTS
    ///< Monitor block. The ATSA_Fault bit validates this value.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} cpu_atsa_start_cal_reg_t;

#define CPU_ATSA_START_CAL_DEFAULT (0x00000000U)
#define CPU_ATSA_START_CAL_RD_MASK (0x0000007fU)
#define CPU_ATSA_START_CAL_WR_MASK (0x00000007U)


///< ATSA Temperture Alarm 0
#define CPU_ATSA_START_CAL_ATSA_TS0_BF_OFF ( 0)
#define CPU_ATSA_START_CAL_ATSA_TS0_BF_WID ( 1)
#define CPU_ATSA_START_CAL_ATSA_TS0_BF_MSK (0x00000001)
#define CPU_ATSA_START_CAL_ATSA_TS0_BF_DEF (0x00000000)

///< ATSA Temperture Alarm 1
#define CPU_ATSA_START_CAL_ATSA_TS1_BF_OFF ( 1)
#define CPU_ATSA_START_CAL_ATSA_TS1_BF_WID ( 1)
#define CPU_ATSA_START_CAL_ATSA_TS1_BF_MSK (0x00000002)
#define CPU_ATSA_START_CAL_ATSA_TS1_BF_DEF (0x00000000)

///< ATSA Temperture Alarm 2
#define CPU_ATSA_START_CAL_ATSA_TS2_BF_OFF ( 2)
#define CPU_ATSA_START_CAL_ATSA_TS2_BF_WID ( 1)
#define CPU_ATSA_START_CAL_ATSA_TS2_BF_MSK (0x00000004)
#define CPU_ATSA_START_CAL_ATSA_TS2_BF_DEF (0x00000000)

///< ATSA Fault has occurred.  The Fault is an interrupt from the ABC DTS
///< monitor. So, it is cleared by software at the DTS Monitor. The low
///< to high transition ofthe fault signal qualifies, latches and validated
///< the SFN value.
#define CPU_ATSA_START_CAL_ATSA_FAULT_BF_OFF ( 3)
#define CPU_ATSA_START_CAL_ATSA_FAULT_BF_WID ( 1)
#define CPU_ATSA_START_CAL_ATSA_FAULT_BF_MSK (0x00000008)
#define CPU_ATSA_START_CAL_ATSA_FAULT_BF_DEF (0x00000000)

///< Number of  the temperature sensor that failed. Software select the
///< eight temperature sensors for use in ATSA monitoring in the ABC DTS
///< Monitor block. The ATSA_Fault bit validates this value.
#define CPU_ATSA_START_CAL_ATSA_SFN_BF_OFF ( 4)
#define CPU_ATSA_START_CAL_ATSA_SFN_BF_WID ( 3)
#define CPU_ATSA_START_CAL_ATSA_SFN_BF_MSK (0x00000070)
#define CPU_ATSA_START_CAL_ATSA_SFN_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_CPU2RCS_MAILBOX register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/cpu2rcs_mailbox
  * CPU2RCS MailboxRegister
  */

typedef union {
  struct {
    uint32_t MAIL_MESSAGE : 32;
    ///< This field contains a message from the ADC CPU to the RCS.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_cpu2rcs_mailbox_reg_t;

#define CPU_CPU2RCS_MAILBOX_DEFAULT (0x00000000U)
#define CPU_CPU2RCS_MAILBOX_RD_MASK (0xffffffffU)
#define CPU_CPU2RCS_MAILBOX_WR_MASK (0xffffffffU)


///< This field contains a message from the ADC CPU to the RCS.
#define CPU_CPU2RCS_MAILBOX_MAIL_MSG_BF_OFF ( 0)
#define CPU_CPU2RCS_MAILBOX_MAIL_MSG_BF_WID (32)
#define CPU_CPU2RCS_MAILBOX_MAIL_MSG_BF_MSK (0xFFFFFFFF)
#define CPU_CPU2RCS_MAILBOX_MAIL_MSG_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_RCS2CPU_MAILBOX register description at address offset 0x1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/rcs2cpu_mailbox
  * CPU2RCS MailboxRegister
  */

typedef union {
  struct {
    uint32_t RCS_TO_CPU_MAILBOX : 32;
    ///< This field contains a message from the ADC CPU to the RCS.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_rcs2cpu_mailbox_reg_t;

#define CPU_RCS2CPU_MAILBOX_DEFAULT (0x00000000U)
#define CPU_RCS2CPU_MAILBOX_RD_MASK (0xffffffffU)
#define CPU_RCS2CPU_MAILBOX_WR_MASK (0xffffffffU)


///< This field contains a message from the ADC CPU to the RCS.
#define CPU_RCS2CPU_MAILBOX_RCS_TO_CPU_MAILBOX_BF_OFF ( 0)
#define CPU_RCS2CPU_MAILBOX_RCS_TO_CPU_MAILBOX_BF_WID (32)
#define CPU_RCS2CPU_MAILBOX_RCS_TO_CPU_MAILBOX_BF_MSK (0xFFFFFFFF)
#define CPU_RCS2CPU_MAILBOX_RCS_TO_CPU_MAILBOX_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CAL_TIME_INT0 register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cal_time_int0
  * ADC Calibration Time Interrupt 0
  */

typedef union {
  struct {
    uint32_t ADC_CAL_TIME_INTR0 : 1;
    ///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
    ///< by software.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cal_time_int0_reg_t;

#define CPU_ADC_CAL_TIME_INT0_DEFAULT (0x00000000U)
#define CPU_ADC_CAL_TIME_INT0_RD_MASK (0x00000001U)
#define CPU_ADC_CAL_TIME_INT0_WR_MASK (0x00000001U)


///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
///< by software.
#define CPU_ADC_CAL_TIME_INT0_ADC_CAL_TIME_INTR0_BF_OFF ( 0)
#define CPU_ADC_CAL_TIME_INT0_ADC_CAL_TIME_INTR0_BF_WID ( 1)
#define CPU_ADC_CAL_TIME_INT0_ADC_CAL_TIME_INTR0_BF_MSK (0x00000001)
#define CPU_ADC_CAL_TIME_INT0_ADC_CAL_TIME_INTR0_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CAL_TIME_INT1 register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cal_time_int1
  * ADC Calibration Time Interrupt 1
  */

typedef union {
  struct {
    uint32_t ADC_CAL_TIME_INTR1 : 1;
    ///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
    ///< by software.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cal_time_int1_reg_t;

#define CPU_ADC_CAL_TIME_INT1_DEFAULT (0x00000000U)
#define CPU_ADC_CAL_TIME_INT1_RD_MASK (0x00000001U)
#define CPU_ADC_CAL_TIME_INT1_WR_MASK (0x00000001U)


///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
///< by software.
#define CPU_ADC_CAL_TIME_INT1_ADC_CAL_TIME_INTR1_BF_OFF ( 0)
#define CPU_ADC_CAL_TIME_INT1_ADC_CAL_TIME_INTR1_BF_WID ( 1)
#define CPU_ADC_CAL_TIME_INT1_ADC_CAL_TIME_INTR1_BF_MSK (0x00000001)
#define CPU_ADC_CAL_TIME_INT1_ADC_CAL_TIME_INTR1_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CAL_TIME_INT2 register description at address offset 0x28
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cal_time_int2
  * ADC Calibration Time Interrupt 2
  */

typedef union {
  struct {
    uint32_t ADC_CAL_TIME_INTR2 : 1;
    ///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
    ///< by software.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cal_time_int2_reg_t;

#define CPU_ADC_CAL_TIME_INT2_DEFAULT (0x00000000U)
#define CPU_ADC_CAL_TIME_INT2_RD_MASK (0x00000001U)
#define CPU_ADC_CAL_TIME_INT2_WR_MASK (0x00000001U)


///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
///< by software.
#define CPU_ADC_CAL_TIME_INT2_ADC_CAL_TIME_INTR2_BF_OFF ( 0)
#define CPU_ADC_CAL_TIME_INT2_ADC_CAL_TIME_INTR2_BF_WID ( 1)
#define CPU_ADC_CAL_TIME_INT2_ADC_CAL_TIME_INTR2_BF_MSK (0x00000001)
#define CPU_ADC_CAL_TIME_INT2_ADC_CAL_TIME_INTR2_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CAL_TIME_INT3 register description at address offset 0x2c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cal_time_int3
  * ADC Calibration Time Interrupt 3
  */

typedef union {
  struct {
    uint32_t ADC_CAL_TIME_INTR3 : 1;
    ///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
    ///< by software.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cal_time_int3_reg_t;

#define CPU_ADC_CAL_TIME_INT3_DEFAULT (0x00000000U)
#define CPU_ADC_CAL_TIME_INT3_RD_MASK (0x00000001U)
#define CPU_ADC_CAL_TIME_INT3_WR_MASK (0x00000001U)


///< ADC Claibartion time Interrupt 0. The interrupt meaning is assigned
///< by software.
#define CPU_ADC_CAL_TIME_INT3_ADC_CAL_TIME_INTR3_BF_OFF ( 0)
#define CPU_ADC_CAL_TIME_INT3_ADC_CAL_TIME_INTR3_BF_WID ( 1)
#define CPU_ADC_CAL_TIME_INT3_ADC_CAL_TIME_INTR3_BF_MSK (0x00000001)
#define CPU_ADC_CAL_TIME_INT3_ADC_CAL_TIME_INTR3_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_STATUS register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_status
  * ADC_CPU Status Register
  */

typedef union {
  struct {
    uint32_t PWAIT_MODE : 1;
    ///< PwaitMode - Indicates that the processor is in sleep mode. The processor
    ///< asserts this signal when it has executed a WAITI instruction and is
    ///< waiting for an interrupt. Any asserted interrupt that is not disabled
    ///< will wake the processor, which will then jump to the appropriate interrupt
    ///< vector.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t IRAM_LOAD_STORE : 1;
    ///< Iram0Loadstore - The IRam0LoadStore signal differentiates between
    ///< an instruction doing a data load or store to instruction RAM, and
    ///< the instruction fetch logic using the instruction RAM to fetch Instructions.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_stat_reg_t;

#define CPU_ADC_CPU_STAT_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_STAT_RD_MASK (0x00000003U)
#define CPU_ADC_CPU_STAT_WR_MASK (0x00000000U)


///< PwaitMode - Indicates that the processor is in sleep mode. The processor
///< asserts this signal when it has executed a WAITI instruction and is
///< waiting for an interrupt. Any asserted interrupt that is not disabled
///< will wake the processor, which will then jump to the appropriate interrupt
///< vector.
#define CPU_ADC_CPU_STAT_PWAIT_MODE_BF_OFF ( 0)
#define CPU_ADC_CPU_STAT_PWAIT_MODE_BF_WID ( 1)
#define CPU_ADC_CPU_STAT_PWAIT_MODE_BF_MSK (0x00000001)
#define CPU_ADC_CPU_STAT_PWAIT_MODE_BF_DEF (0x00000000)

///< Iram0Loadstore - The IRam0LoadStore signal differentiates between
///< an instruction doing a data load or store to instruction RAM, and
///< the instruction fetch logic using the instruction RAM to fetch Instructions.
#define CPU_ADC_CPU_STAT_IRAM_LOAD_STORE_BF_OFF ( 1)
#define CPU_ADC_CPU_STAT_IRAM_LOAD_STORE_BF_WID ( 1)
#define CPU_ADC_CPU_STAT_IRAM_LOAD_STORE_BF_MSK (0x00000002)
#define CPU_ADC_CPU_STAT_IRAM_LOAD_STORE_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_DEBUG_STATUS register description at address offset 0x44
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_debug_status
  * ADC_CPU Debug Status
  */

typedef union {
  struct {
    uint32_t DEBUG_MODE : 1;
    ///< Debug_Mode - Same as XOCD_MODE but is not maskable by software.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t XOCD_MODE : 1;
    ///< XOCD Mode: Indicates that the processor is in On Chip Debug (OCD)
    ///< Halt mode.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_dbg_stat_reg_t;

#define CPU_ADC_CPU_DBG_STAT_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_DBG_STAT_RD_MASK (0x00000003U)
#define CPU_ADC_CPU_DBG_STAT_WR_MASK (0x00000000U)


///< Debug_Mode - Same as XOCD_MODE but is not maskable by software.
#define CPU_ADC_CPU_DBG_STAT_DBG_MODE_BF_OFF ( 0)
#define CPU_ADC_CPU_DBG_STAT_DBG_MODE_BF_WID ( 1)
#define CPU_ADC_CPU_DBG_STAT_DBG_MODE_BF_MSK (0x00000001)
#define CPU_ADC_CPU_DBG_STAT_DBG_MODE_BF_DEF (0x00000000)

///< XOCD Mode: Indicates that the processor is in On Chip Debug (OCD)
///< Halt mode.
#define CPU_ADC_CPU_DBG_STAT_XOCD_MODE_BF_OFF ( 1)
#define CPU_ADC_CPU_DBG_STAT_XOCD_MODE_BF_WID ( 1)
#define CPU_ADC_CPU_DBG_STAT_XOCD_MODE_BF_MSK (0x00000002)
#define CPU_ADC_CPU_DBG_STAT_XOCD_MODE_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_TP_PDEBUG_DATA register description at address offset 0x48
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_tp_pdebug_data
  * ADC_CPU Debug Status
  */

typedef union {
  struct {
    uint32_t PDEBUG_DATA : 32;
    ///< Processor Trace Debug Data
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_adc_cpu_tp_pdbg_data_reg_t;

#define CPU_ADC_CPU_TP_PDBG_DATA_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_TP_PDBG_DATA_RD_MASK (0xffffffffU)
#define CPU_ADC_CPU_TP_PDBG_DATA_WR_MASK (0x00000000U)


///< Processor Trace Debug Data
#define CPU_ADC_CPU_TP_PDBG_DATA_PDBG_DATA_BF_OFF ( 0)
#define CPU_ADC_CPU_TP_PDBG_DATA_PDBG_DATA_BF_WID (32)
#define CPU_ADC_CPU_TP_PDBG_DATA_PDBG_DATA_BF_MSK (0xFFFFFFFF)
#define CPU_ADC_CPU_TP_PDBG_DATA_PDBG_DATA_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_TP_PDEBUG_INST register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_tp_pdebug_inst
  * ADC_CPU TP Debug_Instruction
  */

typedef union {
  struct {
    uint32_t PDEBUG_INSTR : 32;
    ///< Processor Trace Debug Instruction
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_adc_cpu_tp_pdbg_inst_reg_t;

#define CPU_ADC_CPU_TP_PDBG_INST_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_TP_PDBG_INST_RD_MASK (0xffffffffU)
#define CPU_ADC_CPU_TP_PDBG_INST_WR_MASK (0x00000000U)


///< Processor Trace Debug Instruction
#define CPU_ADC_CPU_TP_PDBG_INST_PDBG_INSTR_BF_OFF ( 0)
#define CPU_ADC_CPU_TP_PDBG_INST_PDBG_INSTR_BF_WID (32)
#define CPU_ADC_CPU_TP_PDBG_INST_PDBG_INSTR_BF_MSK (0xFFFFFFFF)
#define CPU_ADC_CPU_TP_PDBG_INST_PDBG_INSTR_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_TP_PDEBUG_INBPIF register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_tp_pdebug_inbpif
  * ADC_CPU TP PIF_Inbound_iInfo
  */

typedef union {
  struct {
    uint32_t PDEBUG_INBPIF : 8;
    ///< Processor Traceport Inbound PIF Transaction Infromation.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_tp_pdbg_inbpif_reg_t;

#define CPU_ADC_CPU_TP_PDBG_INBPIF_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_TP_PDBG_INBPIF_RD_MASK (0x000000ffU)
#define CPU_ADC_CPU_TP_PDBG_INBPIF_WR_MASK (0x00000000U)


///< Processor Traceport Inbound PIF Transaction Infromation.
#define CPU_ADC_CPU_TP_PDBG_INBPIF_PDBG_INBPIF_BF_OFF ( 0)
#define CPU_ADC_CPU_TP_PDBG_INBPIF_PDBG_INBPIF_BF_WID ( 8)
#define CPU_ADC_CPU_TP_PDBG_INBPIF_PDBG_INBPIF_BF_MSK (0x000000FF)
#define CPU_ADC_CPU_TP_PDBG_INBPIF_PDBG_INBPIF_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_TP_PDEBUG_LS0STAT register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_tp_pdebug_ls0stat
  * ADC_CPU TP Debug_LSU0_Stat
  */

typedef union {
  struct {
    uint32_t PDEBUG_LS0_STAT : 32;
    ///< Processor Trace LSU Status
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_adc_cpu_tp_pdbg_ls0stat_reg_t;

#define CPU_ADC_CPU_TP_PDBG_LS0STAT_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_RD_MASK (0xffffffffU)
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_WR_MASK (0x00000000U)


///< Processor Trace LSU Status
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_PDBG_LS0_STAT_BF_OFF ( 0)
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_PDBG_LS0_STAT_BF_WID (32)
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_PDBG_LS0_STAT_BF_MSK (0xFFFFFFFF)
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_PDBG_LS0_STAT_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_TP_PDEBUG_PC register description at address offset 0x58
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_tp_pdebug_pc
  * ADC_CPU TP Debug_PC
  */

typedef union {
  struct {
    uint32_t PDEBUG_PC : 32;
    ///< Processor Trace Program Counter
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_adc_cpu_tp_pdbg_pc_reg_t;

#define CPU_ADC_CPU_TP_PDBG_PC_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_TP_PDBG_PC_RD_MASK (0xffffffffU)
#define CPU_ADC_CPU_TP_PDBG_PC_WR_MASK (0x00000000U)


///< Processor Trace Program Counter
#define CPU_ADC_CPU_TP_PDBG_PC_PDBG_PC_BF_OFF ( 0)
#define CPU_ADC_CPU_TP_PDBG_PC_PDBG_PC_BF_WID (32)
#define CPU_ADC_CPU_TP_PDBG_PC_PDBG_PC_BF_MSK (0xFFFFFFFF)
#define CPU_ADC_CPU_TP_PDBG_PC_PDBG_PC_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_TP_PDEBUG_STATUS register description at address offset 0x5c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_tp_pdebug_status
  * ADC_CPU TP PDebug_Status
  */

typedef union {
  struct {
    uint32_t PDEBUG_PC : 8;
    ///< Processor Trace Status Infromatiopn
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_tp_pdbg_stat_reg_t;

#define CPU_ADC_CPU_TP_PDBG_STAT_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_TP_PDBG_STAT_RD_MASK (0x000000ffU)
#define CPU_ADC_CPU_TP_PDBG_STAT_WR_MASK (0x00000000U)


///< Processor Trace Status Infromatiopn
#define CPU_ADC_CPU_TP_PDBG_STAT_PDBG_PC_BF_OFF ( 0)
#define CPU_ADC_CPU_TP_PDBG_STAT_PDBG_PC_BF_WID ( 8)
#define CPU_ADC_CPU_TP_PDBG_STAT_PDBG_PC_BF_MSK (0x000000FF)
#define CPU_ADC_CPU_TP_PDBG_STAT_PDBG_PC_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_PFAULT_INFO_MSB register description at address offset 0x60
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_pfault_info_msb
  * ADC_CPU Fault_Info MSB
  */

typedef union {
  struct {
    uint32_t PFAULT_INFO_MSB : 32;
    ///< Processor Fault Information MSB bits 63:32
    ///< AccessType="RO/C/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_adc_cpu_pfault_info_msb_reg_t;

#define CPU_ADC_CPU_PFAULT_INFO_MSB_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_PFAULT_INFO_MSB_RD_MASK (0xffffffffU)
#define CPU_ADC_CPU_PFAULT_INFO_MSB_WR_MASK (0x00000000U)


///< Processor Fault Information MSB bits 63:32
#define CPU_ADC_CPU_PFAULT_INFO_MSB_PFAULT_INFO_MSB_BF_OFF ( 0)
#define CPU_ADC_CPU_PFAULT_INFO_MSB_PFAULT_INFO_MSB_BF_WID (32)
#define CPU_ADC_CPU_PFAULT_INFO_MSB_PFAULT_INFO_MSB_BF_MSK (0xFFFFFFFF)
#define CPU_ADC_CPU_PFAULT_INFO_MSB_PFAULT_INFO_MSB_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_PFAULT_INFO_LSB register description at address offset 0x64
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_pfault_info_lsb
  * ADC_CPU Fault_Info LSB
  */

typedef union {
  struct {
    uint32_t PFAULT_INFO_LSB : 32;
    ///< Processor Fault Information MSB bits 31:0
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_adc_cpu_pfault_info_lsb_reg_t;

#define CPU_ADC_CPU_PFAULT_INFO_LSB_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_PFAULT_INFO_LSB_RD_MASK (0xffffffffU)
#define CPU_ADC_CPU_PFAULT_INFO_LSB_WR_MASK (0x00000000U)


///< Processor Fault Information MSB bits 31:0
#define CPU_ADC_CPU_PFAULT_INFO_LSB_PFAULT_INFO_LSB_BF_OFF ( 0)
#define CPU_ADC_CPU_PFAULT_INFO_LSB_PFAULT_INFO_LSB_BF_WID (32)
#define CPU_ADC_CPU_PFAULT_INFO_LSB_PFAULT_INFO_LSB_BF_MSK (0xFFFFFFFF)
#define CPU_ADC_CPU_PFAULT_INFO_LSB_PFAULT_INFO_LSB_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_MEM_ERR_STATUS register description at address offset 0x68
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_mem_err_status
  * ADC CPU Memory Error Status
  */

typedef union {
  struct {
    uint32_t IRAM_SBE : 1;
    ///< IRAM Correctable Single Bit Error has occurred.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DRAM_SBE : 1;
    ///< DRAM Correctable Single Bit Error has occurred.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t IRAM_DBE : 1;
    ///< IRAM Non-Correctable Double Bit Error has occurred.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t DRAM_DBE : 1;
    ///< DRAM Non-Correctable Double Bit Error has occurred.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t IRAM_SBE_OVLF : 1;
    ///< IRAM SBE Counter overflowed
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t DRAM_SBE_OVLF : 1;
    ///< DRAM SBE Counter overflowed
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t IRAM_SBE_CNT : 4;
    ///< IRAM Single Bit Error Count Value
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t DRAM_SBE_CNT : 4;
    ///< DRAM Single Bit Error Count Value
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_mem_err_stat_reg_t;

#define CPU_ADC_CPU_MEM_ERR_STAT_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_MEM_ERR_STAT_RD_MASK (0x0000ff3fU)
#define CPU_ADC_CPU_MEM_ERR_STAT_WR_MASK (0x00000000U)


///< IRAM Correctable Single Bit Error has occurred.
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_BF_OFF ( 0)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_BF_MSK (0x00000001)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_BF_DEF (0x00000000)

///< DRAM Correctable Single Bit Error has occurred.
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_BF_OFF ( 1)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_BF_MSK (0x00000002)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_BF_DEF (0x00000000)

///< IRAM Non-Correctable Double Bit Error has occurred.
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_DBE_BF_OFF ( 2)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_DBE_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_DBE_BF_MSK (0x00000004)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_DBE_BF_DEF (0x00000000)

///< DRAM Non-Correctable Double Bit Error has occurred.
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_DBE_BF_OFF ( 3)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_DBE_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_DBE_BF_MSK (0x00000008)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_DBE_BF_DEF (0x00000000)

///< IRAM SBE Counter overflowed
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_OVLF_BF_OFF ( 4)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_OVLF_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_OVLF_BF_MSK (0x00000010)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_OVLF_BF_DEF (0x00000000)

///< DRAM SBE Counter overflowed
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_OVLF_BF_OFF ( 5)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_OVLF_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_OVLF_BF_MSK (0x00000020)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_OVLF_BF_DEF (0x00000000)

///< IRAM Single Bit Error Count Value
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_CNT_BF_OFF ( 8)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_CNT_BF_WID ( 4)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_CNT_BF_MSK (0x00000F00)
#define CPU_ADC_CPU_MEM_ERR_STAT_IRAM_SBE_CNT_BF_DEF (0x00000000)

///< DRAM Single Bit Error Count Value
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_CNT_BF_OFF (12)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_CNT_BF_WID ( 4)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_CNT_BF_MSK (0x0000F000)
#define CPU_ADC_CPU_MEM_ERR_STAT_DRAM_SBE_CNT_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ADC_CPU_MEM_ERR_CLR register description at address offset 0x6c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/adc_cpu_mem_err_clr
  * ADC CPU Memory Error Clear
  */

typedef union {
  struct {
    uint32_t IRAM_ERR_CLR : 1;
    ///< Clear IRAM SBE and DBE errors reported in the adc_cpu_mem_err_status
    ///< register by writing this bit to a one.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DRAM_ERR_CLR : 1;
    ///< Clear DRAM  SBE and DBE error from adc_cpu_mem_err_status register
    ///< by writing this bit to a one.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t IRAM_SBE_OVFL_CNT_CLR : 1;
    ///< Clear IRAM SBE Overflow bit and Counter value in adc_cpu_mem_err_status
    ///< register by writing this bit to a one.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DRAM_SBE_OVFL_CNT_CLR : 1;
    ///< Clear DRAM SBE Overflow bit and Counter value in adc_cpu_mem_err_status
    ///< register by writing this bit to a one.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} cpu_adc_cpu_mem_err_clr_reg_t;

#define CPU_ADC_CPU_MEM_ERR_CLR_DEFAULT (0x00000000U)
#define CPU_ADC_CPU_MEM_ERR_CLR_RD_MASK (0x0000000fU)
#define CPU_ADC_CPU_MEM_ERR_CLR_WR_MASK (0x0000000fU)


///< Clear IRAM SBE and DBE errors reported in the adc_cpu_mem_err_status
///< register by writing this bit to a one.
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_ERR_CLR_BF_OFF ( 0)
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_ERR_CLR_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_ERR_CLR_BF_MSK (0x00000001)
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_ERR_CLR_BF_DEF (0x00000000)

///< Clear DRAM  SBE and DBE error from adc_cpu_mem_err_status register
///< by writing this bit to a one.
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_ERR_CLR_BF_OFF ( 1)
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_ERR_CLR_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_ERR_CLR_BF_MSK (0x00000002)
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_ERR_CLR_BF_DEF (0x00000000)

///< Clear IRAM SBE Overflow bit and Counter value in adc_cpu_mem_err_status
///< register by writing this bit to a one.
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_SBE_OVFL_CNT_CLR_BF_OFF ( 2)
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_SBE_OVFL_CNT_CLR_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_SBE_OVFL_CNT_CLR_BF_MSK (0x00000004)
#define CPU_ADC_CPU_MEM_ERR_CLR_IRAM_SBE_OVFL_CNT_CLR_BF_DEF (0x00000000)

///< Clear DRAM SBE Overflow bit and Counter value in adc_cpu_mem_err_status
///< register by writing this bit to a one.
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_SBE_OVFL_CNT_CLR_BF_OFF ( 3)
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_SBE_OVFL_CNT_CLR_BF_WID ( 1)
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_SBE_OVFL_CNT_CLR_BF_MSK (0x00000008)
#define CPU_ADC_CPU_MEM_ERR_CLR_DRAM_SBE_OVFL_CNT_CLR_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_APB_BRIDGE_STATUS register description at address offset 0x70
  *
  * Register default value:        0x00010000
  * Register full path in IP: cpu_reg_map/reg/APB_BRIDGE_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW/L" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW/1S/V/L" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} cpu_apb_brdg_stat_reg_t;

#define CPU_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define CPU_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define CPU_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define CPU_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define CPU_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define CPU_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define CPU_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define CPU_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define CPU_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define CPU_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define CPU_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define CPU_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define CPU_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define CPU_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define CPU_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define CPU_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define CPU_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define CPU_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define CPU_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define CPU_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define CPU_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define CPU_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define CPU_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define CPU_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define CPU_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define CPU_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define CPU_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ANT_INT_STATUS register description at address offset 0x74
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/ant_int_status
  * ANT Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t CPU_SBE_OVERFLOW : 1;
    ///< CPU Memory Signal bit Error Counter has Overflowed. Mean either the
    ///< IRAM or DRAM Siingle Bit Error Correctable Counters has overflow.
    ///< This warrent investigatiion. For details see adc_cpu_pfault_info_msb
    ///< and adc_cpu_mem_err_status registers
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CPU_ERROR_CORRECTED : 1;
    ///< CPU Memory Error Corrected: Single bit memory error detected and corrected.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t CPU_DOUBLE_EXCEPTION_ERROR : 1;
    ///< CPU_Double Exception Error
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t CPU_PFATAL_ERROR : 1;
    ///< Processor Fatal Error Occurred. See Processor Fatal LSB and MSB Registers
    ///< for details.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t CPU_TO_RCS_MAILBOX : 1;
    ///< Signals that the ADC CPU Has a Message for the RCS Processor to read.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t ATSA_CAL_START_INTR : 1;
    ///< ATSA temperture alarm interrupt to RCS.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cpu_ant_int_stat_reg_t;

#define CPU_ANT_INT_STAT_DEFAULT (0x00000000U)
#define CPU_ANT_INT_STAT_RD_MASK (0x0000003fU)
#define CPU_ANT_INT_STAT_WR_MASK (0x00000000U)


///< CPU Memory Signal bit Error Counter has Overflowed. Mean either the
///< IRAM or DRAM Siingle Bit Error Correctable Counters has overflow.
///< This warrent investigatiion. For details see adc_cpu_pfault_info_msb
///< and adc_cpu_mem_err_status registers
#define CPU_ANT_INT_STAT_CPU_SBE_OVERFLOW_BF_OFF ( 0)
#define CPU_ANT_INT_STAT_CPU_SBE_OVERFLOW_BF_WID ( 1)
#define CPU_ANT_INT_STAT_CPU_SBE_OVERFLOW_BF_MSK (0x00000001)
#define CPU_ANT_INT_STAT_CPU_SBE_OVERFLOW_BF_DEF (0x00000000)

///< CPU Memory Error Corrected: Single bit memory error detected and corrected.
#define CPU_ANT_INT_STAT_CPU_ERR_CORRECTED_BF_OFF ( 1)
#define CPU_ANT_INT_STAT_CPU_ERR_CORRECTED_BF_WID ( 1)
#define CPU_ANT_INT_STAT_CPU_ERR_CORRECTED_BF_MSK (0x00000002)
#define CPU_ANT_INT_STAT_CPU_ERR_CORRECTED_BF_DEF (0x00000000)

///< CPU_Double Exception Error
#define CPU_ANT_INT_STAT_CPU_DOUBLE_EXCEPTION_ERR_BF_OFF ( 2)
#define CPU_ANT_INT_STAT_CPU_DOUBLE_EXCEPTION_ERR_BF_WID ( 1)
#define CPU_ANT_INT_STAT_CPU_DOUBLE_EXCEPTION_ERR_BF_MSK (0x00000004)
#define CPU_ANT_INT_STAT_CPU_DOUBLE_EXCEPTION_ERR_BF_DEF (0x00000000)

///< Processor Fatal Error Occurred. See Processor Fatal LSB and MSB Registers
///< for details.
#define CPU_ANT_INT_STAT_CPU_PFATAL_ERR_BF_OFF ( 3)
#define CPU_ANT_INT_STAT_CPU_PFATAL_ERR_BF_WID ( 1)
#define CPU_ANT_INT_STAT_CPU_PFATAL_ERR_BF_MSK (0x00000008)
#define CPU_ANT_INT_STAT_CPU_PFATAL_ERR_BF_DEF (0x00000000)

///< Signals that the ADC CPU Has a Message for the RCS Processor to read.
#define CPU_ANT_INT_STAT_CPU_TO_RCS_MAILBOX_BF_OFF ( 4)
#define CPU_ANT_INT_STAT_CPU_TO_RCS_MAILBOX_BF_WID ( 1)
#define CPU_ANT_INT_STAT_CPU_TO_RCS_MAILBOX_BF_MSK (0x00000010)
#define CPU_ANT_INT_STAT_CPU_TO_RCS_MAILBOX_BF_DEF (0x00000000)

///< ATSA temperture alarm interrupt to RCS.
#define CPU_ANT_INT_STAT_ATSA_CAL_START_INTR_BF_OFF ( 5)
#define CPU_ANT_INT_STAT_ATSA_CAL_START_INTR_BF_WID ( 1)
#define CPU_ANT_INT_STAT_ATSA_CAL_START_INTR_BF_MSK (0x00000020)
#define CPU_ANT_INT_STAT_ATSA_CAL_START_INTR_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ANT_INT_HIGH_EN register description at address offset 0x78
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/ant_int_high_en
  * ANT Designate High_Priority_Interrupts
  */

typedef union {
  struct {
    uint32_t CPU_SBE_OVERFLOW : 1;
    ///< Enable bit as interrupt high enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CPU_ERROR_CORRECTED : 1;
    ///< Enable bit as interrupt high enable
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CPU_DOUBLE_EXCPETION_ERROR : 1;
    ///< Register error interrupt high enable
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CPU_PFATAL_ERROR : 1;
    ///< Register error interrupt high enable
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CPU2RCS_MAILBOX : 1;
    ///< Register error interrupt high enable
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ATSA_CAL_START_INTR : 1;
    ///< ATSA temperture alarm interrupt to RCS.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cpu_ant_int_high_en_reg_t;

#define CPU_ANT_INT_HIGH_EN_DEFAULT (0x00000000U)
#define CPU_ANT_INT_HIGH_EN_RD_MASK (0x0000003fU)
#define CPU_ANT_INT_HIGH_EN_WR_MASK (0x0000003fU)


///< Enable bit as interrupt high enable
#define CPU_ANT_INT_HIGH_EN_CPU_SBE_OVERFLOW_BF_OFF ( 0)
#define CPU_ANT_INT_HIGH_EN_CPU_SBE_OVERFLOW_BF_WID ( 1)
#define CPU_ANT_INT_HIGH_EN_CPU_SBE_OVERFLOW_BF_MSK (0x00000001)
#define CPU_ANT_INT_HIGH_EN_CPU_SBE_OVERFLOW_BF_DEF (0x00000000)

///< Enable bit as interrupt high enable
#define CPU_ANT_INT_HIGH_EN_CPU_ERR_CORRECTED_BF_OFF ( 1)
#define CPU_ANT_INT_HIGH_EN_CPU_ERR_CORRECTED_BF_WID ( 1)
#define CPU_ANT_INT_HIGH_EN_CPU_ERR_CORRECTED_BF_MSK (0x00000002)
#define CPU_ANT_INT_HIGH_EN_CPU_ERR_CORRECTED_BF_DEF (0x00000000)

///< Register error interrupt high enable
#define CPU_ANT_INT_HIGH_EN_CPU_DOUBLE_EXCPETION_ERR_BF_OFF ( 2)
#define CPU_ANT_INT_HIGH_EN_CPU_DOUBLE_EXCPETION_ERR_BF_WID ( 1)
#define CPU_ANT_INT_HIGH_EN_CPU_DOUBLE_EXCPETION_ERR_BF_MSK (0x00000004)
#define CPU_ANT_INT_HIGH_EN_CPU_DOUBLE_EXCPETION_ERR_BF_DEF (0x00000000)

///< Register error interrupt high enable
#define CPU_ANT_INT_HIGH_EN_CPU_PFATAL_ERR_BF_OFF ( 3)
#define CPU_ANT_INT_HIGH_EN_CPU_PFATAL_ERR_BF_WID ( 1)
#define CPU_ANT_INT_HIGH_EN_CPU_PFATAL_ERR_BF_MSK (0x00000008)
#define CPU_ANT_INT_HIGH_EN_CPU_PFATAL_ERR_BF_DEF (0x00000000)

///< Register error interrupt high enable
#define CPU_ANT_INT_HIGH_EN_CPU2RCS_MAILBOX_BF_OFF ( 4)
#define CPU_ANT_INT_HIGH_EN_CPU2RCS_MAILBOX_BF_WID ( 1)
#define CPU_ANT_INT_HIGH_EN_CPU2RCS_MAILBOX_BF_MSK (0x00000010)
#define CPU_ANT_INT_HIGH_EN_CPU2RCS_MAILBOX_BF_DEF (0x00000000)

///< ATSA temperture alarm interrupt to RCS.
#define CPU_ANT_INT_HIGH_EN_ATSA_CAL_START_INTR_BF_OFF ( 5)
#define CPU_ANT_INT_HIGH_EN_ATSA_CAL_START_INTR_BF_WID ( 1)
#define CPU_ANT_INT_HIGH_EN_ATSA_CAL_START_INTR_BF_MSK (0x00000020)
#define CPU_ANT_INT_HIGH_EN_ATSA_CAL_START_INTR_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ANT_INT_LOW_EN register description at address offset 0x7c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/ant_int_low_en
  * ANT Interrupt Low Enable Register
  */

typedef union {
  struct {
    uint32_t CPU_SBE_OVERFLOW : 1;
    ///< Register error interrupt low enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CPU_ERROR_CORRECTED : 1;
    ///< Register error interrupt low enable
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CPU_DOUBLE_EXCEPTION_ERROR : 1;
    ///< Register error interrupt low enable
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CPU_PFATAL_ERROR : 1;
    ///< Register error interrupt low enable
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CPU2RCS_MAILBOX : 1;
    ///< Register error interrupt low enable
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ATSA_CAL_START_INTR : 1;
    ///< ATSA temperture alarm interrupt to RCS.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cpu_ant_int_low_en_reg_t;

#define CPU_ANT_INT_LOW_EN_DEFAULT (0x00000000U)
#define CPU_ANT_INT_LOW_EN_RD_MASK (0x0000003fU)
#define CPU_ANT_INT_LOW_EN_WR_MASK (0x0000003fU)


///< Register error interrupt low enable
#define CPU_ANT_INT_LOW_EN_CPU_SBE_OVERFLOW_BF_OFF ( 0)
#define CPU_ANT_INT_LOW_EN_CPU_SBE_OVERFLOW_BF_WID ( 1)
#define CPU_ANT_INT_LOW_EN_CPU_SBE_OVERFLOW_BF_MSK (0x00000001)
#define CPU_ANT_INT_LOW_EN_CPU_SBE_OVERFLOW_BF_DEF (0x00000000)

///< Register error interrupt low enable
#define CPU_ANT_INT_LOW_EN_CPU_ERR_CORRECTED_BF_OFF ( 1)
#define CPU_ANT_INT_LOW_EN_CPU_ERR_CORRECTED_BF_WID ( 1)
#define CPU_ANT_INT_LOW_EN_CPU_ERR_CORRECTED_BF_MSK (0x00000002)
#define CPU_ANT_INT_LOW_EN_CPU_ERR_CORRECTED_BF_DEF (0x00000000)

///< Register error interrupt low enable
#define CPU_ANT_INT_LOW_EN_CPU_DOUBLE_EXCEPTION_ERR_BF_OFF ( 2)
#define CPU_ANT_INT_LOW_EN_CPU_DOUBLE_EXCEPTION_ERR_BF_WID ( 1)
#define CPU_ANT_INT_LOW_EN_CPU_DOUBLE_EXCEPTION_ERR_BF_MSK (0x00000004)
#define CPU_ANT_INT_LOW_EN_CPU_DOUBLE_EXCEPTION_ERR_BF_DEF (0x00000000)

///< Register error interrupt low enable
#define CPU_ANT_INT_LOW_EN_CPU_PFATAL_ERR_BF_OFF ( 3)
#define CPU_ANT_INT_LOW_EN_CPU_PFATAL_ERR_BF_WID ( 1)
#define CPU_ANT_INT_LOW_EN_CPU_PFATAL_ERR_BF_MSK (0x00000008)
#define CPU_ANT_INT_LOW_EN_CPU_PFATAL_ERR_BF_DEF (0x00000000)

///< Register error interrupt low enable
#define CPU_ANT_INT_LOW_EN_CPU2RCS_MAILBOX_BF_OFF ( 4)
#define CPU_ANT_INT_LOW_EN_CPU2RCS_MAILBOX_BF_WID ( 1)
#define CPU_ANT_INT_LOW_EN_CPU2RCS_MAILBOX_BF_MSK (0x00000010)
#define CPU_ANT_INT_LOW_EN_CPU2RCS_MAILBOX_BF_DEF (0x00000000)

///< ATSA temperture alarm interrupt to RCS.
#define CPU_ANT_INT_LOW_EN_ATSA_CAL_START_INTR_BF_OFF ( 5)
#define CPU_ANT_INT_LOW_EN_ATSA_CAL_START_INTR_BF_WID ( 1)
#define CPU_ANT_INT_LOW_EN_ATSA_CAL_START_INTR_BF_MSK (0x00000020)
#define CPU_ANT_INT_LOW_EN_ATSA_CAL_START_INTR_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ANT_INT_CLEAR register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/ant_int_clear
  * ANT_Interrupt Clear Register
  */

typedef union {
  struct {
    uint32_t CPU_SBE_OVERFLOW : 1;
    ///< Register error interrupt clear
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CPU_ERROR_CORRECTED : 1;
    ///< Register error interrupt clear
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CPU_DOUBLE_EXCPETION_ERROR : 1;
    ///< Register error interrupt clear
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CPU_PFATAL_ERROR : 1;
    ///< Register error interrupt clear
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CPU2RCS_MAILBOX : 1;
    ///< Register error interrupt clear
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ATSA_CAL_START_INTR : 1;
    ///< ATSA temperture alarm interrupt to RCS.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cpu_ant_int_clr_reg_t;

#define CPU_ANT_INT_CLR_DEFAULT (0x00000000U)
#define CPU_ANT_INT_CLR_RD_MASK (0x0000003fU)
#define CPU_ANT_INT_CLR_WR_MASK (0x0000003fU)


///< Register error interrupt clear
#define CPU_ANT_INT_CLR_CPU_SBE_OVERFLOW_BF_OFF ( 0)
#define CPU_ANT_INT_CLR_CPU_SBE_OVERFLOW_BF_WID ( 1)
#define CPU_ANT_INT_CLR_CPU_SBE_OVERFLOW_BF_MSK (0x00000001)
#define CPU_ANT_INT_CLR_CPU_SBE_OVERFLOW_BF_DEF (0x00000000)

///< Register error interrupt clear
#define CPU_ANT_INT_CLR_CPU_ERR_CORRECTED_BF_OFF ( 1)
#define CPU_ANT_INT_CLR_CPU_ERR_CORRECTED_BF_WID ( 1)
#define CPU_ANT_INT_CLR_CPU_ERR_CORRECTED_BF_MSK (0x00000002)
#define CPU_ANT_INT_CLR_CPU_ERR_CORRECTED_BF_DEF (0x00000000)

///< Register error interrupt clear
#define CPU_ANT_INT_CLR_CPU_DOUBLE_EXCPETION_ERR_BF_OFF ( 2)
#define CPU_ANT_INT_CLR_CPU_DOUBLE_EXCPETION_ERR_BF_WID ( 1)
#define CPU_ANT_INT_CLR_CPU_DOUBLE_EXCPETION_ERR_BF_MSK (0x00000004)
#define CPU_ANT_INT_CLR_CPU_DOUBLE_EXCPETION_ERR_BF_DEF (0x00000000)

///< Register error interrupt clear
#define CPU_ANT_INT_CLR_CPU_PFATAL_ERR_BF_OFF ( 3)
#define CPU_ANT_INT_CLR_CPU_PFATAL_ERR_BF_WID ( 1)
#define CPU_ANT_INT_CLR_CPU_PFATAL_ERR_BF_MSK (0x00000008)
#define CPU_ANT_INT_CLR_CPU_PFATAL_ERR_BF_DEF (0x00000000)

///< Register error interrupt clear
#define CPU_ANT_INT_CLR_CPU2RCS_MAILBOX_BF_OFF ( 4)
#define CPU_ANT_INT_CLR_CPU2RCS_MAILBOX_BF_WID ( 1)
#define CPU_ANT_INT_CLR_CPU2RCS_MAILBOX_BF_MSK (0x00000010)
#define CPU_ANT_INT_CLR_CPU2RCS_MAILBOX_BF_DEF (0x00000000)

///< ATSA temperture alarm interrupt to RCS.
#define CPU_ANT_INT_CLR_ATSA_CAL_START_INTR_BF_OFF ( 5)
#define CPU_ANT_INT_CLR_ATSA_CAL_START_INTR_BF_WID ( 1)
#define CPU_ANT_INT_CLR_ATSA_CAL_START_INTR_BF_MSK (0x00000020)
#define CPU_ANT_INT_CLR_ATSA_CAL_START_INTR_BF_DEF (0x00000000)


/** @brief CPU_REG_MAP_REG_ANT_INT_FORCE register description at address offset 0x84
  *
  * Register default value:        0x00000000
  * Register full path in IP: cpu_reg_map/reg/ant_int_force
  * ANT Interrupt Force Register
  */

typedef union {
  struct {
    uint32_t CPU_SBE_OVERFLOW : 1;
    ///< Register error interrupt force
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CPU_ERROR_CORRECTED : 1;
    ///< Register error interrupt force
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CPU_DOUBLE_EXCEPTION_ERROR : 1;
    ///< Register error interrupt force
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CPU_PFATAL_ERROR : 1;
    ///< Register error interrupt force
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CPU2RCS_MAILBOX : 1;
    ///< Register error interrupt force
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ATSA_CAL_START_INTR : 1;
    ///< ATSA temperture alarm interrupt to RCS.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cpu_ant_int_force_reg_t;

#define CPU_ANT_INT_FORCE_DEFAULT (0x00000000U)
#define CPU_ANT_INT_FORCE_RD_MASK (0x0000003fU)
#define CPU_ANT_INT_FORCE_WR_MASK (0x0000003fU)


///< Register error interrupt force
#define CPU_ANT_INT_FORCE_CPU_SBE_OVERFLOW_BF_OFF ( 0)
#define CPU_ANT_INT_FORCE_CPU_SBE_OVERFLOW_BF_WID ( 1)
#define CPU_ANT_INT_FORCE_CPU_SBE_OVERFLOW_BF_MSK (0x00000001)
#define CPU_ANT_INT_FORCE_CPU_SBE_OVERFLOW_BF_DEF (0x00000000)

///< Register error interrupt force
#define CPU_ANT_INT_FORCE_CPU_ERR_CORRECTED_BF_OFF ( 1)
#define CPU_ANT_INT_FORCE_CPU_ERR_CORRECTED_BF_WID ( 1)
#define CPU_ANT_INT_FORCE_CPU_ERR_CORRECTED_BF_MSK (0x00000002)
#define CPU_ANT_INT_FORCE_CPU_ERR_CORRECTED_BF_DEF (0x00000000)

///< Register error interrupt force
#define CPU_ANT_INT_FORCE_CPU_DOUBLE_EXCEPTION_ERR_BF_OFF ( 2)
#define CPU_ANT_INT_FORCE_CPU_DOUBLE_EXCEPTION_ERR_BF_WID ( 1)
#define CPU_ANT_INT_FORCE_CPU_DOUBLE_EXCEPTION_ERR_BF_MSK (0x00000004)
#define CPU_ANT_INT_FORCE_CPU_DOUBLE_EXCEPTION_ERR_BF_DEF (0x00000000)

///< Register error interrupt force
#define CPU_ANT_INT_FORCE_CPU_PFATAL_ERR_BF_OFF ( 3)
#define CPU_ANT_INT_FORCE_CPU_PFATAL_ERR_BF_WID ( 1)
#define CPU_ANT_INT_FORCE_CPU_PFATAL_ERR_BF_MSK (0x00000008)
#define CPU_ANT_INT_FORCE_CPU_PFATAL_ERR_BF_DEF (0x00000000)

///< Register error interrupt force
#define CPU_ANT_INT_FORCE_CPU2RCS_MAILBOX_BF_OFF ( 4)
#define CPU_ANT_INT_FORCE_CPU2RCS_MAILBOX_BF_WID ( 1)
#define CPU_ANT_INT_FORCE_CPU2RCS_MAILBOX_BF_MSK (0x00000010)
#define CPU_ANT_INT_FORCE_CPU2RCS_MAILBOX_BF_DEF (0x00000000)

///< ATSA temperture alarm interrupt to RCS.
#define CPU_ANT_INT_FORCE_ATSA_CAL_START_INTR_BF_OFF ( 5)
#define CPU_ANT_INT_FORCE_ATSA_CAL_START_INTR_BF_WID ( 1)
#define CPU_ANT_INT_FORCE_ATSA_CAL_START_INTR_BF_MSK (0x00000020)
#define CPU_ANT_INT_FORCE_ATSA_CAL_START_INTR_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define CPU_SCRATCH_REG(_BASE) ((cpu_scratch_reg_t*) CPU_SCRATCH_ADR(_BASE))
#define CPU_ADC_CPU_CTRL_REG(_BASE) ((cpu_adc_cpu_ctrl_reg_t*) CPU_ADC_CPU_CTRL_ADR(_BASE))
#define CPU_ADC_CPU_DBG_CTRL_REG(_BASE) ((cpu_adc_cpu_dbg_ctrl_reg_t*) CPU_ADC_CPU_DBG_CTRL_ADR(_BASE))
#define CPU_ADC_CPU_TP_PDBG_EN_REG(_BASE) ((cpu_adc_cpu_tp_pdbg_en_reg_t*) CPU_ADC_CPU_TP_PDBG_EN_ADR(_BASE))
#define CPU_RCS_START_CAL_REG(_BASE) ((cpu_rcs_start_cal_reg_t*) CPU_RCS_START_CAL_ADR(_BASE))
#define CPU_ATSA_START_CAL_REG(_BASE) ((cpu_atsa_start_cal_reg_t*) CPU_ATSA_START_CAL_ADR(_BASE))
#define CPU_CPU2RCS_MAILBOX_REG(_BASE) ((cpu_cpu2rcs_mailbox_reg_t*) CPU_CPU2RCS_MAILBOX_ADR(_BASE))
#define CPU_RCS2CPU_MAILBOX_REG(_BASE) ((cpu_rcs2cpu_mailbox_reg_t*) CPU_RCS2CPU_MAILBOX_ADR(_BASE))
#define CPU_ADC_CAL_TIME_INT0_REG(_BASE) ((cpu_adc_cal_time_int0_reg_t*) CPU_ADC_CAL_TIME_INT0_ADR(_BASE))
#define CPU_ADC_CAL_TIME_INT1_REG(_BASE) ((cpu_adc_cal_time_int1_reg_t*) CPU_ADC_CAL_TIME_INT1_ADR(_BASE))
#define CPU_ADC_CAL_TIME_INT2_REG(_BASE) ((cpu_adc_cal_time_int2_reg_t*) CPU_ADC_CAL_TIME_INT2_ADR(_BASE))
#define CPU_ADC_CAL_TIME_INT3_REG(_BASE) ((cpu_adc_cal_time_int3_reg_t*) CPU_ADC_CAL_TIME_INT3_ADR(_BASE))
#define CPU_ADC_CPU_STAT_REG(_BASE) ((cpu_adc_cpu_stat_reg_t*) CPU_ADC_CPU_STAT_ADR(_BASE))
#define CPU_ADC_CPU_DBG_STAT_REG(_BASE) ((cpu_adc_cpu_dbg_stat_reg_t*) CPU_ADC_CPU_DBG_STAT_ADR(_BASE))
#define CPU_ADC_CPU_TP_PDBG_DATA_REG(_BASE) ((cpu_adc_cpu_tp_pdbg_data_reg_t*) CPU_ADC_CPU_TP_PDBG_DATA_ADR(_BASE))
#define CPU_ADC_CPU_TP_PDBG_INST_REG(_BASE) ((cpu_adc_cpu_tp_pdbg_inst_reg_t*) CPU_ADC_CPU_TP_PDBG_INST_ADR(_BASE))
#define CPU_ADC_CPU_TP_PDBG_INBPIF_REG(_BASE) ((cpu_adc_cpu_tp_pdbg_inbpif_reg_t*) CPU_ADC_CPU_TP_PDBG_INBPIF_ADR(_BASE))
#define CPU_ADC_CPU_TP_PDBG_LS0STAT_REG(_BASE) ((cpu_adc_cpu_tp_pdbg_ls0stat_reg_t*) CPU_ADC_CPU_TP_PDBG_LS0STAT_ADR(_BASE))
#define CPU_ADC_CPU_TP_PDBG_PC_REG(_BASE) ((cpu_adc_cpu_tp_pdbg_pc_reg_t*) CPU_ADC_CPU_TP_PDBG_PC_ADR(_BASE))
#define CPU_ADC_CPU_TP_PDBG_STAT_REG(_BASE) ((cpu_adc_cpu_tp_pdbg_stat_reg_t*) CPU_ADC_CPU_TP_PDBG_STAT_ADR(_BASE))
#define CPU_ADC_CPU_PFAULT_INFO_MSB_REG(_BASE) ((cpu_adc_cpu_pfault_info_msb_reg_t*) CPU_ADC_CPU_PFAULT_INFO_MSB_ADR(_BASE))
#define CPU_ADC_CPU_PFAULT_INFO_LSB_REG(_BASE) ((cpu_adc_cpu_pfault_info_lsb_reg_t*) CPU_ADC_CPU_PFAULT_INFO_LSB_ADR(_BASE))
#define CPU_ADC_CPU_MEM_ERR_STAT_REG(_BASE) ((cpu_adc_cpu_mem_err_stat_reg_t*) CPU_ADC_CPU_MEM_ERR_STAT_ADR(_BASE))
#define CPU_ADC_CPU_MEM_ERR_CLR_REG(_BASE) ((cpu_adc_cpu_mem_err_clr_reg_t*) CPU_ADC_CPU_MEM_ERR_CLR_ADR(_BASE))
#define CPU_APB_BRDG_STAT_REG(_BASE) ((cpu_apb_brdg_stat_reg_t*) CPU_APB_BRDG_STAT_ADR(_BASE))
#define CPU_ANT_INT_STAT_REG(_BASE) ((cpu_ant_int_stat_reg_t*) CPU_ANT_INT_STAT_ADR(_BASE))
#define CPU_ANT_INT_HIGH_EN_REG(_BASE) ((cpu_ant_int_high_en_reg_t*) CPU_ANT_INT_HIGH_EN_ADR(_BASE))
#define CPU_ANT_INT_LOW_EN_REG(_BASE) ((cpu_ant_int_low_en_reg_t*) CPU_ANT_INT_LOW_EN_ADR(_BASE))
#define CPU_ANT_INT_CLR_REG(_BASE) ((cpu_ant_int_clr_reg_t*) CPU_ANT_INT_CLR_ADR(_BASE))
#define CPU_ANT_INT_FORCE_REG(_BASE) ((cpu_ant_int_force_reg_t*) CPU_ANT_INT_FORCE_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    cpu_scratch_reg_t SCRATCH;         /*< Address offset = 0x0 */
    cpu_adc_cpu_ctrl_reg_t ADC_CPU_CTRL; /*< Address offset = 0x4 */
    cpu_adc_cpu_dbg_ctrl_reg_t ADC_CPU_DBG_CTRL; /*< Address offset = 0x8 */
    cpu_adc_cpu_tp_pdbg_en_reg_t ADC_CPU_TP_PDBG_EN; /*< Address offset = 0xc */
    cpu_rcs_start_cal_reg_t RCS_START_CAL;   /*< Address offset = 0x10 */
    cpu_atsa_start_cal_reg_t ATSA_START_CAL;  /*< Address offset = 0x14 */
    cpu_cpu2rcs_mailbox_reg_t CPU2RCS_MAILBOX; /*< Address offset = 0x18 */
    cpu_rcs2cpu_mailbox_reg_t RCS2CPU_MAILBOX; /*< Address offset = 0x1c */
    cpu_adc_cal_time_int0_reg_t ADC_CAL_TIME_INT0; /*< Address offset = 0x20 */
    cpu_adc_cal_time_int1_reg_t ADC_CAL_TIME_INT1; /*< Address offset = 0x24 */
    cpu_adc_cal_time_int2_reg_t ADC_CAL_TIME_INT2; /*< Address offset = 0x28 */
    cpu_adc_cal_time_int3_reg_t ADC_CAL_TIME_INT3; /*< Address offset = 0x2c */
    const uint8_t        reservedArea0 [16];  /*< Address offset = 0x30 */
    cpu_adc_cpu_stat_reg_t ADC_CPU_STAT;  /*< Address offset = 0x40 */
    cpu_adc_cpu_dbg_stat_reg_t ADC_CPU_DBG_STAT; /*< Address offset = 0x44 */
    cpu_adc_cpu_tp_pdbg_data_reg_t ADC_CPU_TP_PDBG_DATA; /*< Address offset = 0x48 */
    cpu_adc_cpu_tp_pdbg_inst_reg_t ADC_CPU_TP_PDBG_INST; /*< Address offset = 0x4c */
    cpu_adc_cpu_tp_pdbg_inbpif_reg_t ADC_CPU_TP_PDBG_INBPIF; /*< Address offset = 0x50 */
    cpu_adc_cpu_tp_pdbg_ls0stat_reg_t ADC_CPU_TP_PDBG_LS0STAT; /*< Address offset = 0x54 */
    cpu_adc_cpu_tp_pdbg_pc_reg_t ADC_CPU_TP_PDBG_PC; /*< Address offset = 0x58 */
    cpu_adc_cpu_tp_pdbg_stat_reg_t ADC_CPU_TP_PDBG_STAT; /*< Address offset = 0x5c */
    cpu_adc_cpu_pfault_info_msb_reg_t ADC_CPU_PFAULT_INFO_MSB; /*< Address offset = 0x60 */
    cpu_adc_cpu_pfault_info_lsb_reg_t ADC_CPU_PFAULT_INFO_LSB; /*< Address offset = 0x64 */
    cpu_adc_cpu_mem_err_stat_reg_t ADC_CPU_MEM_ERR_STAT; /*< Address offset = 0x68 */
    cpu_adc_cpu_mem_err_clr_reg_t ADC_CPU_MEM_ERR_CLR; /*< Address offset = 0x6c */
    cpu_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x70 */
    cpu_ant_int_stat_reg_t ANT_INT_STAT;  /*< Address offset = 0x74 */
    cpu_ant_int_high_en_reg_t ANT_INT_HIGH_EN; /*< Address offset = 0x78 */
    cpu_ant_int_low_en_reg_t ANT_INT_LOW_EN;  /*< Address offset = 0x7c */
    cpu_ant_int_clr_reg_t ANT_INT_CLR;   /*< Address offset = 0x80 */
    cpu_ant_int_force_reg_t ANT_INT_FORCE;   /*< Address offset = 0x84 */
} cpu_t;     // size: 0x0078

// AddressSpace struct pointer
//
#define ANT0_CPU         ((cpu_t*) ANT0_CPU_BASE)
#define ANT1_CPU         ((cpu_t*) ANT1_CPU_BASE)
#define ANT2_CPU         ((cpu_t*) ANT2_CPU_BASE)
#define ANT3_CPU         ((cpu_t*) ANT3_CPU_BASE)

// ******************************************* /Address Space

#endif      // _CPU_H_

