#ifndef _CMEM_CFG_H_
#define _CMEM_CFG_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define FB_ANT0_CMEM_CFG0_BASE  ( 0x05028000 )
#define FB_ANT0_CMEM_CFG1_BASE  ( 0x05068000 )
#define FB_ANT1_CMEM_CFG0_BASE  ( 0x050a8000 )
#define FB_ANT1_CMEM_CFG1_BASE  ( 0x050e8000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define CMEM_CFG_SCRATCH_OFFSET ( 0x00000000U )
#define CMEM_CFG_OFFSET ( 0x00000004U )
#define CMEM_CFG_START_OFFSET ( 0x00000008U )
#define CMEM_CFG_END_OFFSET ( 0x0000000cU )
#define CMEM_CFG_CUR_OFFSET ( 0x00000010U )
#define CMEM_CFG_MODE_OFFSET ( 0x00000014U )
#define CMEM_CFG_LFSR_SEED_OFFSET ( 0x00000018U )
#define CMEM_CFG_FIXED_PATTERN_OFFSET ( 0x0000001cU )
#define CMEM_CFG_RAMP_CFG_OFFSET ( 0x00000020U )
#define CMEM_CFG_INIT_RAM_OFFSET ( 0x00000024U )
#define CMEM_CFG_ERR_STAT_OFFSET ( 0x00000028U )
#define CMEM_CFG_INT_STAT_OFFSET ( 0x00000040U )
#define CMEM_CFG_INT_HI_EN_OFFSET ( 0x00000044U )
#define CMEM_CFG_INT_LO_EN_OFFSET ( 0x00000048U )
#define CMEM_CFG_INT_CLR_OFFSET ( 0x0000004cU )
#define CMEM_CFG_INT_FORCE_OFFSET ( 0x00000050U )
#define CMEM_CFG_ECC_ERR_INFO0_OFFSET ( 0x00000054U )
#define CMEM_CFG_ECC_ERR_INFO1_OFFSET ( 0x00000058U )
#define CMEM_CFG_ECC_ERR_INFO2_OFFSET ( 0x0000005cU )
#define CMEM_CFG_ECC_ERR_INFO3_OFFSET ( 0x00000060U )
#define CMEM_CFG_ECC_ERR_INFO4_OFFSET ( 0x00000064U )
#define CMEM_CFG_ECC_ERR_INFO5_OFFSET ( 0x00000068U )
#define CMEM_CFG_ECC_ERR_INFO6_OFFSET ( 0x0000006cU )
#define CMEM_CFG_ECC_ERR_INFO7_OFFSET ( 0x00000070U )
#define CMEM_CFG_ECC_CTRL0_OFFSET ( 0x00000074U )
#define CMEM_CFG_ECC_CTRL1_OFFSET ( 0x00000078U )
#define CMEM_CFG_ECC_CTRL2_OFFSET ( 0x0000007cU )
#define CMEM_CFG_ECC_CTRL3_OFFSET ( 0x00000080U )
#define CMEM_CFG_ECC_CTRL4_OFFSET ( 0x00000084U )
#define CMEM_CFG_ECC_CTRL5_OFFSET ( 0x00000088U )
#define CMEM_CFG_ECC_CTRL6_OFFSET ( 0x0000008cU )
#define CMEM_CFG_ECC_CTRL7_OFFSET ( 0x00000090U )
#define CMEM_CFG_ECC_ERR_STAT_OFFSET ( 0x00000094U )
#define CMEM_CFG_APB_BRDG_STAT_OFFSET ( 0x00000098U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define CMEM_CFG_SCRATCH_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_SCRATCH_OFFSET ) ))
#define CMEM_CFG_ADR(_BASE)    (( ( _BASE ) + ( CMEM_CFG_OFFSET ) ))
#define CMEM_CFG_START_ADR(_BASE)  (( ( _BASE ) + ( CMEM_CFG_START_OFFSET ) ))
#define CMEM_CFG_END_ADR(_BASE)    (( ( _BASE ) + ( CMEM_CFG_END_OFFSET ) ))
#define CMEM_CFG_CUR_ADR(_BASE)    (( ( _BASE ) + ( CMEM_CFG_CUR_OFFSET ) ))
#define CMEM_CFG_MODE_ADR(_BASE)   (( ( _BASE ) + ( CMEM_CFG_MODE_OFFSET ) ))
#define CMEM_CFG_LFSR_SEED_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_LFSR_SEED_OFFSET ) ))
#define CMEM_CFG_FIXED_PATTERN_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_FIXED_PATTERN_OFFSET ) ))
#define CMEM_CFG_RAMP_CFG_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_RAMP_CFG_OFFSET ) ))
#define CMEM_CFG_INIT_RAM_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_INIT_RAM_OFFSET ) ))
#define CMEM_CFG_ERR_STAT_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ERR_STAT_OFFSET ) ))
#define CMEM_CFG_INT_STAT_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_INT_STAT_OFFSET ) ))
#define CMEM_CFG_INT_HI_EN_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_INT_HI_EN_OFFSET ) ))
#define CMEM_CFG_INT_LO_EN_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_INT_LO_EN_OFFSET ) ))
#define CMEM_CFG_INT_CLR_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_INT_CLR_OFFSET ) ))
#define CMEM_CFG_INT_FORCE_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_INT_FORCE_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO0_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO0_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO1_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO1_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO2_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO2_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO3_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO3_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO4_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO4_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO5_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO5_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO6_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO6_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_INFO7_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_INFO7_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL0_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL0_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL1_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL1_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL2_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL2_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL3_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL3_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL4_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL4_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL5_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL5_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL6_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL6_OFFSET ) ))
#define CMEM_CFG_ECC_CTRL7_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_CTRL7_OFFSET ) ))
#define CMEM_CFG_ECC_ERR_STAT_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_ECC_ERR_STAT_OFFSET ) ))
#define CMEM_CFG_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( CMEM_CFG_APB_BRDG_STAT_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief CMEM_CFG_CMEM_CFG_MAP_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/SCRATCH
  * CMEM scratchpad register.
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Do anything with this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cmem_cfg_scratch_reg_t;

#define CMEM_CFG_SCRATCH_DEFAULT (0x00000000U)
#define CMEM_CFG_SCRATCH_RD_MASK (0xffffffffU)
#define CMEM_CFG_SCRATCH_WR_MASK (0xffffffffU)


///< Do anything with this field.
#define CMEM_CFG_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define CMEM_CFG_SCRATCH_SCRATCHPAD_BF_WID (32)
#define CMEM_CFG_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define CMEM_CFG_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_CFG register description at address offset 0x4
  *
  * Register default value:        0x00000010
  * Register full path in IP: cmem_cfg/cmem_cfg_map/CFG
  * CMEM configuration register.
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< 0 CMEM disabled                                   </br>1 CMEM enabled.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BYP_BFN : 1;
    ///< 0: Do not bypass BFN for send enable     </br>1: Bypass BFN for send
    ///< enable.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t BFN_SRC : 2;
    ///< 00: default - cmem bfn will be used.        </br>01: Use swg bfn for
    ///< send enable.  Timing aligns SWG and CMEM data.     </br>10: Use alternate
    ///< cmem bfn for send enable.  Timing aligns CMEM0 and CMEM1 data.
    ///< </br>11: RESERVED.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t MEM_PD : 1;
    ///< 0 Memory active.                                    </br>1  Memory
    ///< powered down.  Any access to the RAM will fail.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_reg_t;

#define CMEM_CFG_DEFAULT (0x00000010U)
#define CMEM_CFG_RD_MASK (0x0000001fU)
#define CMEM_CFG_WR_MASK (0x0000001fU)


///< 0 CMEM disabled                                   </br>1 CMEM enabled.
#define CMEM_CFG_EN_BF_OFF ( 0)
#define CMEM_CFG_EN_BF_WID ( 1)
#define CMEM_CFG_EN_BF_MSK (0x00000001)
#define CMEM_CFG_EN_BF_DEF (0x00000000)

///< 0: Do not bypass BFN for send enable     </br>1: Bypass BFN for send
///< enable.
#define CMEM_CFG_BYP_BFN_BF_OFF ( 1)
#define CMEM_CFG_BYP_BFN_BF_WID ( 1)
#define CMEM_CFG_BYP_BFN_BF_MSK (0x00000002)
#define CMEM_CFG_BYP_BFN_BF_DEF (0x00000000)

///< 00: default - cmem bfn will be used.        </br>01: Use swg bfn for
///< send enable.  Timing aligns SWG and CMEM data.     </br>10: Use alternate
///< cmem bfn for send enable.  Timing aligns CMEM0 and CMEM1 data.
///< </br>11: RESERVED.
#define CMEM_CFG_BFN_SRC_BF_OFF ( 2)
#define CMEM_CFG_BFN_SRC_BF_WID ( 2)
#define CMEM_CFG_BFN_SRC_BF_MSK (0x0000000C)
#define CMEM_CFG_BFN_SRC_BF_DEF (0x00000000)

///< 0 Memory active.                                    </br>1  Memory
///< powered down.  Any access to the RAM will fail.
#define CMEM_CFG_MEM_PD_BF_OFF ( 4)
#define CMEM_CFG_MEM_PD_BF_WID ( 1)
#define CMEM_CFG_MEM_PD_BF_MSK (0x00000010)
#define CMEM_CFG_MEM_PD_BF_DEF (0x00000010)


/** @brief CMEM_CFG_CMEM_CFG_MAP_START register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/START
  * Start address register.
  */

typedef union {
  struct {
    uint32_t ADDR : 12;
    ///< Address.  Note: Loops require the start and end pointers to have an
    ///< even number of steps for each loop.  (i.e.  end pointer  -  start
    ///< pointer  = odd number)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_start_reg_t;

#define CMEM_CFG_START_DEFAULT (0x00000000U)
#define CMEM_CFG_START_RD_MASK (0x00000fffU)
#define CMEM_CFG_START_WR_MASK (0x00000fffU)


///< Address.  Note: Loops require the start and end pointers to have an
///< even number of steps for each loop.  (i.e.  end pointer  -  start
///< pointer  = odd number)
#define CMEM_CFG_START_ADDR_BF_OFF ( 0)
#define CMEM_CFG_START_ADDR_BF_WID (12)
#define CMEM_CFG_START_ADDR_BF_MSK (0x00000FFF)
#define CMEM_CFG_START_ADDR_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_END register description at address offset 0xc
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/END
  * End address register.
  */

typedef union {
  struct {
    uint32_t ADDR : 12;
    ///< Address.  Note: Loops require the start and end pointers to have an
    ///< even number of steps for each loop.  (i.e.  end pointer  -  start
    ///< pointer  = odd number)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_end_reg_t;

#define CMEM_CFG_END_DEFAULT (0x00000000U)
#define CMEM_CFG_END_RD_MASK (0x00000fffU)
#define CMEM_CFG_END_WR_MASK (0x00000fffU)


///< Address.  Note: Loops require the start and end pointers to have an
///< even number of steps for each loop.  (i.e.  end pointer  -  start
///< pointer  = odd number)
#define CMEM_CFG_END_ADDR_BF_OFF ( 0)
#define CMEM_CFG_END_ADDR_BF_WID (12)
#define CMEM_CFG_END_ADDR_BF_MSK (0x00000FFF)
#define CMEM_CFG_END_ADDR_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_CUR register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/CUR
  * Current address register.
  */

typedef union {
  struct {
    uint32_t ADDR : 12;
    ///< Address.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_cur_reg_t;

#define CMEM_CFG_CUR_DEFAULT (0x00000000U)
#define CMEM_CFG_CUR_RD_MASK (0x00000fffU)
#define CMEM_CFG_CUR_WR_MASK (0x00000000U)


///< Address.
#define CMEM_CFG_CUR_ADDR_BF_OFF ( 0)
#define CMEM_CFG_CUR_ADDR_BF_WID (12)
#define CMEM_CFG_CUR_ADDR_BF_MSK (0x00000FFF)
#define CMEM_CFG_CUR_ADDR_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_MODE register description at address offset 0x14
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/MODE
  * State machine mode register.
  */

typedef union {
  struct {
    uint32_t MODE : 2;
    ///< 00: Data sent from data RAM from start pointer to end pointer only
    ///< once.                                   </br>01: Data sent from data
    ///< RAM. Will loopback to start pointer when end pointer is reached and
    ///< repeat loop has reached its value.
    ///< </br>10: Data sent from data RAM. Will loopback continuously from
    ///< start pointer to end pointer.                                   </br>11:
    ///< Data sent from data RAM. Will loopback to start pointer when end pointer
    ///< is reached and repeat loop has reached its value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NOREPEAT : 12;
    ///< Number of repeats.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_mode_reg_t;

#define CMEM_CFG_MODE_DEFAULT (0x00000000U)
#define CMEM_CFG_MODE_RD_MASK (0x00003fffU)
#define CMEM_CFG_MODE_WR_MASK (0x00003fffU)


///< 00: Data sent from data RAM from start pointer to end pointer only
///< once.                                   </br>01: Data sent from data
///< RAM. Will loopback to start pointer when end pointer is reached and
///< repeat loop has reached its value.
///< </br>10: Data sent from data RAM. Will loopback continuously from
///< start pointer to end pointer.                                   </br>11:
///< Data sent from data RAM. Will loopback to start pointer when end pointer
///< is reached and repeat loop has reached its value.
#define CMEM_CFG_MODE_BF_OFF ( 0)
#define CMEM_CFG_MODE_BF_WID ( 2)
#define CMEM_CFG_MODE_BF_MSK (0x00000003)
#define CMEM_CFG_MODE_BF_DEF (0x00000000)

///< Number of repeats.
#define CMEM_CFG_MODE_NOREPEAT_BF_OFF ( 2)
#define CMEM_CFG_MODE_NOREPEAT_BF_WID (12)
#define CMEM_CFG_MODE_NOREPEAT_BF_MSK (0x00003FFC)
#define CMEM_CFG_MODE_NOREPEAT_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_LFSR_SEED register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/LFSR_SEED
  * LFSR seed register.
  */

typedef union {
  struct {
    uint32_t SEED : 32;
    ///< A 32 bit LFSR can be used by hardware to auto-populate
    ///< </br> the RAM contents for test purposes.  LFSR seed defines
    ///< </br> the initial value of the LFSR. Data will      </br> be written
    ///< to the RAM in 4 byte chunks.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cmem_cfg_lfsr_seed_reg_t;

#define CMEM_CFG_LFSR_SEED_DEFAULT (0x00000000U)
#define CMEM_CFG_LFSR_SEED_RD_MASK (0xffffffffU)
#define CMEM_CFG_LFSR_SEED_WR_MASK (0xffffffffU)


///< A 32 bit LFSR can be used by hardware to auto-populate
///< </br> the RAM contents for test purposes.  LFSR seed defines
///< </br> the initial value of the LFSR. Data will      </br> be written
///< to the RAM in 4 byte chunks.
#define CMEM_CFG_LFSR_SEED_BF_OFF ( 0)
#define CMEM_CFG_LFSR_SEED_BF_WID (32)
#define CMEM_CFG_LFSR_SEED_BF_MSK (0xFFFFFFFF)
#define CMEM_CFG_LFSR_SEED_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_FIXED_PATTERN register description at address offset 0x1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/FIXED_PATTERN
  * Fixed pattern register.
  */

typedef union {
  struct {
    uint32_t FIXED : 32;
    ///< A 32 bit fixed pattern can be used by hardware to auto
    ///< </br> populate the RAM contents for test purposes.  Data will
    ///< </br> be written to the RAM in 4 byte chunks.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cmem_cfg_fixed_pattern_reg_t;

#define CMEM_CFG_FIXED_PATTERN_DEFAULT (0x00000000U)
#define CMEM_CFG_FIXED_PATTERN_RD_MASK (0xffffffffU)
#define CMEM_CFG_FIXED_PATTERN_WR_MASK (0xffffffffU)


///< A 32 bit fixed pattern can be used by hardware to auto
///< </br> populate the RAM contents for test purposes.  Data will
///< </br> be written to the RAM in 4 byte chunks.
#define CMEM_CFG_FIXED_PATTERN_FIXED_BF_OFF ( 0)
#define CMEM_CFG_FIXED_PATTERN_FIXED_BF_WID (32)
#define CMEM_CFG_FIXED_PATTERN_FIXED_BF_MSK (0xFFFFFFFF)
#define CMEM_CFG_FIXED_PATTERN_FIXED_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_RAMP_CFG register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/RAMP_CFG
  * Ramp configuration register.
  */

typedef union {
  struct {
    uint32_t RAMP_INIT : 4;
    ///< A ramp pattern can written to the RAM by the hardware
    ///< </br> for test purposes.  The ramp_init specifies the value
    ///< </br> to be written to the first 4 bit chunk.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RAMP_STEP : 4;
    ///< A ramp pattern can written to the RAM by the hardware
    ///< </br> for test purposes.  The ramp_step
    ///< </br> defines the value to be added/subtracted to prev value
    ///< </br> for each additional 4 bit chunk.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_ramp_cfg_reg_t;

#define CMEM_CFG_RAMP_CFG_DEFAULT (0x00000000U)
#define CMEM_CFG_RAMP_CFG_RD_MASK (0x000000ffU)
#define CMEM_CFG_RAMP_CFG_WR_MASK (0x000000ffU)


///< A ramp pattern can written to the RAM by the hardware
///< </br> for test purposes.  The ramp_init specifies the value
///< </br> to be written to the first 4 bit chunk.
#define CMEM_CFG_RAMP_CFG_RAMP_INIT_BF_OFF ( 0)
#define CMEM_CFG_RAMP_CFG_RAMP_INIT_BF_WID ( 4)
#define CMEM_CFG_RAMP_CFG_RAMP_INIT_BF_MSK (0x0000000F)
#define CMEM_CFG_RAMP_CFG_RAMP_INIT_BF_DEF (0x00000000)

///< A ramp pattern can written to the RAM by the hardware
///< </br> for test purposes.  The ramp_step
///< </br> defines the value to be added/subtracted to prev value
///< </br> for each additional 4 bit chunk.
#define CMEM_CFG_RAMP_CFG_RAMP_STEP_BF_OFF ( 4)
#define CMEM_CFG_RAMP_CFG_RAMP_STEP_BF_WID ( 4)
#define CMEM_CFG_RAMP_CFG_RAMP_STEP_BF_MSK (0x000000F0)
#define CMEM_CFG_RAMP_CFG_RAMP_STEP_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_INIT_RAM register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/INIT_RAM
  * Initialize RAM register.
  */

typedef union {
  struct {
    uint32_t INIT_MODE : 3;
    ///< 0: LFSR init                                  </br>1: Fixed pattern
    ///< </br>2: Addr pattern             </br>3: Incr ramp
    ///< </br>4: Decr ramp.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t INIT_INVERT : 1;
    ///< Invert initial pattern.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t INIT_LOOP : 1;
    ///< Continuous initial loop.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t INIT_START : 1;
    ///< Hardware initial start.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t INIT_DONE : 1;
    ///< Hardware initial done.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_init_ram_reg_t;

#define CMEM_CFG_INIT_RAM_DEFAULT (0x00000000U)
#define CMEM_CFG_INIT_RAM_RD_MASK (0x0000007fU)
#define CMEM_CFG_INIT_RAM_WR_MASK (0x0000003fU)


///< 0: LFSR init                                  </br>1: Fixed pattern
///< </br>2: Addr pattern             </br>3: Incr ramp
///< </br>4: Decr ramp.
#define CMEM_CFG_INIT_RAM_INIT_MODE_BF_OFF ( 0)
#define CMEM_CFG_INIT_RAM_INIT_MODE_BF_WID ( 3)
#define CMEM_CFG_INIT_RAM_INIT_MODE_BF_MSK (0x00000007)
#define CMEM_CFG_INIT_RAM_INIT_MODE_BF_DEF (0x00000000)

///< Invert initial pattern.
#define CMEM_CFG_INIT_RAM_INIT_INVERT_BF_OFF ( 3)
#define CMEM_CFG_INIT_RAM_INIT_INVERT_BF_WID ( 1)
#define CMEM_CFG_INIT_RAM_INIT_INVERT_BF_MSK (0x00000008)
#define CMEM_CFG_INIT_RAM_INIT_INVERT_BF_DEF (0x00000000)

///< Continuous initial loop.
#define CMEM_CFG_INIT_RAM_INIT_LOOP_BF_OFF ( 4)
#define CMEM_CFG_INIT_RAM_INIT_LOOP_BF_WID ( 1)
#define CMEM_CFG_INIT_RAM_INIT_LOOP_BF_MSK (0x00000010)
#define CMEM_CFG_INIT_RAM_INIT_LOOP_BF_DEF (0x00000000)

///< Hardware initial start.
#define CMEM_CFG_INIT_RAM_INIT_START_BF_OFF ( 5)
#define CMEM_CFG_INIT_RAM_INIT_START_BF_WID ( 1)
#define CMEM_CFG_INIT_RAM_INIT_START_BF_MSK (0x00000020)
#define CMEM_CFG_INIT_RAM_INIT_START_BF_DEF (0x00000000)

///< Hardware initial done.
#define CMEM_CFG_INIT_RAM_INIT_DONE_BF_OFF ( 6)
#define CMEM_CFG_INIT_RAM_INIT_DONE_BF_WID ( 1)
#define CMEM_CFG_INIT_RAM_INIT_DONE_BF_MSK (0x00000040)
#define CMEM_CFG_INIT_RAM_INIT_DONE_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_ERR_STATUS register description at address offset 0x28
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/ERR_STATUS
  * Memory error indication register. NON-ECC errors
  */

typedef union {
  struct {
    uint32_t MGMT_WR_ERR : 1;
    ///< Write access error.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t MGMT_RD_ERR : 1;
    ///< Read access error.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t INIT_ERR : 1;
    ///< Init access error.
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_err_stat_reg_t;

#define CMEM_CFG_ERR_STAT_DEFAULT (0x00000000U)
#define CMEM_CFG_ERR_STAT_RD_MASK (0x00000007U)
#define CMEM_CFG_ERR_STAT_WR_MASK (0x00000000U)


///< Write access error.
#define CMEM_CFG_ERR_STAT_MGMT_WR_ERR_BF_OFF ( 0)
#define CMEM_CFG_ERR_STAT_MGMT_WR_ERR_BF_WID ( 1)
#define CMEM_CFG_ERR_STAT_MGMT_WR_ERR_BF_MSK (0x00000001)
#define CMEM_CFG_ERR_STAT_MGMT_WR_ERR_BF_DEF (0x00000000)

///< Read access error.
#define CMEM_CFG_ERR_STAT_MGMT_RD_ERR_BF_OFF ( 1)
#define CMEM_CFG_ERR_STAT_MGMT_RD_ERR_BF_WID ( 1)
#define CMEM_CFG_ERR_STAT_MGMT_RD_ERR_BF_MSK (0x00000002)
#define CMEM_CFG_ERR_STAT_MGMT_RD_ERR_BF_DEF (0x00000000)

///< Init access error.
#define CMEM_CFG_ERR_STAT_INIT_ERR_BF_OFF ( 2)
#define CMEM_CFG_ERR_STAT_INIT_ERR_BF_WID ( 1)
#define CMEM_CFG_ERR_STAT_INIT_ERR_BF_MSK (0x00000004)
#define CMEM_CFG_ERR_STAT_INIT_ERR_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_INT_STATUS register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/INT_STATUS
  * CMEM Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t MGMT_WR_COLL : 1;
    ///< Indicates management write during memory machine initilization error
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t MGMT_RD_COLL : 1;
    ///< Indicates management read during memory machine initilization error
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t MEM_INIT_ERR : 1;
    ///< Indicates initilization error
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t CMEM_ECC_SBE : 1;
    ///< CMEM ECC Single Bit Error. This bit indicates that an ECC single-bit
    ///< error was detected when reading the CMEM. This is the OR'ed version
    ///< of register bits CMEM_ECC_ERR_STAT.ECC_SBE.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t CMEM_ECC_DBE : 1;
    ///< CMEM ECC Double/Multi Bit Error. This bit indicates that an ECC double/multi-bit
    ///< error was detected when reading the CMEM. This is the OR'ed version
    ///< of register bits CMEM_ECC_ERR_STAT.ECC_DBE.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t CMEM_ECC_SBE_CNT_OVFL : 1;
    ///< CMEM ECC SBE Count Overflow. This bit indicates that an ECC SBE count
    ///< overflow happened for CMEM. This is the OR'ed version of register
    ///< bits CMEM_ECC_ERR_STAT.ECC_SBE_CNT_OVFL.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_int_stat_reg_t;

#define CMEM_CFG_INT_STAT_DEFAULT (0x00000000U)
#define CMEM_CFG_INT_STAT_RD_MASK (0x0000003fU)
#define CMEM_CFG_INT_STAT_WR_MASK (0x00000000U)


///< Indicates management write during memory machine initilization error
#define CMEM_CFG_INT_STAT_MGMT_WR_COLL_BF_OFF ( 0)
#define CMEM_CFG_INT_STAT_MGMT_WR_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_STAT_MGMT_WR_COLL_BF_MSK (0x00000001)
#define CMEM_CFG_INT_STAT_MGMT_WR_COLL_BF_DEF (0x00000000)

///< Indicates management read during memory machine initilization error
#define CMEM_CFG_INT_STAT_MGMT_RD_COLL_BF_OFF ( 1)
#define CMEM_CFG_INT_STAT_MGMT_RD_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_STAT_MGMT_RD_COLL_BF_MSK (0x00000002)
#define CMEM_CFG_INT_STAT_MGMT_RD_COLL_BF_DEF (0x00000000)

///< Indicates initilization error
#define CMEM_CFG_INT_STAT_MEM_INIT_ERR_BF_OFF ( 2)
#define CMEM_CFG_INT_STAT_MEM_INIT_ERR_BF_WID ( 1)
#define CMEM_CFG_INT_STAT_MEM_INIT_ERR_BF_MSK (0x00000004)
#define CMEM_CFG_INT_STAT_MEM_INIT_ERR_BF_DEF (0x00000000)

///< CMEM ECC Single Bit Error. This bit indicates that an ECC single-bit
///< error was detected when reading the CMEM. This is the OR'ed version
///< of register bits CMEM_ECC_ERR_STAT.ECC_SBE.
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_BF_OFF ( 3)
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_BF_WID ( 1)
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_BF_MSK (0x00000008)
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_BF_DEF (0x00000000)

///< CMEM ECC Double/Multi Bit Error. This bit indicates that an ECC double/multi-bit
///< error was detected when reading the CMEM. This is the OR'ed version
///< of register bits CMEM_ECC_ERR_STAT.ECC_DBE.
#define CMEM_CFG_INT_STAT_CMEM_ECC_DBE_BF_OFF ( 4)
#define CMEM_CFG_INT_STAT_CMEM_ECC_DBE_BF_WID ( 1)
#define CMEM_CFG_INT_STAT_CMEM_ECC_DBE_BF_MSK (0x00000010)
#define CMEM_CFG_INT_STAT_CMEM_ECC_DBE_BF_DEF (0x00000000)

///< CMEM ECC SBE Count Overflow. This bit indicates that an ECC SBE count
///< overflow happened for CMEM. This is the OR'ed version of register
///< bits CMEM_ECC_ERR_STAT.ECC_SBE_CNT_OVFL.
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define CMEM_CFG_INT_STAT_CMEM_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_INT_HI_EN register description at address offset 0x44
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/INT_HI_EN
  * CMEM Interrupt High Enable Register
  */

typedef union {
  struct {
    uint32_t MGMT_WR_COLL : 1;
    ///< High Enable for  management write during memory machine initilization
    ///< error
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MGMT_RD_COLL : 1;
    ///< High Enable for  management read during memory machine initilization
    ///< error
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MEM_INIT_ERR : 1;
    ///< High Enable for  initilization error
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t HIGH_EN_CMEM_ECC_SBE : 1;
    ///< High Enable for CMEM ECC Single-bit Error.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t HIGH_EN_CMEM_ECC_DBE : 1;
    ///< High Enable for CMEM ECC Multi-bit Error.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t HIGH_EN_CMEM_ECC_SBE_CNT_OVFL : 1;
    ///< High Enable for CMEM ECC SBE Count Overflow.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_int_hi_en_reg_t;

#define CMEM_CFG_INT_HI_EN_DEFAULT (0x00000000U)
#define CMEM_CFG_INT_HI_EN_RD_MASK (0x0000003fU)
#define CMEM_CFG_INT_HI_EN_WR_MASK (0x0000003fU)


///< High Enable for  management write during memory machine initilization
///< error
#define CMEM_CFG_INT_HI_EN_MGMT_WR_COLL_BF_OFF ( 0)
#define CMEM_CFG_INT_HI_EN_MGMT_WR_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_HI_EN_MGMT_WR_COLL_BF_MSK (0x00000001)
#define CMEM_CFG_INT_HI_EN_MGMT_WR_COLL_BF_DEF (0x00000000)

///< High Enable for  management read during memory machine initilization
///< error
#define CMEM_CFG_INT_HI_EN_MGMT_RD_COLL_BF_OFF ( 1)
#define CMEM_CFG_INT_HI_EN_MGMT_RD_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_HI_EN_MGMT_RD_COLL_BF_MSK (0x00000002)
#define CMEM_CFG_INT_HI_EN_MGMT_RD_COLL_BF_DEF (0x00000000)

///< High Enable for  initilization error
#define CMEM_CFG_INT_HI_EN_MEM_INIT_ERR_BF_OFF ( 2)
#define CMEM_CFG_INT_HI_EN_MEM_INIT_ERR_BF_WID ( 1)
#define CMEM_CFG_INT_HI_EN_MEM_INIT_ERR_BF_MSK (0x00000004)
#define CMEM_CFG_INT_HI_EN_MEM_INIT_ERR_BF_DEF (0x00000000)

///< High Enable for CMEM ECC Single-bit Error.
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_BF_OFF ( 3)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_BF_WID ( 1)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_BF_MSK (0x00000008)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_BF_DEF (0x00000000)

///< High Enable for CMEM ECC Multi-bit Error.
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_DBE_BF_OFF ( 4)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_DBE_BF_WID ( 1)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_DBE_BF_MSK (0x00000010)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_DBE_BF_DEF (0x00000000)

///< High Enable for CMEM ECC SBE Count Overflow.
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define CMEM_CFG_INT_HI_EN_HIGH_EN_CMEM_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_INT_LO_EN register description at address offset 0x48
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/INT_LO_EN
  * CMEM Interrupt Low Enable Register
  */

typedef union {
  struct {
    uint32_t MGMT_WR_COLL : 1;
    ///< Low Enable for management write during memory machine initilization
    ///< error
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MGMT_RD_COLL : 1;
    ///< Low Enable for management read during memory machine initilization
    ///< error
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MEM_INIT_ERR : 1;
    ///< Low Enable for initilization error
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t LOW_EN_CMEM_ECC_SBE : 1;
    ///< Low Enable for CMEM ECC Single-bit Error.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LOW_EN_CMEM_ECC_DBE : 1;
    ///< Low Enable for CMEM ECC Multi-bit Error.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t LOW_EN_CMEM_ECC_SBE_CNT_OVFL : 1;
    ///< Low Enable for CMEM ECC SBE Count Overflow.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_int_lo_en_reg_t;

#define CMEM_CFG_INT_LO_EN_DEFAULT (0x00000000U)
#define CMEM_CFG_INT_LO_EN_RD_MASK (0x0000003fU)
#define CMEM_CFG_INT_LO_EN_WR_MASK (0x0000003fU)


///< Low Enable for management write during memory machine initilization
///< error
#define CMEM_CFG_INT_LO_EN_MGMT_WR_COLL_BF_OFF ( 0)
#define CMEM_CFG_INT_LO_EN_MGMT_WR_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_LO_EN_MGMT_WR_COLL_BF_MSK (0x00000001)
#define CMEM_CFG_INT_LO_EN_MGMT_WR_COLL_BF_DEF (0x00000000)

///< Low Enable for management read during memory machine initilization
///< error
#define CMEM_CFG_INT_LO_EN_MGMT_RD_COLL_BF_OFF ( 1)
#define CMEM_CFG_INT_LO_EN_MGMT_RD_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_LO_EN_MGMT_RD_COLL_BF_MSK (0x00000002)
#define CMEM_CFG_INT_LO_EN_MGMT_RD_COLL_BF_DEF (0x00000000)

///< Low Enable for initilization error
#define CMEM_CFG_INT_LO_EN_MEM_INIT_ERR_BF_OFF ( 2)
#define CMEM_CFG_INT_LO_EN_MEM_INIT_ERR_BF_WID ( 1)
#define CMEM_CFG_INT_LO_EN_MEM_INIT_ERR_BF_MSK (0x00000004)
#define CMEM_CFG_INT_LO_EN_MEM_INIT_ERR_BF_DEF (0x00000000)

///< Low Enable for CMEM ECC Single-bit Error.
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_BF_OFF ( 3)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_BF_WID ( 1)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_BF_MSK (0x00000008)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_BF_DEF (0x00000000)

///< Low Enable for CMEM ECC Multi-bit Error.
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_DBE_BF_OFF ( 4)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_DBE_BF_WID ( 1)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_DBE_BF_MSK (0x00000010)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_DBE_BF_DEF (0x00000000)

///< Low Enable for CMEM ECC SBE Count Overflow.
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define CMEM_CFG_INT_LO_EN_LOW_EN_CMEM_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_INT_CLEAR register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/INT_CLEAR
  * CMEM Interrupt Clear Register
  */

typedef union {
  struct {
    uint32_t MGMT_WR_COLL : 1;
    ///< Clear for management write during memory machine initilization error
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MGMT_RD_COLL : 1;
    ///< Clear for management read during memory machine initilization error
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MEM_INIT_ERR : 1;
    ///< Clear for initilization error
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CLEAR_CMEM_ECC_SBE : 1;
    ///< Clear for CMEM ECC Single-bit Error.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CLEAR_CMEM_ECC_DBE : 1;
    ///< Clear for CMEM ECC Multi-bit Error.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CLEAR_CMEM_ECC_SBE_CNT_OVFL : 1;
    ///< Clear for CMEM ECC SBE Count Overflow.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_int_clr_reg_t;

#define CMEM_CFG_INT_CLR_DEFAULT (0x00000000U)
#define CMEM_CFG_INT_CLR_RD_MASK (0x0000003fU)
#define CMEM_CFG_INT_CLR_WR_MASK (0x0000003fU)


///< Clear for management write during memory machine initilization error
#define CMEM_CFG_INT_CLR_MGMT_WR_COLL_BF_OFF ( 0)
#define CMEM_CFG_INT_CLR_MGMT_WR_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_CLR_MGMT_WR_COLL_BF_MSK (0x00000001)
#define CMEM_CFG_INT_CLR_MGMT_WR_COLL_BF_DEF (0x00000000)

///< Clear for management read during memory machine initilization error
#define CMEM_CFG_INT_CLR_MGMT_RD_COLL_BF_OFF ( 1)
#define CMEM_CFG_INT_CLR_MGMT_RD_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_CLR_MGMT_RD_COLL_BF_MSK (0x00000002)
#define CMEM_CFG_INT_CLR_MGMT_RD_COLL_BF_DEF (0x00000000)

///< Clear for initilization error
#define CMEM_CFG_INT_CLR_MEM_INIT_ERR_BF_OFF ( 2)
#define CMEM_CFG_INT_CLR_MEM_INIT_ERR_BF_WID ( 1)
#define CMEM_CFG_INT_CLR_MEM_INIT_ERR_BF_MSK (0x00000004)
#define CMEM_CFG_INT_CLR_MEM_INIT_ERR_BF_DEF (0x00000000)

///< Clear for CMEM ECC Single-bit Error.
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_BF_OFF ( 3)
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_BF_WID ( 1)
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_BF_MSK (0x00000008)
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_BF_DEF (0x00000000)

///< Clear for CMEM ECC Multi-bit Error.
#define CMEM_CFG_INT_CLR_CMEM_ECC_DBE_BF_OFF ( 4)
#define CMEM_CFG_INT_CLR_CMEM_ECC_DBE_BF_WID ( 1)
#define CMEM_CFG_INT_CLR_CMEM_ECC_DBE_BF_MSK (0x00000010)
#define CMEM_CFG_INT_CLR_CMEM_ECC_DBE_BF_DEF (0x00000000)

///< Clear for CMEM ECC SBE Count Overflow.
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define CMEM_CFG_INT_CLR_CMEM_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_INT_FORCE register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/INT_FORCE
  * CMEM Interrupt Force Register
  */

typedef union {
  struct {
    uint32_t MGMT_WR_COLL : 1;
    ///< Forces management write during memory machine initilization error
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MGMT_RD_COLL : 1;
    ///< Forces management read during memory machine initilization error
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MEM_INIT_ERR : 1;
    ///< Forces initilization error
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t FORCE_CMEM_ECC_SBE : 1;
    ///< Forces CMEM ECC Single-bit Error.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t FORCE_CMEM_ECC_DBE : 1;
    ///< Forces CMEM ECC Multi-bit Error.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t FORCE_CMEM_ECC_SBE_CNT_OVFL : 1;
    ///< Forces CMEM ECC SBE Count Overflow.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_int_force_reg_t;

#define CMEM_CFG_INT_FORCE_DEFAULT (0x00000000U)
#define CMEM_CFG_INT_FORCE_RD_MASK (0x0000003fU)
#define CMEM_CFG_INT_FORCE_WR_MASK (0x0000003fU)


///< Forces management write during memory machine initilization error
#define CMEM_CFG_INT_FORCE_MGMT_WR_COLL_BF_OFF ( 0)
#define CMEM_CFG_INT_FORCE_MGMT_WR_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_FORCE_MGMT_WR_COLL_BF_MSK (0x00000001)
#define CMEM_CFG_INT_FORCE_MGMT_WR_COLL_BF_DEF (0x00000000)

///< Forces management read during memory machine initilization error
#define CMEM_CFG_INT_FORCE_MGMT_RD_COLL_BF_OFF ( 1)
#define CMEM_CFG_INT_FORCE_MGMT_RD_COLL_BF_WID ( 1)
#define CMEM_CFG_INT_FORCE_MGMT_RD_COLL_BF_MSK (0x00000002)
#define CMEM_CFG_INT_FORCE_MGMT_RD_COLL_BF_DEF (0x00000000)

///< Forces initilization error
#define CMEM_CFG_INT_FORCE_MEM_INIT_ERR_BF_OFF ( 2)
#define CMEM_CFG_INT_FORCE_MEM_INIT_ERR_BF_WID ( 1)
#define CMEM_CFG_INT_FORCE_MEM_INIT_ERR_BF_MSK (0x00000004)
#define CMEM_CFG_INT_FORCE_MEM_INIT_ERR_BF_DEF (0x00000000)

///< Forces CMEM ECC Single-bit Error.
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_BF_OFF ( 3)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_BF_WID ( 1)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_BF_MSK (0x00000008)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_BF_DEF (0x00000000)

///< Forces CMEM ECC Multi-bit Error.
#define CMEM_CFG_INT_FORCE_CMEM_ECC_DBE_BF_OFF ( 4)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_DBE_BF_WID ( 1)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_DBE_BF_MSK (0x00000010)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_DBE_BF_DEF (0x00000000)

///< Forces CMEM ECC SBE Count Overflow.
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define CMEM_CFG_INT_FORCE_CMEM_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_CMEM_ECC_ERR_INFO[8] register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/CMEM_ECC_ERR_INFO
  * CMEM ECC Error Information Register
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 12;
    ///< ECC Error Address. This is the captured memory address of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE address. It can be cleared by ERR_CLR bit in the corresponding
    ///< CMEM_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ERR_SYNDROME : 8;
    ///< ECC Error Syndrome. This is the captured ECC syndrome of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE syndrome. It can be cleared by ERR_CLR bit in the corresponding
    ///< CMEM_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t SBE_COUNT : 4;
    ///< SBE Count. This is the value of the SBE counter, which doesn't roll
    ///< over and can be cleared by CNT_CLR bit in the corresponding CMEM_ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_ecc_err_info_reg_t;

#define CMEM_CFG_ECC_ERR_INFO_DEFAULT (0x00000000U)
#define CMEM_CFG_ECC_ERR_INFO_RD_MASK (0x00ffffffU)
#define CMEM_CFG_ECC_ERR_INFO_WR_MASK (0x00000000U)


///< ECC Error Address. This is the captured memory address of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE address. It can be cleared by ERR_CLR bit in the corresponding
///< CMEM_ECC_CTRL register.
#define CMEM_CFG_ECC_ERR_INFO_ERR_ADDR_BF_OFF ( 0)
#define CMEM_CFG_ECC_ERR_INFO_ERR_ADDR_BF_WID (12)
#define CMEM_CFG_ECC_ERR_INFO_ERR_ADDR_BF_MSK (0x00000FFF)
#define CMEM_CFG_ECC_ERR_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< ECC Error Syndrome. This is the captured ECC syndrome of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE syndrome. It can be cleared by ERR_CLR bit in the corresponding
///< CMEM_ECC_CTRL register.
#define CMEM_CFG_ECC_ERR_INFO_ERR_SYNDROME_BF_OFF (12)
#define CMEM_CFG_ECC_ERR_INFO_ERR_SYNDROME_BF_WID ( 8)
#define CMEM_CFG_ECC_ERR_INFO_ERR_SYNDROME_BF_MSK (0x000FF000)
#define CMEM_CFG_ECC_ERR_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< SBE Count. This is the value of the SBE counter, which doesn't roll
///< over and can be cleared by CNT_CLR bit in the corresponding CMEM_ECC_CTRL
///< register.
#define CMEM_CFG_ECC_ERR_INFO_SBE_CNT_BF_OFF (20)
#define CMEM_CFG_ECC_ERR_INFO_SBE_CNT_BF_WID ( 4)
#define CMEM_CFG_ECC_ERR_INFO_SBE_CNT_BF_MSK (0x00F00000)
#define CMEM_CFG_ECC_ERR_INFO_SBE_CNT_BF_DEF (0x00000000)
#define CMEM_CFG_ECC_ERR_INFO_ARR_SZ0 (8)
#define CMEM_CFG_ECC_ERR_INFO_ARRAY_STRIDE0 (0x0004)


/** @brief CMEM_CFG_CMEM_CFG_MAP_CMEM_ECC_CTRL[8] register description at address offset 0x74
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/CMEM_ECC_CTRL
  * CMEM ECC Control Register
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< Force Error Type. This bit indicates the type of ECC errors forced
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< Force Error. When set to 1, this bit enables to insert one ECC error
    ///< determined by FORCE_TYPE. It's automatically cleared when the expected
    ///< ECC error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< Error Clear. Writing this bit to 1 clears SBE, DBE, ERR_ADDR and ERR_SYNDROME
    ///< status and information of the correponding ecc slice. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< Count Clear. Writing this bit to 1 clears SBE_COUNT and SBE_CNT_OVFL
    ///< status and information of the corresponding ecc slice. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< Check and Correction Disable. When set, this bit disables ECC checking
    ///< and correction for the corresponding ecc slice. It's used for debug
    ///< and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< Generation Disable. When set, this bit disables ECC generation for
    ///< the corresponding ecc slice. It's used for debug and testing purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_ecc_ctrl_reg_t;

#define CMEM_CFG_ECC_CTRL_DEFAULT (0x00000000U)
#define CMEM_CFG_ECC_CTRL_RD_MASK (0x0000003fU)
#define CMEM_CFG_ECC_CTRL_WR_MASK (0x0000003fU)


///< Force Error Type. This bit indicates the type of ECC errors forced
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define CMEM_CFG_ECC_CTRL_FORCE_TYPE_BF_OFF ( 0)
#define CMEM_CFG_ECC_CTRL_FORCE_TYPE_BF_WID ( 1)
#define CMEM_CFG_ECC_CTRL_FORCE_TYPE_BF_MSK (0x00000001)
#define CMEM_CFG_ECC_CTRL_FORCE_TYPE_BF_DEF (0x00000000)

///< Force Error. When set to 1, this bit enables to insert one ECC error
///< determined by FORCE_TYPE. It's automatically cleared when the expected
///< ECC error is seen by hardware.
#define CMEM_CFG_ECC_CTRL_FORCE_ERR_BF_OFF ( 1)
#define CMEM_CFG_ECC_CTRL_FORCE_ERR_BF_WID ( 1)
#define CMEM_CFG_ECC_CTRL_FORCE_ERR_BF_MSK (0x00000002)
#define CMEM_CFG_ECC_CTRL_FORCE_ERR_BF_DEF (0x00000000)

///< Error Clear. Writing this bit to 1 clears SBE, DBE, ERR_ADDR and ERR_SYNDROME
///< status and information of the correponding ecc slice. This bit retains
///< the last written value.
#define CMEM_CFG_ECC_CTRL_ERR_CLR_BF_OFF ( 2)
#define CMEM_CFG_ECC_CTRL_ERR_CLR_BF_WID ( 1)
#define CMEM_CFG_ECC_CTRL_ERR_CLR_BF_MSK (0x00000004)
#define CMEM_CFG_ECC_CTRL_ERR_CLR_BF_DEF (0x00000000)

///< Count Clear. Writing this bit to 1 clears SBE_COUNT and SBE_CNT_OVFL
///< status and information of the corresponding ecc slice. This bit retains
///< the last written value.
#define CMEM_CFG_ECC_CTRL_CNT_CLR_BF_OFF ( 3)
#define CMEM_CFG_ECC_CTRL_CNT_CLR_BF_WID ( 1)
#define CMEM_CFG_ECC_CTRL_CNT_CLR_BF_MSK (0x00000008)
#define CMEM_CFG_ECC_CTRL_CNT_CLR_BF_DEF (0x00000000)

///< Check and Correction Disable. When set, this bit disables ECC checking
///< and correction for the corresponding ecc slice. It's used for debug
///< and testing purpose.
#define CMEM_CFG_ECC_CTRL_CHK_DIS_BF_OFF ( 4)
#define CMEM_CFG_ECC_CTRL_CHK_DIS_BF_WID ( 1)
#define CMEM_CFG_ECC_CTRL_CHK_DIS_BF_MSK (0x00000010)
#define CMEM_CFG_ECC_CTRL_CHK_DIS_BF_DEF (0x00000000)

///< Generation Disable. When set, this bit disables ECC generation for
///< the corresponding ecc slice. It's used for debug and testing purpose.
#define CMEM_CFG_ECC_CTRL_GEN_DIS_BF_OFF ( 5)
#define CMEM_CFG_ECC_CTRL_GEN_DIS_BF_WID ( 1)
#define CMEM_CFG_ECC_CTRL_GEN_DIS_BF_MSK (0x00000020)
#define CMEM_CFG_ECC_CTRL_GEN_DIS_BF_DEF (0x00000000)
#define CMEM_CFG_ECC_CTRL_ARR_SZ0 (8)
#define CMEM_CFG_ECC_CTRL_ARRAY_STRIDE0 (0x0004)


/** @brief CMEM_CFG_CMEM_CFG_MAP_CMEM_ECC_ERR_STAT register description at address offset 0x94
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/CMEM_ECC_ERR_STAT
  * CMEM ECC Error Status Register
  */

typedef union {
  struct {
    uint32_t SBE : 8;
    ///< ECC Single Bit Error. Each bit is for an ECC protected memory slice
    ///< in a CMEM, and when high, indicates an ECC single bit error was detected,
    ///< and can be cleared by ERR_CLR bit in corresponding CMEM_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 8;
    ///< ECC Double/Multi Bit Error. Each bit is for an ECC protected memory
    ///< slice in a CMEM, and when high, indicates an ECC double/multi bit
    ///< error was detected, and can be cleared by ERR_CLR bit in corresponding
    ///< CMEM_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 8;
    ///< SBE Count Overflow. Each bit is for an ECC protected memory slice
    ///< in a CMEM, and when high, indicates the SBE_COUNT[3:0] is overflowed.
    ///< It can be cleared by CNT_CLR bit in corresponding CMEM_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} cmem_cfg_ecc_err_stat_reg_t;

#define CMEM_CFG_ECC_ERR_STAT_DEFAULT (0x00000000U)
#define CMEM_CFG_ECC_ERR_STAT_RD_MASK (0x00ffffffU)
#define CMEM_CFG_ECC_ERR_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. Each bit is for an ECC protected memory slice
///< in a CMEM, and when high, indicates an ECC single bit error was detected,
///< and can be cleared by ERR_CLR bit in corresponding CMEM_ECC_CTRL register.
#define CMEM_CFG_ECC_ERR_STAT_SBE_BF_OFF ( 0)
#define CMEM_CFG_ECC_ERR_STAT_SBE_BF_WID ( 8)
#define CMEM_CFG_ECC_ERR_STAT_SBE_BF_MSK (0x000000FF)
#define CMEM_CFG_ECC_ERR_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. Each bit is for an ECC protected memory
///< slice in a CMEM, and when high, indicates an ECC double/multi bit
///< error was detected, and can be cleared by ERR_CLR bit in corresponding
///< CMEM_ECC_CTRL register.
#define CMEM_CFG_ECC_ERR_STAT_DBE_BF_OFF ( 8)
#define CMEM_CFG_ECC_ERR_STAT_DBE_BF_WID ( 8)
#define CMEM_CFG_ECC_ERR_STAT_DBE_BF_MSK (0x0000FF00)
#define CMEM_CFG_ECC_ERR_STAT_DBE_BF_DEF (0x00000000)

///< SBE Count Overflow. Each bit is for an ECC protected memory slice
///< in a CMEM, and when high, indicates the SBE_COUNT[3:0] is overflowed.
///< It can be cleared by CNT_CLR bit in corresponding CMEM_ECC_CTRL register.
#define CMEM_CFG_ECC_ERR_STAT_SBE_CNT_OVFL_BF_OFF (16)
#define CMEM_CFG_ECC_ERR_STAT_SBE_CNT_OVFL_BF_WID ( 8)
#define CMEM_CFG_ECC_ERR_STAT_SBE_CNT_OVFL_BF_MSK (0x00FF0000)
#define CMEM_CFG_ECC_ERR_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief CMEM_CFG_CMEM_CFG_MAP_APB_BRIDGE_STATUS register description at address offset 0x98
  *
  * Register default value:        0x00010000
  * Register full path in IP: cmem_cfg/cmem_cfg_map/APB_BRIDGE_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW/L" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW/1S/V/L" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} cmem_cfg_apb_brdg_stat_reg_t;

#define CMEM_CFG_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define CMEM_CFG_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define CMEM_CFG_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define CMEM_CFG_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define CMEM_CFG_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define CMEM_CFG_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define CMEM_CFG_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define CMEM_CFG_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define CMEM_CFG_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define CMEM_CFG_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define CMEM_CFG_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define CMEM_CFG_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define CMEM_CFG_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define CMEM_CFG_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define CMEM_CFG_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define CMEM_CFG_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define CMEM_CFG_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define CMEM_CFG_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define CMEM_CFG_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define CMEM_CFG_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define CMEM_CFG_SCRATCH_REG(_BASE) ((cmem_cfg_scratch_reg_t*) CMEM_CFG_SCRATCH_ADR(_BASE))
#define CMEM_CFG_REG(_BASE) ((cmem_cfg_reg_t*) CMEM_CFG_ADR(_BASE))
#define CMEM_CFG_START_REG(_BASE) ((cmem_cfg_start_reg_t*) CMEM_CFG_START_ADR(_BASE))
#define CMEM_CFG_END_REG(_BASE) ((cmem_cfg_end_reg_t*) CMEM_CFG_END_ADR(_BASE))
#define CMEM_CFG_CUR_REG(_BASE) ((cmem_cfg_cur_reg_t*) CMEM_CFG_CUR_ADR(_BASE))
#define CMEM_CFG_MODE_REG(_BASE) ((cmem_cfg_mode_reg_t*) CMEM_CFG_MODE_ADR(_BASE))
#define CMEM_CFG_LFSR_SEED_REG(_BASE) ((cmem_cfg_lfsr_seed_reg_t*) CMEM_CFG_LFSR_SEED_ADR(_BASE))
#define CMEM_CFG_FIXED_PATTERN_REG(_BASE) ((cmem_cfg_fixed_pattern_reg_t*) CMEM_CFG_FIXED_PATTERN_ADR(_BASE))
#define CMEM_CFG_RAMP_CFG_REG(_BASE) ((cmem_cfg_ramp_cfg_reg_t*) CMEM_CFG_RAMP_CFG_ADR(_BASE))
#define CMEM_CFG_INIT_RAM_REG(_BASE) ((cmem_cfg_init_ram_reg_t*) CMEM_CFG_INIT_RAM_ADR(_BASE))
#define CMEM_CFG_ERR_STAT_REG(_BASE) ((cmem_cfg_err_stat_reg_t*) CMEM_CFG_ERR_STAT_ADR(_BASE))
#define CMEM_CFG_INT_STAT_REG(_BASE) ((cmem_cfg_int_stat_reg_t*) CMEM_CFG_INT_STAT_ADR(_BASE))
#define CMEM_CFG_INT_HI_EN_REG(_BASE) ((cmem_cfg_int_hi_en_reg_t*) CMEM_CFG_INT_HI_EN_ADR(_BASE))
#define CMEM_CFG_INT_LO_EN_REG(_BASE) ((cmem_cfg_int_lo_en_reg_t*) CMEM_CFG_INT_LO_EN_ADR(_BASE))
#define CMEM_CFG_INT_CLR_REG(_BASE) ((cmem_cfg_int_clr_reg_t*) CMEM_CFG_INT_CLR_ADR(_BASE))
#define CMEM_CFG_INT_FORCE_REG(_BASE) ((cmem_cfg_int_force_reg_t*) CMEM_CFG_INT_FORCE_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO0_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO0_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO1_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO1_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO2_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO2_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO3_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO3_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO4_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO4_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO5_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO5_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO6_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO6_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_INFO7_REG(_BASE) ((cmem_cfg_ecc_err_info_reg_t*) CMEM_CFG_ECC_ERR_INFO7_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL0_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL0_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL1_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL1_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL2_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL2_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL3_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL3_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL4_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL4_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL5_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL5_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL6_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL6_ADR(_BASE))
#define CMEM_CFG_ECC_CTRL7_REG(_BASE) ((cmem_cfg_ecc_ctrl_reg_t*) CMEM_CFG_ECC_CTRL7_ADR(_BASE))
#define CMEM_CFG_ECC_ERR_STAT_REG(_BASE) ((cmem_cfg_ecc_err_stat_reg_t*) CMEM_CFG_ECC_ERR_STAT_ADR(_BASE))
#define CMEM_CFG_APB_BRDG_STAT_REG(_BASE) ((cmem_cfg_apb_brdg_stat_reg_t*) CMEM_CFG_APB_BRDG_STAT_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    cmem_cfg_scratch_reg_t SCRATCH; /*< Address offset = 0x0 */
    cmem_cfg_reg_t CFG;    /*< Address offset = 0x4 */
    cmem_cfg_start_reg_t START;  /*< Address offset = 0x8 */
    cmem_cfg_end_reg_t END;    /*< Address offset = 0xc */
    cmem_cfg_cur_reg_t CUR;    /*< Address offset = 0x10 */
    cmem_cfg_mode_reg_t MODE;   /*< Address offset = 0x14 */
    cmem_cfg_lfsr_seed_reg_t LFSR_SEED; /*< Address offset = 0x18 */
    cmem_cfg_fixed_pattern_reg_t FIXED_PATTERN; /*< Address offset = 0x1c */
    cmem_cfg_ramp_cfg_reg_t RAMP_CFG; /*< Address offset = 0x20 */
    cmem_cfg_init_ram_reg_t INIT_RAM; /*< Address offset = 0x24 */
    cmem_cfg_err_stat_reg_t ERR_STAT; /*< Address offset = 0x28 */
    const uint8_t        reservedArea0 [20];  /*< Address offset = 0x2c */
    cmem_cfg_int_stat_reg_t INT_STAT; /*< Address offset = 0x40 */
    cmem_cfg_int_hi_en_reg_t INT_HI_EN; /*< Address offset = 0x44 */
    cmem_cfg_int_lo_en_reg_t INT_LO_EN; /*< Address offset = 0x48 */
    cmem_cfg_int_clr_reg_t INT_CLR; /*< Address offset = 0x4c */
    cmem_cfg_int_force_reg_t INT_FORCE; /*< Address offset = 0x50 */
    cmem_cfg_ecc_err_info_reg_t CMEM_ECC_ERR_INFO[8]; /*< Address offset = 0x54 */
    cmem_cfg_ecc_ctrl_reg_t CMEM_ECC_CTRL[8]; /*< Address offset = 0x74 */
    cmem_cfg_ecc_err_stat_reg_t CMEM_ECC_ERR_STAT; /*< Address offset = 0x94 */
    cmem_cfg_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x98 */
} cmem_cfg_t;     // size: 0x0050

// AddressSpace struct pointer
//
#define FB_ANT0_CMEM_CFG0  ((cmem_cfg_t*) FB_ANT0_CMEM_CFG0_BASE)
#define FB_ANT0_CMEM_CFG1  ((cmem_cfg_t*) FB_ANT0_CMEM_CFG1_BASE)
#define FB_ANT1_CMEM_CFG0  ((cmem_cfg_t*) FB_ANT1_CMEM_CFG0_BASE)
#define FB_ANT1_CMEM_CFG1  ((cmem_cfg_t*) FB_ANT1_CMEM_CFG1_BASE)

// ******************************************* /Address Space

#endif      // _CMEM_CFG_H_

