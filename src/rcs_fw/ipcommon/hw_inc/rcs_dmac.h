#ifndef _RCS_DMAC_H_
#define _RCS_DMAC_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define RCS_DMAC_BASE         ( 0x00270000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define RCS_DMAC_IDREG_OFFSET ( 0x00000000U )
#define RCS_DMAC_COMPVERREG_OFFSET ( 0x00000008U )
#define RCS_DMAC_CFGREG_OFFSET ( 0x00000010U )
#define RCS_DMAC_CHENREG_OFFSET ( 0x00000018U )
#define RCS_DMAC_INTSTATREG_OFFSET ( 0x00000030U )
#define RCS_DMAC_CMNREG_INTCLRREG_OFFSET ( 0x00000038U )
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_OFFSET ( 0x00000040U )
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_OFFSET ( 0x00000048U )
#define RCS_DMAC_CMNREG_INTSTATREG_OFFSET ( 0x00000050U )
#define RCS_DMAC_RSTREG_OFFSET ( 0x00000058U )
#define RCS_DMAC_CH1_SAR_OFFSET ( 0x00000100U )
#define RCS_DMAC_CH1_DAR_OFFSET ( 0x00000108U )
#define RCS_DMAC_CH1_BLK_TS_OFFSET ( 0x00000110U )
#define RCS_DMAC_CH1_CTL_OFFSET ( 0x00000118U )
#define RCS_DMAC_CH1_CFG_OFFSET ( 0x00000120U )
#define RCS_DMAC_CH1_LLP_OFFSET ( 0x00000128U )
#define RCS_DMAC_CH1_STATREG_OFFSET ( 0x00000130U )
#define RCS_DMAC_CH1_SWHSSRCREG_OFFSET ( 0x00000138U )
#define RCS_DMAC_CH1_SWHSDSTREG_OFFSET ( 0x00000140U )
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_OFFSET ( 0x00000148U )
#define RCS_DMAC_CH1_IDREG_OFFSET ( 0x00000150U )
#define RCS_DMAC_CH1_QOSREG_OFFSET ( 0x00000158U )
#define RCS_DMAC_CH1_INTSTAT_ENREG_OFFSET ( 0x00000180U )
#define RCS_DMAC_CH1_INTSTAT_OFFSET ( 0x00000188U )
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_OFFSET ( 0x00000190U )
#define RCS_DMAC_CH1_INTCLRREG_OFFSET ( 0x00000198U )
#define RCS_DMAC_CH1_CFG_EXTD_OFFSET ( 0x000001a0U )
#define RCS_DMAC_CH2_SAR_OFFSET ( 0x00000200U )
#define RCS_DMAC_CH2_DAR_OFFSET ( 0x00000208U )
#define RCS_DMAC_CH2_BLK_TS_OFFSET ( 0x00000210U )
#define RCS_DMAC_CH2_CTL_OFFSET ( 0x00000218U )
#define RCS_DMAC_CH2_CFG_OFFSET ( 0x00000220U )
#define RCS_DMAC_CH2_LLP_OFFSET ( 0x00000228U )
#define RCS_DMAC_CH2_STATREG_OFFSET ( 0x00000230U )
#define RCS_DMAC_CH2_SWHSSRCREG_OFFSET ( 0x00000238U )
#define RCS_DMAC_CH2_SWHSDSTREG_OFFSET ( 0x00000240U )
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_OFFSET ( 0x00000248U )
#define RCS_DMAC_CH2_IDREG_OFFSET ( 0x00000250U )
#define RCS_DMAC_CH2_QOSREG_OFFSET ( 0x00000258U )
#define RCS_DMAC_CH2_INTSTAT_ENREG_OFFSET ( 0x00000280U )
#define RCS_DMAC_CH2_INTSTAT_OFFSET ( 0x00000288U )
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_OFFSET ( 0x00000290U )
#define RCS_DMAC_CH2_INTCLRREG_OFFSET ( 0x00000298U )
#define RCS_DMAC_CH2_CFG_EXTD_OFFSET ( 0x000002a0U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define RCS_DMAC_IDREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_IDREG_OFFSET ) ))
#define RCS_DMAC_COMPVERREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_COMPVERREG_OFFSET ) ))
#define RCS_DMAC_CFGREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CFGREG_OFFSET ) ))
#define RCS_DMAC_CHENREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CHENREG_OFFSET ) ))
#define RCS_DMAC_INTSTATREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_INTSTATREG_OFFSET ) ))
#define RCS_DMAC_CMNREG_INTCLRREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CMNREG_INTCLRREG_OFFSET ) ))
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CMNREG_INTSTAT_ENREG_OFFSET ) ))
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CMNREG_INTSIGNAL_ENREG_OFFSET ) ))
#define RCS_DMAC_CMNREG_INTSTATREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CMNREG_INTSTATREG_OFFSET ) ))
#define RCS_DMAC_RSTREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_RSTREG_OFFSET ) ))
#define RCS_DMAC_CH1_SAR_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_SAR_OFFSET ) ))
#define RCS_DMAC_CH1_DAR_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_DAR_OFFSET ) ))
#define RCS_DMAC_CH1_BLK_TS_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_BLK_TS_OFFSET ) ))
#define RCS_DMAC_CH1_CTL_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_CTL_OFFSET ) ))
#define RCS_DMAC_CH1_CFG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_CFG_OFFSET ) ))
#define RCS_DMAC_CH1_LLP_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_LLP_OFFSET ) ))
#define RCS_DMAC_CH1_STATREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_STATREG_OFFSET ) ))
#define RCS_DMAC_CH1_SWHSSRCREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_SWHSSRCREG_OFFSET ) ))
#define RCS_DMAC_CH1_SWHSDSTREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_SWHSDSTREG_OFFSET ) ))
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_OFFSET ) ))
#define RCS_DMAC_CH1_IDREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_IDREG_OFFSET ) ))
#define RCS_DMAC_CH1_QOSREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_QOSREG_OFFSET ) ))
#define RCS_DMAC_CH1_INTSTAT_ENREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_INTSTAT_ENREG_OFFSET ) ))
#define RCS_DMAC_CH1_INTSTAT_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_INTSTAT_OFFSET ) ))
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_INTSIGNAL_ENREG_OFFSET ) ))
#define RCS_DMAC_CH1_INTCLRREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_INTCLRREG_OFFSET ) ))
#define RCS_DMAC_CH1_CFG_EXTD_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH1_CFG_EXTD_OFFSET ) ))
#define RCS_DMAC_CH2_SAR_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_SAR_OFFSET ) ))
#define RCS_DMAC_CH2_DAR_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_DAR_OFFSET ) ))
#define RCS_DMAC_CH2_BLK_TS_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_BLK_TS_OFFSET ) ))
#define RCS_DMAC_CH2_CTL_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_CTL_OFFSET ) ))
#define RCS_DMAC_CH2_CFG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_CFG_OFFSET ) ))
#define RCS_DMAC_CH2_LLP_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_LLP_OFFSET ) ))
#define RCS_DMAC_CH2_STATREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_STATREG_OFFSET ) ))
#define RCS_DMAC_CH2_SWHSSRCREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_SWHSSRCREG_OFFSET ) ))
#define RCS_DMAC_CH2_SWHSDSTREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_SWHSDSTREG_OFFSET ) ))
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_OFFSET ) ))
#define RCS_DMAC_CH2_IDREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_IDREG_OFFSET ) ))
#define RCS_DMAC_CH2_QOSREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_QOSREG_OFFSET ) ))
#define RCS_DMAC_CH2_INTSTAT_ENREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_INTSTAT_ENREG_OFFSET ) ))
#define RCS_DMAC_CH2_INTSTAT_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_INTSTAT_OFFSET ) ))
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_INTSIGNAL_ENREG_OFFSET ) ))
#define RCS_DMAC_CH2_INTCLRREG_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_INTCLRREG_OFFSET ) ))
#define RCS_DMAC_CH2_CFG_EXTD_ADR (( ( RCS_DMAC_BASE ) + ( RCS_DMAC_CH2_CFG_EXTD_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_IDREG register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_IDREG
  * DW_axi_dmac Component ID Register
  */

typedef union {
  struct {
    uint64_t DMAC_ID : 32;
    ///< DMAC ID Number.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_IDREG : 32;
    ///< DMAC_IDREG Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="32" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_idreg_reg_t;

#define RCS_DMAC_IDREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_IDREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_IDREG_WR_MASK (0x0000000000000000ULL)


///< DMAC ID Number.
#define RCS_DMAC_IDREG_DMAC_ID_BF_OFF ( 0)
#define RCS_DMAC_IDREG_DMAC_ID_BF_WID (32)
#define RCS_DMAC_IDREG_DMAC_ID_BF_MSK (0xFFFFFFFF)
#define RCS_DMAC_IDREG_DMAC_ID_BF_DEF (0x00000000)

///< DMAC_IDREG Reserved bits - Read Only
#define RCS_DMAC_IDREG_RSVD_DMAC_IDREG_BF_OFF (32)
#define RCS_DMAC_IDREG_RSVD_DMAC_IDREG_BF_WID (32)
#define RCS_DMAC_IDREG_RSVD_DMAC_IDREG_BF_MSK (0xFFFFFFFF00000000)
#define RCS_DMAC_IDREG_RSVD_DMAC_IDREG_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_COMPVERREG register description at address offset 0x8
  *
  * Register default value:        0x3230312A
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_COMPVERREG
  * DW_axi_dmac Component Version Register
  */

typedef union {
  struct {
    uint64_t DMAC_COMPVER : 32;
    ///< DMAC Component Version Number.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x3230312A"
    uint64_t RSVD_DMAC_COMPVERREG : 32;
    ///< DMAC_COMPVERREG Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="32" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_compverreg_reg_t;

#define RCS_DMAC_COMPVERREG_DEFAULT (0x000000003230312aULL)
#define RCS_DMAC_COMPVERREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_COMPVERREG_WR_MASK (0x0000000000000000ULL)


///< DMAC Component Version Number.
#define RCS_DMAC_COMPVERREG_DMAC_COMPVER_BF_OFF ( 0)
#define RCS_DMAC_COMPVERREG_DMAC_COMPVER_BF_WID (32)
#define RCS_DMAC_COMPVERREG_DMAC_COMPVER_BF_MSK (0xFFFFFFFF)
#define RCS_DMAC_COMPVERREG_DMAC_COMPVER_BF_DEF (0x3230312A)

///< DMAC_COMPVERREG Reserved bits - Read Only
#define RCS_DMAC_COMPVERREG_RSVD_DMAC_COMPVERREG_BF_OFF (32)
#define RCS_DMAC_COMPVERREG_RSVD_DMAC_COMPVERREG_BF_WID (32)
#define RCS_DMAC_COMPVERREG_RSVD_DMAC_COMPVERREG_BF_MSK (0xFFFFFFFF00000000)
#define RCS_DMAC_COMPVERREG_RSVD_DMAC_COMPVERREG_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_CFGREG register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_CFGREG
  * DW_axi_dmac Global Configuration Register
  */

typedef union {
  struct {
    uint64_t DMAC_EN : 1;
    ///< This bit is used to enable the DW_axi_dmac.  - 0: DW_axi_dmac disabled
    ///< - 1: DW_axi_dmac enabled Note: If this bit DMAC_EN bit is cleared
    ///< while any channel is still active, then this bit still returns 1 to
    ///< indicate that there are channels still active until DW_axi_dmac hardware
    ///< has terminated all activity on all channels, at which point this bit
    ///< returns zero (0).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint64_t INT_EN : 1;
    ///< This bit is used to globally enable the interrupt generation.  - 0:
    ///< DW_axi_dmac Interrupts are disabled  - 1: DW_axi_dmac Interrupt logic
    ///< is enabled.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint64_t RSVD_DMAC_CFGREG : 62;
    ///< DMAC_CFGREG Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_cfgreg_reg_t;

#define RCS_DMAC_CFGREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CFGREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CFGREG_WR_MASK (0x0000000000000003ULL)


///< This bit is used to enable the DW_axi_dmac.  - 0: DW_axi_dmac disabled
///< - 1: DW_axi_dmac enabled Note: If this bit DMAC_EN bit is cleared
///< while any channel is still active, then this bit still returns 1 to
///< indicate that there are channels still active until DW_axi_dmac hardware
///< has terminated all activity on all channels, at which point this bit
///< returns zero (0).
#define RCS_DMAC_CFGREG_DMAC_EN_BF_OFF ( 0)
#define RCS_DMAC_CFGREG_DMAC_EN_BF_WID ( 1)
#define RCS_DMAC_CFGREG_DMAC_EN_BF_MSK (0x00000001)
#define RCS_DMAC_CFGREG_DMAC_EN_BF_DEF (0x00000000)

///< This bit is used to globally enable the interrupt generation.  - 0:
///< DW_axi_dmac Interrupts are disabled  - 1: DW_axi_dmac Interrupt logic
///< is enabled.
#define RCS_DMAC_CFGREG_INT_EN_BF_OFF ( 1)
#define RCS_DMAC_CFGREG_INT_EN_BF_WID ( 1)
#define RCS_DMAC_CFGREG_INT_EN_BF_MSK (0x00000002)
#define RCS_DMAC_CFGREG_INT_EN_BF_DEF (0x00000000)

///< DMAC_CFGREG Reserved bits - Read Only
#define RCS_DMAC_CFGREG_RSVD_DMAC_CFGREG_BF_OFF ( 2)
#define RCS_DMAC_CFGREG_RSVD_DMAC_CFGREG_BF_WID (62)
#define RCS_DMAC_CFGREG_RSVD_DMAC_CFGREG_BF_MSK (0xFFFFFFFFFFFFFFFC)
#define RCS_DMAC_CFGREG_RSVD_DMAC_CFGREG_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_CHENREG register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_CHENREG
  * DW_axi_dmac Channel Enable Register
  */

typedef union {
  struct {
    uint64_t CH1_EN : 1;
    ///< This bit is used to enable the DW_axi_dmac Channel-1.  - 0: DW_axi_dmac
    ///< Channel-1 is disabled  - 1: DW_axi_dmac Channel-1 is enabled The bit
    ///< 'DMAC_ChEnReg.CH1_EN' is automatically cleared by hardware to disable
    ///< the channel after the last AMBA transfer of the DMA transfer to the
    ///< destination has completed. Software can therefore poll this bit to
    ///< determine when this channel is free for a new DMA transfer.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t CH2_EN : 1;
    ///< This bit is used to enable the DW_axi_dmac Channel-2.  - 0: DW_axi_dmac
    ///< Channel-2 is disabled  - 1: DW_axi_dmac Channel-2 is enabled The bit
    ///< 'DMAC_ChEnReg.CH2_EN' is automatically cleared by hardware to disable
    ///< the channel after the last AMBA transfer of the DMA transfer to the
    ///< destination has completed. Software can therefore poll this bit to
    ///< determine when this channel is free for a new DMA transfer.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHENREG_CH_EN : 6;
    ///< CH_EN Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint64_t CH1_EN_WE : 1;
    ///< DW_axi_dmac Channel-1 Enable Write Enable bit. Read back value of
    ///< this register bit is always '0'.
    ///< AccessType="WS/V" BitOffset="8" ResetValue="0x0"
    uint64_t CH2_EN_WE : 1;
    ///< DW_axi_dmac Channel-2 Enable Write Enable bit. Read back value of
    ///< this register bit is always '0'.
    ///< AccessType="WS/V" BitOffset="9" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHENREG_CH_WE_EN : 6;
    ///< CH_WE_EN Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint64_t CH1_SUSP : 1;
    ///< Channel-1 Suspend Request. Software sets this bit to 1 to request
    ///< channel suspend. If this bit is set to 1, DW_axi_dmac suspends all
    ///< DMA data transfers from the source gracefully until this bit is cleared.
    ///< There is no guarantee that the current dma transaction will complete.
    ///< This bit can also be used in conjunction with CH1_Status.CH_SUSPENDED
    ///< to cleanly disable the channel without losing any data. In this case,
    ///< software first sets CH1_SUSP bit to 1 and polls CH1_Status.CH_SUSPENDED
    ///< till it is set to 1. Software can then clear CH1_EN bit to 0 to disable
    ///< the channel.  - 0: No Channel Suspend Request.   - 1: Request for
    ///< Channel Suspend. Software can clear CH1_SUSP bit to 0, after DW_axi_dmac
    ///< sets CH1_Status.CH_SUSPENDED bit to 1, to exit the channel suspend
    ///< mode. Note: CH_SUSP is cleared when channel is disabled.
    ///< AccessType="RW/V" BitOffset="16" ResetValue="0x0"
    uint64_t CH2_SUSP : 1;
    ///< Channel-2 Suspend Request. Software sets this bit to 1 to request
    ///< channel suspend. If this bit is set to 1, DW_axi_dmac suspends all
    ///< DMA data transfers from the source gracefully until this bit is cleared.
    ///< There is no guarantee that the current dma transaction will complete.
    ///< This bit can also be used in conjunction with CH2_Status.CH_SUSPENDED
    ///< to cleanly disable the channel without losing any data. In this case,
    ///< software first sets CH2_SUSP bit to 1 and polls CH2_Status.CH_SUSPENDED
    ///< till it is set to 1. Software can then clear CH2_EN bit to 0 to disable
    ///< the channel.  - 0: No Channel Suspend Request.   - 1: Request for
    ///< Channel Suspend. Software can clear CH2_SUSP bit to 0, after DW_axi_dmac
    ///< sets CH2_Status.CH_SUSPENDED bit to 1, to exit the channel suspend
    ///< mode. Note: CH_SUSP is cleared when channel is disabled.
    ///< AccessType="RW/V" BitOffset="17" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHENREG_CH_SUSP : 6;
    ///< CH_SUSP Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint64_t CH1_SUSP_WE : 1;
    ///< This bit is used as a write enable to the Channel-1 Suspend bit. The
    ///< read back value of this register bit is always 0.
    ///< AccessType="WS/V" BitOffset="24" ResetValue="0x0"
    uint64_t CH2_SUSP_WE : 1;
    ///< This bit is used as a write enable to the Channel-2 Suspend bit. The
    ///< read back value of this register bit is always 0.
    ///< AccessType="WS/V" BitOffset="25" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHENREG_CH_SUSP_WE : 6;
    ///< CH_SUSP_WE Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint64_t CH1_ABORT : 1;
    ///< Channel-1 Terminate Request. Software sets this bit to 1 to request
    ///< channel terminate. If this bit is set to 1, DW_axi_dmac disables the
    ///< channel immediately. Terminating the channel might result in AXI Protocol
    ///< violation as DW_axi_dmac does not make sure that all AXI transfers
    ///< initiated on the manager interface are completed.Terminating the channel
    ///< is not recommended and should be used only in situations where a particular
    ///< channel hangs due to no response from the corresponding AXI manager
    ///< interface and software wants to disable the channel without resetting
    ///< the entire DW_axi_dmac. It is recommended to try channel disabling
    ///< first and then only opt for channel terminating.  - 0: No Channel
    ///< Terminate Request.   - 1: Request for Channel Terminate. DW_axi_dmac
    ///< clears this bit to 0 once the channel is terminated (when it sets
    ///< CH1_Status.CH_ABORTED bit to 1).
    ///< AccessType="RW/V" BitOffset="32" ResetValue="0x0"
    uint64_t CH2_ABORT : 1;
    ///< Channel-2 Terminate Request. Software sets this bit to 1 to request
    ///< channel terminate. If this bit is set to 1, DW_axi_dmac disables the
    ///< channel immediately. Terminating the channel might result in AXI Protocol
    ///< violation as DW_axi_dmac does not make sure that all AXI transfers
    ///< initiated on the manager interface are completed.Terminating the channel
    ///< is not recommended and should be used only in situations where a particular
    ///< channel hangs due to no response from the corresponding AXI manager
    ///< interface and software wants to disable the channel without resetting
    ///< the entire DW_axi_dmac. It is recommended to try channel disabling
    ///< first and then only opt for channel terminating.  - 0: No Channel
    ///< Terminate Request.   - 1: Request for Channel Terminate. DW_axi_dmac
    ///< clears this bit to 0 once the channel is terminated (when it sets
    ///< CH2_Status.CH_ABORTED bit to 1).
    ///< AccessType="RW/V" BitOffset="33" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHENREG_CH_ABORT : 6;
    ///< CH_ABORT Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="34" ResetValue="0x0"
    uint64_t CH1_ABORT_WE : 1;
    ///< This bit is used to write enable the Channel-1 Terminate bit. The
    ///< read back value of this register bit is always 0.
    ///< AccessType="WS/V" BitOffset="40" ResetValue="0x0"
    uint64_t CH2_ABORT_WE : 1;
    ///< This bit is used to write enable the Channel-2 Terminate bit. The
    ///< read back value of this register bit is always 0.
    ///< AccessType="WS/V" BitOffset="41" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHENREG_CH_ABORT_WE : 6;
    ///< CH_ABORT_WE Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="42" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHENREG : 16;
    ///< DMAC_CHENREG Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="48" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_chenreg_reg_t;

#define RCS_DMAC_CHENREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CHENREG_RD_MASK (0xfffffcfffcfffcffULL)
#define RCS_DMAC_CHENREG_WR_MASK (0x0000030303030303ULL)


///< This bit is used to enable the DW_axi_dmac Channel-1.  - 0: DW_axi_dmac
///< Channel-1 is disabled  - 1: DW_axi_dmac Channel-1 is enabled The bit
///< 'DMAC_ChEnReg.CH1_EN' is automatically cleared by hardware to disable
///< the channel after the last AMBA transfer of the DMA transfer to the
///< destination has completed. Software can therefore poll this bit to
///< determine when this channel is free for a new DMA transfer.
#define RCS_DMAC_CHENREG_CH1_EN_BF_OFF ( 0)
#define RCS_DMAC_CHENREG_CH1_EN_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH1_EN_BF_MSK (0x00000001)
#define RCS_DMAC_CHENREG_CH1_EN_BF_DEF (0x00000000)

///< This bit is used to enable the DW_axi_dmac Channel-2.  - 0: DW_axi_dmac
///< Channel-2 is disabled  - 1: DW_axi_dmac Channel-2 is enabled The bit
///< 'DMAC_ChEnReg.CH2_EN' is automatically cleared by hardware to disable
///< the channel after the last AMBA transfer of the DMA transfer to the
///< destination has completed. Software can therefore poll this bit to
///< determine when this channel is free for a new DMA transfer.
#define RCS_DMAC_CHENREG_CH2_EN_BF_OFF ( 1)
#define RCS_DMAC_CHENREG_CH2_EN_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH2_EN_BF_MSK (0x00000002)
#define RCS_DMAC_CHENREG_CH2_EN_BF_DEF (0x00000000)

///< CH_EN Reserved bits - Read Only
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_EN_BF_OFF ( 2)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_EN_BF_WID ( 6)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_EN_BF_MSK (0x000000FC)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_EN_BF_DEF (0x00000000)

///< DW_axi_dmac Channel-1 Enable Write Enable bit. Read back value of
///< this register bit is always '0'.
#define RCS_DMAC_CHENREG_CH1_EN_WE_BF_OFF ( 8)
#define RCS_DMAC_CHENREG_CH1_EN_WE_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH1_EN_WE_BF_MSK (0x00000100)
#define RCS_DMAC_CHENREG_CH1_EN_WE_BF_DEF (0x00000000)

///< DW_axi_dmac Channel-2 Enable Write Enable bit. Read back value of
///< this register bit is always '0'.
#define RCS_DMAC_CHENREG_CH2_EN_WE_BF_OFF ( 9)
#define RCS_DMAC_CHENREG_CH2_EN_WE_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH2_EN_WE_BF_MSK (0x00000200)
#define RCS_DMAC_CHENREG_CH2_EN_WE_BF_DEF (0x00000000)

///< CH_WE_EN Reserved bits - Read Only
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_WE_EN_BF_OFF (10)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_WE_EN_BF_WID ( 6)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_WE_EN_BF_MSK (0x0000FC00)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_WE_EN_BF_DEF (0x00000000)

///< Channel-1 Suspend Request. Software sets this bit to 1 to request
///< channel suspend. If this bit is set to 1, DW_axi_dmac suspends all
///< DMA data transfers from the source gracefully until this bit is cleared.
///< There is no guarantee that the current dma transaction will complete.
///< This bit can also be used in conjunction with CH1_Status.CH_SUSPENDED
///< to cleanly disable the channel without losing any data. In this case,
///< software first sets CH1_SUSP bit to 1 and polls CH1_Status.CH_SUSPENDED
///< till it is set to 1. Software can then clear CH1_EN bit to 0 to disable
///< the channel.  - 0: No Channel Suspend Request.   - 1: Request for
///< Channel Suspend. Software can clear CH1_SUSP bit to 0, after DW_axi_dmac
///< sets CH1_Status.CH_SUSPENDED bit to 1, to exit the channel suspend
///< mode. Note: CH_SUSP is cleared when channel is disabled.
#define RCS_DMAC_CHENREG_CH1_SUSP_BF_OFF (16)
#define RCS_DMAC_CHENREG_CH1_SUSP_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH1_SUSP_BF_MSK (0x00010000)
#define RCS_DMAC_CHENREG_CH1_SUSP_BF_DEF (0x00000000)

///< Channel-2 Suspend Request. Software sets this bit to 1 to request
///< channel suspend. If this bit is set to 1, DW_axi_dmac suspends all
///< DMA data transfers from the source gracefully until this bit is cleared.
///< There is no guarantee that the current dma transaction will complete.
///< This bit can also be used in conjunction with CH2_Status.CH_SUSPENDED
///< to cleanly disable the channel without losing any data. In this case,
///< software first sets CH2_SUSP bit to 1 and polls CH2_Status.CH_SUSPENDED
///< till it is set to 1. Software can then clear CH2_EN bit to 0 to disable
///< the channel.  - 0: No Channel Suspend Request.   - 1: Request for
///< Channel Suspend. Software can clear CH2_SUSP bit to 0, after DW_axi_dmac
///< sets CH2_Status.CH_SUSPENDED bit to 1, to exit the channel suspend
///< mode. Note: CH_SUSP is cleared when channel is disabled.
#define RCS_DMAC_CHENREG_CH2_SUSP_BF_OFF (17)
#define RCS_DMAC_CHENREG_CH2_SUSP_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH2_SUSP_BF_MSK (0x00020000)
#define RCS_DMAC_CHENREG_CH2_SUSP_BF_DEF (0x00000000)

///< CH_SUSP Reserved bits - Read Only
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_BF_OFF (18)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_BF_WID ( 6)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_BF_MSK (0x00FC0000)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_BF_DEF (0x00000000)

///< This bit is used as a write enable to the Channel-1 Suspend bit. The
///< read back value of this register bit is always 0.
#define RCS_DMAC_CHENREG_CH1_SUSP_WE_BF_OFF (24)
#define RCS_DMAC_CHENREG_CH1_SUSP_WE_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH1_SUSP_WE_BF_MSK (0x01000000)
#define RCS_DMAC_CHENREG_CH1_SUSP_WE_BF_DEF (0x00000000)

///< This bit is used as a write enable to the Channel-2 Suspend bit. The
///< read back value of this register bit is always 0.
#define RCS_DMAC_CHENREG_CH2_SUSP_WE_BF_OFF (25)
#define RCS_DMAC_CHENREG_CH2_SUSP_WE_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH2_SUSP_WE_BF_MSK (0x02000000)
#define RCS_DMAC_CHENREG_CH2_SUSP_WE_BF_DEF (0x00000000)

///< CH_SUSP_WE Reserved bits - Read Only
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_WE_BF_OFF (26)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_WE_BF_WID ( 6)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_WE_BF_MSK (0xFC000000)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_SUSP_WE_BF_DEF (0x00000000)

///< Channel-1 Terminate Request. Software sets this bit to 1 to request
///< channel terminate. If this bit is set to 1, DW_axi_dmac disables the
///< channel immediately. Terminating the channel might result in AXI Protocol
///< violation as DW_axi_dmac does not make sure that all AXI transfers
///< initiated on the manager interface are completed.Terminating the channel
///< is not recommended and should be used only in situations where a particular
///< channel hangs due to no response from the corresponding AXI manager
///< interface and software wants to disable the channel without resetting
///< the entire DW_axi_dmac. It is recommended to try channel disabling
///< first and then only opt for channel terminating.  - 0: No Channel
///< Terminate Request.   - 1: Request for Channel Terminate. DW_axi_dmac
///< clears this bit to 0 once the channel is terminated (when it sets
///< CH1_Status.CH_ABORTED bit to 1).
#define RCS_DMAC_CHENREG_CH1_ABORT_BF_OFF (32)
#define RCS_DMAC_CHENREG_CH1_ABORT_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH1_ABORT_BF_MSK (0x100000000)
#define RCS_DMAC_CHENREG_CH1_ABORT_BF_DEF (0x00000000)

///< Channel-2 Terminate Request. Software sets this bit to 1 to request
///< channel terminate. If this bit is set to 1, DW_axi_dmac disables the
///< channel immediately. Terminating the channel might result in AXI Protocol
///< violation as DW_axi_dmac does not make sure that all AXI transfers
///< initiated on the manager interface are completed.Terminating the channel
///< is not recommended and should be used only in situations where a particular
///< channel hangs due to no response from the corresponding AXI manager
///< interface and software wants to disable the channel without resetting
///< the entire DW_axi_dmac. It is recommended to try channel disabling
///< first and then only opt for channel terminating.  - 0: No Channel
///< Terminate Request.   - 1: Request for Channel Terminate. DW_axi_dmac
///< clears this bit to 0 once the channel is terminated (when it sets
///< CH2_Status.CH_ABORTED bit to 1).
#define RCS_DMAC_CHENREG_CH2_ABORT_BF_OFF (33)
#define RCS_DMAC_CHENREG_CH2_ABORT_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH2_ABORT_BF_MSK (0x200000000)
#define RCS_DMAC_CHENREG_CH2_ABORT_BF_DEF (0x00000000)

///< CH_ABORT Reserved bits - Read Only
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_BF_OFF (34)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_BF_WID ( 6)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_BF_MSK (0xFC00000000)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_BF_DEF (0x00000000)

///< This bit is used to write enable the Channel-1 Terminate bit. The
///< read back value of this register bit is always 0.
#define RCS_DMAC_CHENREG_CH1_ABORT_WE_BF_OFF (40)
#define RCS_DMAC_CHENREG_CH1_ABORT_WE_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH1_ABORT_WE_BF_MSK (0x10000000000)
#define RCS_DMAC_CHENREG_CH1_ABORT_WE_BF_DEF (0x00000000)

///< This bit is used to write enable the Channel-2 Terminate bit. The
///< read back value of this register bit is always 0.
#define RCS_DMAC_CHENREG_CH2_ABORT_WE_BF_OFF (41)
#define RCS_DMAC_CHENREG_CH2_ABORT_WE_BF_WID ( 1)
#define RCS_DMAC_CHENREG_CH2_ABORT_WE_BF_MSK (0x20000000000)
#define RCS_DMAC_CHENREG_CH2_ABORT_WE_BF_DEF (0x00000000)

///< CH_ABORT_WE Reserved bits - Read Only
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_WE_BF_OFF (42)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_WE_BF_WID ( 6)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_WE_BF_MSK (0xFC0000000000)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_CH_ABORT_WE_BF_DEF (0x00000000)

///< DMAC_CHENREG Reserved bits - Read Only
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_BF_OFF (48)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_BF_WID (16)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_BF_MSK (0xFFFF000000000000)
#define RCS_DMAC_CHENREG_RSVD_DMAC_CHENREG_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_INTSTATUSREG register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_INTSTATUSREG
  * DW_axi_dmac Combined Interrupt Status Register
  */

typedef union {
  struct {
    uint64_t CH1_INTSTAT : 1;
    ///< Channel 1 Interrupt Status Bit.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t CH2_INTSTAT : 1;
    ///< Channel 2 Interrupt Status Bit.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint64_t RSVD_DMAC_INTSTATUSREG_8TO1 : 6;
    ///< DMAC_INTSTATUSREG Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint64_t RSVD_DMAC_INTSTATUSREG : 8;
    ///< DMAC Interrupt Status Register (bits 15to8) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint64_t COMMONREG_INTSTAT : 1;
    ///< Common Register Interrupt Status Bit.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint64_t RSVD_DMAC_INTSTATUSREG_63TO17 : 47;
    ///< DMAC Interrupt Status Register (bits 63to17) Reserved bits - Read
    ///< Only
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_intstatreg_reg_t;

#define RCS_DMAC_INTSTATREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_INTSTATREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_INTSTATREG_WR_MASK (0x0000000000000000ULL)


///< Channel 1 Interrupt Status Bit.
#define RCS_DMAC_INTSTATREG_CH1_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_INTSTATREG_CH1_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_INTSTATREG_CH1_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_INTSTATREG_CH1_INTSTAT_BF_DEF (0x00000000)

///< Channel 2 Interrupt Status Bit.
#define RCS_DMAC_INTSTATREG_CH2_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_INTSTATREG_CH2_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_INTSTATREG_CH2_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_INTSTATREG_CH2_INTSTAT_BF_DEF (0x00000000)

///< DMAC_INTSTATUSREG Reserved bits - Read Only
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_8TO1_BF_OFF ( 2)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_8TO1_BF_WID ( 6)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_8TO1_BF_MSK (0x000000FC)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_8TO1_BF_DEF (0x00000000)

///< DMAC Interrupt Status Register (bits 15to8) Reserved bits - Read Only
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_BF_OFF ( 8)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_BF_WID ( 8)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_BF_MSK (0x0000FF00)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_BF_DEF (0x00000000)

///< Common Register Interrupt Status Bit.
#define RCS_DMAC_INTSTATREG_CMNREG_INTSTAT_BF_OFF (16)
#define RCS_DMAC_INTSTATREG_CMNREG_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_INTSTATREG_CMNREG_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_INTSTATREG_CMNREG_INTSTAT_BF_DEF (0x00000000)

///< DMAC Interrupt Status Register (bits 63to17) Reserved bits - Read
///< Only
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_63TO17_BF_OFF (17)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_63TO17_BF_WID (47)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_63TO17_BF_MSK (0xFFFFFFFFFFFE0000)
#define RCS_DMAC_INTSTATREG_RSVD_DMAC_INTSTATREG_63TO17_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_COMMONREG_INTCLEARREG register description at address offset 0x38
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_COMMONREG_INTCLEARREG
  * DW_axi_dmac Common Register Space Interrupt Clear Register
  */

typedef union {
  struct {
    uint64_t CLEAR_SLVIF_COMMONREG_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Decode Error Interrupt clear
    ///< Bit. This bit is used to clear the corresponding channel interrupt
    ///< status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_COMMONREG_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write to Read only Error Interrupt
    ///< clear Bit. This bit is used to clear the corresponding channel interrupt
    ///< status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="WS" BitOffset="1" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_COMMONREG_RD2WO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Read to Write only Error Interrupt
    ///< clear Bit. This bit is used to clear  the corresponding channel interrupt
    ///< status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="WS" BitOffset="2" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_COMMONREG_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write On Hold Error Interrupt
    ///< clear Bit. This bit is used to clear  the corresponding channel interrupt
    ///< status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="WS" BitOffset="3" ResetValue="0x0"
    uint64_t RSVD_DMAC_COMMONREG_INTCLEARREG_5TO4 : 2;
    ///< DMAC Common Register Interrupt Clear Register (bits 5to4). Reserved
    ///< bits - Write only
    ///< AccessType="WS" BitOffset="4" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_COMMONREG_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Address Parity Error Interrupt
    ///< clear Bit. This bit is used to clear the corresponding channel interrupt
    ///< status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="WS" BitOffset="6" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_COMMONREG_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write Parity Error Interrupt
    ///< clear Bit. This bit is used to clear the corresponding channel interrupt
    ///< status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="WS" BitOffset="7" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Undefined register Decode Error Interrupt clear
    ///< Bit. This bit is used to clear the corresponding channel interrupt
    ///< status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="WS" BitOffset="8" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_RCH0_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) ECC Protection related
    ///< Correctable Error Interrupt Clear bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="9" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Clear bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="10" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_RCH1_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
    ///< related Correctable Error Interrupt Clear bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="11" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
    ///< Protection related Uncorrectable Error Interrupt Clear bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="12" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_BCH_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel ECC Protection related
    ///< Correctable Error Interrupt Clear bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="13" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_BCH_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Clear bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="14" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_RCH0_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) ECC Protection related
    ///< Correctable Error Interrupt Clear bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="15" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Clear bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="16" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_RCH1_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
    ///< related Correctable Error Interrupt Clear bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="17" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC
    ///< Protection related Uncorrectable Error Interrupt Clear bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="18" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_BCH_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel ECC Protection related
    ///< Correctable Error Interrupt Clear bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="19" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_BCH_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Clear bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="20" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="21" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="22" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="23" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="24" ResetValue="0x0"
    uint64_t CLEAR_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="25" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="26" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="27" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="28" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="29" ResetValue="0x0"
    uint64_t CLEAR_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
    ///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
    ///< channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="WS" BitOffset="30" ResetValue="0x0"
    uint64_t RSVD_DMAC_COMMONREG_INTCLEARREG_63TO31 : 33;
    ///< DMAC Common Register Interrupt Clear Register (bits 63to31) Reserved
    ///< bits - Write Only
    ///< AccessType="WS" BitOffset="31" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_cmnreg_intclrreg_reg_t;

#define RCS_DMAC_CMNREG_INTCLRREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CMNREG_INTCLRREG_RD_MASK (0x0000000000000000ULL)
#define RCS_DMAC_CMNREG_INTCLRREG_WR_MASK (0xffffffffffffffffULL)


///< Register Bus Interface Common Register Decode Error Interrupt clear
///< Bit. This bit is used to clear the corresponding channel interrupt
///< status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Write to Read only Error Interrupt
///< clear Bit. This bit is used to clear the corresponding channel interrupt
///< status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Read to Write only Error Interrupt
///< clear Bit. This bit is used to clear  the corresponding channel interrupt
///< status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_OFF ( 2)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_MSK (0x00000004)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Write On Hold Error Interrupt
///< clear Bit. This bit is used to clear  the corresponding channel interrupt
///< status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Common Register Interrupt Clear Register (bits 5to4). Reserved
///< bits - Write only
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_5TO4_BF_OFF ( 4)
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_5TO4_BF_WID ( 2)
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_5TO4_BF_MSK (0x00000030)
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_5TO4_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Address Parity Error Interrupt
///< clear Bit. This bit is used to clear the corresponding channel interrupt
///< status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Write Parity Error Interrupt
///< clear Bit. This bit is used to clear the corresponding channel interrupt
///< status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Undefined register Decode Error Interrupt clear
///< Bit. This bit is used to clear the corresponding channel interrupt
///< status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Data) ECC Protection related
///< Correctable Error Interrupt Clear bit. This bit is used to clear the
///< corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
///< related Uncorrectable Error Interrupt Clear bit. This bit is used
///< to clear the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
///< related Correctable Error Interrupt Clear bit. This bit is used to
///< clear the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
///< Protection related Uncorrectable Error Interrupt Clear bit. This bit
///< is used to clear the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Response Channel ECC Protection related
///< Correctable Error Interrupt Clear bit. This bit is used to clear the
///< corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
///< related Uncorrectable Error Interrupt Clear bit. This bit is used
///< to clear the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Channel (Data) ECC Protection related
///< Correctable Error Interrupt Clear bit. This bit is used to clear the
///< corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_OFF (15)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_MSK (0x00008000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
///< related Uncorrectable Error Interrupt Clear bit. This bit is used
///< to clear the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
///< related Correctable Error Interrupt Clear bit. This bit is used to
///< clear the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC
///< Protection related Uncorrectable Error Interrupt Clear bit. This bit
///< is used to clear the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Response Channel ECC Protection related
///< Correctable Error Interrupt Clear bit. This bit is used to clear the
///< corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
///< related Uncorrectable Error Interrupt Clear bit. This bit is used
///< to clear the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_OFF (22)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_MSK (0x00400000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_OFF (23)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_MSK (0x00800000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_OFF (26)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_MSK (0x04000000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
///< related Error Interrupt Clear bit. This bit is used to clear the corresponding
///< channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CMNREG_INTCLRREG_CLR_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Common Register Interrupt Clear Register (bits 63to31) Reserved
///< bits - Write Only
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_63TO31_BF_OFF (31)
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_63TO31_BF_WID (33)
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_63TO31_BF_MSK (0xFFFFFFFF80000000)
#define RCS_DMAC_CMNREG_INTCLRREG_RSVD_DMAC_CMNREG_INTCLRREG_63TO31_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_COMMONREG_INTSTATUS_ENABLEREG register description at address offset 0x40
  *
  * Register default value:        0xFFFFFFFFFFFFFFFF
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_COMMONREG_INTSTATUS_ENABLEREG
  * DW_axi_dmac Common Register Space Interrupt Enable Register
  */

typedef union {
  struct {
    uint64_t ENABLE_SLVIF_COMMONREG_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Decode Error Interrupt Status
    ///< Enable Bit. This bit is used to enable the corresponding channel interrupt
    ///< status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write to Read only Error Interrupt
    ///< Status Enable Bit. This bit is used to enable the corresponding channel
    ///< interrupt status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_RD2WO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Read to Write only Error Interrupt
    ///< Status Enable Bit. This bit is used to enable the corresponding channel
    ///< interrupt status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write On Hold Error Interrupt
    ///< Status Enable Bit. This bit is used to enable the corresponding channel
    ///< interrupt status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint64_t RSVD_DMAC_COMMONREG_INTSTATUS_ENABLEREG_5TO4 : 2;
    ///< DMAC Common Register Interrupt Status Enable Register (bits 5to4).
    ///< Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="4" ResetValue="0x3"
    uint64_t ENABLE_SLVIF_COMMONREG_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Address Parity Error Interrupt
    ///< Status Enable Bit. This bit is used to enable the corresponding channel
    ///< interrupt status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write Parity Error Interrupt
    ///< Status Enable Bit. This bit is used to enable the corresponding channel
    ///< interrupt status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="RO" BitOffset="7" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Undefined register Decode Error Interrupt Status
    ///< enable Bit. This bit is used to enable the corresponding channel interrupt
    ///< status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH0_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="9" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="10" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH1_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
    ///< related Correctable Error Interrupt Status bit. This bit is used to
    ///< enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="11" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
    ///< Protection related Uncorrectable Error Interrupt Status bit. This
    ///< bit is used to enable the corresponding channel interrupt status bit
    ///< (MXIF1_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="12" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_BCH_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="13" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_BCH_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="14" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH0_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="15" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH1_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
    ///< related Correctable Error Interrupt Status bit. This bit is used to
    ///< enable the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="17" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC
    ///< Protection related Uncorrectable Error Interrupt Status bit. This
    ///< bit is used to enable the corresponding channel interrupt status bit
    ///< (MXIF2_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="18" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_BCH_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="19" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_BCH_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="20" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="21" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="22" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="23" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="24" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="25" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="26" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="27" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="28" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="29" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg).
    ///< AccessType="RO" BitOffset="30" ResetValue="0x1"
    uint64_t RSVD_DMAC_COMMONREG_INTSTATUS_ENABLEREG_63TO31 : 33;
    ///< DMAC Common Register Interrupt Status Enable Register (bits 63to31).
    ///< Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="31" ResetValue="0x1FFFFFFFF"
  } ;
  uint64_t value;
} rcs_dmac_cmnreg_intstat_enreg_reg_t;

#define RCS_DMAC_CMNREG_INTSTAT_ENREG_DEFAULT (0xffffffffffffffffULL)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_WR_MASK (0x000000000000010fULL)


///< Register Bus Interface Common Register Decode Error Interrupt Status
///< Enable Bit. This bit is used to enable the corresponding channel interrupt
///< status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_DEF (0x00000001)

///< Register Bus Interface Common Register Write to Read only Error Interrupt
///< Status Enable Bit. This bit is used to enable the corresponding channel
///< interrupt status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_DEF (0x00000002)

///< Register Bus Interface Common Register Read to Write only Error Interrupt
///< Status Enable Bit. This bit is used to enable the corresponding channel
///< interrupt status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_OFF ( 2)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_MSK (0x00000004)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_DEF (0x00000004)

///< Register Bus Interface Common Register Write On Hold Error Interrupt
///< Status Enable Bit. This bit is used to enable the corresponding channel
///< interrupt status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00000008)

///< DMAC Common Register Interrupt Status Enable Register (bits 5to4).
///< Reserved bits - Read Only
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_5TO4_BF_OFF ( 4)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_5TO4_BF_WID ( 2)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_5TO4_BF_MSK (0x00000030)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_5TO4_BF_DEF (0x00000030)

///< Register Bus Interface Common Register Address Parity Error Interrupt
///< Status Enable Bit. This bit is used to enable the corresponding channel
///< interrupt status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x00000040)

///< Register Bus Interface Common Register Write Parity Error Interrupt
///< Status Enable Bit. This bit is used to enable the corresponding channel
///< interrupt status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_DEF (0x00000080)

///< Register Bus Interface Undefined register Decode Error Interrupt Status
///< enable Bit. This bit is used to enable the corresponding channel interrupt
///< status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg.
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_DEF (0x00000100)

///< AXI Manager Interface 1 Read Channel (Data) ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_DEF (0x00000200)

///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000400)

///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
///< related Correctable Error Interrupt Status bit. This bit is used to
///< enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_DEF (0x00000800)

///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
///< Protection related Uncorrectable Error Interrupt Status bit. This
///< bit is used to enable the corresponding channel interrupt status bit
///< (MXIF1_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00001000)

///< AXI Manager Interface 1 Write Response Channel ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_DEF (0x00002000)

///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00004000)

///< AXI Manager Interface 2 Read Channel (Data) ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_OFF (15)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_MSK (0x00008000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_DEF (0x00008000)

///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00010000)

///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
///< related Correctable Error Interrupt Status bit. This bit is used to
///< enable the corresponding channel interrupt status bit (MXIF2_RCH1_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_DEF (0x00020000)

///< AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC
///< Protection related Uncorrectable Error Interrupt Status bit. This
///< bit is used to enable the corresponding channel interrupt status bit
///< (MXIF2_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00040000)

///< AXI Manager Interface 2 Write Response Channel ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_DEF (0x00080000)

///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00100000)

///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_DEF (0x00200000)

///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_OFF (22)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_MSK (0x00400000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_DEF (0x00400000)

///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_OFF (23)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_MSK (0x00800000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_DEF (0x00800000)

///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_DEF (0x01000000)

///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_DEF (0x02000000)

///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_OFF (26)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_MSK (0x04000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_DEF (0x04000000)

///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_DEF (0x08000000)

///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_DEF (0x10000000)

///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_DEF (0x20000000)

///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg).
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_DEF (0x40000000)

///< DMAC Common Register Interrupt Status Enable Register (bits 63to31).
///< Reserved bits - Read Only
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_63TO31_BF_OFF (31)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_63TO31_BF_WID (33)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_63TO31_BF_MSK (0xFFFFFFFF80000000)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_RSVD_DMAC_CMNREG_INTSTAT_ENREG_63TO31_BF_DEF (0xFFFFFFFF80000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_COMMONREG_INTSIGNAL_ENABLEREG register description at address offset 0x48
  *
  * Register default value:        0xFFFFFFFFFFFFFFFF
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_COMMONREG_INTSIGNAL_ENABLEREG
  * DW_axi_dmac Common Register Space Interrupt Signal Enable Register
  */

typedef union {
  struct {
    uint64_t ENABLE_SLVIF_COMMONREG_DEC_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Common Register Decode Error Interrupt Signal
    ///< Enable Bit. This bit is used to enable the propagation of corresponding
    ///< channel interrupt status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg)
    ///< to generate a port level interrupt.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_WR2RO_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Common Register Write to Read only Error Interrupt
    ///< Signal Enable Bit. This bit is used to enable the propagation of corresponding
    ///< channel interrupt status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in
    ///< DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_RD2WO_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Common Register Read to Write only Error Interrupt
    ///< Signal Enable Bit. This bit is used to enable the propagation of corresponding
    ///< channel interrupt status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in
    ///< DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_WRONHOLD_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Common Register Write On Hold Error Interrupt
    ///< Signal Enable Bit. This bit is used to enable the propagation of corresponding
    ///< channel interrupt status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint64_t RSVD_DMAC_COMMONREG_INTSIGNAL_ENABLEREG_5TO4 : 2;
    ///< DMAC Common Register Interrupt Signal Enable Register (bits 5to4).
    ///< Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="4" ResetValue="0x3"
    uint64_t ENABLE_SLVIF_COMMONREG_ADDRPARITY_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Address Parity Error Interrupt Signal Enable
    ///< Bit. This bit is used to enable the propagation of corresponding channel
    ///< interrupt status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg)
    ///< to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_COMMONREG_WRPARITY_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write Parity Error Interrupt Signal Enable
    ///< Bit. This bit is used to enable the propagation of corresponding channel
    ///< interrupt status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg)
    ///< to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="7" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_UNDEFINEDREG_DEC_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Undefined register Decode Error Interrupt Signal
    ///< Enable Bit. This bit is used to enable the propagation of corresponding
    ///< channel interrupt status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in
    ///< DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH0_PROT_CORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="9" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH0_PROT_UNCORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="10" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH1_PROT_CORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
    ///< related Correctable Error Interrupt Status bit. This bit is used to
    ///< enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="11" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH1_PROT_UNCORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
    ///< Protection related Uncorrectable Error Interrupt Status bit. This
    ///< bit is used to enable the corresponding channel interrupt status bit
    ///< (MXIF1_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg)
    ///< to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_BCH_PROT_CORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Write Response Channel ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="13" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_BCH_PROT_UNCORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="14" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH0_PROT_CORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="15" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH0_PROT_UNCORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH1_PROT_CORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
    ///< related Correctable Error Interrupt Status bit. This bit is used to
    ///< enable the corresponding channel interrupt status bit (MXIF2_RCHPROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="17" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH1_PROT_UNCORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC
    ///< Protection related Uncorrectable Error Interrupt Status bit. This
    ///< bit is used to enable the corresponding channel interrupt status bit
    ///< (MXIF2_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg)
    ///< to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="18" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_BCH_PROT_CORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Write Response Channel ECC Protection related
    ///< Correctable Error Interrupt Status bit. This bit is used to enable
    ///< the corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="19" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_BCH_PROT_UNCORRERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
    ///< related Uncorrectable Error Interrupt Status bit. This bit is used
    ///< to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="21" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="22" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_WCH_PROT_WREADY_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="23" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_RCH_PROT_RVALID_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x1"
    uint64_t ENABLE_MXIF1_BCH_PROT_BVALID_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="25" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="26" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="27" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_WCH_PROT_WREADY_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="28" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_RCH_PROT_RVALID_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="29" ResetValue="0x1"
    uint64_t ENABLE_MXIF2_BCH_PROT_BVALID_PARERR_INTSIGNAL : 1;
    ///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
    ///< related Error Interrupt Status bit. This bit is used to enable the
    ///< corresponding channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat
    ///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="30" ResetValue="0x1"
    uint64_t RSVD_DMAC_COMMONREG_INTSIGNAL_ENABLEREG_63TO31 : 33;
    ///< DMAC Common Register Interrupt Signal Enable Register (bits 63to31)
    ///< Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="31" ResetValue="0x1FFFFFFFF"
  } ;
  uint64_t value;
} rcs_dmac_cmnreg_intsignal_enreg_reg_t;

#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_DEFAULT (0xffffffffffffffffULL)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_WR_MASK (0x000000000000010fULL)


///< Register Bus Interface Common Register Decode Error Interrupt Signal
///< Enable Bit. This bit is used to enable the propagation of corresponding
///< channel interrupt status bit (SLVIF_CommonReg_DEC_ERR_IntStat in DMAC_CommonReg_IntStatusReg)
///< to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSIGNAL_BF_OFF ( 0)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSIGNAL_BF_MSK (0x00000001)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_DEC_ERR_INTSIGNAL_BF_DEF (0x00000001)

///< Register Bus Interface Common Register Write to Read only Error Interrupt
///< Signal Enable Bit. This bit is used to enable the propagation of corresponding
///< channel interrupt status bit (SLVIF_CommonReg_WR2RO_ERR_IntStat in
///< DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSIGNAL_BF_OFF ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSIGNAL_BF_MSK (0x00000002)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WR2RO_ERR_INTSIGNAL_BF_DEF (0x00000002)

///< Register Bus Interface Common Register Read to Write only Error Interrupt
///< Signal Enable Bit. This bit is used to enable the propagation of corresponding
///< channel interrupt status bit (SLVIF_CommonReg_RD2WO_ERR_IntStat in
///< DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSIGNAL_BF_OFF ( 2)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSIGNAL_BF_MSK (0x00000004)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_RD2WO_ERR_INTSIGNAL_BF_DEF (0x00000004)

///< Register Bus Interface Common Register Write On Hold Error Interrupt
///< Signal Enable Bit. This bit is used to enable the propagation of corresponding
///< channel interrupt status bit (SLVIF_CommonReg_WrOnHold_ERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSIGNAL_BF_OFF ( 3)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSIGNAL_BF_MSK (0x00000008)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRONHOLD_ERR_INTSIGNAL_BF_DEF (0x00000008)

///< DMAC Common Register Interrupt Signal Enable Register (bits 5to4).
///< Reserved bits - Read Only
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_5TO4_BF_OFF ( 4)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_5TO4_BF_WID ( 2)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_5TO4_BF_MSK (0x00000030)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_5TO4_BF_DEF (0x00000030)

///< Register Bus Interface Address Parity Error Interrupt Signal Enable
///< Bit. This bit is used to enable the propagation of corresponding channel
///< interrupt status bit (SLVIF_CommonReg_ADDRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg)
///< to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSIGNAL_BF_OFF ( 6)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSIGNAL_BF_MSK (0x00000040)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_ADDRPARITY_ERR_INTSIGNAL_BF_DEF (0x00000040)

///< Register Bus Interface Write Parity Error Interrupt Signal Enable
///< Bit. This bit is used to enable the propagation of corresponding channel
///< interrupt status bit (SLVIF_CommonReg_WRPARITY_ERR_IntStat in DMAC_CommonReg_IntStatusReg)
///< to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSIGNAL_BF_OFF ( 7)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSIGNAL_BF_MSK (0x00000080)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_CMNREG_WRPARITY_ERR_INTSIGNAL_BF_DEF (0x00000080)

///< Register Bus Interface Undefined register Decode Error Interrupt Signal
///< Enable Bit. This bit is used to enable the propagation of corresponding
///< channel interrupt status bit (SLVIF_UndefinedReg_DEC_ERR_IntStat in
///< DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSIGNAL_BF_OFF ( 8)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSIGNAL_BF_MSK (0x00000100)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_SLVIF_UNDEFINEDREG_DEC_ERR_INTSIGNAL_BF_DEF (0x00000100)

///< AXI Manager Interface 1 Read Channel (Data) ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSIGNAL_BF_OFF ( 9)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSIGNAL_BF_MSK (0x00000200)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_CORRERR_INTSIGNAL_BF_DEF (0x00000200)

///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF1_RCH0_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_OFF (10)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_MSK (0x00000400)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_DEF (0x00000400)

///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
///< related Correctable Error Interrupt Status bit. This bit is used to
///< enable the corresponding channel interrupt status bit (MXIF1_RCH1_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSIGNAL_BF_OFF (11)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSIGNAL_BF_MSK (0x00000800)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_CORRERR_INTSIGNAL_BF_DEF (0x00000800)

///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
///< Protection related Uncorrectable Error Interrupt Status bit. This
///< bit is used to enable the corresponding channel interrupt status bit
///< (MXIF1_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg)
///< to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_OFF (12)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_MSK (0x00001000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_DEF (0x00001000)

///< AXI Manager Interface 1 Write Response Channel ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF1_BCH_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSIGNAL_BF_OFF (13)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSIGNAL_BF_MSK (0x00002000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_CORRERR_INTSIGNAL_BF_DEF (0x00002000)

///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF1_BCH_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSIGNAL_BF_OFF (14)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSIGNAL_BF_MSK (0x00004000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_UNCORRERR_INTSIGNAL_BF_DEF (0x00004000)

///< AXI Manager Interface 2 Read Channel (Data) ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSIGNAL_BF_OFF (15)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSIGNAL_BF_MSK (0x00008000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_CORRERR_INTSIGNAL_BF_DEF (0x00008000)

///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF2_RCH0_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_OFF (16)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_MSK (0x00010000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH0_PROT_UNCORRERR_INTSIGNAL_BF_DEF (0x00010000)

///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
///< related Correctable Error Interrupt Status bit. This bit is used to
///< enable the corresponding channel interrupt status bit (MXIF2_RCHPROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSIGNAL_BF_OFF (17)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSIGNAL_BF_MSK (0x00020000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_CORRERR_INTSIGNAL_BF_DEF (0x00020000)

///< AXI Manager Interface 2 Read Channel (Other Control signals) Parity/ECC
///< Protection related Uncorrectable Error Interrupt Status bit. This
///< bit is used to enable the corresponding channel interrupt status bit
///< (MXIF2_RCH1_PROT_UnCorrERR_IntStat in DMAC_CommonReg_IntStatusReg)
///< to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_OFF (18)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_MSK (0x00040000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH1_PROT_UNCORRERR_INTSIGNAL_BF_DEF (0x00040000)

///< AXI Manager Interface 2 Write Response Channel ECC Protection related
///< Correctable Error Interrupt Status bit. This bit is used to enable
///< the corresponding channel interrupt status bit (MXIF2_BCH_PROT_CorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSIGNAL_BF_OFF (19)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSIGNAL_BF_MSK (0x00080000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_CORRERR_INTSIGNAL_BF_DEF (0x00080000)

///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
///< related Uncorrectable Error Interrupt Status bit. This bit is used
///< to enable the corresponding channel interrupt status bit (MXIF2_BCH_PROT_UnCorrERR_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSIGNAL_BF_OFF (20)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSIGNAL_BF_MSK (0x00100000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_UNCORRERR_INTSIGNAL_BF_DEF (0x00100000)

///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_ARCH_PROT_ARREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_OFF (21)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_MSK (0x00200000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_DEF (0x00200000)

///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_AWCH_PROT_AWREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_OFF (22)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_MSK (0x00400000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_DEF (0x00400000)

///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_WCH_PROT_WREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_OFF (23)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_MSK (0x00800000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_DEF (0x00800000)

///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_RCH_PROT_RVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_OFF (24)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_MSK (0x01000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_DEF (0x01000000)

///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF1_BCH_PROT_BVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_OFF (25)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_MSK (0x02000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF1_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_DEF (0x02000000)

///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_ARCH_PROT_ARREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_OFF (26)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_MSK (0x04000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSIGNAL_BF_DEF (0x04000000)

///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_AWCH_PROT_AWREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_OFF (27)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_MSK (0x08000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSIGNAL_BF_DEF (0x08000000)

///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_WCH_PROT_WREADY_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_OFF (28)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_MSK (0x10000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_WCH_PROT_WREADY_PARERR_INTSIGNAL_BF_DEF (0x10000000)

///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_RCH_PROT_RVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_OFF (29)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_MSK (0x20000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_RCH_PROT_RVALID_PARERR_INTSIGNAL_BF_DEF (0x20000000)

///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
///< related Error Interrupt Status bit. This bit is used to enable the
///< corresponding channel interrupt status bit (MXIF2_BCH_PROT_BVALID_ParErr_IntStat
///< in DMAC_CommonReg_IntStatusReg) to generate a port level interrupt.
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_OFF (30)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_MSK (0x40000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_EN_MXIF2_BCH_PROT_BVALID_PARERR_INTSIGNAL_BF_DEF (0x40000000)

///< DMAC Common Register Interrupt Signal Enable Register (bits 63to31)
///< Reserved bits - Read Only
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_63TO31_BF_OFF (31)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_63TO31_BF_WID (33)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_63TO31_BF_MSK (0xFFFFFFFF80000000)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_RSVD_DMAC_CMNREG_INTSIGNAL_ENREG_63TO31_BF_DEF (0xFFFFFFFF80000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_COMMONREG_INTSTATUSREG register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_COMMONREG_INTSTATUSREG
  * DW_axi_dmac Common Register Space Interrupt Status Register
  */

typedef union {
  struct {
    uint64_t SLVIF_COMMONREG_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Decode Error Interrupt Status
    ///< Bit. Decode Error generated by DW_axi_dmac during register access.
    ///< This error occurs if the register access is to an invalid address
    ///< in the common register space (0x000 to 0x0FF) resulting in error response
    ///< by DW_axi_dmac register bus interface.  - 0: No Register Bus Interface
    ///< Decode Errors.  - 1: Register Bus Interface Decode Error detected.
    ///< The Error Interrupt status is generated if the corresponding Status
    ///< Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set
    ///< to 1. This bit is cleared to 0 on writing 1 to the corresponding channel
    ///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG on enabling the
    ///< channel (required when the interrupt is not enabled).
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t SLVIF_COMMONREG_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write to Read Only Error Interrupt
    ///< Status bit. This error occurs if write operation is performed to a
    ///< Read Only register in the common register space (0x000 to 0x0FF).
    ///< - 0: No Register Bus Interface Write to Read Only Errors.  - 1: Register
    ///< Bus Interface Write to Read Only Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
    ///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
    ///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
    ///< on enabling the channel (required when the interrupt is not enabled).
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint64_t SLVIF_COMMONREG_RD2WO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Read to Write only Error Interrupt
    ///< Status bit. This error occurs if Read operation is performed to a
    ///< Write Only register in the common register space (0x000 to 0x0FF).
    ///< - 0: No Register Bus Interface Read to Write Only Errors.  - 1: Register
    ///< Bus Interface Read to Write Only Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
    ///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
    ///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
    ///< on enabling the channel (required when the interrupt is not enabled).
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint64_t SLVIF_COMMONREG_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write On Hold Error Interrupt
    ///< Status Bit. This error occurs if an illegal write operation is performed
    ///< on a common register; this happens if a write operation is performed
    ///< on a common register except DMAC_RESETREG with DMAC_RST field set
    ///< to 1 when DW_axi_dmac is in Hold mode.   - 0: No Register Bus Interface
    ///< Common Register Write On Hold Errors.  - 1: Register Bus Interface
    ///< Common Register Write On Hold Error detected. Error Interrupt Status
    ///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
    ///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
    ///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
    ///< on enabling the channel (required when the interrupt is not enabled).
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint64_t RSVD_DMAC_COMMONREG_INTSTATUSREG_5TO4 : 2;
    ///< DMAC Common Register Interrupt Status Register (bits 5to4) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint64_t SLVIF_COMMONREG_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Address Parity Error Interrupt
    ///< Status Bit. This error occurs if address is used to do write/read
    ///< operation to a register in the common register space, but the locally
    ///< computed parity bits not matching the received parity bits.   - 0:
    ///< No Common Register Space Address Parity Error.  - 1: Common Register
    ///< Space Address Parity Error detected. Error Interrupt Status is generated
    ///< if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
    ///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
    ///< the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
    ///< (required when the interrupt is not enabled.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint64_t SLVIF_COMMONREG_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Common Register Write Parity Error Interrupt
    ///< Status Bit. This error occurs if write operation with data and parity
    ///< is performed to a register in the common register space, but the locally
    ///< computed parity bits not matching the received parity bits.   - 0:
    ///< No Common Register Space Write Parity Error.  - 1: Common Register
    ///< Space Write Parity Error detected. Error Interrupt Status is generated
    ///< if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
    ///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
    ///< the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
    ///< (required when the interrupt is not enabled.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint64_t SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Undefined register Decode Error Interrupt Signal
    ///< Enable Bit. Decode Error generated by DW_axi_dmac during register
    ///< access. This error occurs if the register access is to undefined address
    ///< range (>0x8FF if 8 channels are configured, >0x4FF if 4 channels are
    ///< configured etc.) resulting in error response by DW_axi_dmac register
    ///< bus interface.   - 0: No Register Bus Interface Decode Errors.  -
    ///< 1: Register Bus Interface Decode Error detected. Error Interrupt Status
    ///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
    ///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
    ///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
    ///< on enabling the channel (required when the interrupt is not enabled).
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint64_t MXIF1_RCH0_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) ECC Protection Correctable
    ///< Error Interrupt Status bit.     This error occurs if ECC Correctable
    ///< error is detected on the AXI Channel Read Data payload.  - 0: No AXI
    ///< Manager 1 Read Channel Data related Correctable Error.  - 1: AXI Manager
    ///< 1 Read Channel Data related Correctable Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint64_t MXIF1_RCH0_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
    ///< Uncorrectable Error Interrupt Status bit.     This error occurs if
    ///< Parity/ECC Uncorrectable error is detected on the AXI Channel Read
    ///< Data payload.  - 0: No AXI Manager 1 Read Channel Data related Uncorrectable
    ///< Error.  - 1: AXI Manager 1 Read Channel Data related Uncorrectable
    ///< Error detected. Error Interrupt status is generated if the corresponding
    ///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
    ///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
    ///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint64_t MXIF1_RCH1_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
    ///< Correctable Error Interrupt Status bit.     This error occurs if ECC
    ///< Correctable error is detected on the AXI Channel Read Control payload.
    ///< - 0: No AXI Manager 1 Read Channel Control signals related Correctable
    ///< Error.  - 1: AXI Manager 1 Read Channel Control signals related Correctable
    ///< Error detected. Error Interrupt status is generated if the corresponding
    ///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
    ///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
    ///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint64_t MXIF1_RCH1_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
    ///< Protection Uncorrectable Error Interrupt Status bit.     This error
    ///< occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel
    ///< Read Control payload.   - 0: No AXI Manager 1 Read Channel Control
    ///< signals related Uncorrectable Error.  - 1: AXI Manager 1 Read Channel
    ///< Control signals related Uncorrectable Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint64_t MXIF1_BCH_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel ECC Protection Correctable
    ///< Error Interrupt Status bit.     This error occurs if ECC Correctable
    ///< error is detected on the AXI Channel Write Response payload.  - 0:
    ///< No AXI Manager 1 Write Response Channel Correctable Error.  - 1: AXI
    ///< Manager 1 Write Response Channel Correctable Error detected. Error
    ///< Interrupt status is generated if the corresponding Status Enable bit
    ///< in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit
    ///< is cleared to 0 on writing 1 to the corresponding interrupt clear
    ///< bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint64_t MXIF1_BCH_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
    ///< Uncorrectable Error Interrupt Status bit.     This error occurs if
    ///< Parity/ECC Uncorrectable error is detected on the AXI Channel Write
    ///< Response payload.  - 0: No AXI Manager 1 Write Response Channel Uncorrectable
    ///< Error.  - 1: AXI Manager 1 Write Response Channel Uncorrectable Error
    ///< detected. Error Interrupt status is generated if the corresponding
    ///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
    ///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
    ///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint64_t MXIF2_RCH0_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) ECC Protection Correctable
    ///< Error Interrupt Status bit.     This error occurs if ECC Correctable
    ///< error is detected on the AXI Channel Read Data payload.  - 0: No AXI
    ///< Manager 2 Read Channel Data related Correctable Error.  - 1: AXI Manager
    ///< 2 Read Channel Data related Correctable Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint64_t MXIF2_RCH0_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
    ///< Uncorrectable Error Interrupt Status bit.     This error occurs if
    ///< Parity/ECC Uncorrectable error is detected on the AXI Channel Read
    ///< Data payload.  - 0: No AXI Manager 2 Read Channel Data related Uncorrectable
    ///< Error.  - 1: AXI Manager 2 Read Channel Data related Uncorrectable
    ///< Error detected. Error Interrupt status is generated if the corresponding
    ///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
    ///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
    ///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint64_t MXIF2_RCH1_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
    ///< Correctable Error Interrupt Status bit.     This error occurs if ECC
    ///< Correctable error is detected on the AXI Channel Read Control payload.
    ///< - 0: No AXI Manager 2 Read Channel Control signals related Correctable
    ///< Error.  - 1: AXI Manager 2 Read Channel Control signals related Correctable
    ///< Error detected. Error Interrupt status is generated if the corresponding
    ///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
    ///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
    ///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint64_t MXIF2_RCH1_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
    ///< Protection Uncorrectable Error Interrupt Status bit.     This error
    ///< occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel
    ///< Read Control payload.   - 0: No AXI Manager 2 Read Channel Control
    ///< signals related Uncorrectable Error.  - 1: AXI Manager 2 Read Channel
    ///< Control signals related Uncorrectable Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint64_t MXIF2_BCH_PROT_CORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel ECC Protection Correctable
    ///< Error Interrupt Status bit.     This error occurs if ECC Correctable
    ///< error is detected on the AXI Channel Write Response payload.  - 0:
    ///< No AXI Manager 2 Write Response Channel Correctable Error.  - 1: AXI
    ///< Manager 2 Write Response Channel Correctable Error detected. Error
    ///< Interrupt status is generated if the corresponding Status Enable bit
    ///< in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit
    ///< is cleared to 0 on writing 1 to the corresponding interrupt clear
    ///< bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint64_t MXIF2_BCH_PROT_UNCORRERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
    ///< Uncorrectable Error Interrupt Status bit.     This error occurs if
    ///< Parity/ECC Uncorrectable error is detected on the AXI Channel Write
    ///< Response payload.  - 0: No AXI Manager 2 Write Response Channel Uncorrectable
    ///< Error.  - 1: AXI Manager 2 Write Response Channel Uncorrectable Error
    ///< detected. Error Interrupt status is generated if the corresponding
    ///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
    ///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
    ///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint64_t MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if ARREADY Parity
    ///< error is detected on the Read Address AXI Channel.  - 0: No AXI Manager
    ///< 1 Read Address Channel ARREADY Parity Error.  - 1: AXI Manager 1 Read
    ///< Address Channel ARREADY Parity Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint64_t MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if AWREADY Parity
    ///< error is detected on the Write Address AXI Channel.  - 0: No AXI Manager
    ///< 1 Write Address Channel AWREADY Parity Error.  - 1: AXI Manager 1
    ///< Write Address Channel AWREADY Parity Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if WREADY Parity
    ///< error is detected on the Write Data AXI Channel.  - 0: No AXI Manager
    ///< 1 Write Data Channel WREADY Parity Error.  - 1: AXI Manager 1 Write
    ///< Data Channel WREADY Parity Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="23" ResetValue="0x0"
    uint64_t MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if RVALID Parity
    ///< error is detected on the Read Data AXI Channel.  - 0: No AXI Manager
    ///< 1 Read Data Channel RVALID Parity Error.  - 1: AXI Manager 1 Read
    ///< Data Channel RVALID Parity Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint64_t MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if BVALID Parity
    ///< error is detected on the Write Response AXI Channel.  - 0: No AXI
    ///< Manager 1 Write Response Channel BVALID Parity Error.  - 1: AXI Manager
    ///< 1 Write Response Channel BVALID Parity Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint64_t MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if ARREADY Parity
    ///< error is detected on the Read Address AXI Channel.  - 0: No AXI Manager
    ///< 2 Read Address Channel ARREADY Parity Error.  - 1: AXI Manager 2 Read
    ///< Address Channel ARREADY Parity Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint64_t MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if AWREADY Parity
    ///< error is detected on the Write Address AXI Channel.  - 0: No AXI Manager
    ///< 2 Write Address Channel AWREADY Parity Error.  - 1: AXI Manager 2
    ///< Write Address Channel AWREADY Parity Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint64_t MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if WREADY Parity
    ///< error is detected on the Write Data AXI Channel.  - 0: No AXI Manager
    ///< 2 Write Data Channel WREADY Parity Error.  - 1: AXI Manager 2 Write
    ///< Data Channel WREADY Parity Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint64_t MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if RVALID Parity
    ///< error is detected on the Read Data AXI Channel.  - 0: No AXI Manager
    ///< 2 Read Data Channel RVALID Parity Error.  - 1: AXI Manager 2 Read
    ///< Data Channel RVALID Parity Error detected. Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint64_t MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT : 1;
    ///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
    ///< Error Interrupt Status bit.     This error occurs if BVALID Parity
    ///< error is detected on the Write Response AXI Channel.  - 0: No AXI
    ///< Manager 2 Write Response Channel BVALID Parity Error.  - 1: AXI Manager
    ///< 2 Write Response Channel BVALID Parity Error detected. Error Interrupt
    ///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint64_t RSVD_DMAC_COMMONREG_INTSTATUSREG_63TO31 : 33;
    ///< DMAC Common Register Interrupt Signal Enable Register (bits 63to31)
    ///< Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_cmnreg_intstatreg_reg_t;

#define RCS_DMAC_CMNREG_INTSTATREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CMNREG_INTSTATREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CMNREG_INTSTATREG_WR_MASK (0x0000000000000000ULL)


///< Register Bus Interface Common Register Decode Error Interrupt Status
///< Bit. Decode Error generated by DW_axi_dmac during register access.
///< This error occurs if the register access is to an invalid address
///< in the common register space (0x000 to 0x0FF) resulting in error response
///< by DW_axi_dmac register bus interface.  - 0: No Register Bus Interface
///< Decode Errors.  - 1: Register Bus Interface Decode Error detected.
///< The Error Interrupt status is generated if the corresponding Status
///< Enable bit in DMAC_CommonReg_IntStatus_Enable register bit is set
///< to 1. This bit is cleared to 0 on writing 1 to the corresponding channel
///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG on enabling the
///< channel (required when the interrupt is not enabled).
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Write to Read Only Error Interrupt
///< Status bit. This error occurs if write operation is performed to a
///< Read Only register in the common register space (0x000 to 0x0FF).
///< - 0: No Register Bus Interface Write to Read Only Errors.  - 1: Register
///< Bus Interface Write to Read Only Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
///< on enabling the channel (required when the interrupt is not enabled).
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WR2RO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Read to Write only Error Interrupt
///< Status bit. This error occurs if Read operation is performed to a
///< Write Only register in the common register space (0x000 to 0x0FF).
///< - 0: No Register Bus Interface Read to Write Only Errors.  - 1: Register
///< Bus Interface Read to Write Only Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
///< on enabling the channel (required when the interrupt is not enabled).
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_OFF ( 2)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_MSK (0x00000004)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_RD2WO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Write On Hold Error Interrupt
///< Status Bit. This error occurs if an illegal write operation is performed
///< on a common register; this happens if a write operation is performed
///< on a common register except DMAC_RESETREG with DMAC_RST field set
///< to 1 when DW_axi_dmac is in Hold mode.   - 0: No Register Bus Interface
///< Common Register Write On Hold Errors.  - 1: Register Bus Interface
///< Common Register Write On Hold Error detected. Error Interrupt Status
///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
///< on enabling the channel (required when the interrupt is not enabled).
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Common Register Interrupt Status Register (bits 5to4) Reserved
///< bits - Read Only
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_5TO4_BF_OFF ( 4)
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_5TO4_BF_WID ( 2)
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_5TO4_BF_MSK (0x00000030)
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_5TO4_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Address Parity Error Interrupt
///< Status Bit. This error occurs if address is used to do write/read
///< operation to a register in the common register space, but the locally
///< computed parity bits not matching the received parity bits.   - 0:
///< No Common Register Space Address Parity Error.  - 1: Common Register
///< Space Address Parity Error detected. Error Interrupt Status is generated
///< if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
///< the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
///< (required when the interrupt is not enabled.
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Common Register Write Parity Error Interrupt
///< Status Bit. This error occurs if write operation with data and parity
///< is performed to a register in the common register space, but the locally
///< computed parity bits not matching the received parity bits.   - 0:
///< No Common Register Space Write Parity Error.  - 1: Common Register
///< Space Write Parity Error detected. Error Interrupt Status is generated
///< if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
///< the corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
///< (required when the interrupt is not enabled.
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_CMNREG_WRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Undefined register Decode Error Interrupt Signal
///< Enable Bit. Decode Error generated by DW_axi_dmac during register
///< access. This error occurs if the register access is to undefined address
///< range (>0x8FF if 8 channels are configured, >0x4FF if 4 channels are
///< configured etc.) resulting in error response by DW_axi_dmac register
///< bus interface.   - 0: No Register Bus Interface Decode Errors.  -
///< 1: Register Bus Interface Decode Error detected. Error Interrupt Status
///< is generated if the corresponding Status Enable bit in DMAC_CommonReg_IntStatus_Enable
///< register bit is set to 1. This bit is cleared to 0 on writing 1 to
///< the corresponding channel interrupt clear bit in DMAC_COMMONREG_INTCLEARREG
///< on enabling the channel (required when the interrupt is not enabled).
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CMNREG_INTSTATREG_SLVIF_UNDEFINEDREG_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Data) ECC Protection Correctable
///< Error Interrupt Status bit.     This error occurs if ECC Correctable
///< error is detected on the AXI Channel Read Data payload.  - 0: No AXI
///< Manager 1 Read Channel Data related Correctable Error.  - 1: AXI Manager
///< 1 Read Channel Data related Correctable Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Data) Parity/ECC Protection
///< Uncorrectable Error Interrupt Status bit.     This error occurs if
///< Parity/ECC Uncorrectable error is detected on the AXI Channel Read
///< Data payload.  - 0: No AXI Manager 1 Read Channel Data related Uncorrectable
///< Error.  - 1: AXI Manager 1 Read Channel Data related Uncorrectable
///< Error detected. Error Interrupt status is generated if the corresponding
///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH0_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Other Control signals) ECC Protection
///< Correctable Error Interrupt Status bit.     This error occurs if ECC
///< Correctable error is detected on the AXI Channel Read Control payload.
///< - 0: No AXI Manager 1 Read Channel Control signals related Correctable
///< Error.  - 1: AXI Manager 1 Read Channel Control signals related Correctable
///< Error detected. Error Interrupt status is generated if the corresponding
///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
///< Protection Uncorrectable Error Interrupt Status bit.     This error
///< occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel
///< Read Control payload.   - 0: No AXI Manager 1 Read Channel Control
///< signals related Uncorrectable Error.  - 1: AXI Manager 1 Read Channel
///< Control signals related Uncorrectable Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH1_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Response Channel ECC Protection Correctable
///< Error Interrupt Status bit.     This error occurs if ECC Correctable
///< error is detected on the AXI Channel Write Response payload.  - 0:
///< No AXI Manager 1 Write Response Channel Correctable Error.  - 1: AXI
///< Manager 1 Write Response Channel Correctable Error detected. Error
///< Interrupt status is generated if the corresponding Status Enable bit
///< in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit
///< is cleared to 0 on writing 1 to the corresponding interrupt clear
///< bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Response Channel Parity/ECC Protection
///< Uncorrectable Error Interrupt Status bit.     This error occurs if
///< Parity/ECC Uncorrectable error is detected on the AXI Channel Write
///< Response payload.  - 0: No AXI Manager 1 Write Response Channel Uncorrectable
///< Error.  - 1: AXI Manager 1 Write Response Channel Uncorrectable Error
///< detected. Error Interrupt status is generated if the corresponding
///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Channel (Data) ECC Protection Correctable
///< Error Interrupt Status bit.     This error occurs if ECC Correctable
///< error is detected on the AXI Channel Read Data payload.  - 0: No AXI
///< Manager 2 Read Channel Data related Correctable Error.  - 1: AXI Manager
///< 2 Read Channel Data related Correctable Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_OFF (15)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_MSK (0x00008000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Channel (Data) Parity/ECC Protection
///< Uncorrectable Error Interrupt Status bit.     This error occurs if
///< Parity/ECC Uncorrectable error is detected on the AXI Channel Read
///< Data payload.  - 0: No AXI Manager 2 Read Channel Data related Uncorrectable
///< Error.  - 1: AXI Manager 2 Read Channel Data related Uncorrectable
///< Error detected. Error Interrupt status is generated if the corresponding
///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH0_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Channel (Other Control signals) ECC Protection
///< Correctable Error Interrupt Status bit.     This error occurs if ECC
///< Correctable error is detected on the AXI Channel Read Control payload.
///< - 0: No AXI Manager 2 Read Channel Control signals related Correctable
///< Error.  - 1: AXI Manager 2 Read Channel Control signals related Correctable
///< Error detected. Error Interrupt status is generated if the corresponding
///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Channel (Other Control signals) Parity/ECC
///< Protection Uncorrectable Error Interrupt Status bit.     This error
///< occurs if Parity/ECC Uncorrectable error is detected on the AXI Channel
///< Read Control payload.   - 0: No AXI Manager 2 Read Channel Control
///< signals related Uncorrectable Error.  - 1: AXI Manager 2 Read Channel
///< Control signals related Uncorrectable Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH1_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Response Channel ECC Protection Correctable
///< Error Interrupt Status bit.     This error occurs if ECC Correctable
///< error is detected on the AXI Channel Write Response payload.  - 0:
///< No AXI Manager 2 Write Response Channel Correctable Error.  - 1: AXI
///< Manager 2 Write Response Channel Correctable Error detected. Error
///< Interrupt status is generated if the corresponding Status Enable bit
///< in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is set to 1. This bit
///< is cleared to 0 on writing 1 to the corresponding interrupt clear
///< bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Response Channel Parity/ECC Protection
///< Uncorrectable Error Interrupt Status bit.     This error occurs if
///< Parity/ECC Uncorrectable error is detected on the AXI Channel Write
///< Response payload.  - 0: No AXI Manager 2 Write Response Channel Uncorrectable
///< Error.  - 1: AXI Manager 2 Write Response Channel Uncorrectable Error
///< detected. Error Interrupt status is generated if the corresponding
///< Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG register is
///< set to 1. This bit is cleared to 0 on writing 1 to the corresponding
///< interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Address Channel ARREADY Parity Protection
///< Error Interrupt Status bit.     This error occurs if ARREADY Parity
///< error is detected on the Read Address AXI Channel.  - 0: No AXI Manager
///< 1 Read Address Channel ARREADY Parity Error.  - 1: AXI Manager 1 Read
///< Address Channel ARREADY Parity Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Address Channel AWREADY Parity Protection
///< Error Interrupt Status bit.     This error occurs if AWREADY Parity
///< error is detected on the Write Address AXI Channel.  - 0: No AXI Manager
///< 1 Write Address Channel AWREADY Parity Error.  - 1: AXI Manager 1
///< Write Address Channel AWREADY Parity Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_OFF (22)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_MSK (0x00400000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Data Channel WREADY Parity Protection
///< Error Interrupt Status bit.     This error occurs if WREADY Parity
///< error is detected on the Write Data AXI Channel.  - 0: No AXI Manager
///< 1 Write Data Channel WREADY Parity Error.  - 1: AXI Manager 1 Write
///< Data Channel WREADY Parity Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_OFF (23)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_MSK (0x00800000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_WCH_PROT_WREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Read Data Channel RVALID Parity Protection
///< Error Interrupt Status bit.     This error occurs if RVALID Parity
///< error is detected on the Read Data AXI Channel.  - 0: No AXI Manager
///< 1 Read Data Channel RVALID Parity Error.  - 1: AXI Manager 1 Read
///< Data Channel RVALID Parity Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_RCH_PROT_RVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 1 Write Response Channel BVALID Parity Protection
///< Error Interrupt Status bit.     This error occurs if BVALID Parity
///< error is detected on the Write Response AXI Channel.  - 0: No AXI
///< Manager 1 Write Response Channel BVALID Parity Error.  - 1: AXI Manager
///< 1 Write Response Channel BVALID Parity Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF1_BCH_PROT_BVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Address Channel ARREADY Parity Protection
///< Error Interrupt Status bit.     This error occurs if ARREADY Parity
///< error is detected on the Read Address AXI Channel.  - 0: No AXI Manager
///< 2 Read Address Channel ARREADY Parity Error.  - 1: AXI Manager 2 Read
///< Address Channel ARREADY Parity Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_OFF (26)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_MSK (0x04000000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_ARCH_PROT_ARREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Address Channel AWREADY Parity Protection
///< Error Interrupt Status bit.     This error occurs if AWREADY Parity
///< error is detected on the Write Address AXI Channel.  - 0: No AXI Manager
///< 2 Write Address Channel AWREADY Parity Error.  - 1: AXI Manager 2
///< Write Address Channel AWREADY Parity Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_AWCH_PROT_AWREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Data Channel WREADY Parity Protection
///< Error Interrupt Status bit.     This error occurs if WREADY Parity
///< error is detected on the Write Data AXI Channel.  - 0: No AXI Manager
///< 2 Write Data Channel WREADY Parity Error.  - 1: AXI Manager 2 Write
///< Data Channel WREADY Parity Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_WCH_PROT_WREADY_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Read Data Channel RVALID Parity Protection
///< Error Interrupt Status bit.     This error occurs if RVALID Parity
///< error is detected on the Read Data AXI Channel.  - 0: No AXI Manager
///< 2 Read Data Channel RVALID Parity Error.  - 1: AXI Manager 2 Read
///< Data Channel RVALID Parity Error detected. Error Interrupt status
///< is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_RCH_PROT_RVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< AXI Manager Interface 2 Write Response Channel BVALID Parity Protection
///< Error Interrupt Status bit.     This error occurs if BVALID Parity
///< error is detected on the Write Response AXI Channel.  - 0: No AXI
///< Manager 2 Write Response Channel BVALID Parity Error.  - 1: AXI Manager
///< 2 Write Response Channel BVALID Parity Error detected. Error Interrupt
///< status is generated if the corresponding Status Enable bit in DMAC_COMMONREG_INTSTATUS_ENABLEREG
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in DMAC_COMMONREG_INTCLEARREG.
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CMNREG_INTSTATREG_MXIF2_BCH_PROT_BVALID_PARERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Common Register Interrupt Signal Enable Register (bits 63to31)
///< Reserved bits - Read Only
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_63TO31_BF_OFF (31)
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_63TO31_BF_WID (33)
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_63TO31_BF_MSK (0xFFFFFFFF80000000)
#define RCS_DMAC_CMNREG_INTSTATREG_RSVD_DMAC_CMNREG_INTSTATREG_63TO31_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_COMMON_REGISTERS_ADDRESS_BLOCK_DMAC_RESETREG register description at address offset 0x58
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Common_Registers_Address_Block/DMAC_RESETREG
  * DW_axi_dmac Software Reset Register
  */

typedef union {
  struct {
    uint64_t DMAC_RST : 1;
    ///< DMAC Reset Request bit Software writes 1 to this bit to reset the
    ///< DW_axi_dmac and polls this bit to see it as 0. DW_axi_dmac resets
    ///< all the modules except the register bus interface module and clears
    ///< this bit to 0. Note: Software is not allowed to write 0 to this bit.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_RESETREG_1TO63 : 63;
    ///< DMAC_ResetReg (bits 1to63) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_rstreg_reg_t;

#define RCS_DMAC_RSTREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_RSTREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_RSTREG_WR_MASK (0x0000000000000001ULL)


///< DMAC Reset Request bit Software writes 1 to this bit to reset the
///< DW_axi_dmac and polls this bit to see it as 0. DW_axi_dmac resets
///< all the modules except the register bus interface module and clears
///< this bit to 0. Note: Software is not allowed to write 0 to this bit.
#define RCS_DMAC_RSTREG_DMAC_RST_BF_OFF ( 0)
#define RCS_DMAC_RSTREG_DMAC_RST_BF_WID ( 1)
#define RCS_DMAC_RSTREG_DMAC_RST_BF_MSK (0x00000001)
#define RCS_DMAC_RSTREG_DMAC_RST_BF_DEF (0x00000000)

///< DMAC_ResetReg (bits 1to63) Reserved bits - Read Only
#define RCS_DMAC_RSTREG_RSVD_DMAC_RSTREG_1TO63_BF_OFF ( 1)
#define RCS_DMAC_RSTREG_RSVD_DMAC_RSTREG_1TO63_BF_WID (63)
#define RCS_DMAC_RSTREG_RSVD_DMAC_RSTREG_1TO63_BF_MSK (0xFFFFFFFFFFFFFFFE)
#define RCS_DMAC_RSTREG_RSVD_DMAC_RSTREG_1TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_SAR register description at address offset 0x100
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_SAR
  * DW_axi_dmac Channel x Source Address Register
  */

typedef union {
  struct {
    uint64_t SAR : 64;
    ///< Current Source Address of DMA transfer. Updated after each source
    ///< transfer. The SINC fields in the CHx_CTL register determines whether
    ///< the address increments or is left unchanged on every source transfer
    ///< throughout the block transfer.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_sar_reg_t;

#define RCS_DMAC_CH1_SAR_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_SAR_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_SAR_WR_MASK (0xffffffffffffffffULL)


///< Current Source Address of DMA transfer. Updated after each source
///< transfer. The SINC fields in the CHx_CTL register determines whether
///< the address increments or is left unchanged on every source transfer
///< throughout the block transfer.
#define RCS_DMAC_CH1_SAR_BF_OFF ( 0)
#define RCS_DMAC_CH1_SAR_BF_WID (64)
#define RCS_DMAC_CH1_SAR_BF_MSK (0xFFFFFFFFFFFFFFFF)
#define RCS_DMAC_CH1_SAR_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_DAR register description at address offset 0x108
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_DAR
  * DW_axi_dmac Channel x Destination Address Register
  */

typedef union {
  struct {
    uint64_t DAR : 64;
    ///< Current Destination Address of DMA transfer. Updated after each destination
    ///< transfer. The DINC fields in the CHx_CTL register determines whether
    ///< the address increments or is left unchanged on every destination transfer
    ///< throughout the block transfer.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_dar_reg_t;

#define RCS_DMAC_CH1_DAR_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_DAR_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_DAR_WR_MASK (0xffffffffffffffffULL)


///< Current Destination Address of DMA transfer. Updated after each destination
///< transfer. The DINC fields in the CHx_CTL register determines whether
///< the address increments or is left unchanged on every destination transfer
///< throughout the block transfer.
#define RCS_DMAC_CH1_DAR_BF_OFF ( 0)
#define RCS_DMAC_CH1_DAR_BF_WID (64)
#define RCS_DMAC_CH1_DAR_BF_MSK (0xFFFFFFFFFFFFFFFF)
#define RCS_DMAC_CH1_DAR_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_BLOCK_TS register description at address offset 0x110
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_BLOCK_TS
  * DW_axi_dmac Channel x Block Transfer Size Register
  */

typedef union {
  struct {
    uint64_t BLOCK_TS : 22;
    ///< Block Transfer Size. The number programmed into BLOCK_TS field indicates
    ///< the total number of data of width CHx_CTL.SRC_TR_WIDTH to be transferred
    ///< in a DMA block transfer. Block Transfer Size = BLOCK_TS+1 Note: The
    ///< value programmed to the BLOCK_TS field must be greater than or equal
    ///< to the source or destination transfer width and the read back value
    ///< of BLOCK_TS field is always the value programmed into it. This register
    ///< field is not applicable when source or destination is flow controller
    ///< and it is applicable when DMA is flow controller.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_BLOCK_TSREG_63TO22 : 42;
    ///< DMAC Channelx Block Transfer Size Register (bits 63to22) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_blk_ts_reg_t;

#define RCS_DMAC_CH1_BLK_TS_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_BLK_TS_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_BLK_TS_WR_MASK (0x00000000003fffffULL)


///< Block Transfer Size. The number programmed into BLOCK_TS field indicates
///< the total number of data of width CHx_CTL.SRC_TR_WIDTH to be transferred
///< in a DMA block transfer. Block Transfer Size = BLOCK_TS+1 Note: The
///< value programmed to the BLOCK_TS field must be greater than or equal
///< to the source or destination transfer width and the read back value
///< of BLOCK_TS field is always the value programmed into it. This register
///< field is not applicable when source or destination is flow controller
///< and it is applicable when DMA is flow controller.
#define RCS_DMAC_CH1_BLK_TS_BLK_TS_BF_OFF ( 0)
#define RCS_DMAC_CH1_BLK_TS_BLK_TS_BF_WID (22)
#define RCS_DMAC_CH1_BLK_TS_BLK_TS_BF_MSK (0x003FFFFF)
#define RCS_DMAC_CH1_BLK_TS_BLK_TS_BF_DEF (0x00000000)

///< DMAC Channelx Block Transfer Size Register (bits 63to22) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_OFF (22)
#define RCS_DMAC_CH1_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_WID (42)
#define RCS_DMAC_CH1_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_MSK (0xFFFFFFFFFFC00000)
#define RCS_DMAC_CH1_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_CTL register description at address offset 0x118
  *
  * Register default value:        0x00001200
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_CTL
  * DW_axi_dmac Channel x Control Register
  */

typedef union {
  struct {
    uint64_t SMS : 1;
    ///< Source Manager Select. Identifies the Manager Interface layer from
    ///< which the source device (peripheral or memory) is accessed.  - 0:
    ///< AXI manager 1   - 1: AXI Manager 2
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_1 : 1;
    ///< DMAC Channelx Control Transfer Register bit1 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint64_t DMS : 1;
    ///< Destination Manager Select. Identifies the Manager Interface layer
    ///< from which the destination device (peripheral or memory) is accessed.
    ///< - 0: AXI manager 1   - 1: AXI Manager 2
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_3 : 1;
    ///< DMAC Channelx Control Transfer Register bit3 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint64_t SINC : 1;
    ///< Source Address Increment. Indicates whether to increment the source
    ///< address on every source transfer. If the device is fetching data from
    ///< a source peripheral FIFO with a fixed address, then set this field
    ///< to 'No change'.  - 0: Increment   - 1: No Change NOTE: Increment aligns
    ///< the address to the next CHx_CTL.SRC_TR_WIDTH boundary.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_5 : 1;
    ///< DMAC Channelx Control Transfer Register bit5 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint64_t DINC : 1;
    ///< Destination Address Increment. Indicates whether to increment the
    ///< destination address on every destination transfer. If the device is
    ///< writing data from a source peripheral FIFO with a fixed address, then
    ///< set this field to 'No change'.  - 0: Increment   - 1: No Change NOTE:
    ///< Increment aligns the address to the next CHx_CTL.DST_TR_WIDTH boundary.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_7 : 1;
    ///< DMAC Channelx Control Transfer Register bit7 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
    uint64_t SRC_TR_WIDTH : 3;
    ///< Source Transfer Width. Mapped to AXI bus arsize, this value must be
    ///< less than or equal to DMAX_M_DATA_WIDTH.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x2"
    uint64_t DST_TR_WIDTH : 3;
    ///< Destination Transfer Width. Mapped to AXI bus awsize, this value must
    ///< be less than or equal to DMAX_M_DATA_WIDTH.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x2"
    uint64_t SRC_MSIZE : 4;
    ///< Source Burst Transaction Length. Number of data items, each of width
    ///< CHx_CTL.SRC_TR_WIDTH, to be read from the source every time a source
    ///< burst transaction request is made from the corresponding hardware
    ///< or software handshaking interface. The maximum value of DST_MSIZE
    ///< is limited by DMAX_CHx_MAX_MSIZE. Note: This Value is not related
    ///< to the AXI arlen signal.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint64_t DST_MSIZE : 4;
    ///< Destination Burst Transaction Length. Number of data items, each of
    ///< width CHx_CTL.DST_TR_WIDTH, to be written to the destination every
    ///< time a destination burst transaction request is made from the corresponding
    ///< hardware or software handshaking interface. Note: This Value is not
    ///< related to the AXI awlen signal.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint64_t AR_CACHE : 4;
    ///< AXI 'ar_cache' signal
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint64_t AW_CACHE : 4;
    ///< AXI 'aw_cache' signal
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint64_t NONPOSTED_LASTWRITE_EN : 1;
    ///< Non Posted Last Write Enable This bit decides whether posted writes
    ///< can be used throughout the block transfer.  - 0: Posted writes may
    ///< be used throughout the block transfer.  - 1: Posted writes may be
    ///< used till the end of the block (inside a block) and the last write
    ///< in the block must be non-posted. This is to synchronize block completion
    ///< interrupt generation to the last write data reaching the end memory/peripheral.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_31 : 1;
    ///< DMAC Channelx Control Transfer Register bit31 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="31" ResetValue="0x0"
    uint64_t AR_PROT : 3;
    ///< AXI 'ar_prot' signal
    ///< AccessType="RW" BitOffset="32" ResetValue="0x0"
    uint64_t AW_PROT : 3;
    ///< AXI 'aw_prot' signal
    ///< AccessType="RW" BitOffset="35" ResetValue="0x0"
    uint64_t ARLEN_EN : 1;
    ///< Source Burst Length Enable If this bit is set to 1, DW_axi_dmac uses
    ///< the value of CHx_CTL.ARLEN as AXI Burst length for source data transfer
    ///< till the extent possible; remaining transfers use maximum possible
    ///< burst length. If this bit is set to 0, DW_axi_dmac uses any possible
    ///< value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
    ///< as AXI Burst length for source data transfer.
    ///< AccessType="RW" BitOffset="38" ResetValue="0x0"
    uint64_t ARLEN : 8;
    ///< Source Burst Length AXI Burst length used for source data transfer.
    ///< The specified burst length is used for source data transfer till the
    ///< extent possible; remaining transfers use maximum possible value that
    ///< is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH. The maximum
    ///< value of ARLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH
    ///< AccessType="RW" BitOffset="39" ResetValue="0x0"
    uint64_t AWLEN_EN : 1;
    ///< Destination Burst Length Enable If this bit is set to 1, DW_axi_dmac
    ///< uses the value of CHx_CTL.AWLEN as AXI Burst length for destination
    ///< data transfer till the extent possible; remaining transfers use maximum
    ///< possible burst length. If this bit is set to 0, DW_axi_dmac uses any
    ///< possible value which is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
    ///< as AXI Burst length for destination data transfer.
    ///< AccessType="RW" BitOffset="47" ResetValue="0x0"
    uint64_t AWLEN : 8;
    ///< Destination Burst Length AXI Burst length used for destination data
    ///< transfer. The specified burst length is used for destination data
    ///< transfer till the extent possible; remaining transfers use maximum
    ///< possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.
    ///< The maximum value of AWLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH.
    ///< Note: The AWLEN setting may not be honored towards end-to-block transfers,
    ///< the end of a transaction (only applicable to non-memory peripherals),
    ///< and during 4K boundary crossings.
    ///< AccessType="RW" BitOffset="48" ResetValue="0x0"
    uint64_t SRC_STAT_EN : 1;
    ///< Source Status Enable Enable the logic to fetch status from source
    ///< peripheral of channel x pointed to by the content of CHx_SSTATAR register
    ///< and stores it in CHx_SSTAT register. This value is written back to
    ///< the CHx_SSTAT location of linked list at end of each block transfer
    ///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
    ///< transfer is used by either source or destination peripheral.
    ///< AccessType="RO" BitOffset="56" ResetValue="0x0"
    uint64_t DST_STAT_EN : 1;
    ///< Destination Status Enable Enable the logic to fetch status from destination
    ///< peripheral of channel x pointed to by the content of CHx_DSTATAR register
    ///< and stores it in CHx_DSTAT register. This value is written back to
    ///< the CHx_DSTAT location of linked list at end of each block transfer
    ///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
    ///< transfer is used by either source or destination peripheral.
    ///< AccessType="RO" BitOffset="57" ResetValue="0x0"
    uint64_t IOC_BLKTFR : 1;
    ///< Interrupt On completion of Block Transfer This bit is used to control
    ///< the block transfer completion interrupt generation on a block by block
    ///< basis for shadow register or linked list based multi-block transfers.
    ///< Writing 1 to this register field enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat
    ///< field if this interrupt generation is enabled in CHx_IntStatus_EnableReg
    ///< register and the external interrupt output is asserted if this interrupt
    ///< generation is enabled in CHx_IntSignal_EnableReg register. Note: If
    ///< a linked-list or shadow-register-based multi-block transfer is not
    ///< used for both source and destination (for instance if source and destination
    ///< use contiguous address or auto-reload-based multi-block transfer),
    ///< the value of this field cannot be modified per block. Additionally,
    ///< the value programmed before the channel is enabled is used for all
    ///< the blocks in the DMA transfer.
    ///< AccessType="RW" BitOffset="58" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_59TO61 : 3;
    ///< DMAC Channelx Control Transfer Register (bits 59to61) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="59" ResetValue="0x0"
    uint64_t SHADOWREG_OR_LLI_LAST : 1;
    ///< Last Shadow Register/Linked List Item. Indicates whether shadow register
    ///< content or the linked list item fetched from the memory is the last
    ///< one or not.  - 0: Not last Shadow Register/LLI  - 1: Last Shadow Register/LLI
    ///< LLI based multi-block transfer: DW_axi_dmac uses this bit to decide
    ///< if another LLI fetch is needed in the current DMA transfer.  - If
    ///< this bit is 0, DW_axi_dmac fetches the next LLI from the address pointed
    ///< out by LLP field in the current LLI.  - If this bit is 1, DW_axi_dmac
    ///< understands that current block is the final block in the dma transfer
    ///< and ends the dma transfer once the AMBA transfer corresponding to
    ///< the current block completes. Shadow Reg based multi-block transfer:
    ///< DW_axi_dmac uses this bit to decide if another Shadow Register fetch
    ///< is needed in the current DMA transfer.  - If this bit is 0, DW_axi_dmac
    ///< understands that there are one or more blocks to be transferred in
    ///< the current block and hence one or more shadow register set contents
    ///< will be valid and needs to be fetched.  - If this bit is 1, DW_axi_dmac
    ///< understands that current block is the final block in the dma transfer
    ///< and ends the dma transfer once the AMBA transfer corresponding to
    ///< the current block completes.
    ///< AccessType="RW/V" BitOffset="62" ResetValue="0x0"
    uint64_t SHADOWREG_OR_LLI_VALID : 1;
    ///< Shadow Register content/Linked List Item valid. Indicates whether
    ///< the content of shadow register or the linked list item fetched from
    ///< the memory is valid.  - 0: Shadow Register content/LLI is invalid.
    ///< - 1: Last Shadow Register/LLI is valid. LLI based multi-block transfer:
    ///< The CHx_CTL register is loaded from the LLI. Hence, the software is
    ///< not allowed to directly update this register through the DW_axi_dmac
    ///< subordinate interface. This field can be used to dynamically extend
    ///< the LLI by the software. On noticing this bit as 0, DW_axi_dmac discards
    ///< the LLI and generates the ShadowReg_Or_LII_Invalid_ERR Interrupt if
    ///< the corresponding channel error interrupt mask bit is set to 0. In
    ///< the case of LLI pre-fetching, the ShadowReg_Or_LLI_Invalid_ERR interrupt
    ///< is not generated even if the ShadowReg_Or_LLI_Valid bit is seen to
    ///< be 0 for the pre-fetched LLI. In this case, DW_axi_dmac attempts the
    ///< LLI fetch operation again after completing the current block transfer
    ///< and generates the ShadowReg_Or_LII_Invalid_ERR interrupt only if ShadowReg_Or_LII_Valid
    ///< bit is still seen to be 0. This error condition causes the DW_axi_dmac
    ///< to halt the corresponding channel gracefully. DW_axi_dmac waits until
    ///< software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
    ///< valid LLI availability before attempting another LLI read operation.
    ///< This bit is cleared to 0 and written back to the corresponding LLI
    ///< location after block transfer completion when LLI write-back option
    ///< is enabled. Hence, for LLI-based multi-block transfers, the software
    ///< might manipulate/redefine any descriptor with the ShadowReg_Or_LII_Valid
    ///< bit set to 0 if LLI write-back option is enabled. Shadow Reg based
    ///< multi-block transfer: On noticing this bit as 0 during shadow register
    ///< fetch phase, DW_axi_dmac discards the Shadow Register contents and
    ///< generates ShadowReg_Or_LLI_Invlid_ERR Interrupt. In this case, the
    ///< software has to write (any value) to CHx_BLK_TFR_ResumeReqReg after
    ///< updating the shadow registers and after setting ShadowReg_Or_LLI_Valid
    ///< bit to 1 to indicate to DW_axi_dmac that shadow register contents
    ///< are valid and the next block transfer can be resumed. DW_axi_dmac
    ///< clears this bit to 0 after copying the shadow register contents. Software
    ///< can reprogram the shadow registers only if ShadowReg_Or_LLI_Valid
    ///< bit is 0. Software needs to read this register in block completion
    ///< interrupt service routine (if interrupt is enabled)/continuously poll
    ///< this register (if interrupt is not enabled) to make sure that this
    ///< bit is 0 before updating the shadow registers. If shadow-register-based
    ///< multi-block transfer is enabled and software attempts to write to
    ///< the shadow register when ShadowReg_Or_LLI_Valid bit is 1, DW_axi_dmac
    ///< generates SLVIF_ShadowReg_WrOnValid_ERR interrupt.
    ///< AccessType="RW/V" BitOffset="63" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_ctl_reg_t;

#define RCS_DMAC_CH1_CTL_DEFAULT (0x0000000000001200ULL)
#define RCS_DMAC_CH1_CTL_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_CTL_WR_MASK (0xc4ffffff7fffff50ULL)


///< Source Manager Select. Identifies the Manager Interface layer from
///< which the source device (peripheral or memory) is accessed.  - 0:
///< AXI manager 1   - 1: AXI Manager 2
#define RCS_DMAC_CH1_CTL_SMS_BF_OFF ( 0)
#define RCS_DMAC_CH1_CTL_SMS_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_SMS_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_CTL_SMS_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit1 Reserved bits - Read
///< Only
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_1_BF_OFF ( 1)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_1_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_1_BF_MSK (0x00000002)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_1_BF_DEF (0x00000000)

///< Destination Manager Select. Identifies the Manager Interface layer
///< from which the destination device (peripheral or memory) is accessed.
///< - 0: AXI manager 1   - 1: AXI Manager 2
#define RCS_DMAC_CH1_CTL_DMS_BF_OFF ( 2)
#define RCS_DMAC_CH1_CTL_DMS_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_DMS_BF_MSK (0x00000004)
#define RCS_DMAC_CH1_CTL_DMS_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit3 Reserved bits - Read
///< Only
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_3_BF_OFF ( 3)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_3_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_3_BF_MSK (0x00000008)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_3_BF_DEF (0x00000000)

///< Source Address Increment. Indicates whether to increment the source
///< address on every source transfer. If the device is fetching data from
///< a source peripheral FIFO with a fixed address, then set this field
///< to 'No change'.  - 0: Increment   - 1: No Change NOTE: Increment aligns
///< the address to the next CHx_CTL.SRC_TR_WIDTH boundary.
#define RCS_DMAC_CH1_CTL_SINC_BF_OFF ( 4)
#define RCS_DMAC_CH1_CTL_SINC_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_SINC_BF_MSK (0x00000010)
#define RCS_DMAC_CH1_CTL_SINC_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit5 Reserved bits - Read
///< Only
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_5_BF_OFF ( 5)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_5_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_5_BF_MSK (0x00000020)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_5_BF_DEF (0x00000000)

///< Destination Address Increment. Indicates whether to increment the
///< destination address on every destination transfer. If the device is
///< writing data from a source peripheral FIFO with a fixed address, then
///< set this field to 'No change'.  - 0: Increment   - 1: No Change NOTE:
///< Increment aligns the address to the next CHx_CTL.DST_TR_WIDTH boundary.
#define RCS_DMAC_CH1_CTL_DINC_BF_OFF ( 6)
#define RCS_DMAC_CH1_CTL_DINC_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_DINC_BF_MSK (0x00000040)
#define RCS_DMAC_CH1_CTL_DINC_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit7 Reserved bits - Read
///< Only
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_7_BF_OFF ( 7)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_7_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_7_BF_MSK (0x00000080)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_7_BF_DEF (0x00000000)

///< Source Transfer Width. Mapped to AXI bus arsize, this value must be
///< less than or equal to DMAX_M_DATA_WIDTH.
#define RCS_DMAC_CH1_CTL_SRC_TR_WIDTH_BF_OFF ( 8)
#define RCS_DMAC_CH1_CTL_SRC_TR_WIDTH_BF_WID ( 3)
#define RCS_DMAC_CH1_CTL_SRC_TR_WIDTH_BF_MSK (0x00000700)
#define RCS_DMAC_CH1_CTL_SRC_TR_WIDTH_BF_DEF (0x00000200)

///< Destination Transfer Width. Mapped to AXI bus awsize, this value must
///< be less than or equal to DMAX_M_DATA_WIDTH.
#define RCS_DMAC_CH1_CTL_DST_TR_WIDTH_BF_OFF (11)
#define RCS_DMAC_CH1_CTL_DST_TR_WIDTH_BF_WID ( 3)
#define RCS_DMAC_CH1_CTL_DST_TR_WIDTH_BF_MSK (0x00003800)
#define RCS_DMAC_CH1_CTL_DST_TR_WIDTH_BF_DEF (0x00001000)

///< Source Burst Transaction Length. Number of data items, each of width
///< CHx_CTL.SRC_TR_WIDTH, to be read from the source every time a source
///< burst transaction request is made from the corresponding hardware
///< or software handshaking interface. The maximum value of DST_MSIZE
///< is limited by DMAX_CHx_MAX_MSIZE. Note: This Value is not related
///< to the AXI arlen signal.
#define RCS_DMAC_CH1_CTL_SRC_MSIZE_BF_OFF (14)
#define RCS_DMAC_CH1_CTL_SRC_MSIZE_BF_WID ( 4)
#define RCS_DMAC_CH1_CTL_SRC_MSIZE_BF_MSK (0x0003C000)
#define RCS_DMAC_CH1_CTL_SRC_MSIZE_BF_DEF (0x00000000)

///< Destination Burst Transaction Length. Number of data items, each of
///< width CHx_CTL.DST_TR_WIDTH, to be written to the destination every
///< time a destination burst transaction request is made from the corresponding
///< hardware or software handshaking interface. Note: This Value is not
///< related to the AXI awlen signal.
#define RCS_DMAC_CH1_CTL_DST_MSIZE_BF_OFF (18)
#define RCS_DMAC_CH1_CTL_DST_MSIZE_BF_WID ( 4)
#define RCS_DMAC_CH1_CTL_DST_MSIZE_BF_MSK (0x003C0000)
#define RCS_DMAC_CH1_CTL_DST_MSIZE_BF_DEF (0x00000000)

///< AXI 'ar_cache' signal
#define RCS_DMAC_CH1_CTL_AR_CACHE_BF_OFF (22)
#define RCS_DMAC_CH1_CTL_AR_CACHE_BF_WID ( 4)
#define RCS_DMAC_CH1_CTL_AR_CACHE_BF_MSK (0x03C00000)
#define RCS_DMAC_CH1_CTL_AR_CACHE_BF_DEF (0x00000000)

///< AXI 'aw_cache' signal
#define RCS_DMAC_CH1_CTL_AW_CACHE_BF_OFF (26)
#define RCS_DMAC_CH1_CTL_AW_CACHE_BF_WID ( 4)
#define RCS_DMAC_CH1_CTL_AW_CACHE_BF_MSK (0x3C000000)
#define RCS_DMAC_CH1_CTL_AW_CACHE_BF_DEF (0x00000000)

///< Non Posted Last Write Enable This bit decides whether posted writes
///< can be used throughout the block transfer.  - 0: Posted writes may
///< be used throughout the block transfer.  - 1: Posted writes may be
///< used till the end of the block (inside a block) and the last write
///< in the block must be non-posted. This is to synchronize block completion
///< interrupt generation to the last write data reaching the end memory/peripheral.
#define RCS_DMAC_CH1_CTL_NONPOSTED_LASTWRITE_EN_BF_OFF (30)
#define RCS_DMAC_CH1_CTL_NONPOSTED_LASTWRITE_EN_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_NONPOSTED_LASTWRITE_EN_BF_MSK (0x40000000)
#define RCS_DMAC_CH1_CTL_NONPOSTED_LASTWRITE_EN_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit31 Reserved bits - Read
///< Only
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_31_BF_OFF (31)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_31_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_31_BF_MSK (0x80000000)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_31_BF_DEF (0x00000000)

///< AXI 'ar_prot' signal
#define RCS_DMAC_CH1_CTL_AR_PROT_BF_OFF (32)
#define RCS_DMAC_CH1_CTL_AR_PROT_BF_WID ( 3)
#define RCS_DMAC_CH1_CTL_AR_PROT_BF_MSK (0x700000000)
#define RCS_DMAC_CH1_CTL_AR_PROT_BF_DEF (0x00000000)

///< AXI 'aw_prot' signal
#define RCS_DMAC_CH1_CTL_AW_PROT_BF_OFF (35)
#define RCS_DMAC_CH1_CTL_AW_PROT_BF_WID ( 3)
#define RCS_DMAC_CH1_CTL_AW_PROT_BF_MSK (0x3800000000)
#define RCS_DMAC_CH1_CTL_AW_PROT_BF_DEF (0x00000000)

///< Source Burst Length Enable If this bit is set to 1, DW_axi_dmac uses
///< the value of CHx_CTL.ARLEN as AXI Burst length for source data transfer
///< till the extent possible; remaining transfers use maximum possible
///< burst length. If this bit is set to 0, DW_axi_dmac uses any possible
///< value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
///< as AXI Burst length for source data transfer.
#define RCS_DMAC_CH1_CTL_ARLEN_EN_BF_OFF (38)
#define RCS_DMAC_CH1_CTL_ARLEN_EN_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_ARLEN_EN_BF_MSK (0x4000000000)
#define RCS_DMAC_CH1_CTL_ARLEN_EN_BF_DEF (0x00000000)

///< Source Burst Length AXI Burst length used for source data transfer.
///< The specified burst length is used for source data transfer till the
///< extent possible; remaining transfers use maximum possible value that
///< is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH. The maximum
///< value of ARLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH
#define RCS_DMAC_CH1_CTL_ARLEN_BF_OFF (39)
#define RCS_DMAC_CH1_CTL_ARLEN_BF_WID ( 8)
#define RCS_DMAC_CH1_CTL_ARLEN_BF_MSK (0x7F8000000000)
#define RCS_DMAC_CH1_CTL_ARLEN_BF_DEF (0x00000000)

///< Destination Burst Length Enable If this bit is set to 1, DW_axi_dmac
///< uses the value of CHx_CTL.AWLEN as AXI Burst length for destination
///< data transfer till the extent possible; remaining transfers use maximum
///< possible burst length. If this bit is set to 0, DW_axi_dmac uses any
///< possible value which is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
///< as AXI Burst length for destination data transfer.
#define RCS_DMAC_CH1_CTL_AWLEN_EN_BF_OFF (47)
#define RCS_DMAC_CH1_CTL_AWLEN_EN_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_AWLEN_EN_BF_MSK (0x800000000000)
#define RCS_DMAC_CH1_CTL_AWLEN_EN_BF_DEF (0x00000000)

///< Destination Burst Length AXI Burst length used for destination data
///< transfer. The specified burst length is used for destination data
///< transfer till the extent possible; remaining transfers use maximum
///< possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.
///< The maximum value of AWLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH.
///< Note: The AWLEN setting may not be honored towards end-to-block transfers,
///< the end of a transaction (only applicable to non-memory peripherals),
///< and during 4K boundary crossings.
#define RCS_DMAC_CH1_CTL_AWLEN_BF_OFF (48)
#define RCS_DMAC_CH1_CTL_AWLEN_BF_WID ( 8)
#define RCS_DMAC_CH1_CTL_AWLEN_BF_MSK (0xFF000000000000)
#define RCS_DMAC_CH1_CTL_AWLEN_BF_DEF (0x00000000)

///< Source Status Enable Enable the logic to fetch status from source
///< peripheral of channel x pointed to by the content of CHx_SSTATAR register
///< and stores it in CHx_SSTAT register. This value is written back to
///< the CHx_SSTAT location of linked list at end of each block transfer
///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
///< transfer is used by either source or destination peripheral.
#define RCS_DMAC_CH1_CTL_SRC_STAT_EN_BF_OFF (56)
#define RCS_DMAC_CH1_CTL_SRC_STAT_EN_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_SRC_STAT_EN_BF_MSK (0x100000000000000)
#define RCS_DMAC_CH1_CTL_SRC_STAT_EN_BF_DEF (0x00000000)

///< Destination Status Enable Enable the logic to fetch status from destination
///< peripheral of channel x pointed to by the content of CHx_DSTATAR register
///< and stores it in CHx_DSTAT register. This value is written back to
///< the CHx_DSTAT location of linked list at end of each block transfer
///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
///< transfer is used by either source or destination peripheral.
#define RCS_DMAC_CH1_CTL_DST_STAT_EN_BF_OFF (57)
#define RCS_DMAC_CH1_CTL_DST_STAT_EN_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_DST_STAT_EN_BF_MSK (0x200000000000000)
#define RCS_DMAC_CH1_CTL_DST_STAT_EN_BF_DEF (0x00000000)

///< Interrupt On completion of Block Transfer This bit is used to control
///< the block transfer completion interrupt generation on a block by block
///< basis for shadow register or linked list based multi-block transfers.
///< Writing 1 to this register field enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat
///< field if this interrupt generation is enabled in CHx_IntStatus_EnableReg
///< register and the external interrupt output is asserted if this interrupt
///< generation is enabled in CHx_IntSignal_EnableReg register. Note: If
///< a linked-list or shadow-register-based multi-block transfer is not
///< used for both source and destination (for instance if source and destination
///< use contiguous address or auto-reload-based multi-block transfer),
///< the value of this field cannot be modified per block. Additionally,
///< the value programmed before the channel is enabled is used for all
///< the blocks in the DMA transfer.
#define RCS_DMAC_CH1_CTL_IOC_BLKTFR_BF_OFF (58)
#define RCS_DMAC_CH1_CTL_IOC_BLKTFR_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_IOC_BLKTFR_BF_MSK (0x400000000000000)
#define RCS_DMAC_CH1_CTL_IOC_BLKTFR_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register (bits 59to61) Reserved bits
///< - Read Only
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_OFF (59)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_WID ( 3)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_MSK (0x3800000000000000)
#define RCS_DMAC_CH1_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_DEF (0x00000000)

///< Last Shadow Register/Linked List Item. Indicates whether shadow register
///< content or the linked list item fetched from the memory is the last
///< one or not.  - 0: Not last Shadow Register/LLI  - 1: Last Shadow Register/LLI
///< LLI based multi-block transfer: DW_axi_dmac uses this bit to decide
///< if another LLI fetch is needed in the current DMA transfer.  - If
///< this bit is 0, DW_axi_dmac fetches the next LLI from the address pointed
///< out by LLP field in the current LLI.  - If this bit is 1, DW_axi_dmac
///< understands that current block is the final block in the dma transfer
///< and ends the dma transfer once the AMBA transfer corresponding to
///< the current block completes. Shadow Reg based multi-block transfer:
///< DW_axi_dmac uses this bit to decide if another Shadow Register fetch
///< is needed in the current DMA transfer.  - If this bit is 0, DW_axi_dmac
///< understands that there are one or more blocks to be transferred in
///< the current block and hence one or more shadow register set contents
///< will be valid and needs to be fetched.  - If this bit is 1, DW_axi_dmac
///< understands that current block is the final block in the dma transfer
///< and ends the dma transfer once the AMBA transfer corresponding to
///< the current block completes.
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_LAST_BF_OFF (62)
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_LAST_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_LAST_BF_MSK (0x4000000000000000)
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_LAST_BF_DEF (0x00000000)

///< Shadow Register content/Linked List Item valid. Indicates whether
///< the content of shadow register or the linked list item fetched from
///< the memory is valid.  - 0: Shadow Register content/LLI is invalid.
///< - 1: Last Shadow Register/LLI is valid. LLI based multi-block transfer:
///< The CHx_CTL register is loaded from the LLI. Hence, the software is
///< not allowed to directly update this register through the DW_axi_dmac
///< subordinate interface. This field can be used to dynamically extend
///< the LLI by the software. On noticing this bit as 0, DW_axi_dmac discards
///< the LLI and generates the ShadowReg_Or_LII_Invalid_ERR Interrupt if
///< the corresponding channel error interrupt mask bit is set to 0. In
///< the case of LLI pre-fetching, the ShadowReg_Or_LLI_Invalid_ERR interrupt
///< is not generated even if the ShadowReg_Or_LLI_Valid bit is seen to
///< be 0 for the pre-fetched LLI. In this case, DW_axi_dmac attempts the
///< LLI fetch operation again after completing the current block transfer
///< and generates the ShadowReg_Or_LII_Invalid_ERR interrupt only if ShadowReg_Or_LII_Valid
///< bit is still seen to be 0. This error condition causes the DW_axi_dmac
///< to halt the corresponding channel gracefully. DW_axi_dmac waits until
///< software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
///< valid LLI availability before attempting another LLI read operation.
///< This bit is cleared to 0 and written back to the corresponding LLI
///< location after block transfer completion when LLI write-back option
///< is enabled. Hence, for LLI-based multi-block transfers, the software
///< might manipulate/redefine any descriptor with the ShadowReg_Or_LII_Valid
///< bit set to 0 if LLI write-back option is enabled. Shadow Reg based
///< multi-block transfer: On noticing this bit as 0 during shadow register
///< fetch phase, DW_axi_dmac discards the Shadow Register contents and
///< generates ShadowReg_Or_LLI_Invlid_ERR Interrupt. In this case, the
///< software has to write (any value) to CHx_BLK_TFR_ResumeReqReg after
///< updating the shadow registers and after setting ShadowReg_Or_LLI_Valid
///< bit to 1 to indicate to DW_axi_dmac that shadow register contents
///< are valid and the next block transfer can be resumed. DW_axi_dmac
///< clears this bit to 0 after copying the shadow register contents. Software
///< can reprogram the shadow registers only if ShadowReg_Or_LLI_Valid
///< bit is 0. Software needs to read this register in block completion
///< interrupt service routine (if interrupt is enabled)/continuously poll
///< this register (if interrupt is not enabled) to make sure that this
///< bit is 0 before updating the shadow registers. If shadow-register-based
///< multi-block transfer is enabled and software attempts to write to
///< the shadow register when ShadowReg_Or_LLI_Valid bit is 1, DW_axi_dmac
///< generates SLVIF_ShadowReg_WrOnValid_ERR interrupt.
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_VALID_BF_OFF (63)
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_VALID_BF_WID ( 1)
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_VALID_BF_MSK (0x8000000000000000)
#define RCS_DMAC_CH1_CTL_SHDWREG_OR_LLI_VALID_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_CFG register description at address offset 0x120
  *
  * Register default value:        0x2001B00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_CFG
  * DW_axi_dmac Channel x Configuration Register
  */

typedef union {
  struct {
    uint64_t SRC_MULTBLK_TYPE : 2;
    ///< Source Multi Block Transfer Type. These bits define the type of multi-block
    ///< transfer used for source peripheral.  - 00: Contiguous  - 01: Reload
    ///< - 10: Shadow Register  - 11: Linked List If the type selected is Contiguous,
    ///< the CHx_SAR register is loaded with the value of the end source address
    ///< of previous block + 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. If the type selected is Reload,
    ///< the CHx_SAR register is reloaded from the initial value of SAR at
    ///< the end of every block for multi-block transfers. A new block transfer
    ///< is then initiated. If the type selected is Shadow Register, the CHx_SAR
    ///< register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid
    ///< bit is set to 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. If the type selected is Linked
    ///< List, the CHx_SAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
    ///< bit is set to 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
    ///< are loaded from their initial values or from the contents of their
    ///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
    ///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
    ///< to 1) at the end of every block for multi-block transfers based on
    ///< the multi-block transfer type programmed for source and destination
    ///< peripherals. Contiguous transfer on both source and destination peripheral
    ///< is not a valid multi-block transfer configuration. This field does
    ///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
    ///< not selected; in that case, the read-back value is always 0.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t DST_MULTBLK_TYPE : 2;
    ///< Destination Multi Block Transfer Type. These bits define the type
    ///< of multi-block transfer used for destination peripheral.  - 00: Contiguous
    ///< - 01: Reload  - 10: Shadow Register  - 11: Linked List If the type
    ///< selected is Contiguous, the CHx_DAR register is loaded with the value
    ///< of the end source address of previous block + 1 at the end of every
    ///< block for multi-block transfers. A new block transfer is then initiated.
    ///< If the type selected is Reload, the CHx_DAR register is reloaded from
    ///< the initial value of DAR at the end of every block for multi-block
    ///< transfers. A new block transfer is then initiated. If the type selected
    ///< is Shadow Register, the CHx_DAR register is loaded from the content
    ///< of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set
    ///< to 1 at the end of every block for multi-block transfers. A new block
    ///< transfer is then initiated. If the type selected is Linked List, the
    ///< CHx_DAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
    ///< bit is set to 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
    ///< are loaded from their initial values or from the contents of their
    ///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
    ///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
    ///< to 1) at the end of every block for multi-block transfers based on
    ///< the multi-block transfer type programmed for source and destination
    ///< peripherals. Contiguous transfer on both source and destination peripheral
    ///< is not a valid multi-block transfer configuration. This field does
    ///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
    ///< not selected; in that case, the read-back value is always 0.
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_4TO17 : 14;
    ///< DMAC Channelx Transfer Configuration Register (bits 4to17) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint64_t RD_UID : 4;
    ///< Defines the number of AXI Unique ID's supported for the AXI Read Channel.
    ///< The value programmed must be less than or equal to DMAX_CH(x)_RD_UID.
    ///< Otherwise, it is limited by the value DMAX_CH(x)_RD_UID.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_22TO24 : 3;
    ///< DMAC Channelx Transfer Configuration Register (bits 22to24) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t WR_UID : 4;
    ///< Defines the number of AXI Unique ID's supported for the AXI Write
    ///< Channel. The value programmed must be less than or equal to DMAX_CH(x)_WR_UID.
    ///< Otherwise, it is limited by the value DMAX_CH(x)_WR_UID.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_29TO31 : 3;
    ///< DMAC Channelx Transfer Configuration Register (bits 29to31) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint64_t TT_FC : 3;
    ///< Transfer Type and Flow Control. The following transfer types are supported.
    ///< - Memory to Memory   - Memory to Peripheral   - Peripheral to Memory
    ///< - Peripheral to Peripheral   Flow Control can be assigned to the DW_axi_dmac,
    ///< the source peripheral, or the destination peripheral.
    ///< AccessType="RW/V" BitOffset="32" ResetValue="0x3"
    uint64_t HS_SEL_SRC : 1;
    ///< Source Software or Hardware Handshaking Select. This register selects
    ///< which of the handshaking interfaces (hardware or software) is active
    ///< for source requests on this channel.  - 0: Hardware handshaking interface.
    ///< Software-initiated transaction requests are ignored.  - 1: Software
    ///< handshaking interface. Hardware-initiated transaction requests are
    ///< ignored. If the source peripheral is memory, then this bit is ignored.
    ///< AccessType="RW/V" BitOffset="35" ResetValue="0x1"
    uint64_t HS_SEL_DST : 1;
    ///< Destination Software or Hardware Handshaking Select. This register
    ///< selects which of the handshaking interfaces (hardware or software)
    ///< is active for destination requests on this channel.  - 0: Hardware
    ///< handshaking interface. Software-initiated transaction requests are
    ///< ignored.  - 1: Software handshaking interface. Hardware-initiated
    ///< transaction requests are ignored. If the destination peripheral is
    ///< memory, then this bit is ignored.
    ///< AccessType="RW/V" BitOffset="36" ResetValue="0x1"
    uint64_t SRC_HWHS_POL : 1;
    ///< Source Hardware Handshaking Interface Polarity.  - 0: ACTIVE HIGH
    ///< - 1: ACTIVE LOW  Note: This field is reserved for future use and currently
    ///< this is always active high.
    ///< AccessType="RO/V" BitOffset="37" ResetValue="0x0"
    uint64_t DST_HWHS_POL : 1;
    ///< Destination Hardware Handshaking Interface Polarity.  - 0: ACTIVE
    ///< HIGH  - 1: ACTIVE LOW  Note: This field is reserved for future use
    ///< and currently this is always active high.
    ///< AccessType="RO/V" BitOffset="38" ResetValue="0x0"
    uint64_t SRC_PER : 3;
    ///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
    ///< the source of Channelx if the CHx_CFG.HS_SEL_SRC field is 0; otherwise,
    ///< this field is ignored. The channel can then communicate with the source
    ///< peripheral connected to that interface through the assigned hardware
    ///< handshaking interface.  Note: For correct DW_axi_dmac operation, only
    ///< one peripheral (source or destination) should be assigned to the same
    ///< handshaking interface. This field does not exist if the configuration
    ///< parameter DMAX_NUM_HS_IF is set to 0. x = 39 if DMAC_NUM_HS_IF is
    ///< 1 x = ceil(log2(DMAC_NUM_HS_IF) + 38 if DMAC_NUM_HS_IF is greater
    ///< than 1. Bits 42: (x+1) do not exist and return 0 on a read.
    ///< AccessType="RW/V" BitOffset="39" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_42_39 : 1;
    ///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+39)
    ///< to 42) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="42" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_43 : 1;
    ///< DMAC Channelx Transfer Configuration Register (43bit) Reserved bit
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="43" ResetValue="0x0"
    uint64_t DST_PER : 3;
    ///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
    ///< the destination of Channelx if the CHx_CFG.HS_SEL_DST field is 0;
    ///< otherwise, this field is ignored. The channel can then communicate
    ///< with the destination peripheral connected to that interface through
    ///< the assigned hardware handshaking interface.  Note: For correct DW_axi_dmac
    ///< operation, only one peripheral (source or destination) should be assigned
    ///< to the same handshaking interface.  This field does not exist if the
    ///< configuration parameter DMAX_NUM_HS_IF is set to 0. x = 44 if DMAC_NUM_HS_IF
    ///< is 1 x = ceil(log2(DMAC_NUM_HS_IF)) + 43 if DMAC_NUM_HS_IF is greater
    ///< than 1 Bits 47: (x+1) do not exist and return 0 on a read.
    ///< AccessType="RW/V" BitOffset="44" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_47_44 : 1;
    ///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+44)
    ///< to 47) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="47" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_48 : 1;
    ///< DMAC Channelx Transfer Configuration Register (48bit) Reserved bit
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="48" ResetValue="0x0"
    uint64_t CH_PRIOR : 3;
    ///< Channel Priority A priority of DMAX_NUM_CHANNELS-1 is the highest
    ///< priority, and 0 is the lowest. This field must be programmed within
    ///< the following range:       0: DMAX_NUM_CHANNELS-1 A programmed value
    ///< outside this range will cause erroneous behavior.
    ///< AccessType="RW/V" BitOffset="49" ResetValue="0x1"
    uint64_t LOCK_CH : 1;
    ///< Channel Lock bit When the channel is granted control of the manager
    ///< bus interface and if the CHx_CFG.LOCK_CH bit is asserted, then no
    ///< other channels are granted control of the manager bus interface for
    ///< the duration specified in CHx_CFG.LOCK_CH_L. Indicates to the manager
    ///< bus interface arbiter that this channel wants exclusive access to
    ///< the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L.
    ///< This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN
    ///< is set to False; in this case, the read-back value is always 0. Locking
    ///< the channel locks AXI Read Address, Write Address and Write Data channels
    ///< on the corresponding manager interface. Note: Channel locking feature
    ///< is supported only for memory-to-memory transfer at Block Transfer
    ///< and DMA Transfer levels. Hardware does not check for the validity
    ///< of channel locking setting, hence the software must take care of enabling
    ///< the channel locking only for memory-to-memory transfers at Block Transfer
    ///< or DMA Transfer levels. Illegal programming of channel locking might
    ///< result in unpredictable behavior.
    ///< AccessType="RO/V" BitOffset="52" ResetValue="0x0"
    uint64_t LOCK_CH_L : 2;
    ///< Channel Lock Level This bit indicates the duration over which CHx_CFG.LOCK_CH
    ///< bit applies.  - 00: Over complete DMA transfer  - 01: Over DMA block
    ///< transfer  - 1x: Reserved This field does not exist if the configuration
    ///< parameter DMAX_CHx_LOCK_EN is set to False; in that case, the read-back
    ///< value is always 0.
    ///< AccessType="RO/V" BitOffset="53" ResetValue="0x0"
    uint64_t SRC_OSR_LMT : 4;
    ///< Source Outstanding Request Limit  - Maximum outstanding request supported
    ///< is 16.  - Source Outstanding Request Limit = SRC_OSR_LMT + 1
    ///< AccessType="RW/V" BitOffset="55" ResetValue="0x0"
    uint64_t DST_OSR_LMT : 4;
    ///< Destination Outstanding Request Limit  - Maximum outstanding request
    ///< supported is 16.  - Destination Outstanding Request Limit = DST_OSR_LMT
    ///< + 1
    ///< AccessType="RW/V" BitOffset="59" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_63 : 1;
    ///< DMAC Channelx Transfer Configuration Register (63bit) Reserved bit
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="63" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_cfg_reg_t;

#define RCS_DMAC_CH1_CFG_DEFAULT (0x0002001b00000000ULL)
#define RCS_DMAC_CH1_CFG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_CFG_WR_MASK (0x7f8e739f0000000fULL)


///< Source Multi Block Transfer Type. These bits define the type of multi-block
///< transfer used for source peripheral.  - 00: Contiguous  - 01: Reload
///< - 10: Shadow Register  - 11: Linked List If the type selected is Contiguous,
///< the CHx_SAR register is loaded with the value of the end source address
///< of previous block + 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. If the type selected is Reload,
///< the CHx_SAR register is reloaded from the initial value of SAR at
///< the end of every block for multi-block transfers. A new block transfer
///< is then initiated. If the type selected is Shadow Register, the CHx_SAR
///< register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid
///< bit is set to 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. If the type selected is Linked
///< List, the CHx_SAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
///< bit is set to 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
///< are loaded from their initial values or from the contents of their
///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
///< to 1) at the end of every block for multi-block transfers based on
///< the multi-block transfer type programmed for source and destination
///< peripherals. Contiguous transfer on both source and destination peripheral
///< is not a valid multi-block transfer configuration. This field does
///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
///< not selected; in that case, the read-back value is always 0.
#define RCS_DMAC_CH1_CFG_SRC_MULTBLK_TYPE_BF_OFF ( 0)
#define RCS_DMAC_CH1_CFG_SRC_MULTBLK_TYPE_BF_WID ( 2)
#define RCS_DMAC_CH1_CFG_SRC_MULTBLK_TYPE_BF_MSK (0x00000003)
#define RCS_DMAC_CH1_CFG_SRC_MULTBLK_TYPE_BF_DEF (0x00000000)

///< Destination Multi Block Transfer Type. These bits define the type
///< of multi-block transfer used for destination peripheral.  - 00: Contiguous
///< - 01: Reload  - 10: Shadow Register  - 11: Linked List If the type
///< selected is Contiguous, the CHx_DAR register is loaded with the value
///< of the end source address of previous block + 1 at the end of every
///< block for multi-block transfers. A new block transfer is then initiated.
///< If the type selected is Reload, the CHx_DAR register is reloaded from
///< the initial value of DAR at the end of every block for multi-block
///< transfers. A new block transfer is then initiated. If the type selected
///< is Shadow Register, the CHx_DAR register is loaded from the content
///< of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set
///< to 1 at the end of every block for multi-block transfers. A new block
///< transfer is then initiated. If the type selected is Linked List, the
///< CHx_DAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
///< bit is set to 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
///< are loaded from their initial values or from the contents of their
///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
///< to 1) at the end of every block for multi-block transfers based on
///< the multi-block transfer type programmed for source and destination
///< peripherals. Contiguous transfer on both source and destination peripheral
///< is not a valid multi-block transfer configuration. This field does
///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
///< not selected; in that case, the read-back value is always 0.
#define RCS_DMAC_CH1_CFG_DST_MULTBLK_TYPE_BF_OFF ( 2)
#define RCS_DMAC_CH1_CFG_DST_MULTBLK_TYPE_BF_WID ( 2)
#define RCS_DMAC_CH1_CFG_DST_MULTBLK_TYPE_BF_MSK (0x0000000C)
#define RCS_DMAC_CH1_CFG_DST_MULTBLK_TYPE_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits 4to17) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_OFF ( 4)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_WID (14)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_MSK (0x0003FFF0)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_DEF (0x00000000)

///< Defines the number of AXI Unique ID's supported for the AXI Read Channel.
///< The value programmed must be less than or equal to DMAX_CH(x)_RD_UID.
///< Otherwise, it is limited by the value DMAX_CH(x)_RD_UID.
#define RCS_DMAC_CH1_CFG_RD_UID_BF_OFF (18)
#define RCS_DMAC_CH1_CFG_RD_UID_BF_WID ( 4)
#define RCS_DMAC_CH1_CFG_RD_UID_BF_MSK (0x003C0000)
#define RCS_DMAC_CH1_CFG_RD_UID_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits 22to24) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_OFF (22)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_WID ( 3)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_MSK (0x01C00000)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_DEF (0x00000000)

///< Defines the number of AXI Unique ID's supported for the AXI Write
///< Channel. The value programmed must be less than or equal to DMAX_CH(x)_WR_UID.
///< Otherwise, it is limited by the value DMAX_CH(x)_WR_UID.
#define RCS_DMAC_CH1_CFG_WR_UID_BF_OFF (25)
#define RCS_DMAC_CH1_CFG_WR_UID_BF_WID ( 4)
#define RCS_DMAC_CH1_CFG_WR_UID_BF_MSK (0x1E000000)
#define RCS_DMAC_CH1_CFG_WR_UID_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits 29to31) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_OFF (29)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_WID ( 3)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_MSK (0xE0000000)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_DEF (0x00000000)

///< Transfer Type and Flow Control. The following transfer types are supported.
///< - Memory to Memory   - Memory to Peripheral   - Peripheral to Memory
///< - Peripheral to Peripheral   Flow Control can be assigned to the DW_axi_dmac,
///< the source peripheral, or the destination peripheral.
#define RCS_DMAC_CH1_CFG_TT_FC_BF_OFF (32)
#define RCS_DMAC_CH1_CFG_TT_FC_BF_WID ( 3)
#define RCS_DMAC_CH1_CFG_TT_FC_BF_MSK (0x700000000)
#define RCS_DMAC_CH1_CFG_TT_FC_BF_DEF (0x300000000)

///< Source Software or Hardware Handshaking Select. This register selects
///< which of the handshaking interfaces (hardware or software) is active
///< for source requests on this channel.  - 0: Hardware handshaking interface.
///< Software-initiated transaction requests are ignored.  - 1: Software
///< handshaking interface. Hardware-initiated transaction requests are
///< ignored. If the source peripheral is memory, then this bit is ignored.
#define RCS_DMAC_CH1_CFG_HS_SEL_SRC_BF_OFF (35)
#define RCS_DMAC_CH1_CFG_HS_SEL_SRC_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_HS_SEL_SRC_BF_MSK (0x800000000)
#define RCS_DMAC_CH1_CFG_HS_SEL_SRC_BF_DEF (0x800000000)

///< Destination Software or Hardware Handshaking Select. This register
///< selects which of the handshaking interfaces (hardware or software)
///< is active for destination requests on this channel.  - 0: Hardware
///< handshaking interface. Software-initiated transaction requests are
///< ignored.  - 1: Software handshaking interface. Hardware-initiated
///< transaction requests are ignored. If the destination peripheral is
///< memory, then this bit is ignored.
#define RCS_DMAC_CH1_CFG_HS_SEL_DST_BF_OFF (36)
#define RCS_DMAC_CH1_CFG_HS_SEL_DST_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_HS_SEL_DST_BF_MSK (0x1000000000)
#define RCS_DMAC_CH1_CFG_HS_SEL_DST_BF_DEF (0x1000000000)

///< Source Hardware Handshaking Interface Polarity.  - 0: ACTIVE HIGH
///< - 1: ACTIVE LOW  Note: This field is reserved for future use and currently
///< this is always active high.
#define RCS_DMAC_CH1_CFG_SRC_HWHS_POL_BF_OFF (37)
#define RCS_DMAC_CH1_CFG_SRC_HWHS_POL_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_SRC_HWHS_POL_BF_MSK (0x2000000000)
#define RCS_DMAC_CH1_CFG_SRC_HWHS_POL_BF_DEF (0x00000000)

///< Destination Hardware Handshaking Interface Polarity.  - 0: ACTIVE
///< HIGH  - 1: ACTIVE LOW  Note: This field is reserved for future use
///< and currently this is always active high.
#define RCS_DMAC_CH1_CFG_DST_HWHS_POL_BF_OFF (38)
#define RCS_DMAC_CH1_CFG_DST_HWHS_POL_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_DST_HWHS_POL_BF_MSK (0x4000000000)
#define RCS_DMAC_CH1_CFG_DST_HWHS_POL_BF_DEF (0x00000000)

///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
///< the source of Channelx if the CHx_CFG.HS_SEL_SRC field is 0; otherwise,
///< this field is ignored. The channel can then communicate with the source
///< peripheral connected to that interface through the assigned hardware
///< handshaking interface.  Note: For correct DW_axi_dmac operation, only
///< one peripheral (source or destination) should be assigned to the same
///< handshaking interface. This field does not exist if the configuration
///< parameter DMAX_NUM_HS_IF is set to 0. x = 39 if DMAC_NUM_HS_IF is
///< 1 x = ceil(log2(DMAC_NUM_HS_IF) + 38 if DMAC_NUM_HS_IF is greater
///< than 1. Bits 42: (x+1) do not exist and return 0 on a read.
#define RCS_DMAC_CH1_CFG_SRC_PER_BF_OFF (39)
#define RCS_DMAC_CH1_CFG_SRC_PER_BF_WID ( 3)
#define RCS_DMAC_CH1_CFG_SRC_PER_BF_MSK (0x38000000000)
#define RCS_DMAC_CH1_CFG_SRC_PER_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+39)
///< to 42) Reserved bits - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_OFF (42)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_MSK (0x40000000000)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (43bit) Reserved bit
///< - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_43_BF_OFF (43)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_43_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_43_BF_MSK (0x80000000000)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_43_BF_DEF (0x00000000)

///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
///< the destination of Channelx if the CHx_CFG.HS_SEL_DST field is 0;
///< otherwise, this field is ignored. The channel can then communicate
///< with the destination peripheral connected to that interface through
///< the assigned hardware handshaking interface.  Note: For correct DW_axi_dmac
///< operation, only one peripheral (source or destination) should be assigned
///< to the same handshaking interface.  This field does not exist if the
///< configuration parameter DMAX_NUM_HS_IF is set to 0. x = 44 if DMAC_NUM_HS_IF
///< is 1 x = ceil(log2(DMAC_NUM_HS_IF)) + 43 if DMAC_NUM_HS_IF is greater
///< than 1 Bits 47: (x+1) do not exist and return 0 on a read.
#define RCS_DMAC_CH1_CFG_DST_PER_BF_OFF (44)
#define RCS_DMAC_CH1_CFG_DST_PER_BF_WID ( 3)
#define RCS_DMAC_CH1_CFG_DST_PER_BF_MSK (0x700000000000)
#define RCS_DMAC_CH1_CFG_DST_PER_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+44)
///< to 47) Reserved bits - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_OFF (47)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_MSK (0x800000000000)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (48bit) Reserved bit
///< - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_48_BF_OFF (48)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_48_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_48_BF_MSK (0x1000000000000)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_48_BF_DEF (0x00000000)

///< Channel Priority A priority of DMAX_NUM_CHANNELS-1 is the highest
///< priority, and 0 is the lowest. This field must be programmed within
///< the following range:       0: DMAX_NUM_CHANNELS-1 A programmed value
///< outside this range will cause erroneous behavior.
#define RCS_DMAC_CH1_CFG_CH_PRIOR_BF_OFF (49)
#define RCS_DMAC_CH1_CFG_CH_PRIOR_BF_WID ( 3)
#define RCS_DMAC_CH1_CFG_CH_PRIOR_BF_MSK (0xE000000000000)
#define RCS_DMAC_CH1_CFG_CH_PRIOR_BF_DEF (0x2000000000000)

///< Channel Lock bit When the channel is granted control of the manager
///< bus interface and if the CHx_CFG.LOCK_CH bit is asserted, then no
///< other channels are granted control of the manager bus interface for
///< the duration specified in CHx_CFG.LOCK_CH_L. Indicates to the manager
///< bus interface arbiter that this channel wants exclusive access to
///< the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L.
///< This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN
///< is set to False; in this case, the read-back value is always 0. Locking
///< the channel locks AXI Read Address, Write Address and Write Data channels
///< on the corresponding manager interface. Note: Channel locking feature
///< is supported only for memory-to-memory transfer at Block Transfer
///< and DMA Transfer levels. Hardware does not check for the validity
///< of channel locking setting, hence the software must take care of enabling
///< the channel locking only for memory-to-memory transfers at Block Transfer
///< or DMA Transfer levels. Illegal programming of channel locking might
///< result in unpredictable behavior.
#define RCS_DMAC_CH1_CFG_LOCK_CH_BF_OFF (52)
#define RCS_DMAC_CH1_CFG_LOCK_CH_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_LOCK_CH_BF_MSK (0x10000000000000)
#define RCS_DMAC_CH1_CFG_LOCK_CH_BF_DEF (0x00000000)

///< Channel Lock Level This bit indicates the duration over which CHx_CFG.LOCK_CH
///< bit applies.  - 00: Over complete DMA transfer  - 01: Over DMA block
///< transfer  - 1x: Reserved This field does not exist if the configuration
///< parameter DMAX_CHx_LOCK_EN is set to False; in that case, the read-back
///< value is always 0.
#define RCS_DMAC_CH1_CFG_LOCK_CH_L_BF_OFF (53)
#define RCS_DMAC_CH1_CFG_LOCK_CH_L_BF_WID ( 2)
#define RCS_DMAC_CH1_CFG_LOCK_CH_L_BF_MSK (0x60000000000000)
#define RCS_DMAC_CH1_CFG_LOCK_CH_L_BF_DEF (0x00000000)

///< Source Outstanding Request Limit  - Maximum outstanding request supported
///< is 16.  - Source Outstanding Request Limit = SRC_OSR_LMT + 1
#define RCS_DMAC_CH1_CFG_SRC_OSR_LMT_BF_OFF (55)
#define RCS_DMAC_CH1_CFG_SRC_OSR_LMT_BF_WID ( 4)
#define RCS_DMAC_CH1_CFG_SRC_OSR_LMT_BF_MSK (0x780000000000000)
#define RCS_DMAC_CH1_CFG_SRC_OSR_LMT_BF_DEF (0x00000000)

///< Destination Outstanding Request Limit  - Maximum outstanding request
///< supported is 16.  - Destination Outstanding Request Limit = DST_OSR_LMT
///< + 1
#define RCS_DMAC_CH1_CFG_DST_OSR_LMT_BF_OFF (59)
#define RCS_DMAC_CH1_CFG_DST_OSR_LMT_BF_WID ( 4)
#define RCS_DMAC_CH1_CFG_DST_OSR_LMT_BF_MSK (0x7800000000000000)
#define RCS_DMAC_CH1_CFG_DST_OSR_LMT_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (63bit) Reserved bit
///< - Read Only
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_63_BF_OFF (63)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_63_BF_WID ( 1)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_63_BF_MSK (0x8000000000000000)
#define RCS_DMAC_CH1_CFG_RSVD_DMAC_CHX_CFG_63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_LLP register description at address offset 0x128
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_LLP
  * DW_axi_dmac Channel x Linked List Pointer Register
  */

typedef union {
  struct {
    uint64_t LMS : 1;
    ///< LLI manager Select This bit identifies the AXI layer/interface where
    ///< the memory device that stores the next linked list item resides.
    ///< - 0: AXI Manager 1  - 1: AXI Manager 2 This field does not exist if
    ///< the configuration parameter DMAX_CHx_LMS is not set to NO_HARDCODE.
    ///< In this case, the read-back value is always the hardcoded value. The
    ///< maximum value of this field that can be read back is 'DMAX_NUM_MASTER_IF-1'.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_LLP_1TO5 : 5;
    ///< DMAC Channelx Linked List Pointer Register (bits 1to5) Reserved bits
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint64_t LOC : 58;
    ///< Starting Address Memory of LLI block Starting Address In Memory of
    ///< next LLI if block chaining is enabled. The six LSBs of the starting
    ///< address are not stored because the address is assumed to be aligned
    ///< to a 64-byte boundary. LLI access always uses the burst size (arsize/awsize)
    ///< that is same as the data bus width and cannot be changed or programmed
    ///< to anything other than this. Burst length (awlen/arlen) is chosen
    ///< based on the data bus width so that the access does not cross one
    ///< complete LLI structure of 64 bytes. DW_axi_dmac will fetch the entire
    ///< LLI (40 bytes) in one AXI burst if the burst length is not limited
    ///< by other settings.
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_llp_reg_t;

#define RCS_DMAC_CH1_LLP_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_LLP_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_LLP_WR_MASK (0xffffffffffffffc0ULL)


///< LLI manager Select This bit identifies the AXI layer/interface where
///< the memory device that stores the next linked list item resides.
///< - 0: AXI Manager 1  - 1: AXI Manager 2 This field does not exist if
///< the configuration parameter DMAX_CHx_LMS is not set to NO_HARDCODE.
///< In this case, the read-back value is always the hardcoded value. The
///< maximum value of this field that can be read back is 'DMAX_NUM_MASTER_IF-1'.
#define RCS_DMAC_CH1_LLP_LMS_BF_OFF ( 0)
#define RCS_DMAC_CH1_LLP_LMS_BF_WID ( 1)
#define RCS_DMAC_CH1_LLP_LMS_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_LLP_LMS_BF_DEF (0x00000000)

///< DMAC Channelx Linked List Pointer Register (bits 1to5) Reserved bits
///< - Read Only
#define RCS_DMAC_CH1_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_OFF ( 1)
#define RCS_DMAC_CH1_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_WID ( 5)
#define RCS_DMAC_CH1_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_MSK (0x0000003E)
#define RCS_DMAC_CH1_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_DEF (0x00000000)

///< Starting Address Memory of LLI block Starting Address In Memory of
///< next LLI if block chaining is enabled. The six LSBs of the starting
///< address are not stored because the address is assumed to be aligned
///< to a 64-byte boundary. LLI access always uses the burst size (arsize/awsize)
///< that is same as the data bus width and cannot be changed or programmed
///< to anything other than this. Burst length (awlen/arlen) is chosen
///< based on the data bus width so that the access does not cross one
///< complete LLI structure of 64 bytes. DW_axi_dmac will fetch the entire
///< LLI (40 bytes) in one AXI burst if the burst length is not limited
///< by other settings.
#define RCS_DMAC_CH1_LLP_LOC_BF_OFF ( 6)
#define RCS_DMAC_CH1_LLP_LOC_BF_WID (58)
#define RCS_DMAC_CH1_LLP_LOC_BF_MSK (0xFFFFFFFFFFFFFFC0)
#define RCS_DMAC_CH1_LLP_LOC_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_STATUSREG register description at address offset 0x130
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_STATUSREG
  * DW_axi_dmac Channel x Status Register
  */

typedef union {
  struct {
    uint64_t CMPLTD_BLK_TFR_SIZE : 22;
    ///< Completed Block Transfer Size. The Completed Block Transfer Size status
    ///< indicates the total number of data items transferred from the Source
    ///< memory/peripheral to the Destination memory/peripheral at any point
    ///< in the DMA block transfer. The completed block transfer size or data
    ///< items is defined as follows:  - When DMA or Source is a Flow controller,
    ///< this field is defined in terms of the CHx_CTL.SRC_TR_WIDTH.  - When
    ///< Destination is a Flow Controller, this field is defined in terms of
    ///< the CHx_CTL.DST_TR_WIDTH. For more information, see  DMA Status Register
    ///< - CHx_STATUSREG  section of the databook.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_STATUSREG_22TO31 : 10;
    ///< DMAC Channelx Status Register (bits 22to31) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t DATA_LEFT_IN_FIFO : 15;
    ///< Data Left in FIFO.  The data left in the FIFO status indicates the
    ///< total number of data left in the channel FIFO after completing the
    ///< current DMA block transfer or DMA block abnormal termination due to
    ///< the following reasons:   - AXI Transfer Error response (SLVERR or
    ///< DECERR) reception   - Channel Terminate The width of the data in channel
    ///< FIFO is defined in terms of CHx_CTL.SRC_TR_WIDTH. For more information,
    ///< see  DMA Status Register - CHx_STATUSREG  section of the databook.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_STATUSREG_47TO63 : 17;
    ///< DMAC Channelx Status Register (bits 47to63) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="47" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_statreg_reg_t;

#define RCS_DMAC_CH1_STATREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_STATREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_STATREG_WR_MASK (0x0000000000000000ULL)


///< Completed Block Transfer Size. The Completed Block Transfer Size status
///< indicates the total number of data items transferred from the Source
///< memory/peripheral to the Destination memory/peripheral at any point
///< in the DMA block transfer. The completed block transfer size or data
///< items is defined as follows:  - When DMA or Source is a Flow controller,
///< this field is defined in terms of the CHx_CTL.SRC_TR_WIDTH.  - When
///< Destination is a Flow Controller, this field is defined in terms of
///< the CHx_CTL.DST_TR_WIDTH. For more information, see  DMA Status Register
///< - CHx_STATUSREG  section of the databook.
#define RCS_DMAC_CH1_STATREG_CMPLTD_BLK_TFR_SIZE_BF_OFF ( 0)
#define RCS_DMAC_CH1_STATREG_CMPLTD_BLK_TFR_SIZE_BF_WID (22)
#define RCS_DMAC_CH1_STATREG_CMPLTD_BLK_TFR_SIZE_BF_MSK (0x003FFFFF)
#define RCS_DMAC_CH1_STATREG_CMPLTD_BLK_TFR_SIZE_BF_DEF (0x00000000)

///< DMAC Channelx Status Register (bits 22to31) Reserved bits - Read Only
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_OFF (22)
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_WID (10)
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_MSK (0xFFC00000)
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_DEF (0x00000000)

///< Data Left in FIFO.  The data left in the FIFO status indicates the
///< total number of data left in the channel FIFO after completing the
///< current DMA block transfer or DMA block abnormal termination due to
///< the following reasons:   - AXI Transfer Error response (SLVERR or
///< DECERR) reception   - Channel Terminate The width of the data in channel
///< FIFO is defined in terms of CHx_CTL.SRC_TR_WIDTH. For more information,
///< see  DMA Status Register - CHx_STATUSREG  section of the databook.
#define RCS_DMAC_CH1_STATREG_DATA_LEFT_IN_FIFO_BF_OFF (32)
#define RCS_DMAC_CH1_STATREG_DATA_LEFT_IN_FIFO_BF_WID (15)
#define RCS_DMAC_CH1_STATREG_DATA_LEFT_IN_FIFO_BF_MSK (0x7FFF00000000)
#define RCS_DMAC_CH1_STATREG_DATA_LEFT_IN_FIFO_BF_DEF (0x00000000)

///< DMAC Channelx Status Register (bits 47to63) Reserved bits - Read Only
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_OFF (47)
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_WID (17)
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_MSK (0xFFFF800000000000)
#define RCS_DMAC_CH1_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_SWHSSRCREG register description at address offset 0x138
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_SWHSSRCREG
  * DW_axi_dmac Channel x Software Handshake Source Register
  */

typedef union {
  struct {
    uint64_t SWHS_REQ_SRC : 1;
    ///< Software Handshake Request for Channel Source. This bit is used to
    ///< request dma source data transfer if software handshaking method is
    ///< selected for the source of the corresponding channel. This bit is
    ///< ignored if software handshaking is not enabled for the source of the
    ///< Channelx. The functionality of this field depends on whether the peripheral
    ///< is the flow controller or not. Software can only set this bit to 1;
    ///< it is not allowed to clear this bit to 0; only DW_axi_dmac can clear
    ///< this bit. Note: SWHS_Req_Src bit is written only if the corresponding
    ///< write enable bit, SWHS_Req_Src_WE is asserted on the same register
    ///< write operation and if the Channelx is enabled in the DMAC_ChEnReg
    ///< register. This allows software to set a bit in the CHx_SWHSSrcReg
    ///< register without performing a read-modified write operation.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t SWHS_REQ_SRC_WE : 1;
    ///< Write Enable bit for Software Handshake Request for Channel Source.
    ///< Note: This bit always returns 0 on a read back.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_SRC : 1;
    ///< Software Handshake Single Request for Channel Source. This bit is
    ///< used to request SINGLE (AXI burst length = 1) dma source data transfer
    ///< if software handshaking method is selected for the source of the corresponding
    ///< channel. This bit is ignored if software handshaking is not enabled
    ///< for the source of the Channelx. The functionality of this field depends
    ///< on whether the peripheral is the flow controller. Software can only
    ///< set this bit to 1; it is not allowed to clear this bit to 0; only
    ///< DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Src bit is written
    ///< only if the corresponding write enable bit, SWHS_SglReq_Src_WE is
    ///< asserted on the same register write operation and if the Channelx
    ///< is enabled in the DMAC_ChEnReg register. This allows software to set
    ///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
    ///< write operation.
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_SRC_WE : 1;
    ///< Write Enable bit for Software Handshake Single Request for Channel
    ///< Source.
    ///< AccessType="WS/V" BitOffset="3" ResetValue="0x0"
    uint64_t SWHS_LST_SRC : 1;
    ///< Software Handshake Last Request for Channel Source. This bit is used
    ///< to request LAST dma source data transfer if software handshaking method
    ///< is selected for the source of the corresponding channel. This bit
    ///< is ignored if software handshaking is not enabled for the source of
    ///< the Channelx or if the source of Channelx is not the flow controller.
    ///< CHx_SWHSSrcReg.SWHS_Req_Src bit must be set to 1 for DW_axi_dmac to
    ///< treat it as a valid software handshaking request. If CHx_SWHSSrcReg.SWHS_SglReq_Src
    ///< is set to 1, the LAST request is for SINGLE dma transaction (AXI burst
    ///< length = 1), else the request is treated as a BURST transaction request.
    ///< Software can only set this bit to 1; it is not allowed to clear this
    ///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_Lst_Src
    ///< bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE
    ///< is asserted on the same register write operation and if the Channelx
    ///< is enabled in the DMAC_ChEnReg register. This allows software to set
    ///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
    ///< write operation.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint64_t SWHS_LST_SRC_WE : 1;
    ///< Write Enable bit for Software Handshake Last Request for Channel Source.
    ///< AccessType="WS/V" BitOffset="5" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_SWHSSRCREG_6TO63 : 58;
    ///< DMAC Channelx Software Handshake Source Register (bits 6to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_swhssrcreg_reg_t;

#define RCS_DMAC_CH1_SWHSSRCREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_SWHSSRCREG_RD_MASK (0xffffffffffffffd5ULL)
#define RCS_DMAC_CH1_SWHSSRCREG_WR_MASK (0x000000000000003fULL)


///< Software Handshake Request for Channel Source. This bit is used to
///< request dma source data transfer if software handshaking method is
///< selected for the source of the corresponding channel. This bit is
///< ignored if software handshaking is not enabled for the source of the
///< Channelx. The functionality of this field depends on whether the peripheral
///< is the flow controller or not. Software can only set this bit to 1;
///< it is not allowed to clear this bit to 0; only DW_axi_dmac can clear
///< this bit. Note: SWHS_Req_Src bit is written only if the corresponding
///< write enable bit, SWHS_Req_Src_WE is asserted on the same register
///< write operation and if the Channelx is enabled in the DMAC_ChEnReg
///< register. This allows software to set a bit in the CHx_SWHSSrcReg
///< register without performing a read-modified write operation.
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_BF_OFF ( 0)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Request for Channel Source.
///< Note: This bit always returns 0 on a read back.
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_OFF ( 1)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_MSK (0x00000002)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_DEF (0x00000000)

///< Software Handshake Single Request for Channel Source. This bit is
///< used to request SINGLE (AXI burst length = 1) dma source data transfer
///< if software handshaking method is selected for the source of the corresponding
///< channel. This bit is ignored if software handshaking is not enabled
///< for the source of the Channelx. The functionality of this field depends
///< on whether the peripheral is the flow controller. Software can only
///< set this bit to 1; it is not allowed to clear this bit to 0; only
///< DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Src bit is written
///< only if the corresponding write enable bit, SWHS_SglReq_Src_WE is
///< asserted on the same register write operation and if the Channelx
///< is enabled in the DMAC_ChEnReg register. This allows software to set
///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
///< write operation.
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_OFF ( 2)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_MSK (0x00000004)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Single Request for Channel
///< Source.
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_OFF ( 3)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_MSK (0x00000008)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_DEF (0x00000000)

///< Software Handshake Last Request for Channel Source. This bit is used
///< to request LAST dma source data transfer if software handshaking method
///< is selected for the source of the corresponding channel. This bit
///< is ignored if software handshaking is not enabled for the source of
///< the Channelx or if the source of Channelx is not the flow controller.
///< CHx_SWHSSrcReg.SWHS_Req_Src bit must be set to 1 for DW_axi_dmac to
///< treat it as a valid software handshaking request. If CHx_SWHSSrcReg.SWHS_SglReq_Src
///< is set to 1, the LAST request is for SINGLE dma transaction (AXI burst
///< length = 1), else the request is treated as a BURST transaction request.
///< Software can only set this bit to 1; it is not allowed to clear this
///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_Lst_Src
///< bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE
///< is asserted on the same register write operation and if the Channelx
///< is enabled in the DMAC_ChEnReg register. This allows software to set
///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
///< write operation.
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_BF_OFF ( 4)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_BF_MSK (0x00000010)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Last Request for Channel Source.
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_WE_BF_OFF ( 5)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_WE_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_WE_BF_MSK (0x00000020)
#define RCS_DMAC_CH1_SWHSSRCREG_SWHS_LST_SRC_WE_BF_DEF (0x00000000)

///< DMAC Channelx Software Handshake Source Register (bits 6to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_OFF ( 6)
#define RCS_DMAC_CH1_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_WID (58)
#define RCS_DMAC_CH1_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_MSK (0xFFFFFFFFFFFFFFC0)
#define RCS_DMAC_CH1_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_SWHSDSTREG register description at address offset 0x140
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_SWHSDSTREG
  * DW_axi_dmac Channel x Software Handshake Destination Register
  */

typedef union {
  struct {
    uint64_t SWHS_REQ_DST : 1;
    ///< Software Handshake Request for Channel Destination. This bit is used
    ///< to request dma destination data transfer if software handshaking method
    ///< is selected for the destination of the corresponding channel. This
    ///< bit is ignored if software handshaking is not enabled for the source
    ///< of the Channelx. The functionality of this field depends on whether
    ///< the peripheral is the flow controller. Software can only set this
    ///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
    ///< can clear this bit. Note: SWHS_Req_Dst bit is written only if the
    ///< corresponding write enable bit, SWHS_Req_Dst_WE is asserted on the
    ///< same register write operation and if the Channelx is enabled in the
    ///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
    ///< register without performing a read-modified write operation.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t SWHS_REQ_DST_WE : 1;
    ///< Write Enable bit for Software Handshake Request for Channel Destination.
    ///< Note: This bit always returns 0 on a read block.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_DST : 1;
    ///< Software Handshake Single Request for Channel Destination. This bit
    ///< is used to request SINGLE (AXI burst length = 1) dma destination data
    ///< transfer if software handshaking method is selected for the destination
    ///< of the corresponding channel. This bit is ignored if software handshaking
    ///< is not enabled for the destination of the Channelx. The functionality
    ///< of this field depends on whether the peripheral is the flow controller.
    ///< Software can only set this bit to 1; it is not allowed to clear this
    ///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Dst
    ///< bit is written only if the corresponding write enable bit, SWHS_SglReq_Dst_WE
    ///< is asserted on the same register write operation and if the Channelx
    ///< is enabled in the DMAC_ChEnReg register. This allows software to set
    ///< a bit in the CHx_SWHSDstReg register without performing a read-modified
    ///< write operation.
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_DST_WE : 1;
    ///< Write Enable bit for Software Handshake Single Request for Channel
    ///< Destination. Note: This bit always returns 0 on a read block.
    ///< AccessType="WS/V" BitOffset="3" ResetValue="0x0"
    uint64_t SWHS_LST_DST : 1;
    ///< Software Handshake Last Request for Channel Destination. This bit
    ///< is used to request LAST dma destination data transfer if software
    ///< handshaking method is selected for the destination of the corresponding
    ///< channel. This bit is ignored if software handshaking is not enabled
    ///< for the destination of the Channelx or if the destination of Channelx
    ///< is not the flow controller. CHx_SWHSDstReg.SWHS_Req_Dst bit must be
    ///< set to 1 for DW_axi_dmac to treat it as a valid software handshaking
    ///< request. If CHx_SWHSDstReg.SWHS_SglReq_Dst is set to 1, the LAST request
    ///< is for SINGLE dma transaction (AXI burst length = 1), else the request
    ///< is treated as a BURST transaction request. Software can only set this
    ///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
    ///< can clear this bit. Note: SWHS_Lst_Src bit is written only if the
    ///< corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the
    ///< same register write operation and if the Channelx is enabled in the
    ///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
    ///< register without performing a read-modified write operation.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint64_t SWHS_LST_DST_WE : 1;
    ///< Write Enable bit for Software Handshake Last Request for Channel Destination.
    ///< Note: This bit always returns 0 on a read back.
    ///< AccessType="WS/V" BitOffset="5" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_SWHSDSTREG_6TO63 : 58;
    ///< DMAC Channelx Software Handshake Destination Register (bits 6to63)
    ///< Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_swhsdstreg_reg_t;

#define RCS_DMAC_CH1_SWHSDSTREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_SWHSDSTREG_RD_MASK (0xffffffffffffffd5ULL)
#define RCS_DMAC_CH1_SWHSDSTREG_WR_MASK (0x000000000000003fULL)


///< Software Handshake Request for Channel Destination. This bit is used
///< to request dma destination data transfer if software handshaking method
///< is selected for the destination of the corresponding channel. This
///< bit is ignored if software handshaking is not enabled for the source
///< of the Channelx. The functionality of this field depends on whether
///< the peripheral is the flow controller. Software can only set this
///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
///< can clear this bit. Note: SWHS_Req_Dst bit is written only if the
///< corresponding write enable bit, SWHS_Req_Dst_WE is asserted on the
///< same register write operation and if the Channelx is enabled in the
///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
///< register without performing a read-modified write operation.
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_BF_OFF ( 0)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Request for Channel Destination.
///< Note: This bit always returns 0 on a read block.
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_WE_BF_OFF ( 1)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_WE_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_WE_BF_MSK (0x00000002)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_REQ_DST_WE_BF_DEF (0x00000000)

///< Software Handshake Single Request for Channel Destination. This bit
///< is used to request SINGLE (AXI burst length = 1) dma destination data
///< transfer if software handshaking method is selected for the destination
///< of the corresponding channel. This bit is ignored if software handshaking
///< is not enabled for the destination of the Channelx. The functionality
///< of this field depends on whether the peripheral is the flow controller.
///< Software can only set this bit to 1; it is not allowed to clear this
///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Dst
///< bit is written only if the corresponding write enable bit, SWHS_SglReq_Dst_WE
///< is asserted on the same register write operation and if the Channelx
///< is enabled in the DMAC_ChEnReg register. This allows software to set
///< a bit in the CHx_SWHSDstReg register without performing a read-modified
///< write operation.
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_BF_OFF ( 2)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_BF_MSK (0x00000004)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Single Request for Channel
///< Destination. Note: This bit always returns 0 on a read block.
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_OFF ( 3)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_MSK (0x00000008)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_DEF (0x00000000)

///< Software Handshake Last Request for Channel Destination. This bit
///< is used to request LAST dma destination data transfer if software
///< handshaking method is selected for the destination of the corresponding
///< channel. This bit is ignored if software handshaking is not enabled
///< for the destination of the Channelx or if the destination of Channelx
///< is not the flow controller. CHx_SWHSDstReg.SWHS_Req_Dst bit must be
///< set to 1 for DW_axi_dmac to treat it as a valid software handshaking
///< request. If CHx_SWHSDstReg.SWHS_SglReq_Dst is set to 1, the LAST request
///< is for SINGLE dma transaction (AXI burst length = 1), else the request
///< is treated as a BURST transaction request. Software can only set this
///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
///< can clear this bit. Note: SWHS_Lst_Src bit is written only if the
///< corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the
///< same register write operation and if the Channelx is enabled in the
///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
///< register without performing a read-modified write operation.
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_BF_OFF ( 4)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_BF_MSK (0x00000010)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Last Request for Channel Destination.
///< Note: This bit always returns 0 on a read back.
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_WE_BF_OFF ( 5)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_WE_BF_WID ( 1)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_WE_BF_MSK (0x00000020)
#define RCS_DMAC_CH1_SWHSDSTREG_SWHS_LST_DST_WE_BF_DEF (0x00000000)

///< DMAC Channelx Software Handshake Destination Register (bits 6to63)
///< Reserved bits - Read Only
#define RCS_DMAC_CH1_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_OFF ( 6)
#define RCS_DMAC_CH1_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_WID (58)
#define RCS_DMAC_CH1_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_MSK (0xFFFFFFFFFFFFFFC0)
#define RCS_DMAC_CH1_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_BLK_TFR_RESUMEREQREG register description at address offset 0x148
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_BLK_TFR_RESUMEREQREG
  * DW_axi_dmac Channel x Block Transfer Resume Request Register
  */

typedef union {
  struct {
    uint64_t BLK_TFR_RESUMEREQ : 1;
    ///< Block Transfer Resume Request during Linked-List or Shadow-Register-based
    ///< multi-block transfer.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63 : 63;
    ///< DMAC Channelx Block Transfer Resume Request Register (bits 1to63)
    ///< Reserved bits - Read Only
    ///< AccessType="WS" BitOffset="1" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_blk_tfr_resumereqreg_reg_t;

#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_RD_MASK (0x0000000000000000ULL)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_WR_MASK (0xffffffffffffffffULL)


///< Block Transfer Resume Request during Linked-List or Shadow-Register-based
///< multi-block transfer.
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_OFF ( 0)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_WID ( 1)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_DEF (0x00000000)

///< DMAC Channelx Block Transfer Resume Request Register (bits 1to63)
///< Reserved bits - Read Only
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_OFF ( 1)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_WID (63)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_MSK (0xFFFFFFFFFFFFFFFE)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_AXI_IDREG register description at address offset 0x150
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_AXI_IDREG
  * DW_axi_dmac Channel x AXI ID Register
  */

typedef union {
  struct {
    uint64_t AXI_READ_ID_SUFFIX : 2;
    ///< AXI Read ID Suffix These bits form part of the ARID output of AXI3/AXI4
    ///< manager interface.       IDW = DMAX_M_ID_WIDTH       L2NC = log2(DMAX_NUM_CHANNELS)
    ///< The upper L2NC+1 bits of aridN is derived from the channel number
    ///< which is currently accessing the manager interface. This varies for
    ///< LLI fetch and source data transfer. For source data transfer, aridN
    ///< for channel1 4'b0000, aridN for channel8 4'b0111 and so on. For LLI
    ///< fetch access, aridN  for channel1 4'b1000, aridN for channel8 4'b1111
    ///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Read_ID_Suffix
    ///< filed.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_IDREG_IDW_L2NCM1TO31 : 14;
    ///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to31) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint64_t AXI_WRITE_ID_SUFFIX : 2;
    ///< AXI Write ID Suffix. These bits form part of the AWID output of AXI3/AXI4
    ///< manager interface.      IDW = DMAX_M_ID_WIDTH      L2NC = log2(DMAX_NUM_CHANNELS)
    ///< The upper L2NC+1 bits of awidN is derived from the channel number
    ///< which is currently accessing the manager interface. This varies for
    ///< LLI fetch and source data transfer. For source data transfer, awidN
    ///< for channel1 4'b0000, awidN for channel8 4'b0111 and so on. For LLI
    ///< fetch access, awidN for channel1 4'b1000, awidN for channel8 4'b1111
    ///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Write_ID_Suffix
    ///< filed.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_IDREG_IDW_L2NCM32TO63 : 14;
    ///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to32) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_IDREG_32TO63 : 32;
    ///< DMAC Channelx AXI ID Register (bits 32to63) Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="32" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_idreg_reg_t;

#define RCS_DMAC_CH1_IDREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_IDREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_IDREG_WR_MASK (0x0000000000030003ULL)


///< AXI Read ID Suffix These bits form part of the ARID output of AXI3/AXI4
///< manager interface.       IDW = DMAX_M_ID_WIDTH       L2NC = log2(DMAX_NUM_CHANNELS)
///< The upper L2NC+1 bits of aridN is derived from the channel number
///< which is currently accessing the manager interface. This varies for
///< LLI fetch and source data transfer. For source data transfer, aridN
///< for channel1 4'b0000, aridN for channel8 4'b0111 and so on. For LLI
///< fetch access, aridN  for channel1 4'b1000, aridN for channel8 4'b1111
///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Read_ID_Suffix
///< filed.
#define RCS_DMAC_CH1_IDREG_READ_ID_SUFFIX_BF_OFF ( 0)
#define RCS_DMAC_CH1_IDREG_READ_ID_SUFFIX_BF_WID ( 2)
#define RCS_DMAC_CH1_IDREG_READ_ID_SUFFIX_BF_MSK (0x00000003)
#define RCS_DMAC_CH1_IDREG_READ_ID_SUFFIX_BF_DEF (0x00000000)

///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to31) Reserved bits
///< - Read Only
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_OFF ( 2)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_WID (14)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_MSK (0x0000FFFC)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_DEF (0x00000000)

///< AXI Write ID Suffix. These bits form part of the AWID output of AXI3/AXI4
///< manager interface.      IDW = DMAX_M_ID_WIDTH      L2NC = log2(DMAX_NUM_CHANNELS)
///< The upper L2NC+1 bits of awidN is derived from the channel number
///< which is currently accessing the manager interface. This varies for
///< LLI fetch and source data transfer. For source data transfer, awidN
///< for channel1 4'b0000, awidN for channel8 4'b0111 and so on. For LLI
///< fetch access, awidN for channel1 4'b1000, awidN for channel8 4'b1111
///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Write_ID_Suffix
///< filed.
#define RCS_DMAC_CH1_IDREG_WRITE_ID_SUFFIX_BF_OFF (16)
#define RCS_DMAC_CH1_IDREG_WRITE_ID_SUFFIX_BF_WID ( 2)
#define RCS_DMAC_CH1_IDREG_WRITE_ID_SUFFIX_BF_MSK (0x00030000)
#define RCS_DMAC_CH1_IDREG_WRITE_ID_SUFFIX_BF_DEF (0x00000000)

///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to32) Reserved bits
///< - Read Only
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_OFF (18)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_WID (14)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_MSK (0xFFFC0000)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_DEF (0x00000000)

///< DMAC Channelx AXI ID Register (bits 32to63) Reserved bits - Read Only
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_OFF (32)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_WID (32)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_MSK (0xFFFFFFFF00000000)
#define RCS_DMAC_CH1_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_AXI_QOSREG register description at address offset 0x158
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_AXI_QOSREG
  * DW_axi_dmac Channel x AXI QoS Register
  */

typedef union {
  struct {
    uint64_t AXI_AWQOS : 4;
    ///< AXI AWQOS. These bits form the awqos output of AXI4 manager interface.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint64_t AXI_ARQOS : 4;
    ///< AXI ARQOS. These bits form the arqos output of AXI4 manager interface.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_QOSREG_8TO63 : 56;
    ///< DMAC Channelx AXI QOS Register (bits 8to63) Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_qosreg_reg_t;

#define RCS_DMAC_CH1_QOSREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_QOSREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_QOSREG_WR_MASK (0x0000000000000000ULL)


///< AXI AWQOS. These bits form the awqos output of AXI4 manager interface.
#define RCS_DMAC_CH1_QOSREG_AWQOS_BF_OFF ( 0)
#define RCS_DMAC_CH1_QOSREG_AWQOS_BF_WID ( 4)
#define RCS_DMAC_CH1_QOSREG_AWQOS_BF_MSK (0x0000000F)
#define RCS_DMAC_CH1_QOSREG_AWQOS_BF_DEF (0x00000000)

///< AXI ARQOS. These bits form the arqos output of AXI4 manager interface.
#define RCS_DMAC_CH1_QOSREG_ARQOS_BF_OFF ( 4)
#define RCS_DMAC_CH1_QOSREG_ARQOS_BF_WID ( 4)
#define RCS_DMAC_CH1_QOSREG_ARQOS_BF_MSK (0x000000F0)
#define RCS_DMAC_CH1_QOSREG_ARQOS_BF_DEF (0x00000000)

///< DMAC Channelx AXI QOS Register (bits 8to63) Reserved bits - Read Only
#define RCS_DMAC_CH1_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_OFF ( 8)
#define RCS_DMAC_CH1_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_WID (56)
#define RCS_DMAC_CH1_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_MSK (0xFFFFFFFFFFFFFF00)
#define RCS_DMAC_CH1_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_INTSTATUS_ENABLEREG register description at address offset 0x180
  *
  * Register default value:        0xFFFFFFFFFFFFFFFF
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_INTSTATUS_ENABLEREG
  * DW_axi_dmac Channel x Interrupt Status Enable Register
  */

typedef union {
  struct {
    uint64_t ENABLE_BLOCK_TFR_DONE_INTSTAT : 1;
    ///< Block Transfer Done Interrupt Status Enable.  - 0: Disable the generation
    ///< of Block Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint64_t ENABLE_DMA_TFR_DONE_INTSTAT : 1;
    ///< DMA Transfer Done Interrupt Status Enable.  - 0: Disable the generation
    ///< of DMA Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_2 : 1;
    ///< DMAC Channelx Interrupt Status Register (bit 2) Reserved bit - Read
    ///< Only
    ///< AccessType="RO" BitOffset="2" ResetValue="0x1"
    uint64_t ENABLE_SRC_TRANSCOMP_INTSTAT : 1;
    ///< Source Transaction Completed Status Enable.  - 0: Disable the generation
    ///< of Source Transaction Complete Interrupt in CHx_INTSTATUSREG  - 1:
    ///< Enable the generation of Source Transaction Complete Interrupt in
    ///< CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint64_t ENABLE_DST_TRANSCOMP_INTSTAT : 1;
    ///< Destination Transaction Completed Status Enable.  - 0: Disable the
    ///< generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG
    ///< - 1: Enable the generation of Destination Transaction complete Interrupt
    ///< in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint64_t ENABLE_SRC_DEC_ERR_INTSTAT : 1;
    ///< Source Decode Error Status Enable.  - 0: Disable the generation of
    ///< Source Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of Source Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint64_t ENABLE_DST_DEC_ERR_INTSTAT : 1;
    ///< Destination Decode Error Status Enable.  - 0: Disable the generation
    ///< of Destination Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint64_t ENABLE_SRC_SLV_ERR_INTSTAT : 1;
    ///< Source Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of Source Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint64_t ENABLE_DST_SLV_ERR_INTSTAT : 1;
    ///< Destination Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG  -
    ///< 1: Enable the generation of Destination Subordinate Error Interrupt
    ///< in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_DEC_ERR_INTSTAT : 1;
    ///< LLI Read Decode Error Status Enable.  - 0: Disable the generation
    ///< of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_DEC_ERR_INTSTAT : 1;
    ///< LLI WRITE Decode Error Status Enable.  - 0: Disable the generation
    ///< of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="10" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_SLV_ERR_INTSTAT : 1;
    ///< LLI Read Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
    ///< Enable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="11" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_SLV_ERR_INTSTAT : 1;
    ///< LLI WRITE Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
    ///< Enable the generation of LLI WRITE Subordinate Error Interrupt in
    ///< CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint64_t ENABLE_SHADOWREG_OR_LLI_INVALID_ERR_INTSTAT : 1;
    ///< Shadow register or LLI Invalid Error Status Enable.  - 0: Disable
    ///< the generation of Shadow Register or LLI Invalid Error Interrupt in
    ///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow Register or
    ///< LLI Invalid  Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_MULTIBLKTYPE_ERR_INTSTAT : 1;
    ///< Register Bus Interface Multi Block type Error Status Enable.  - 0:
    ///< Disable the generation of Register Bus Interface Multi Block type
    ///< Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation of
    ///< Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_15 : 1;
    ///< DMAC Channelx Interrupt Status Register (bit 15) Reserved bit - Read
    ///< Only
    ///< AccessType="RO" BitOffset="15" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Decode Error Status Enable.  - 0: Disable the
    ///< generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG
    ///< - 1: Enable the generation of Register Bus Interface Decode Error
    ///< Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write to Read Only Error Status Enable.  -
    ///< 0: Disable the generation of Register Bus Interface Write to Read
    ///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Register Bus Interface Write to Read Only Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_RD2RWO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Read to write Only Error Status Enable.  -
    ///< 0: Disable the generation of Register Bus Interface Read to Write
    ///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Register Bus Interface Read to Write Only Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONCHEN_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Channel Enabled Error Status Enable.
    ///< - 0: Disable the generation of Register Bus Interface Write On Channel
    ///< enabled Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Register Bus Interface Write On Channel enabled Error Interrupt
    ///< in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="19" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_INTSTAT : 1;
    ///< Shadow Register Write On Valid Error Status Enable.  - 0: Disable
    ///< the generation of Shadow Register Write On Valid Error Interrupt in
    ///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow register Write
    ///< On Valid Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="20" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Hold Error Status Enable.  - 0: Disable
    ///< the generation of Register Bus Interface Write On Hold Error Interrupt
    ///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
    ///< Write On Hold Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_22TO23 : 2;
    ///< DMAC Channelx Interrupt Status Register (bits 22to23) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="22" ResetValue="0x3"
    uint64_t ENABLE_SLVIF_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Address Parity Error Enable.  - 0: Disable
    ///< the generation of Register Bus Interface Address Parity Error Interrupt
    ///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
    ///< Address Parity Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RO" BitOffset="24" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write Parity Error Enable.  - 0: Disable the
    ///< generation of Register Bus Interface Write Parity Error Interrupt
    ///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
    ///< Write Parity Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RO" BitOffset="25" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_26 : 1;
    ///< DMAC Channelx Interrupt Status Register (bit 26) Reserved bit - Read
    ///< Only
    ///< AccessType="RO" BitOffset="26" ResetValue="0x1"
    uint64_t ENABLE_CH_LOCK_CLEARED_INTSTAT : 1;
    ///< Channel Lock Cleared Status Enable.  - 0: Disable the generation of
    ///< Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint64_t ENABLE_CH_SRC_SUSPENDED_INTSTAT : 1;
    ///< Channel Source Suspended Status Enable.  - 0: Disable the generation
    ///< of Channel Source Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint64_t ENABLE_CH_SUSPENDED_INTSTAT : 1;
    ///< Channel Suspended Status Enable.  - 0: Disable the generation of Channel
    ///< Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Channel Suspended Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="29" ResetValue="0x1"
    uint64_t ENABLE_CH_DISABLED_INTSTAT : 1;
    ///< Channel Disabled Status Enable.  - 0: Disable the generation of Channel
    ///< Disabled Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Channel Disabled Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint64_t ENABLE_CH_ABORTED_INTSTAT : 1;
    ///< Channel Terminated Status Enable.  - 0: Disable the generation of
    ///< Channel Terminated Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of Channel Terminated Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="31" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_CORRERR_INTSTAT : 1;
    ///< Channel x Channel Memory Interface ECC Protection Correctable Error
    ///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
    ///< Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.
    ///< - 1: Enable the generation of Channel x Channel Memory Interface Correctable
    ///< Error Interrupt in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="32" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
    ///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
    ///< Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
    ///< - 1: Enable the generation Channel x Channel Memory Interface Uncorrectable
    ///< Error Interrupt in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="33" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_CORRERR_INTSTAT : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
    ///< Interrupt enable.  - 0: Disable the generation of Channel x UID Memory
    ///< Interface Correctable Error Interrupt in CHx_INTSTATUSREG.  - 1: Enable
    ///< the generation Channel x UID Memory Interface Correctable Error Interrupt
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="34" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
    ///< Error Interrupt enable.  - 0: Disable the generation of Channel x
    ///< UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
    ///< - 1: Enable the generation Channel x UID Memory Interface Uncorrectable
    ///< Error Interrupt in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="35" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_32TO63 : 28;
    ///< DMAC Channelx Interrupt Status Enable Register (bits 32to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="36" ResetValue="0xFFFFFFF"
  } ;
  uint64_t value;
} rcs_dmac_ch1_intstat_enreg_reg_t;

#define RCS_DMAC_CH1_INTSTAT_ENREG_DEFAULT (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_INTSTAT_ENREG_WR_MASK (0x00000000f83f7ffbULL)


///< Block Transfer Done Interrupt Status Enable.  - 0: Disable the generation
///< of Block Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_DEF (0x00000001)

///< DMA Transfer Done Interrupt Status Enable.  - 0: Disable the generation
///< of DMA Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_DEF (0x00000002)

///< DMAC Channelx Interrupt Status Register (bit 2) Reserved bit - Read
///< Only
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_DEF (0x00000004)

///< Source Transaction Completed Status Enable.  - 0: Disable the generation
///< of Source Transaction Complete Interrupt in CHx_INTSTATUSREG  - 1:
///< Enable the generation of Source Transaction Complete Interrupt in
///< CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_DEF (0x00000008)

///< Destination Transaction Completed Status Enable.  - 0: Disable the
///< generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG
///< - 1: Enable the generation of Destination Transaction complete Interrupt
///< in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_OFF ( 4)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_MSK (0x00000010)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_DEF (0x00000010)

///< Source Decode Error Status Enable.  - 0: Disable the generation of
///< Source Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of Source Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_OFF ( 5)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_MSK (0x00000020)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_DEF (0x00000020)

///< Destination Decode Error Status Enable.  - 0: Disable the generation
///< of Destination Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_DEF (0x00000040)

///< Source Subordinate Error Status Enable.  - 0: Disable the generation
///< of Source Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_DEF (0x00000080)

///< Destination Subordinate Error Status Enable.  - 0: Disable the generation
///< of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG  -
///< 1: Enable the generation of Destination Subordinate Error Interrupt
///< in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_DEF (0x00000100)

///< LLI Read Decode Error Status Enable.  - 0: Disable the generation
///< of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_DEF (0x00000200)

///< LLI WRITE Decode Error Status Enable.  - 0: Disable the generation
///< of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_DEF (0x00000400)

///< LLI Read Subordinate Error Status Enable.  - 0: Disable the generation
///< of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
///< Enable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_DEF (0x00000800)

///< LLI WRITE Subordinate Error Status Enable.  - 0: Disable the generation
///< of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
///< Enable the generation of LLI WRITE Subordinate Error Interrupt in
///< CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_DEF (0x00001000)

///< Shadow register or LLI Invalid Error Status Enable.  - 0: Disable
///< the generation of Shadow Register or LLI Invalid Error Interrupt in
///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow Register or
///< LLI Invalid  Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_DEF (0x00002000)

///< Register Bus Interface Multi Block type Error Status Enable.  - 0:
///< Disable the generation of Register Bus Interface Multi Block type
///< Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation of
///< Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_DEF (0x00004000)

///< DMAC Channelx Interrupt Status Register (bit 15) Reserved bit - Read
///< Only
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_OFF (15)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_DEF (0x00008000)

///< Register Bus Interface Decode Error Status Enable.  - 0: Disable the
///< generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG
///< - 1: Enable the generation of Register Bus Interface Decode Error
///< Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_DEF (0x00010000)

///< Register Bus Interface Write to Read Only Error Status Enable.  -
///< 0: Disable the generation of Register Bus Interface Write to Read
///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Register Bus Interface Write to Read Only Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_DEF (0x00020000)

///< Register Bus Interface Read to write Only Error Status Enable.  -
///< 0: Disable the generation of Register Bus Interface Read to Write
///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Register Bus Interface Read to Write Only Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_DEF (0x00040000)

///< Register Bus Interface Write On Channel Enabled Error Status Enable.
///< - 0: Disable the generation of Register Bus Interface Write On Channel
///< enabled Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Register Bus Interface Write On Channel enabled Error Interrupt
///< in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_DEF (0x00080000)

///< Shadow Register Write On Valid Error Status Enable.  - 0: Disable
///< the generation of Shadow Register Write On Valid Error Interrupt in
///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow register Write
///< On Valid Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_DEF (0x00100000)

///< Register Bus Interface Write On Hold Error Status Enable.  - 0: Disable
///< the generation of Register Bus Interface Write On Hold Error Interrupt
///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
///< Write On Hold Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00200000)

///< DMAC Channelx Interrupt Status Register (bits 22to23) Reserved bits
///< - Read Only
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_DEF (0x00C00000)

///< Register Bus Interface Address Parity Error Enable.  - 0: Disable
///< the generation of Register Bus Interface Address Parity Error Interrupt
///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
///< Address Parity Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x01000000)

///< Register Bus Interface Write Parity Error Enable.  - 0: Disable the
///< generation of Register Bus Interface Write Parity Error Interrupt
///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
///< Write Parity Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_DEF (0x02000000)

///< DMAC Channelx Interrupt Status Register (bit 26) Reserved bit - Read
///< Only
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_OFF (26)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_DEF (0x04000000)

///< Channel Lock Cleared Status Enable.  - 0: Disable the generation of
///< Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_DEF (0x08000000)

///< Channel Source Suspended Status Enable.  - 0: Disable the generation
///< of Channel Source Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_DEF (0x10000000)

///< Channel Suspended Status Enable.  - 0: Disable the generation of Channel
///< Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Channel Suspended Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_DEF (0x20000000)

///< Channel Disabled Status Enable.  - 0: Disable the generation of Channel
///< Disabled Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Channel Disabled Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_DEF (0x40000000)

///< Channel Terminated Status Enable.  - 0: Disable the generation of
///< Channel Terminated Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of Channel Terminated Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_OFF (31)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_MSK (0x80000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_DEF (0x80000000)

///< Channel x Channel Memory Interface ECC Protection Correctable Error
///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
///< Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.
///< - 1: Enable the generation of Channel x Channel Memory Interface Correctable
///< Error Interrupt in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_OFF (32)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_MSK (0x100000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_DEF (0x100000000)

///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
///< Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
///< - 1: Enable the generation Channel x Channel Memory Interface Uncorrectable
///< Error Interrupt in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_OFF (33)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_MSK (0x200000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_DEF (0x200000000)

///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
///< Interrupt enable.  - 0: Disable the generation of Channel x UID Memory
///< Interface Correctable Error Interrupt in CHx_INTSTATUSREG.  - 1: Enable
///< the generation Channel x UID Memory Interface Correctable Error Interrupt
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_OFF (34)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_MSK (0x400000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_DEF (0x400000000)

///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
///< Error Interrupt enable.  - 0: Disable the generation of Channel x
///< UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
///< - 1: Enable the generation Channel x UID Memory Interface Uncorrectable
///< Error Interrupt in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_OFF (35)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_MSK (0x800000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_DEF (0x800000000)

///< DMAC Channelx Interrupt Status Enable Register (bits 32to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_OFF (36)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_WID (28)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH1_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_DEF (0xFFFFFFF000000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_INTSTATUS register description at address offset 0x188
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_INTSTATUS
  * DW_axi_dmac Channel x Interrupt Status Register
  */

typedef union {
  struct {
    uint64_t BLOCK_TFR_DONE_INTSTAT : 1;
    ///< Block Transfer Done. This indicates to the software that the DW_axi_dmac
    ///< has completed the requested block transfer. The DW_axi_dmac sets this
    ///< bit to 1 when the transfer is successfully completed.  - 0: Block
    ///< Transfer not completed.  - 1: Block Transfer completed. This bit is
    ///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
    ///< bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t DMA_TFR_DONE_INTSTAT : 1;
    ///< DMA Transfer Done. This indicates to the software that the DW_axi_dmac
    ///< has completed the requested DMA transfer. The DW_axi_dmac sets this
    ///< bit to 1 along with setting CHx_INTSTATUS.BLOCK_TFR_DONE bit to 1
    ///< when the last block transfer is completed.  - 0: DMA Transfer not
    ///< completed.  - 1: DMA Transfer Completed  This bit is cleared to 0
    ///< on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_2 : 1;
    ///< DMAC Channelx Specific Interrupt Register (bit 2) Reserved bit - Read
    ///< Only
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint64_t SRC_TRANSCOMP_INTSTAT : 1;
    ///< Source Transaction Completed.      This bit is cleared to 0 on writing
    ///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register or on enabling the channel (needed when interrupt is not
    ///< enabled.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint64_t DST_TRANSCOMP_INTSTAT : 1;
    ///< Destination Transaction Completed.      This bit is cleared to 0 on
    ///< writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register or on enabling the channel (needed when interrupt is not
    ///< enabled.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint64_t SRC_DEC_ERR_INTSTAT : 1;
    ///< Source Decode Error. Decode Error detected by Manager Interface during
    ///< source data transfer. This error occurs if the access is to invalid
    ///< address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
    ///< channel which received the error is set to 0.  - 0: No Source Decode
    ///< Errors.  - 1: Source Decode Error detected. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint64_t DST_DEC_ERR_INTSTAT : 1;
    ///< Destination Decode Error. Decode Error detected by Manager Interface
    ///< during destination data transfer. This error occurs if the access
    ///< is to invalid address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
    ///< channel which received the error is set to 0.  - 0: No destination
    ///< Decode Errors.  - 1: Destination Decode Error Detected This bit is
    ///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
    ///< bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint64_t SRC_SLV_ERR_INTSTAT : 1;
    ///< Source Subordinate Error. Subordinate Error detected by Manager Interface
    ///< during source data transfer. This error occurs if the register bus
    ///< interface from which the data is read issues a Subordinate Error.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
    ///< channel which received the error is set to 0.   - 0: No Source Subordinate
    ///< Errors  - 1: Source Subordinate Error Detected  This bit is cleared
    ///< to 0 on writing 1 to the corresponding channel interrupt clear bit
    ///< in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint64_t DST_SLV_ERR_INTSTAT : 1;
    ///< Destination Subordinate Error. Subordinate Error detected by Manager
    ///< Interface during destination data transfer. This error occurs if the
    ///< register bus interface to which the data is written issues a Subordinate
    ///< Error. This error condition causes the DW_axi_dmac to disable the
    ///< corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding
    ///< to the channel which received the error is set to 0.  - 0: No Destination
    ///< Subordinate Errors  - 1: Destination Subordinate Errors Detected
    ///< This bit is cleared to 0 on writing 1 to the corresponding channel
    ///< interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint64_t LLI_RD_DEC_ERR_INTSTAT : 1;
    ///< LLI Read Decode Error. Decode Error detected by Manager Interface
    ///< during LLI read operation. This error occurs if the access is to invalid
    ///< address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
    ///< error is set to 0.  - 0: NO LLI Read Decode Errors.  - 1: LLI Read
    ///< Decode Error detected Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled.      This bit is cleared
    ///< to 0 on writing 1 to the corresponding channel interrupt clear bit
    ///< in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint64_t LLI_WR_DEC_ERR_INTSTAT : 1;
    ///< LLI WRITE Decode Error. Decode Error detected by Manager Interface
    ///< during LLI write-back operation. This error occurs if the access is
    ///< to invalid address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
    ///< error is set to 0.  - 0: NO LLI Write Decode Errors.  - 1: LLI write
    ///< Decode Error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint64_t LLI_RD_SLV_ERR_INTSTAT : 1;
    ///< LLI Read Subordinate Error. Subordinate Error detected by Manager
    ///< Interface during LLI read operation. This error occurs if the register
    ///< bus interface on which LLI resides issues a Subordinate Error. This
    ///< error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
    ///< error is set to 0.  - 0: No LLI Read Subordinate Errors.  - 1: LLI
    ///< read Subordinate Error detected. Error Interrupt is generated if the
    ///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
    ///< is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint64_t LLI_WR_SLV_ERR_INTSTAT : 1;
    ///< LLI WRITE Subordinate Error. Subordinate Error detected by Manager
    ///< Interface during LLI write-back operation. This error occurs if the
    ///< register bus interface on which LLI resides issues a Subordinate Error.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
    ///< error is set to 0.  - 0: No LLI write Subordinate Errors.  - 1: LLI
    ///< Write SUBORDINATE Error detected. Error Interrupt is generated if
    ///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint64_t SHADOWREG_OR_LLI_INVALID_ERR_INTSTAT : 1;
    ///< Shadow register or LLI Invalid Error. This error occurs if CHx_CTL.ShadowReg_Or_LLI_Valid
    ///< bit is seen to be 0 during DW_axi_dmac Shadow Register / LLI fetch
    ///< phase. This error condition causes the DW_axi_dmac to halt the corresponding
    ///< channel gracefully; Error Interrupt is generated if the corresponding
    ///< channel error interrupt mask bit is set to 0 and the channel waits
    ///< till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
    ///< valid Shadow Register availability. In the case of LLI pre-fetching,
    ///< ShadowReg_Or_LLI_Invalid_ERR Interrupt is not generated even if ShadowReg_Or_LLI_Valid
    ///< bit is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac
    ///< re-attempts the LLI fetch operation after completing the current block
    ///< transfer and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt only
    ///< if ShadowReg_Or_LLI_Valid bit is still seen to be 0.  - 0: No Shadow
    ///< Register / LLI Invalid errors.  - 1: Shadow Register / LLI Invalid
    ///< error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint64_t SLVIF_MULTIBLKTYPE_ERR_INTSTAT : 1;
    ///< Register Bus Interface Multi Block type Error. This error occurs if
    ///< multi-block transfer type programmed in CHx_CFG register (SRC_MLTBLK_TYPE
    ///< and DST_MLTBLK_TYPE) is invalid. This error condition causes the DW_axi_dmac
    ///< to halt the corresponding channel gracefully; Error Interrupt is generated
    ///< if the corresponding channel error interrupt mask bit is set to 0
    ///< and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg
    ///< to indicate valid multi-block transfer type availability.  - 0: No
    ///< Multi-block transfer type Errors.  - 1: Multi-block transfer type
    ///< Error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_15 : 1;
    ///< DMAC Channelx Specific Interrupt Register (bit 15) Reserved bit -
    ///< Read Only
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint64_t SLVIF_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Decode Error. Decode Error generated by DW_axi_dmac
    ///< during register access. This error occurs if the register access is
    ///< to invalid address in Channelx register space resulting in error response
    ///< by DW_axi_dmac register bus interface.  - 0: No Register Bus Interface
    ///< Decode errors.  - 1: Register Bus Interface Decode Error detected.
    ///< Error Interrupt is generated if the corresponding bit in CHxINTSTATUS_ENABLEReg
    ///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
    ///< channel interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint64_t SLVIF_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write to Read Only Error. This error occurs
    ///< if write operation is performed to a Read Only register.  - 0: No
    ///< Register Bus Interface Write to Read Only Errors.  - 1: Register Bus
    ///< Interface Write to Read Only Error detected. Error Interrupt is generated
    ///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint64_t SLVIF_RD2RWO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Read to write Only Error. This error occurs
    ///< if read operation is performed to a Write Only register.  - 0: No
    ///< Register Bus Interface Read to Write Only Errors.  - 1: Register Bus
    ///< Interface Read to Write Only Error detected. Error Interrupt is generated
    ///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint64_t SLVIF_WRONCHEN_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Channel Enabled Error. This error
    ///< occurs if an illegal write operation is performed on a register; this
    ///< happens if a write operation is performed on a register when the channel
    ///< is enabled and if it is not allowed for the corresponding register
    ///< as per the DW_axi_dmac specification.  - 0: No Register Bus Interface
    ///< Write On Channel Enabled Errors.  - 1: Register Bus Interface Write
    ///< On Channel Enabled Error detected. Error Interrupt is generated if
    ///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint64_t SLVIF_SHADOWREG_WRON_VALID_ERR_INTSTAT : 1;
    ///< Shadow Register Write On Valid Error. This error occurs if shadow
    ///< register based multi-block transfer is enabled and software tries
    ///< to write to the shadow register when CHx_CTL.ShadowReg_Or_LLI_Valid
    ///< bit is 1.  - 0: No Register Bus Interface Shadow Register Write On
    ///< Valid Errors.  - 1: Register Bus Interface Shadow Register Write On
    ///< Valid Error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint64_t SLVIF_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Hold Error. This error occurs if an
    ///< illegal write operation is performed on a register; this happens if
    ///< a write operation is performed on a channel register when DW_axi_dmac
    ///< is in Hold mode.  - 0: No Register Bus Interface Write On Hold Errors.
    ///< - 1: Register Bus Interface Write On Hold Error detected. Error Interrupt
    ///< is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is
    ///< enabled. This bit is cleared to 0 on writing 1 to the corresponding
    ///< channel interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_22TO23 : 2;
    ///< DMAC Channelx Specific Interrupt Register (bits 22to23) Reserved bits
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t SLVIF_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Address Parity Error. This error occurs if
    ///< address is used to do write/read operation on a channel register;
    ///< But the Address fails the even/odd parity check.  - 0: No Register
    ///< Bus Interface Address Parity Errors.  - 1: Register Bus Interface
    ///< Address Parity Error detected. Error Interrupt is generated if the
    ///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
    ///< is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint64_t SLVIF_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write Parity Error. This error occurs if a
    ///< Write operation is performed on a channel register; But the Write
    ///< data fails the even/odd parity check.  - 0: No Register Bus Interface
    ///< Write Parity Errors.  - 1: Register Bus Interface Write Parity Error
    ///< detected. Error Interrupt is generated if the corresponding bit in
    ///< CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing
    ///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_26 : 1;
    ///< DMAC Channelx Specific Interrupt Register (bit 26) Reserved bit -
    ///< Read Only
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint64_t CH_LOCK_CLEARED_INTSTAT : 1;
    ///< Channel Lock Cleared. This indicates to the software that the locking
    ///< of the corresponding channel in DW_axi_dmac is cleared.  - 0: Channel
    ///< locking is not cleared.  - 1: Channel locking is cleared.  Channel
    ///< locking is cleared by DW_axi_dmac during the following situations:
    ///< - Channel locking is cleared and the channel locking settings in CHx_CFG
    ///< register is reset if DW_axi_dmac disables the channel upon request
    ///< from software.  - Channel locking is cleared and the channel locking
    ///< settings in CHx_CFG register is reset if DW_axi_dmac disables the
    ///< channel upon receiving error response on the manager interface.  This
    ///< bit is cleared to 0 on enabling the channel.
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint64_t CH_SRC_SUSPENDED_INTSTAT : 1;
    ///< Channel Source Suspended. This indicates to the software that the
    ///< corresponding channel source data transfer in DW_axi_dmac is suspended.
    ///< - 0: Channel source is not suspended  - 1: Channel Source is suspended.
    ///< Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg
    ///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
    ///< channel interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint64_t CH_SUSPENDED_INTSTAT : 1;
    ///< Channel Suspended. This indicates to the software that the corresponding
    ///< channel in DW_axi_dmac is suspended.  - 0: Channel is not suspended.
    ///< - 1: Channel is suspended.  Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint64_t CH_DISABLED_INTSTAT : 1;
    ///< Channel Disabled. This indicates to the software that the corresponding
    ///< channel in DW_axi_dmac is disabled.  - 0: Channel is not disabled.
    ///< - 1: Channel is disabled.     Error Interrupt is generated if the
    ///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.      This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint64_t CH_ABORTED_INTSTAT : 1;
    ///< Channel Terminated. This indicates to the software that the corresponding
    ///< channel in DW_axi_dmac is terminated.  - 0: Channel is not terminated
    ///< - 1: Channel is terminated  Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="31" ResetValue="0x0"
    uint64_t ECC_PROT_CHMEM_CORRERR_INTSTAT : 1;
    ///< Channel x FIFO Memory Interface ECC Protection related Correctable
    ///< Error Interrupt Status bit.  This error occurs if ECC correctable
    ///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
    ///< x FIFO Memory Interface correctable Error.  - 1: Channel x FIFO Memory
    ///< Interface correctable Error detected.   Error Interrupt status is
    ///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t ECC_PROT_CHMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x FIFO Memory Interface ECC Protection related Uncorrectable
    ///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
    ///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
    ///< x FIFO Memory Interface Uncorrectable Error.  - 1: Channel x FIFO
    ///< Memory Interface Uncorrectable Error detected.   Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="33" ResetValue="0x0"
    uint64_t ECC_PROT_UIDMEM_CORRERR_INTSTAT : 1;
    ///< Channel x UID Memory Interface ECC Protection related Correctable
    ///< Error Interrupt Status bit.  This error occurs if ECC correctable
    ///< error is detected on the UID Memory Interface data.    - 0: No Channel
    ///< x UID Memory Interface correctable Error.  - 1: Channel x UID Memory
    ///< Interface correctable Error detected.   Error Interrupt status is
    ///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="34" ResetValue="0x0"
    uint64_t ECC_PROT_UIDMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x UID Memory Interface ECC Protection related Uncorrectable
    ///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
    ///< error is detected on the UID Memory Interface data.    - 0: No Channel
    ///< x UID Memory Interface Uncorrectable Error.  - 1: Channel x UID Memory
    ///< Interface Uncorrectable Error detected.   Error Interrupt status is
    ///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="35" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_36TO63 : 28;
    ///< DMAC Channelx Specific Interrupt Register (bits 36to63) Reserved bits
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="36" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_intstat_reg_t;

#define RCS_DMAC_CH1_INTSTAT_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_INTSTAT_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_INTSTAT_WR_MASK (0x0000000000000000ULL)


///< Block Transfer Done. This indicates to the software that the DW_axi_dmac
///< has completed the requested block transfer. The DW_axi_dmac sets this
///< bit to 1 when the transfer is successfully completed.  - 0: Block
///< Transfer not completed.  - 1: Block Transfer completed. This bit is
///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
///< bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CH1_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMA Transfer Done. This indicates to the software that the DW_axi_dmac
///< has completed the requested DMA transfer. The DW_axi_dmac sets this
///< bit to 1 along with setting CHx_INTSTATUS.BLOCK_TFR_DONE bit to 1
///< when the last block transfer is completed.  - 0: DMA Transfer not
///< completed.  - 1: DMA Transfer Completed  This bit is cleared to 0
///< on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register.
#define RCS_DMAC_CH1_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CH1_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CH1_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bit 2) Reserved bit - Read
///< Only
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_DEF (0x00000000)

///< Source Transaction Completed.      This bit is cleared to 0 on writing
///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register or on enabling the channel (needed when interrupt is not
///< enabled.
#define RCS_DMAC_CH1_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CH1_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CH1_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Destination Transaction Completed.      This bit is cleared to 0 on
///< writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register or on enabling the channel (needed when interrupt is not
///< enabled.
#define RCS_DMAC_CH1_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_OFF ( 4)
#define RCS_DMAC_CH1_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_MSK (0x00000010)
#define RCS_DMAC_CH1_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Source Decode Error. Decode Error detected by Manager Interface during
///< source data transfer. This error occurs if the access is to invalid
///< address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
///< channel which received the error is set to 0.  - 0: No Source Decode
///< Errors.  - 1: Source Decode Error detected. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_OFF ( 5)
#define RCS_DMAC_CH1_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_MSK (0x00000020)
#define RCS_DMAC_CH1_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Decode Error. Decode Error detected by Manager Interface
///< during destination data transfer. This error occurs if the access
///< is to invalid address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
///< channel which received the error is set to 0.  - 0: No destination
///< Decode Errors.  - 1: Destination Decode Error Detected This bit is
///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
///< bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_DST_DEC_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CH1_INTSTAT_DST_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_DST_DEC_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CH1_INTSTAT_DST_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Source Subordinate Error. Subordinate Error detected by Manager Interface
///< during source data transfer. This error occurs if the register bus
///< interface from which the data is read issues a Subordinate Error.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
///< channel which received the error is set to 0.   - 0: No Source Subordinate
///< Errors  - 1: Source Subordinate Error Detected  This bit is cleared
///< to 0 on writing 1 to the corresponding channel interrupt clear bit
///< in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CH1_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CH1_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Subordinate Error. Subordinate Error detected by Manager
///< Interface during destination data transfer. This error occurs if the
///< register bus interface to which the data is written issues a Subordinate
///< Error. This error condition causes the DW_axi_dmac to disable the
///< corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding
///< to the channel which received the error is set to 0.  - 0: No Destination
///< Subordinate Errors  - 1: Destination Subordinate Errors Detected
///< This bit is cleared to 0 on writing 1 to the corresponding channel
///< interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_DST_SLV_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CH1_INTSTAT_DST_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_DST_SLV_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CH1_INTSTAT_DST_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Decode Error. Decode Error detected by Manager Interface
///< during LLI read operation. This error occurs if the access is to invalid
///< address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
///< error is set to 0.  - 0: NO LLI Read Decode Errors.  - 1: LLI Read
///< Decode Error detected Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled.      This bit is cleared
///< to 0 on writing 1 to the corresponding channel interrupt clear bit
///< in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Decode Error. Decode Error detected by Manager Interface
///< during LLI write-back operation. This error occurs if the access is
///< to invalid address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
///< error is set to 0.  - 0: NO LLI Write Decode Errors.  - 1: LLI write
///< Decode Error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Subordinate Error. Subordinate Error detected by Manager
///< Interface during LLI read operation. This error occurs if the register
///< bus interface on which LLI resides issues a Subordinate Error. This
///< error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
///< error is set to 0.  - 0: No LLI Read Subordinate Errors.  - 1: LLI
///< read Subordinate Error detected. Error Interrupt is generated if the
///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
///< is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CH1_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Subordinate Error. Subordinate Error detected by Manager
///< Interface during LLI write-back operation. This error occurs if the
///< register bus interface on which LLI resides issues a Subordinate Error.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN1 bit which received the
///< error is set to 0.  - 0: No LLI write Subordinate Errors.  - 1: LLI
///< Write SUBORDINATE Error detected. Error Interrupt is generated if
///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CH1_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow register or LLI Invalid Error. This error occurs if CHx_CTL.ShadowReg_Or_LLI_Valid
///< bit is seen to be 0 during DW_axi_dmac Shadow Register / LLI fetch
///< phase. This error condition causes the DW_axi_dmac to halt the corresponding
///< channel gracefully; Error Interrupt is generated if the corresponding
///< channel error interrupt mask bit is set to 0 and the channel waits
///< till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
///< valid Shadow Register availability. In the case of LLI pre-fetching,
///< ShadowReg_Or_LLI_Invalid_ERR Interrupt is not generated even if ShadowReg_Or_LLI_Valid
///< bit is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac
///< re-attempts the LLI fetch operation after completing the current block
///< transfer and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt only
///< if ShadowReg_Or_LLI_Valid bit is still seen to be 0.  - 0: No Shadow
///< Register / LLI Invalid errors.  - 1: Shadow Register / LLI Invalid
///< error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CH1_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CH1_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Multi Block type Error. This error occurs if
///< multi-block transfer type programmed in CHx_CFG register (SRC_MLTBLK_TYPE
///< and DST_MLTBLK_TYPE) is invalid. This error condition causes the DW_axi_dmac
///< to halt the corresponding channel gracefully; Error Interrupt is generated
///< if the corresponding channel error interrupt mask bit is set to 0
///< and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg
///< to indicate valid multi-block transfer type availability.  - 0: No
///< Multi-block transfer type Errors.  - 1: Multi-block transfer type
///< Error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bit 15) Reserved bit -
///< Read Only
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_OFF (15)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_DEF (0x00000000)

///< Register Bus Interface Decode Error. Decode Error generated by DW_axi_dmac
///< during register access. This error occurs if the register access is
///< to invalid address in Channelx register space resulting in error response
///< by DW_axi_dmac register bus interface.  - 0: No Register Bus Interface
///< Decode errors.  - 1: Register Bus Interface Decode Error detected.
///< Error Interrupt is generated if the corresponding bit in CHxINTSTATUS_ENABLEReg
///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
///< channel interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write to Read Only Error. This error occurs
///< if write operation is performed to a Read Only register.  - 0: No
///< Register Bus Interface Write to Read Only Errors.  - 1: Register Bus
///< Interface Write to Read Only Error detected. Error Interrupt is generated
///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Read to write Only Error. This error occurs
///< if read operation is performed to a Write Only register.  - 0: No
///< Register Bus Interface Read to Write Only Errors.  - 1: Register Bus
///< Interface Read to Write Only Error detected. Error Interrupt is generated
///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Channel Enabled Error. This error
///< occurs if an illegal write operation is performed on a register; this
///< happens if a write operation is performed on a register when the channel
///< is enabled and if it is not allowed for the corresponding register
///< as per the DW_axi_dmac specification.  - 0: No Register Bus Interface
///< Write On Channel Enabled Errors.  - 1: Register Bus Interface Write
///< On Channel Enabled Error detected. Error Interrupt is generated if
///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow Register Write On Valid Error. This error occurs if shadow
///< register based multi-block transfer is enabled and software tries
///< to write to the shadow register when CHx_CTL.ShadowReg_Or_LLI_Valid
///< bit is 1.  - 0: No Register Bus Interface Shadow Register Write On
///< Valid Errors.  - 1: Register Bus Interface Shadow Register Write On
///< Valid Error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Hold Error. This error occurs if an
///< illegal write operation is performed on a register; this happens if
///< a write operation is performed on a channel register when DW_axi_dmac
///< is in Hold mode.  - 0: No Register Bus Interface Write On Hold Errors.
///< - 1: Register Bus Interface Write On Hold Error detected. Error Interrupt
///< is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is
///< enabled. This bit is cleared to 0 on writing 1 to the corresponding
///< channel interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bits 22to23) Reserved bits
///< - Read Only
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_DEF (0x00000000)

///< Register Bus Interface Address Parity Error. This error occurs if
///< address is used to do write/read operation on a channel register;
///< But the Address fails the even/odd parity check.  - 0: No Register
///< Bus Interface Address Parity Errors.  - 1: Register Bus Interface
///< Address Parity Error detected. Error Interrupt is generated if the
///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
///< is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write Parity Error. This error occurs if a
///< Write operation is performed on a channel register; But the Write
///< data fails the even/odd parity check.  - 0: No Register Bus Interface
///< Write Parity Errors.  - 1: Register Bus Interface Write Parity Error
///< detected. Error Interrupt is generated if the corresponding bit in
///< CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing
///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register.
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CH1_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bit 26) Reserved bit -
///< Read Only
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_OFF (26)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_DEF (0x00000000)

///< Channel Lock Cleared. This indicates to the software that the locking
///< of the corresponding channel in DW_axi_dmac is cleared.  - 0: Channel
///< locking is not cleared.  - 1: Channel locking is cleared.  Channel
///< locking is cleared by DW_axi_dmac during the following situations:
///< - Channel locking is cleared and the channel locking settings in CHx_CFG
///< register is reset if DW_axi_dmac disables the channel upon request
///< from software.  - Channel locking is cleared and the channel locking
///< settings in CHx_CFG register is reset if DW_axi_dmac disables the
///< channel upon receiving error response on the manager interface.  This
///< bit is cleared to 0 on enabling the channel.
#define RCS_DMAC_CH1_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CH1_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CH1_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_DEF (0x00000000)

///< Channel Source Suspended. This indicates to the software that the
///< corresponding channel source data transfer in DW_axi_dmac is suspended.
///< - 0: Channel source is not suspended  - 1: Channel Source is suspended.
///< Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg
///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
///< channel interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CH1_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CH1_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Suspended. This indicates to the software that the corresponding
///< channel in DW_axi_dmac is suspended.  - 0: Channel is not suspended.
///< - 1: Channel is suspended.  Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_CH_SUSPENDED_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CH1_INTSTAT_CH_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_CH_SUSPENDED_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CH1_INTSTAT_CH_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Disabled. This indicates to the software that the corresponding
///< channel in DW_axi_dmac is disabled.  - 0: Channel is not disabled.
///< - 1: Channel is disabled.     Error Interrupt is generated if the
///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.      This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_CH_DISD_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CH1_INTSTAT_CH_DISD_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_CH_DISD_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CH1_INTSTAT_CH_DISD_INTSTAT_BF_DEF (0x00000000)

///< Channel Terminated. This indicates to the software that the corresponding
///< channel in DW_axi_dmac is terminated.  - 0: Channel is not terminated
///< - 1: Channel is terminated  Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH1_INTSTAT_CH_ABORTED_INTSTAT_BF_OFF (31)
#define RCS_DMAC_CH1_INTSTAT_CH_ABORTED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_CH_ABORTED_INTSTAT_BF_MSK (0x80000000)
#define RCS_DMAC_CH1_INTSTAT_CH_ABORTED_INTSTAT_BF_DEF (0x00000000)

///< Channel x FIFO Memory Interface ECC Protection related Correctable
///< Error Interrupt Status bit.  This error occurs if ECC correctable
///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
///< x FIFO Memory Interface correctable Error.  - 1: Channel x FIFO Memory
///< Interface correctable Error detected.   Error Interrupt status is
///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_OFF (32)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_MSK (0x100000000)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< Channel x FIFO Memory Interface ECC Protection related Uncorrectable
///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
///< x FIFO Memory Interface Uncorrectable Error.  - 1: Channel x FIFO
///< Memory Interface Uncorrectable Error detected.   Error Interrupt status
///< is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_OFF (33)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_MSK (0x200000000)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< Channel x UID Memory Interface ECC Protection related Correctable
///< Error Interrupt Status bit.  This error occurs if ECC correctable
///< error is detected on the UID Memory Interface data.    - 0: No Channel
///< x UID Memory Interface correctable Error.  - 1: Channel x UID Memory
///< Interface correctable Error detected.   Error Interrupt status is
///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_OFF (34)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_MSK (0x400000000)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< Channel x UID Memory Interface ECC Protection related Uncorrectable
///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
///< error is detected on the UID Memory Interface data.    - 0: No Channel
///< x UID Memory Interface Uncorrectable Error.  - 1: Channel x UID Memory
///< Interface Uncorrectable Error detected.   Error Interrupt status is
///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_OFF (35)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_MSK (0x800000000)
#define RCS_DMAC_CH1_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bits 36to63) Reserved bits
///< - Read Only
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_OFF (36)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_WID (28)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH1_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_INTSIGNAL_ENABLEREG register description at address offset 0x190
  *
  * Register default value:        0xFFFFFFFFFFFFFFFF
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_INTSIGNAL_ENABLEREG
  * DW_axi_dmac Channel x Interrupt Signal Enable Register
  */

typedef union {
  struct {
    uint64_t ENABLE_BLOCK_TFR_DONE_INTSIGNAL : 1;
    ///< Block Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
    ///< of Block Transfer Done Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Block Transfer Done Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint64_t ENABLE_DMA_TFR_DONE_INTSIGNAL : 1;
    ///< DMA Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
    ///< of DMA Transfer Done Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of DMA Transfer Done Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_2 : 1;
    ///< DMAC Channelx Interrupt Status Enable Register (bit 2) Reserved bit
    ///< - Read Only
    ///< AccessType="RO" BitOffset="2" ResetValue="0x1"
    uint64_t ENABLE_SRC_TRANSCOMP_INTSIGNAL : 1;
    ///< Source Transaction Completed Signal Enable.  - 0: Disable the propagation
    ///< of Source Transaction Complete Interrupt to generate a port level
    ///< interrupt  - 1: Enable the propagation of Source Transaction Complete
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint64_t ENABLE_DST_TRANSCOMP_INTSIGNAL : 1;
    ///< Destination Transaction Completed Signal Enable.  - 0: Disable the
    ///< propagation of Destination Transaction complete Interrupt to generate
    ///< a port level interrupt  - 1: Enable the propagation of Destination
    ///< Transaction complete Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint64_t ENABLE_SRC_DEC_ERR_INTSIGNAL : 1;
    ///< Source Decode Error Signal Enable.  - 0: Disable the propagation of
    ///< Source Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Source Decode Error Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint64_t ENABLE_DST_DEC_ERR_INTSIGNAL : 1;
    ///< Destination Decode Error Signal Enable.  - 0: Disable the propagation
    ///< of Destination Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Destination Decode Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint64_t ENABLE_SRC_SLV_ERR_INTSIGNAL : 1;
    ///< Source Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of Source Subordinate Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Source Subordinate Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint64_t ENABLE_DST_SLV_ERR_INTSIGNAL : 1;
    ///< Destination Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of Destination Subordinate Error Interrupt to generate a port level
    ///< interrupt  - 1: Enable the propagation of Destination Subordinate
    ///< Error Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_DEC_ERR_INTSIGNAL : 1;
    ///< LLI Read Decode Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI Read Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of LLI Read Decode Error Interrupt to
    ///< generate a port level interrupt
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_DEC_ERR_INTSIGNAL : 1;
    ///< LLI WRITE Decode Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI WRITE Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of LLI WRITE Decode Error Interrupt to
    ///< generate a port level interrupt
    ///< AccessType="RW" BitOffset="10" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_SLV_ERR_INTSIGNAL : 1;
    ///< LLI Read Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI Read Subordinate Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of LLI Read Subordinate Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="11" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_SLV_ERR_INTSIGNAL : 1;
    ///< LLI WRITE Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI WRITE Subordinate Error Interrupt to generate a port level
    ///< interrupt  - 1: Enable the propagation of LLI WRITE Subordinate Error
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint64_t ENABLE_SHADOWREG_OR_LLI_INVALID_ERR_INTSIGNAL : 1;
    ///< Shadow register or LLI Invalid Error Signal Enable.  - 0: Disable
    ///< the propagation of Shadow Register or LLI Invalid Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Shadow Register or LLI Invalid  Error Interrupt to generate a port
    ///< level interrupt
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Multi Block type Error Signal Enable.  - 0:
    ///< Disable the propagation of Register Bus Interface Multi Block type
    ///< Error Interrupt to generate a port level interrupt  - 1: Enable the
    ///< propagation of Register Bus Interface Multi Block type Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_15 : 1;
    ///< DMAC Channelx Interrupt Status Enable Register (bit 15) Reserved bit
    ///< - Read Only
    ///< AccessType="RO" BitOffset="15" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_DEC_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Decode Error Signal Enable.  - 0: Disable the
    ///< propagation of Register Bus Interface Decode Error Interrupt to generate
    ///< a port level interrupt  - 1: Enable the propagation of Register Bus
    ///< Interface Decode Error Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WR2RO_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write to Read Only Error Signal Enable.  -
    ///< 0: Disable the propagation of Register Bus Interface Write to Read
    ///< only Error Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Register Bus Interface Write to Read Only Error
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_RD2RWO_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Read to write Only Error Signal Enable.  -
    ///< 0: Disable the propagation of Register Bus Interface Read to Write
    ///< only Error Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Register Bus Interface Read to Write Only Error
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONCHEN_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write On Channel Enabled Error Signal Enable.
    ///< - 0: Disable the propagation of Register Bus Interface Write On Channel
    ///< enabled Error Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Register Bus Interface Write On Channel enabled
    ///< Error Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="19" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_INTSIGNAL : 1;
    ///< Shadow Register Write On Valid Error Signal Enable.  - 0: Disable
    ///< the propagation of Shadow Register Write On Valid Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Shadow register Write On Valid Error Interrupt to generate a port
    ///< level interrupt
    ///< AccessType="RW" BitOffset="20" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONHOLD_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write On Hold Error Signal Enable.  - 0: Disable
    ///< the propagation of Register Bus Interface Write On Hold Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Register Bus Interface Write On Hold Error Interrupt to generate a
    ///< port level interrupt
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSIGNAL_ENABLEREG_22TO23 : 2;
    ///< DMAC Channelx Interrupt Signal Enable Register (bits 22to23) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="22" ResetValue="0x3"
    uint64_t ENABLE_SLVIF_ADDRPARITY_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Address Parity Error Signal Enable.  - 0: Disable
    ///< the propagation of Register Bus Interface Address Parity Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Register Bus Interface Address Parity Error Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RO" BitOffset="24" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRPARITY_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write Parity Error Signal Enable.  - 0: Disable
    ///< the propagation of Register Bus Interface Write Parity Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Register Bus Interface Write Parity Error Interrupt to generate a
    ///< port level interrupt
    ///< AccessType="RO" BitOffset="25" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSIGNAL_ENABLEREG_26 : 1;
    ///< DMAC Channelx Interrupt Signal Enable Register (bit 26) Reserved bit
    ///< - Read Only
    ///< AccessType="RO" BitOffset="26" ResetValue="0x1"
    uint64_t ENABLE_CH_LOCK_CLEARED_INTSIGNAL : 1;
    ///< Channel Lock Cleared Signal Enable.  - 0: Disable the propagation
    ///< of Channel Lock Cleared Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Channel Lock Cleared Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint64_t ENABLE_CH_SRC_SUSPENDED_INTSIGNAL : 1;
    ///< Channel Source Suspended Signal Enable.  - 0: Disable the propagation
    ///< of Channel Source Suspended Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Channel Source Suspended Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint64_t ENABLE_CH_SUSPENDED_INTSIGNAL : 1;
    ///< Channel Suspended Signal Enable.  - 0: Disable the propagation of
    ///< Channel Suspended Interrupt to generate a port level interrupt  -
    ///< 1: Enable the propagation of Channel Suspended Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="29" ResetValue="0x1"
    uint64_t ENABLE_CH_DISABLED_INTSIGNAL : 1;
    ///< Channel Disabled Signal Enable.  - 0: Disable the propagation of Channel
    ///< Disabled Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Channel Disabled Interrupt to generate a port level
    ///< interrupt
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint64_t ENABLE_CH_ABORTED_INTSIGNAL : 1;
    ///< Channel Terminated Signal Enable.  - 0: Disable the propagation of
    ///< Channel Terminated Interrupt to generate a port level interrupt  -
    ///< 1: Enable the propagation of Channel Terminated Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="31" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_CORRERR_INTSIGNAL : 1;
    ///< Channel x Channel Memory Interface ECC Protection Correctable Error
    ///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x Channel Memory Interface Correctable Error to generate a port level
    ///< interrupt.  - 1: Enable the propagation of Channel x Channel Memory
    ///< Interface Correctable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="32" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL : 1;
    ///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
    ///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x Channel Memory Interface Uncorrectable Error to generate a port
    ///< level interrupt.  - 1: Enable the propagation of Channel x Channel
    ///< Memory Interface Uncorrectable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="33" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
    ///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x UID Memory Interface Correctable Error to generate a port level
    ///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
    ///< Correctable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="34" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
    ///< Error Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x UID Memory Interface Uncorrectable Error to generate a port level
    ///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
    ///< Uncorrectable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="35" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSIGNAL_ENABLEREG_36TO63 : 28;
    ///< DMAC Channelx Interrupt Signal Enable Register (bits 36to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="36" ResetValue="0xFFFFFFF"
  } ;
  uint64_t value;
} rcs_dmac_ch1_intsignal_enreg_reg_t;

#define RCS_DMAC_CH1_INTSIGNAL_ENREG_DEFAULT (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_WR_MASK (0x00000000f83f7ffbULL)


///< Block Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
///< of Block Transfer Done Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Block Transfer Done Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_OFF ( 0)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_DEF (0x00000001)

///< DMA Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
///< of DMA Transfer Done Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of DMA Transfer Done Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_OFF ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_MSK (0x00000002)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_DEF (0x00000002)

///< DMAC Channelx Interrupt Status Enable Register (bit 2) Reserved bit
///< - Read Only
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_DEF (0x00000004)

///< Source Transaction Completed Signal Enable.  - 0: Disable the propagation
///< of Source Transaction Complete Interrupt to generate a port level
///< interrupt  - 1: Enable the propagation of Source Transaction Complete
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_OFF ( 3)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_MSK (0x00000008)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_DEF (0x00000008)

///< Destination Transaction Completed Signal Enable.  - 0: Disable the
///< propagation of Destination Transaction complete Interrupt to generate
///< a port level interrupt  - 1: Enable the propagation of Destination
///< Transaction complete Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_OFF ( 4)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_MSK (0x00000010)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_DEF (0x00000010)

///< Source Decode Error Signal Enable.  - 0: Disable the propagation of
///< Source Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Source Decode Error Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_OFF ( 5)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_MSK (0x00000020)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_DEF (0x00000020)

///< Destination Decode Error Signal Enable.  - 0: Disable the propagation
///< of Destination Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Destination Decode Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_OFF ( 6)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_MSK (0x00000040)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_DEF (0x00000040)

///< Source Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of Source Subordinate Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Source Subordinate Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_OFF ( 7)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_MSK (0x00000080)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_DEF (0x00000080)

///< Destination Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of Destination Subordinate Error Interrupt to generate a port level
///< interrupt  - 1: Enable the propagation of Destination Subordinate
///< Error Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_OFF ( 8)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_MSK (0x00000100)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_DEF (0x00000100)

///< LLI Read Decode Error Signal Enable.  - 0: Disable the propagation
///< of LLI Read Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of LLI Read Decode Error Interrupt to
///< generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_OFF ( 9)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_MSK (0x00000200)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_DEF (0x00000200)

///< LLI WRITE Decode Error Signal Enable.  - 0: Disable the propagation
///< of LLI WRITE Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of LLI WRITE Decode Error Interrupt to
///< generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_OFF (10)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_MSK (0x00000400)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_DEF (0x00000400)

///< LLI Read Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of LLI Read Subordinate Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of LLI Read Subordinate Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_OFF (11)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_MSK (0x00000800)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_DEF (0x00000800)

///< LLI WRITE Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of LLI WRITE Subordinate Error Interrupt to generate a port level
///< interrupt  - 1: Enable the propagation of LLI WRITE Subordinate Error
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_OFF (12)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_MSK (0x00001000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_DEF (0x00001000)

///< Shadow register or LLI Invalid Error Signal Enable.  - 0: Disable
///< the propagation of Shadow Register or LLI Invalid Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Shadow Register or LLI Invalid  Error Interrupt to generate a port
///< level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_OFF (13)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_MSK (0x00002000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_DEF (0x00002000)

///< Register Bus Interface Multi Block type Error Signal Enable.  - 0:
///< Disable the propagation of Register Bus Interface Multi Block type
///< Error Interrupt to generate a port level interrupt  - 1: Enable the
///< propagation of Register Bus Interface Multi Block type Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_OFF (14)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_MSK (0x00004000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_DEF (0x00004000)

///< DMAC Channelx Interrupt Status Enable Register (bit 15) Reserved bit
///< - Read Only
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_OFF (15)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_DEF (0x00008000)

///< Register Bus Interface Decode Error Signal Enable.  - 0: Disable the
///< propagation of Register Bus Interface Decode Error Interrupt to generate
///< a port level interrupt  - 1: Enable the propagation of Register Bus
///< Interface Decode Error Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_OFF (16)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_MSK (0x00010000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_DEF (0x00010000)

///< Register Bus Interface Write to Read Only Error Signal Enable.  -
///< 0: Disable the propagation of Register Bus Interface Write to Read
///< only Error Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Register Bus Interface Write to Read Only Error
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_OFF (17)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_MSK (0x00020000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_DEF (0x00020000)

///< Register Bus Interface Read to write Only Error Signal Enable.  -
///< 0: Disable the propagation of Register Bus Interface Read to Write
///< only Error Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Register Bus Interface Read to Write Only Error
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_OFF (18)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_MSK (0x00040000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_DEF (0x00040000)

///< Register Bus Interface Write On Channel Enabled Error Signal Enable.
///< - 0: Disable the propagation of Register Bus Interface Write On Channel
///< enabled Error Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Register Bus Interface Write On Channel enabled
///< Error Interrupt to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_OFF (19)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_MSK (0x00080000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_DEF (0x00080000)

///< Shadow Register Write On Valid Error Signal Enable.  - 0: Disable
///< the propagation of Shadow Register Write On Valid Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Shadow register Write On Valid Error Interrupt to generate a port
///< level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_OFF (20)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_MSK (0x00100000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_DEF (0x00100000)

///< Register Bus Interface Write On Hold Error Signal Enable.  - 0: Disable
///< the propagation of Register Bus Interface Write On Hold Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Register Bus Interface Write On Hold Error Interrupt to generate a
///< port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_OFF (21)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_MSK (0x00200000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_DEF (0x00200000)

///< DMAC Channelx Interrupt Signal Enable Register (bits 22to23) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_DEF (0x00C00000)

///< Register Bus Interface Address Parity Error Signal Enable.  - 0: Disable
///< the propagation of Register Bus Interface Address Parity Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Register Bus Interface Address Parity Error Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_OFF (24)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_MSK (0x01000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_DEF (0x01000000)

///< Register Bus Interface Write Parity Error Signal Enable.  - 0: Disable
///< the propagation of Register Bus Interface Write Parity Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Register Bus Interface Write Parity Error Interrupt to generate a
///< port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_OFF (25)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_MSK (0x02000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_DEF (0x02000000)

///< DMAC Channelx Interrupt Signal Enable Register (bit 26) Reserved bit
///< - Read Only
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_OFF (26)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_DEF (0x04000000)

///< Channel Lock Cleared Signal Enable.  - 0: Disable the propagation
///< of Channel Lock Cleared Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Channel Lock Cleared Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_OFF (27)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_MSK (0x08000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_DEF (0x08000000)

///< Channel Source Suspended Signal Enable.  - 0: Disable the propagation
///< of Channel Source Suspended Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Channel Source Suspended Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_OFF (28)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_MSK (0x10000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_DEF (0x10000000)

///< Channel Suspended Signal Enable.  - 0: Disable the propagation of
///< Channel Suspended Interrupt to generate a port level interrupt  -
///< 1: Enable the propagation of Channel Suspended Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_OFF (29)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_MSK (0x20000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_DEF (0x20000000)

///< Channel Disabled Signal Enable.  - 0: Disable the propagation of Channel
///< Disabled Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Channel Disabled Interrupt to generate a port level
///< interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_OFF (30)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_MSK (0x40000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_DEF (0x40000000)

///< Channel Terminated Signal Enable.  - 0: Disable the propagation of
///< Channel Terminated Interrupt to generate a port level interrupt  -
///< 1: Enable the propagation of Channel Terminated Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_OFF (31)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_MSK (0x80000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_DEF (0x80000000)

///< Channel x Channel Memory Interface ECC Protection Correctable Error
///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x Channel Memory Interface Correctable Error to generate a port level
///< interrupt.  - 1: Enable the propagation of Channel x Channel Memory
///< Interface Correctable Error to generate a port level interrupt.
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_OFF (32)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_MSK (0x100000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_DEF (0x100000000)

///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x Channel Memory Interface Uncorrectable Error to generate a port
///< level interrupt.  - 1: Enable the propagation of Channel x Channel
///< Memory Interface Uncorrectable Error to generate a port level interrupt.
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_OFF (33)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_MSK (0x200000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_DEF (0x200000000)

///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x UID Memory Interface Correctable Error to generate a port level
///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
///< Correctable Error to generate a port level interrupt.
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_OFF (34)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_MSK (0x400000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_DEF (0x400000000)

///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
///< Error Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x UID Memory Interface Uncorrectable Error to generate a port level
///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
///< Uncorrectable Error to generate a port level interrupt.
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_OFF (35)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_MSK (0x800000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_DEF (0x800000000)

///< DMAC Channelx Interrupt Signal Enable Register (bits 36to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_OFF (36)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_WID (28)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_DEF (0xFFFFFFF000000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_INTCLEARREG register description at address offset 0x198
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_INTCLEARREG
  * DW_axi_dmac Channel x Interrupt Status Clear Register
  */

typedef union {
  struct {
    uint64_t CLEAR_BLOCK_TFR_DONE_INTSTAT : 1;
    ///< Block Transfer Done Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CH1_INTSTATUSREG
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint64_t CLEAR_DMA_TFR_DONE_INTSTAT : 1;
    ///< DMA Transfer Done Interrupt Clear Bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="1" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_2 : 1;
    ///< DMAC Channelx Interrupt Clear Register (bit 2) Reserved bit - Write
    ///< Only
    ///< AccessType="WS" BitOffset="2" ResetValue="0x0"
    uint64_t CLEAR_SRC_TRANSCOMP_INTSTAT : 1;
    ///< Source Transaction Completed Interrupt Clear Bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="3" ResetValue="0x0"
    uint64_t CLEAR_DST_TRANSCOMP_INTSTAT : 1;
    ///< Destination Transaction Completed Interrupt Clear Bit. This bit is
    ///< used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="4" ResetValue="0x0"
    uint64_t CLEAR_SRC_DEC_ERR_INTSTAT : 1;
    ///< Source Decode Error Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="5" ResetValue="0x0"
    uint64_t CLEAR_DST_DEC_ERR_INTSTAT : 1;
    ///< Destination Decode Error Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="6" ResetValue="0x0"
    uint64_t CLEAR_SRC_SLV_ERR_INTSTAT : 1;
    ///< Source Subordinate Error Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="7" ResetValue="0x0"
    uint64_t CLEAR_DST_SLV_ERR_INTSTAT : 1;
    ///< Destination Subordinate Error Interrupt Clear Bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="8" ResetValue="0x0"
    uint64_t CLEAR_LLI_RD_DEC_ERR_INTSTAT : 1;
    ///< LLI Read Decode Error Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="9" ResetValue="0x0"
    uint64_t CLEAR_LLI_WR_DEC_ERR_INTSTAT : 1;
    ///< LLI WRITE Decode Error Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="10" ResetValue="0x0"
    uint64_t CLEAR_LLI_RD_SLV_ERR_INTSTAT : 1;
    ///< LLI Read Subordinate Error Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="11" ResetValue="0x0"
    uint64_t CLEAR_LLI_WR_SLV_ERR_INTSTAT : 1;
    ///< LLI WRITE Subordinate Error Interrupt Clear Bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="12" ResetValue="0x0"
    uint64_t CLEAR_SHADOWREG_OR_LLI_INVALID_ERR_INTSTAT : 1;
    ///< Shadow register or LLI Invalid Error Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="13" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT : 1;
    ///< Register Bus Interface Multi Block type Error Interrupt Clear Bit.
    ///< This bit is used to clear the corresponding channel interrupt status
    ///< bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="14" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_15 : 1;
    ///< DMAC Channelx Interrupt Clear Register (bit 15) Reserved bit - Write
    ///< Only
    ///< AccessType="WS" BitOffset="15" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Decode Error Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="16" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write to Read Only Error Interrupt Clear Bit.
    ///< This bit is used to clear the corresponding channel interrupt status
    ///< bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="17" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_RD2RWO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Read to write Only Error Interrupt Clear Bit.
    ///< This bit is used to clear the corresponding channel interrupt status
    ///< bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="18" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WRONCHEN_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Channel Enabled Error Interrupt Clear
    ///< Bit. This bit is used to clear the corresponding channel interrupt
    ///< status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="19" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_SHADOWREG_WRON_VALID_ERR_INTSTAT : 1;
    ///< Shadow Register Write On Valid Error Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="20" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Hold Error Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="21" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_22TO23 : 2;
    ///< DMAC Channelx Interrupt Clear Register (bits 22to23) Reserved bit
    ///< - Write Only
    ///< AccessType="WS" BitOffset="22" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Address Parity Error Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="24" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write Parity Error Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="25" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_26 : 1;
    ///< DMAC Channelx Interrupt Clear Register (bit 26) Reserved bit - Write
    ///< Only
    ///< AccessType="WS" BitOffset="26" ResetValue="0x0"
    uint64_t CLEAR_CH_LOCK_CLEARED_INTSTAT : 1;
    ///< Channel Lock Cleared Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="27" ResetValue="0x0"
    uint64_t CLEAR_CH_SRC_SUSPENDED_INTSTAT : 1;
    ///< Channel Source Suspended Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="28" ResetValue="0x0"
    uint64_t CLEAR_CH_SUSPENDED_INTSTAT : 1;
    ///< Channel Suspended Interrupt Clear Bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="29" ResetValue="0x0"
    uint64_t CLEAR_CH_DISABLED_INTSTAT : 1;
    ///< Channel Disabled Interrupt Clear Bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="30" ResetValue="0x0"
    uint64_t CLEAR_CH_ABORTED_INTSTAT : 1;
    ///< Channel Terminated Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="31" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_CHMEM_CORRERR_INTSTAT : 1;
    ///< ECC Protection Correctable Channel Memory Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="32" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT : 1;
    ///< ECC Protection Uncorrectable Channel Memory Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="33" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_UIDMEM_CORRERR_INTSTAT : 1;
    ///< ECC Protection Correctable UID Memory Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="34" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT : 1;
    ///< ECC Protection Uncorrectable UID Memory Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="35" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_36TO63 : 28;
    ///< DMAC Channelx Interrupt Clear Register (bits 36to63) Reserved bit
    ///< - Write Only
    ///< AccessType="WS" BitOffset="36" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_intclrreg_reg_t;

#define RCS_DMAC_CH1_INTCLRREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_INTCLRREG_RD_MASK (0x0000000000000000ULL)
#define RCS_DMAC_CH1_INTCLRREG_WR_MASK (0xffffffffffffffffULL)


///< Block Transfer Done Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CH1_INTSTATUSREG
#define RCS_DMAC_CH1_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CH1_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CH1_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMA Transfer Done Interrupt Clear Bit. This bit is used to clear the
///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bit 2) Reserved bit - Write
///< Only
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_DEF (0x00000000)

///< Source Transaction Completed Interrupt Clear Bit. This bit is used
///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Destination Transaction Completed Interrupt Clear Bit. This bit is
///< used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_OFF ( 4)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_MSK (0x00000010)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Source Decode Error Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_OFF ( 5)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_MSK (0x00000020)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Decode Error Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Source Subordinate Error Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Subordinate Error Interrupt Clear Bit. This bit is used
///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CH1_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Decode Error Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Decode Error Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Subordinate Error Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Subordinate Error Interrupt Clear Bit. This bit is used
///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow register or LLI Invalid Error Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Multi Block type Error Interrupt Clear Bit.
///< This bit is used to clear the corresponding channel interrupt status
///< bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bit 15) Reserved bit - Write
///< Only
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_OFF (15)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_DEF (0x00000000)

///< Register Bus Interface Decode Error Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write to Read Only Error Interrupt Clear Bit.
///< This bit is used to clear the corresponding channel interrupt status
///< bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Read to write Only Error Interrupt Clear Bit.
///< This bit is used to clear the corresponding channel interrupt status
///< bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Channel Enabled Error Interrupt Clear
///< Bit. This bit is used to clear the corresponding channel interrupt
///< status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow Register Write On Valid Error Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Hold Error Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bits 22to23) Reserved bit
///< - Write Only
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_DEF (0x00000000)

///< Register Bus Interface Address Parity Error Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write Parity Error Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bit 26) Reserved bit - Write
///< Only
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_OFF (26)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_DEF (0x00000000)

///< Channel Lock Cleared Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_DEF (0x00000000)

///< Channel Source Suspended Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Suspended Interrupt Clear Bit. This bit is used to clear the
///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Disabled Interrupt Clear Bit. This bit is used to clear the
///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_DEF (0x00000000)

///< Channel Terminated Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_OFF (31)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_MSK (0x80000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Correctable Channel Memory Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_OFF (32)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_MSK (0x100000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Uncorrectable Channel Memory Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_OFF (33)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_MSK (0x200000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Correctable UID Memory Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_OFF (34)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_MSK (0x400000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Uncorrectable UID Memory Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_OFF (35)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_MSK (0x800000000)
#define RCS_DMAC_CH1_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bits 36to63) Reserved bit
///< - Write Only
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_OFF (36)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_WID (28)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH1_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL1_REGISTERS_ADDRESS_BLOCK_CH1_CFG_EXTD register description at address offset 0x1a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel1_Registers_Address_Block/CH1_CFG_EXTD
  * DW_axi_dmac Channel x Extended Configuration Register
  */

typedef union {
  struct {
    uint64_t LLI_AXPROT : 3;
    ///< LLI Fetch and LLI Writeback AXI AxPROT. These bits form the arprot/awprot
    ///< output of AXI manager interface.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint64_t LLI_AXCACHE : 4;
    ///< LLI Fetch and LLI Writeback AXI AxCACHE. These bits form the arcache/awcache
    ///< output of AXI manager interface.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_EXTD_7TO63 : 57;
    ///< DMAC Channel x Extended Configuration Register (bits 7to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch1_cfg_extd_reg_t;

#define RCS_DMAC_CH1_CFG_EXTD_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH1_CFG_EXTD_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH1_CFG_EXTD_WR_MASK (0x000000000000007fULL)


///< LLI Fetch and LLI Writeback AXI AxPROT. These bits form the arprot/awprot
///< output of AXI manager interface.
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXPROT_BF_OFF ( 0)
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXPROT_BF_WID ( 3)
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXPROT_BF_MSK (0x00000007)
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXPROT_BF_DEF (0x00000000)

///< LLI Fetch and LLI Writeback AXI AxCACHE. These bits form the arcache/awcache
///< output of AXI manager interface.
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXCACHE_BF_OFF ( 3)
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXCACHE_BF_WID ( 4)
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXCACHE_BF_MSK (0x00000078)
#define RCS_DMAC_CH1_CFG_EXTD_LLI_AXCACHE_BF_DEF (0x00000000)

///< DMAC Channel x Extended Configuration Register (bits 7to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH1_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_OFF ( 7)
#define RCS_DMAC_CH1_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_WID (57)
#define RCS_DMAC_CH1_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_MSK (0xFFFFFFFFFFFFFF80)
#define RCS_DMAC_CH1_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_SAR register description at address offset 0x200
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_SAR
  * DW_axi_dmac Channel $i Source Address Register
  */

typedef union {
  struct {
    uint64_t SAR : 64;
    ///< Current Source Address of DMA transfer. Updated after each source
    ///< transfer. The SINC fields in the CHx_CTL register determines whether
    ///< the address increments or is left unchanged on every source transfer
    ///< throughout the block transfer.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_sar_reg_t;

#define RCS_DMAC_CH2_SAR_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_SAR_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_SAR_WR_MASK (0xffffffffffffffffULL)


///< Current Source Address of DMA transfer. Updated after each source
///< transfer. The SINC fields in the CHx_CTL register determines whether
///< the address increments or is left unchanged on every source transfer
///< throughout the block transfer.
#define RCS_DMAC_CH2_SAR_BF_OFF ( 0)
#define RCS_DMAC_CH2_SAR_BF_WID (64)
#define RCS_DMAC_CH2_SAR_BF_MSK (0xFFFFFFFFFFFFFFFF)
#define RCS_DMAC_CH2_SAR_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_DAR register description at address offset 0x208
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_DAR
  * DW_axi_dmac Channel $i Destination Address Register
  */

typedef union {
  struct {
    uint64_t DAR : 64;
    ///< Current Destination Address of DMA transfer. Updated after each destination
    ///< transfer. The DINC fields in the CHx_CTL register determines whether
    ///< the address increments or is left unchanged on every destination transfer
    ///< throughout the block transfer.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_dar_reg_t;

#define RCS_DMAC_CH2_DAR_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_DAR_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_DAR_WR_MASK (0xffffffffffffffffULL)


///< Current Destination Address of DMA transfer. Updated after each destination
///< transfer. The DINC fields in the CHx_CTL register determines whether
///< the address increments or is left unchanged on every destination transfer
///< throughout the block transfer.
#define RCS_DMAC_CH2_DAR_BF_OFF ( 0)
#define RCS_DMAC_CH2_DAR_BF_WID (64)
#define RCS_DMAC_CH2_DAR_BF_MSK (0xFFFFFFFFFFFFFFFF)
#define RCS_DMAC_CH2_DAR_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_BLOCK_TS register description at address offset 0x210
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_BLOCK_TS
  * DW_axi_dmac Channel $i Block Transfer Size Register
  */

typedef union {
  struct {
    uint64_t BLOCK_TS : 22;
    ///< Block Transfer Size. The number programmed into BLOCK_TS field indicates
    ///< the total number of data of width CHx_CTL.SRC_TR_WIDTH to be transferred
    ///< in a DMA block transfer. Block Transfer Size = BLOCK_TS+1 Note: The
    ///< value programmed to the BLOCK_TS field must be greater than or equal
    ///< to the source or destination transfer width and the read back value
    ///< of BLOCK_TS field is always the value programmed into it. This register
    ///< field is not applicable when source or destination is flow controller
    ///< and it is applicable when DMA is flow controller.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_BLOCK_TSREG_63TO22 : 42;
    ///< DMAC Channelx Block Transfer Size Register (bits 63to22) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_blk_ts_reg_t;

#define RCS_DMAC_CH2_BLK_TS_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_BLK_TS_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_BLK_TS_WR_MASK (0x00000000003fffffULL)


///< Block Transfer Size. The number programmed into BLOCK_TS field indicates
///< the total number of data of width CHx_CTL.SRC_TR_WIDTH to be transferred
///< in a DMA block transfer. Block Transfer Size = BLOCK_TS+1 Note: The
///< value programmed to the BLOCK_TS field must be greater than or equal
///< to the source or destination transfer width and the read back value
///< of BLOCK_TS field is always the value programmed into it. This register
///< field is not applicable when source or destination is flow controller
///< and it is applicable when DMA is flow controller.
#define RCS_DMAC_CH2_BLK_TS_BLK_TS_BF_OFF ( 0)
#define RCS_DMAC_CH2_BLK_TS_BLK_TS_BF_WID (22)
#define RCS_DMAC_CH2_BLK_TS_BLK_TS_BF_MSK (0x003FFFFF)
#define RCS_DMAC_CH2_BLK_TS_BLK_TS_BF_DEF (0x00000000)

///< DMAC Channelx Block Transfer Size Register (bits 63to22) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_OFF (22)
#define RCS_DMAC_CH2_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_WID (42)
#define RCS_DMAC_CH2_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_MSK (0xFFFFFFFFFFC00000)
#define RCS_DMAC_CH2_BLK_TS_RSVD_DMAC_CHX_BLK_TSREG_63TO22_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_CTL register description at address offset 0x218
  *
  * Register default value:        0x00001200
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_CTL
  * DW_axi_dmac Channel $i Control Register
  */

typedef union {
  struct {
    uint64_t SMS : 1;
    ///< Source Manager Select. Identifies the Manager Interface layer from
    ///< which the source device (peripheral or memory) is accessed.  - 0:
    ///< AXI manager 1   - 1: AXI Manager 2
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_1 : 1;
    ///< DMAC Channelx Control Transfer Register bit1 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint64_t DMS : 1;
    ///< Destination Manager Select. Identifies the Manager Interface layer
    ///< from which the destination device (peripheral or memory) is accessed.
    ///< - 0: AXI manager 1   - 1: AXI Manager 2
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_3 : 1;
    ///< DMAC Channelx Control Transfer Register bit3 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint64_t SINC : 1;
    ///< Source Address Increment. Indicates whether to increment the source
    ///< address on every source transfer. If the device is fetching data from
    ///< a source peripheral FIFO with a fixed address, then set this field
    ///< to 'No change'.  - 0: Increment   - 1: No Change NOTE: Increment aligns
    ///< the address to the next CHx_CTL.SRC_TR_WIDTH boundary.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_5 : 1;
    ///< DMAC Channelx Control Transfer Register bit5 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint64_t DINC : 1;
    ///< Destination Address Increment. Indicates whether to increment the
    ///< destination address on every destination transfer. If the device is
    ///< writing data from a source peripheral FIFO with a fixed address, then
    ///< set this field to 'No change'.  - 0: Increment   - 1: No Change NOTE:
    ///< Increment aligns the address to the next CHx_CTL.DST_TR_WIDTH boundary.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_7 : 1;
    ///< DMAC Channelx Control Transfer Register bit7 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
    uint64_t SRC_TR_WIDTH : 3;
    ///< Source Transfer Width. Mapped to AXI bus arsize, this value must be
    ///< less than or equal to DMAX_M_DATA_WIDTH.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x2"
    uint64_t DST_TR_WIDTH : 3;
    ///< Destination Transfer Width. Mapped to AXI bus awsize, this value must
    ///< be less than or equal to DMAX_M_DATA_WIDTH.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x2"
    uint64_t SRC_MSIZE : 4;
    ///< Source Burst Transaction Length. Number of data items, each of width
    ///< CHx_CTL.SRC_TR_WIDTH, to be read from the source every time a source
    ///< burst transaction request is made from the corresponding hardware
    ///< or software handshaking interface. The maximum value of DST_MSIZE
    ///< is limited by DMAX_CHx_MAX_MSIZE. Note: This Value is not related
    ///< to the AXI arlen signal.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint64_t DST_MSIZE : 4;
    ///< Destination Burst Transaction Length. Number of data items, each of
    ///< width CHx_CTL.DST_TR_WIDTH, to be written to the destination every
    ///< time a destination burst transaction request is made from the corresponding
    ///< hardware or software handshaking interface. Note: This Value is not
    ///< related to the AXI awlen signal.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint64_t AR_CACHE : 4;
    ///< AXI 'ar_cache' signal
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint64_t AW_CACHE : 4;
    ///< AXI 'aw_cache' signal
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint64_t NONPOSTED_LASTWRITE_EN : 1;
    ///< Non Posted Last Write Enable This bit decides whether posted writes
    ///< can be used throughout the block transfer.  - 0: Posted writes may
    ///< be used throughout the block transfer.  - 1: Posted writes may be
    ///< used till the end of the block (inside a block) and the last write
    ///< in the block must be non-posted. This is to synchronize block completion
    ///< interrupt generation to the last write data reaching the end memory/peripheral.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_31 : 1;
    ///< DMAC Channelx Control Transfer Register bit31 Reserved bits - Read
    ///< Only
    ///< AccessType="RO" BitOffset="31" ResetValue="0x0"
    uint64_t AR_PROT : 3;
    ///< AXI 'ar_prot' signal
    ///< AccessType="RW" BitOffset="32" ResetValue="0x0"
    uint64_t AW_PROT : 3;
    ///< AXI 'aw_prot' signal
    ///< AccessType="RW" BitOffset="35" ResetValue="0x0"
    uint64_t ARLEN_EN : 1;
    ///< Source Burst Length Enable If this bit is set to 1, DW_axi_dmac uses
    ///< the value of CHx_CTL.ARLEN as AXI Burst length for source data transfer
    ///< till the extent possible; remaining transfers use maximum possible
    ///< burst length. If this bit is set to 0, DW_axi_dmac uses any possible
    ///< value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
    ///< as AXI Burst length for source data transfer.
    ///< AccessType="RW" BitOffset="38" ResetValue="0x0"
    uint64_t ARLEN : 8;
    ///< Source Burst Length AXI Burst length used for source data transfer.
    ///< The specified burst length is used for source data transfer till the
    ///< extent possible; remaining transfers use maximum possible value that
    ///< is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH. The maximum
    ///< value of ARLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH
    ///< AccessType="RW" BitOffset="39" ResetValue="0x0"
    uint64_t AWLEN_EN : 1;
    ///< Destination Burst Length Enable If this bit is set to 1, DW_axi_dmac
    ///< uses the value of CHx_CTL.AWLEN as AXI Burst length for destination
    ///< data transfer till the extent possible; remaining transfers use maximum
    ///< possible burst length. If this bit is set to 0, DW_axi_dmac uses any
    ///< possible value which is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
    ///< as AXI Burst length for destination data transfer.
    ///< AccessType="RW" BitOffset="47" ResetValue="0x0"
    uint64_t AWLEN : 8;
    ///< Destination Burst Length AXI Burst length used for destination data
    ///< transfer. The specified burst length is used for destination data
    ///< transfer till the extent possible; remaining transfers use maximum
    ///< possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.
    ///< The maximum value of AWLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH.
    ///< Note: The AWLEN setting may not be honored towards end-to-block transfers,
    ///< the end of a transaction (only applicable to non-memory peripherals),
    ///< and during 4K boundary crossings.
    ///< AccessType="RW" BitOffset="48" ResetValue="0x0"
    uint64_t SRC_STAT_EN : 1;
    ///< Source Status Enable Enable the logic to fetch status from source
    ///< peripheral of channel x pointed to by the content of CHx_SSTATAR register
    ///< and stores it in CHx_SSTAT register. This value is written back to
    ///< the CHx_SSTAT location of linked list at end of each block transfer
    ///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
    ///< transfer is used by either source or destination peripheral.
    ///< AccessType="RO" BitOffset="56" ResetValue="0x0"
    uint64_t DST_STAT_EN : 1;
    ///< Destination Status Enable Enable the logic to fetch status from destination
    ///< peripheral of channel x pointed to by the content of CHx_DSTATAR register
    ///< and stores it in CHx_DSTAT register. This value is written back to
    ///< the CHx_DSTAT location of linked list at end of each block transfer
    ///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
    ///< transfer is used by either source or destination peripheral.
    ///< AccessType="RO" BitOffset="57" ResetValue="0x0"
    uint64_t IOC_BLKTFR : 1;
    ///< Interrupt On completion of Block Transfer This bit is used to control
    ///< the block transfer completion interrupt generation on a block by block
    ///< basis for shadow register or linked list based multi-block transfers.
    ///< Writing 1 to this register field enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat
    ///< field if this interrupt generation is enabled in CHx_IntStatus_EnableReg
    ///< register and the external interrupt output is asserted if this interrupt
    ///< generation is enabled in CHx_IntSignal_EnableReg register. Note: If
    ///< a linked-list or shadow-register-based multi-block transfer is not
    ///< used for both source and destination (for instance if source and destination
    ///< use contiguous address or auto-reload-based multi-block transfer),
    ///< the value of this field cannot be modified per block. Additionally,
    ///< the value programmed before the channel is enabled is used for all
    ///< the blocks in the DMA transfer.
    ///< AccessType="RW" BitOffset="58" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CTL_59TO61 : 3;
    ///< DMAC Channelx Control Transfer Register (bits 59to61) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="59" ResetValue="0x0"
    uint64_t SHADOWREG_OR_LLI_LAST : 1;
    ///< Last Shadow Register/Linked List Item. Indicates whether shadow register
    ///< content or the linked list item fetched from the memory is the last
    ///< one or not.  - 0: Not last Shadow Register/LLI  - 1: Last Shadow Register/LLI
    ///< LLI based multi-block transfer: DW_axi_dmac uses this bit to decide
    ///< if another LLI fetch is needed in the current DMA transfer.  - If
    ///< this bit is 0, DW_axi_dmac fetches the next LLI from the address pointed
    ///< out by LLP field in the current LLI.  - If this bit is 1, DW_axi_dmac
    ///< understands that current block is the final block in the dma transfer
    ///< and ends the dma transfer once the AMBA transfer corresponding to
    ///< the current block completes. Shadow Reg based multi-block transfer:
    ///< DW_axi_dmac uses this bit to decide if another Shadow Register fetch
    ///< is needed in the current DMA transfer.  - If this bit is 0, DW_axi_dmac
    ///< understands that there are one or more blocks to be transferred in
    ///< the current block and hence one or more shadow register set contents
    ///< will be valid and needs to be fetched.  - If this bit is 1, DW_axi_dmac
    ///< understands that current block is the final block in the dma transfer
    ///< and ends the dma transfer once the AMBA transfer corresponding to
    ///< the current block completes.
    ///< AccessType="RW/V" BitOffset="62" ResetValue="0x0"
    uint64_t SHADOWREG_OR_LLI_VALID : 1;
    ///< Shadow Register content/Linked List Item valid. Indicates whether
    ///< the content of shadow register or the linked list item fetched from
    ///< the memory is valid.  - 0: Shadow Register content/LLI is invalid.
    ///< - 1: Last Shadow Register/LLI is valid. LLI based multi-block transfer:
    ///< The CHx_CTL register is loaded from the LLI. Hence, the software is
    ///< not allowed to directly update this register through the DW_axi_dmac
    ///< subordinate interface. This field can be used to dynamically extend
    ///< the LLI by the software. On noticing this bit as 0, DW_axi_dmac discards
    ///< the LLI and generates the ShadowReg_Or_LII_Invalid_ERR Interrupt if
    ///< the corresponding channel error interrupt mask bit is set to 0. In
    ///< the case of LLI pre-fetching, the ShadowReg_Or_LLI_Invalid_ERR interrupt
    ///< is not generated even if the ShadowReg_Or_LLI_Valid bit is seen to
    ///< be 0 for the pre-fetched LLI. In this case, DW_axi_dmac attempts the
    ///< LLI fetch operation again after completing the current block transfer
    ///< and generates the ShadowReg_Or_LII_Invalid_ERR interrupt only if ShadowReg_Or_LII_Valid
    ///< bit is still seen to be 0. This error condition causes the DW_axi_dmac
    ///< to halt the corresponding channel gracefully. DW_axi_dmac waits until
    ///< software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
    ///< valid LLI availability before attempting another LLI read operation.
    ///< This bit is cleared to 0 and written back to the corresponding LLI
    ///< location after block transfer completion when LLI write-back option
    ///< is enabled. Hence, for LLI-based multi-block transfers, the software
    ///< might manipulate/redefine any descriptor with the ShadowReg_Or_LII_Valid
    ///< bit set to 0 if LLI write-back option is enabled. Shadow Reg based
    ///< multi-block transfer: On noticing this bit as 0 during shadow register
    ///< fetch phase, DW_axi_dmac discards the Shadow Register contents and
    ///< generates ShadowReg_Or_LLI_Invlid_ERR Interrupt. In this case, the
    ///< software has to write (any value) to CHx_BLK_TFR_ResumeReqReg after
    ///< updating the shadow registers and after setting ShadowReg_Or_LLI_Valid
    ///< bit to 1 to indicate to DW_axi_dmac that shadow register contents
    ///< are valid and the next block transfer can be resumed. DW_axi_dmac
    ///< clears this bit to 0 after copying the shadow register contents. Software
    ///< can reprogram the shadow registers only if ShadowReg_Or_LLI_Valid
    ///< bit is 0. Software needs to read this register in block completion
    ///< interrupt service routine (if interrupt is enabled)/continuously poll
    ///< this register (if interrupt is not enabled) to make sure that this
    ///< bit is 0 before updating the shadow registers. If shadow-register-based
    ///< multi-block transfer is enabled and software attempts to write to
    ///< the shadow register when ShadowReg_Or_LLI_Valid bit is 1, DW_axi_dmac
    ///< generates SLVIF_ShadowReg_WrOnValid_ERR interrupt.
    ///< AccessType="RW/V" BitOffset="63" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_ctl_reg_t;

#define RCS_DMAC_CH2_CTL_DEFAULT (0x0000000000001200ULL)
#define RCS_DMAC_CH2_CTL_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_CTL_WR_MASK (0xc4ffffff7fffff50ULL)


///< Source Manager Select. Identifies the Manager Interface layer from
///< which the source device (peripheral or memory) is accessed.  - 0:
///< AXI manager 1   - 1: AXI Manager 2
#define RCS_DMAC_CH2_CTL_SMS_BF_OFF ( 0)
#define RCS_DMAC_CH2_CTL_SMS_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_SMS_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_CTL_SMS_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit1 Reserved bits - Read
///< Only
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_1_BF_OFF ( 1)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_1_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_1_BF_MSK (0x00000002)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_1_BF_DEF (0x00000000)

///< Destination Manager Select. Identifies the Manager Interface layer
///< from which the destination device (peripheral or memory) is accessed.
///< - 0: AXI manager 1   - 1: AXI Manager 2
#define RCS_DMAC_CH2_CTL_DMS_BF_OFF ( 2)
#define RCS_DMAC_CH2_CTL_DMS_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_DMS_BF_MSK (0x00000004)
#define RCS_DMAC_CH2_CTL_DMS_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit3 Reserved bits - Read
///< Only
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_3_BF_OFF ( 3)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_3_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_3_BF_MSK (0x00000008)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_3_BF_DEF (0x00000000)

///< Source Address Increment. Indicates whether to increment the source
///< address on every source transfer. If the device is fetching data from
///< a source peripheral FIFO with a fixed address, then set this field
///< to 'No change'.  - 0: Increment   - 1: No Change NOTE: Increment aligns
///< the address to the next CHx_CTL.SRC_TR_WIDTH boundary.
#define RCS_DMAC_CH2_CTL_SINC_BF_OFF ( 4)
#define RCS_DMAC_CH2_CTL_SINC_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_SINC_BF_MSK (0x00000010)
#define RCS_DMAC_CH2_CTL_SINC_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit5 Reserved bits - Read
///< Only
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_5_BF_OFF ( 5)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_5_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_5_BF_MSK (0x00000020)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_5_BF_DEF (0x00000000)

///< Destination Address Increment. Indicates whether to increment the
///< destination address on every destination transfer. If the device is
///< writing data from a source peripheral FIFO with a fixed address, then
///< set this field to 'No change'.  - 0: Increment   - 1: No Change NOTE:
///< Increment aligns the address to the next CHx_CTL.DST_TR_WIDTH boundary.
#define RCS_DMAC_CH2_CTL_DINC_BF_OFF ( 6)
#define RCS_DMAC_CH2_CTL_DINC_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_DINC_BF_MSK (0x00000040)
#define RCS_DMAC_CH2_CTL_DINC_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit7 Reserved bits - Read
///< Only
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_7_BF_OFF ( 7)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_7_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_7_BF_MSK (0x00000080)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_7_BF_DEF (0x00000000)

///< Source Transfer Width. Mapped to AXI bus arsize, this value must be
///< less than or equal to DMAX_M_DATA_WIDTH.
#define RCS_DMAC_CH2_CTL_SRC_TR_WIDTH_BF_OFF ( 8)
#define RCS_DMAC_CH2_CTL_SRC_TR_WIDTH_BF_WID ( 3)
#define RCS_DMAC_CH2_CTL_SRC_TR_WIDTH_BF_MSK (0x00000700)
#define RCS_DMAC_CH2_CTL_SRC_TR_WIDTH_BF_DEF (0x00000200)

///< Destination Transfer Width. Mapped to AXI bus awsize, this value must
///< be less than or equal to DMAX_M_DATA_WIDTH.
#define RCS_DMAC_CH2_CTL_DST_TR_WIDTH_BF_OFF (11)
#define RCS_DMAC_CH2_CTL_DST_TR_WIDTH_BF_WID ( 3)
#define RCS_DMAC_CH2_CTL_DST_TR_WIDTH_BF_MSK (0x00003800)
#define RCS_DMAC_CH2_CTL_DST_TR_WIDTH_BF_DEF (0x00001000)

///< Source Burst Transaction Length. Number of data items, each of width
///< CHx_CTL.SRC_TR_WIDTH, to be read from the source every time a source
///< burst transaction request is made from the corresponding hardware
///< or software handshaking interface. The maximum value of DST_MSIZE
///< is limited by DMAX_CHx_MAX_MSIZE. Note: This Value is not related
///< to the AXI arlen signal.
#define RCS_DMAC_CH2_CTL_SRC_MSIZE_BF_OFF (14)
#define RCS_DMAC_CH2_CTL_SRC_MSIZE_BF_WID ( 4)
#define RCS_DMAC_CH2_CTL_SRC_MSIZE_BF_MSK (0x0003C000)
#define RCS_DMAC_CH2_CTL_SRC_MSIZE_BF_DEF (0x00000000)

///< Destination Burst Transaction Length. Number of data items, each of
///< width CHx_CTL.DST_TR_WIDTH, to be written to the destination every
///< time a destination burst transaction request is made from the corresponding
///< hardware or software handshaking interface. Note: This Value is not
///< related to the AXI awlen signal.
#define RCS_DMAC_CH2_CTL_DST_MSIZE_BF_OFF (18)
#define RCS_DMAC_CH2_CTL_DST_MSIZE_BF_WID ( 4)
#define RCS_DMAC_CH2_CTL_DST_MSIZE_BF_MSK (0x003C0000)
#define RCS_DMAC_CH2_CTL_DST_MSIZE_BF_DEF (0x00000000)

///< AXI 'ar_cache' signal
#define RCS_DMAC_CH2_CTL_AR_CACHE_BF_OFF (22)
#define RCS_DMAC_CH2_CTL_AR_CACHE_BF_WID ( 4)
#define RCS_DMAC_CH2_CTL_AR_CACHE_BF_MSK (0x03C00000)
#define RCS_DMAC_CH2_CTL_AR_CACHE_BF_DEF (0x00000000)

///< AXI 'aw_cache' signal
#define RCS_DMAC_CH2_CTL_AW_CACHE_BF_OFF (26)
#define RCS_DMAC_CH2_CTL_AW_CACHE_BF_WID ( 4)
#define RCS_DMAC_CH2_CTL_AW_CACHE_BF_MSK (0x3C000000)
#define RCS_DMAC_CH2_CTL_AW_CACHE_BF_DEF (0x00000000)

///< Non Posted Last Write Enable This bit decides whether posted writes
///< can be used throughout the block transfer.  - 0: Posted writes may
///< be used throughout the block transfer.  - 1: Posted writes may be
///< used till the end of the block (inside a block) and the last write
///< in the block must be non-posted. This is to synchronize block completion
///< interrupt generation to the last write data reaching the end memory/peripheral.
#define RCS_DMAC_CH2_CTL_NONPOSTED_LASTWRITE_EN_BF_OFF (30)
#define RCS_DMAC_CH2_CTL_NONPOSTED_LASTWRITE_EN_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_NONPOSTED_LASTWRITE_EN_BF_MSK (0x40000000)
#define RCS_DMAC_CH2_CTL_NONPOSTED_LASTWRITE_EN_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register bit31 Reserved bits - Read
///< Only
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_31_BF_OFF (31)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_31_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_31_BF_MSK (0x80000000)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_31_BF_DEF (0x00000000)

///< AXI 'ar_prot' signal
#define RCS_DMAC_CH2_CTL_AR_PROT_BF_OFF (32)
#define RCS_DMAC_CH2_CTL_AR_PROT_BF_WID ( 3)
#define RCS_DMAC_CH2_CTL_AR_PROT_BF_MSK (0x700000000)
#define RCS_DMAC_CH2_CTL_AR_PROT_BF_DEF (0x00000000)

///< AXI 'aw_prot' signal
#define RCS_DMAC_CH2_CTL_AW_PROT_BF_OFF (35)
#define RCS_DMAC_CH2_CTL_AW_PROT_BF_WID ( 3)
#define RCS_DMAC_CH2_CTL_AW_PROT_BF_MSK (0x3800000000)
#define RCS_DMAC_CH2_CTL_AW_PROT_BF_DEF (0x00000000)

///< Source Burst Length Enable If this bit is set to 1, DW_axi_dmac uses
///< the value of CHx_CTL.ARLEN as AXI Burst length for source data transfer
///< till the extent possible; remaining transfers use maximum possible
///< burst length. If this bit is set to 0, DW_axi_dmac uses any possible
///< value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
///< as AXI Burst length for source data transfer.
#define RCS_DMAC_CH2_CTL_ARLEN_EN_BF_OFF (38)
#define RCS_DMAC_CH2_CTL_ARLEN_EN_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_ARLEN_EN_BF_MSK (0x4000000000)
#define RCS_DMAC_CH2_CTL_ARLEN_EN_BF_DEF (0x00000000)

///< Source Burst Length AXI Burst length used for source data transfer.
///< The specified burst length is used for source data transfer till the
///< extent possible; remaining transfers use maximum possible value that
///< is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH. The maximum
///< value of ARLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH
#define RCS_DMAC_CH2_CTL_ARLEN_BF_OFF (39)
#define RCS_DMAC_CH2_CTL_ARLEN_BF_WID ( 8)
#define RCS_DMAC_CH2_CTL_ARLEN_BF_MSK (0x7F8000000000)
#define RCS_DMAC_CH2_CTL_ARLEN_BF_DEF (0x00000000)

///< Destination Burst Length Enable If this bit is set to 1, DW_axi_dmac
///< uses the value of CHx_CTL.AWLEN as AXI Burst length for destination
///< data transfer till the extent possible; remaining transfers use maximum
///< possible burst length. If this bit is set to 0, DW_axi_dmac uses any
///< possible value which is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH
///< as AXI Burst length for destination data transfer.
#define RCS_DMAC_CH2_CTL_AWLEN_EN_BF_OFF (47)
#define RCS_DMAC_CH2_CTL_AWLEN_EN_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_AWLEN_EN_BF_MSK (0x800000000000)
#define RCS_DMAC_CH2_CTL_AWLEN_EN_BF_DEF (0x00000000)

///< Destination Burst Length AXI Burst length used for destination data
///< transfer. The specified burst length is used for destination data
///< transfer till the extent possible; remaining transfers use maximum
///< possible value that is less than or equal to DMAX_CHx_MAX_AMBA_BURST_LENGTH.
///< The maximum value of AWLEN is limited by DMAX_CHx_MAX_AMBA_BURST_LENGTH.
///< Note: The AWLEN setting may not be honored towards end-to-block transfers,
///< the end of a transaction (only applicable to non-memory peripherals),
///< and during 4K boundary crossings.
#define RCS_DMAC_CH2_CTL_AWLEN_BF_OFF (48)
#define RCS_DMAC_CH2_CTL_AWLEN_BF_WID ( 8)
#define RCS_DMAC_CH2_CTL_AWLEN_BF_MSK (0xFF000000000000)
#define RCS_DMAC_CH2_CTL_AWLEN_BF_DEF (0x00000000)

///< Source Status Enable Enable the logic to fetch status from source
///< peripheral of channel x pointed to by the content of CHx_SSTATAR register
///< and stores it in CHx_SSTAT register. This value is written back to
///< the CHx_SSTAT location of linked list at end of each block transfer
///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
///< transfer is used by either source or destination peripheral.
#define RCS_DMAC_CH2_CTL_SRC_STAT_EN_BF_OFF (56)
#define RCS_DMAC_CH2_CTL_SRC_STAT_EN_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_SRC_STAT_EN_BF_MSK (0x100000000000000)
#define RCS_DMAC_CH2_CTL_SRC_STAT_EN_BF_DEF (0x00000000)

///< Destination Status Enable Enable the logic to fetch status from destination
///< peripheral of channel x pointed to by the content of CHx_DSTATAR register
///< and stores it in CHx_DSTAT register. This value is written back to
///< the CHx_DSTAT location of linked list at end of each block transfer
///< if DMAX_CHx_LLI_WB_EN is set to 1 and if linked list based multi-block
///< transfer is used by either source or destination peripheral.
#define RCS_DMAC_CH2_CTL_DST_STAT_EN_BF_OFF (57)
#define RCS_DMAC_CH2_CTL_DST_STAT_EN_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_DST_STAT_EN_BF_MSK (0x200000000000000)
#define RCS_DMAC_CH2_CTL_DST_STAT_EN_BF_DEF (0x00000000)

///< Interrupt On completion of Block Transfer This bit is used to control
///< the block transfer completion interrupt generation on a block by block
///< basis for shadow register or linked list based multi-block transfers.
///< Writing 1 to this register field enables CHx_IntStatusReg.BLOCK_TFR_DONE_IntStat
///< field if this interrupt generation is enabled in CHx_IntStatus_EnableReg
///< register and the external interrupt output is asserted if this interrupt
///< generation is enabled in CHx_IntSignal_EnableReg register. Note: If
///< a linked-list or shadow-register-based multi-block transfer is not
///< used for both source and destination (for instance if source and destination
///< use contiguous address or auto-reload-based multi-block transfer),
///< the value of this field cannot be modified per block. Additionally,
///< the value programmed before the channel is enabled is used for all
///< the blocks in the DMA transfer.
#define RCS_DMAC_CH2_CTL_IOC_BLKTFR_BF_OFF (58)
#define RCS_DMAC_CH2_CTL_IOC_BLKTFR_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_IOC_BLKTFR_BF_MSK (0x400000000000000)
#define RCS_DMAC_CH2_CTL_IOC_BLKTFR_BF_DEF (0x00000000)

///< DMAC Channelx Control Transfer Register (bits 59to61) Reserved bits
///< - Read Only
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_OFF (59)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_WID ( 3)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_MSK (0x3800000000000000)
#define RCS_DMAC_CH2_CTL_RSVD_DMAC_CHX_CTL_59TO61_BF_DEF (0x00000000)

///< Last Shadow Register/Linked List Item. Indicates whether shadow register
///< content or the linked list item fetched from the memory is the last
///< one or not.  - 0: Not last Shadow Register/LLI  - 1: Last Shadow Register/LLI
///< LLI based multi-block transfer: DW_axi_dmac uses this bit to decide
///< if another LLI fetch is needed in the current DMA transfer.  - If
///< this bit is 0, DW_axi_dmac fetches the next LLI from the address pointed
///< out by LLP field in the current LLI.  - If this bit is 1, DW_axi_dmac
///< understands that current block is the final block in the dma transfer
///< and ends the dma transfer once the AMBA transfer corresponding to
///< the current block completes. Shadow Reg based multi-block transfer:
///< DW_axi_dmac uses this bit to decide if another Shadow Register fetch
///< is needed in the current DMA transfer.  - If this bit is 0, DW_axi_dmac
///< understands that there are one or more blocks to be transferred in
///< the current block and hence one or more shadow register set contents
///< will be valid and needs to be fetched.  - If this bit is 1, DW_axi_dmac
///< understands that current block is the final block in the dma transfer
///< and ends the dma transfer once the AMBA transfer corresponding to
///< the current block completes.
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_LAST_BF_OFF (62)
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_LAST_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_LAST_BF_MSK (0x4000000000000000)
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_LAST_BF_DEF (0x00000000)

///< Shadow Register content/Linked List Item valid. Indicates whether
///< the content of shadow register or the linked list item fetched from
///< the memory is valid.  - 0: Shadow Register content/LLI is invalid.
///< - 1: Last Shadow Register/LLI is valid. LLI based multi-block transfer:
///< The CHx_CTL register is loaded from the LLI. Hence, the software is
///< not allowed to directly update this register through the DW_axi_dmac
///< subordinate interface. This field can be used to dynamically extend
///< the LLI by the software. On noticing this bit as 0, DW_axi_dmac discards
///< the LLI and generates the ShadowReg_Or_LII_Invalid_ERR Interrupt if
///< the corresponding channel error interrupt mask bit is set to 0. In
///< the case of LLI pre-fetching, the ShadowReg_Or_LLI_Invalid_ERR interrupt
///< is not generated even if the ShadowReg_Or_LLI_Valid bit is seen to
///< be 0 for the pre-fetched LLI. In this case, DW_axi_dmac attempts the
///< LLI fetch operation again after completing the current block transfer
///< and generates the ShadowReg_Or_LII_Invalid_ERR interrupt only if ShadowReg_Or_LII_Valid
///< bit is still seen to be 0. This error condition causes the DW_axi_dmac
///< to halt the corresponding channel gracefully. DW_axi_dmac waits until
///< software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
///< valid LLI availability before attempting another LLI read operation.
///< This bit is cleared to 0 and written back to the corresponding LLI
///< location after block transfer completion when LLI write-back option
///< is enabled. Hence, for LLI-based multi-block transfers, the software
///< might manipulate/redefine any descriptor with the ShadowReg_Or_LII_Valid
///< bit set to 0 if LLI write-back option is enabled. Shadow Reg based
///< multi-block transfer: On noticing this bit as 0 during shadow register
///< fetch phase, DW_axi_dmac discards the Shadow Register contents and
///< generates ShadowReg_Or_LLI_Invlid_ERR Interrupt. In this case, the
///< software has to write (any value) to CHx_BLK_TFR_ResumeReqReg after
///< updating the shadow registers and after setting ShadowReg_Or_LLI_Valid
///< bit to 1 to indicate to DW_axi_dmac that shadow register contents
///< are valid and the next block transfer can be resumed. DW_axi_dmac
///< clears this bit to 0 after copying the shadow register contents. Software
///< can reprogram the shadow registers only if ShadowReg_Or_LLI_Valid
///< bit is 0. Software needs to read this register in block completion
///< interrupt service routine (if interrupt is enabled)/continuously poll
///< this register (if interrupt is not enabled) to make sure that this
///< bit is 0 before updating the shadow registers. If shadow-register-based
///< multi-block transfer is enabled and software attempts to write to
///< the shadow register when ShadowReg_Or_LLI_Valid bit is 1, DW_axi_dmac
///< generates SLVIF_ShadowReg_WrOnValid_ERR interrupt.
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_VALID_BF_OFF (63)
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_VALID_BF_WID ( 1)
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_VALID_BF_MSK (0x8000000000000000)
#define RCS_DMAC_CH2_CTL_SHDWREG_OR_LLI_VALID_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_CFG register description at address offset 0x220
  *
  * Register default value:        0x1B00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_CFG
  * DW_axi_dmac Channel $i Configuration Register
  */

typedef union {
  struct {
    uint64_t SRC_MULTBLK_TYPE : 2;
    ///< Source Multi Block Transfer Type. These bits define the type of multi-block
    ///< transfer used for source peripheral.  - 00: Contiguous  - 01: Reload
    ///< - 10: Shadow Register  - 11: Linked List If the type selected is Contiguous,
    ///< the CHx_SAR register is loaded with the value of the end source address
    ///< of previous block + 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. If the type selected is Reload,
    ///< the CHx_SAR register is reloaded from the initial value of SAR at
    ///< the end of every block for multi-block transfers. A new block transfer
    ///< is then initiated. If the type selected is Shadow Register, the CHx_SAR
    ///< register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid
    ///< bit is set to 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. If the type selected is Linked
    ///< List, the CHx_SAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
    ///< bit is set to 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
    ///< are loaded from their initial values or from the contents of their
    ///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
    ///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
    ///< to 1) at the end of every block for multi-block transfers based on
    ///< the multi-block transfer type programmed for source and destination
    ///< peripherals. Contiguous transfer on both source and destination peripheral
    ///< is not a valid multi-block transfer configuration. This field does
    ///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
    ///< not selected; in that case, the read-back value is always 0.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t DST_MULTBLK_TYPE : 2;
    ///< Destination Multi Block Transfer Type. These bits define the type
    ///< of multi-block transfer used for destination peripheral.  - 00: Contiguous
    ///< - 01: Reload  - 10: Shadow Register  - 11: Linked List If the type
    ///< selected is Contiguous, the CHx_DAR register is loaded with the value
    ///< of the end source address of previous block + 1 at the end of every
    ///< block for multi-block transfers. A new block transfer is then initiated.
    ///< If the type selected is Reload, the CHx_DAR register is reloaded from
    ///< the initial value of DAR at the end of every block for multi-block
    ///< transfers. A new block transfer is then initiated. If the type selected
    ///< is Shadow Register, the CHx_DAR register is loaded from the content
    ///< of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set
    ///< to 1 at the end of every block for multi-block transfers. A new block
    ///< transfer is then initiated. If the type selected is Linked List, the
    ///< CHx_DAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
    ///< bit is set to 1 at the end of every block for multi-block transfers.
    ///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
    ///< are loaded from their initial values or from the contents of their
    ///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
    ///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
    ///< to 1) at the end of every block for multi-block transfers based on
    ///< the multi-block transfer type programmed for source and destination
    ///< peripherals. Contiguous transfer on both source and destination peripheral
    ///< is not a valid multi-block transfer configuration. This field does
    ///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
    ///< not selected; in that case, the read-back value is always 0.
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_4TO17 : 14;
    ///< DMAC Channelx Transfer Configuration Register (bits 4to17) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint64_t RD_UID : 4;
    ///< Defines the number of AXI Unique ID's supported for the AXI Read Channel.
    ///< The value programmed must be less than or equal to DMAX_CH(x)_RD_UID.
    ///< Otherwise, it is limited by the value DMAX_CH(x)_RD_UID.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_22TO24 : 3;
    ///< DMAC Channelx Transfer Configuration Register (bits 22to24) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t WR_UID : 4;
    ///< Defines the number of AXI Unique ID's supported for the AXI Write
    ///< Channel. The value programmed must be less than or equal to DMAX_CH(x)_WR_UID.
    ///< Otherwise, it is limited by the value DMAX_CH(x)_WR_UID.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_29TO31 : 3;
    ///< DMAC Channelx Transfer Configuration Register (bits 29to31) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint64_t TT_FC : 3;
    ///< Transfer Type and Flow Control. The following transfer types are supported.
    ///< - Memory to Memory   - Memory to Peripheral   - Peripheral to Memory
    ///< - Peripheral to Peripheral   Flow Control can be assigned to the DW_axi_dmac,
    ///< the source peripheral, or the destination peripheral.
    ///< AccessType="RW/V" BitOffset="32" ResetValue="0x3"
    uint64_t HS_SEL_SRC : 1;
    ///< Source Software or Hardware Handshaking Select. This register selects
    ///< which of the handshaking interfaces (hardware or software) is active
    ///< for source requests on this channel.  - 0: Hardware handshaking interface.
    ///< Software-initiated transaction requests are ignored.  - 1: Software
    ///< handshaking interface. Hardware-initiated transaction requests are
    ///< ignored. If the source peripheral is memory, then this bit is ignored.
    ///< AccessType="RW/V" BitOffset="35" ResetValue="0x1"
    uint64_t HS_SEL_DST : 1;
    ///< Destination Software or Hardware Handshaking Select. This register
    ///< selects which of the handshaking interfaces (hardware or software)
    ///< is active for destination requests on this channel.  - 0: Hardware
    ///< handshaking interface. Software-initiated transaction requests are
    ///< ignored.  - 1: Software handshaking interface. Hardware-initiated
    ///< transaction requests are ignored. If the destination peripheral is
    ///< memory, then this bit is ignored.
    ///< AccessType="RW/V" BitOffset="36" ResetValue="0x1"
    uint64_t SRC_HWHS_POL : 1;
    ///< Source Hardware Handshaking Interface Polarity.  - 0: ACTIVE HIGH
    ///< - 1: ACTIVE LOW  Note: This field is reserved for future use and currently
    ///< this is always active high.
    ///< AccessType="RO/V" BitOffset="37" ResetValue="0x0"
    uint64_t DST_HWHS_POL : 1;
    ///< Destination Hardware Handshaking Interface Polarity.  - 0: ACTIVE
    ///< HIGH  - 1: ACTIVE LOW  Note: This field is reserved for future use
    ///< and currently this is always active high.
    ///< AccessType="RO/V" BitOffset="38" ResetValue="0x0"
    uint64_t SRC_PER : 3;
    ///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
    ///< the source of Channelx if the CHx_CFG.HS_SEL_SRC field is 0; otherwise,
    ///< this field is ignored. The channel can then communicate with the source
    ///< peripheral connected to that interface through the assigned hardware
    ///< handshaking interface.  Note: For correct DW_axi_dmac operation, only
    ///< one peripheral (source or destination) should be assigned to the same
    ///< handshaking interface. This field does not exist if the configuration
    ///< parameter DMAX_NUM_HS_IF is set to 0. x = 39 if DMAC_NUM_HS_IF is
    ///< 1 x = ceil(log2(DMAC_NUM_HS_IF) + 38 if DMAC_NUM_HS_IF is greater
    ///< than 1. Bits 42: (x+1) do not exist and return 0 on a read.
    ///< AccessType="RW/V" BitOffset="39" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_42_39 : 1;
    ///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+39)
    ///< to 42) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="42" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_43 : 1;
    ///< DMAC Channelx Transfer Configuration Register (43bit) Reserved bit
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="43" ResetValue="0x0"
    uint64_t DST_PER : 3;
    ///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
    ///< the destination of Channelx if the CHx_CFG.HS_SEL_DST field is 0;
    ///< otherwise, this field is ignored. The channel can then communicate
    ///< with the destination peripheral connected to that interface through
    ///< the assigned hardware handshaking interface.  Note: For correct DW_axi_dmac
    ///< operation, only one peripheral (source or destination) should be assigned
    ///< to the same handshaking interface.  This field does not exist if the
    ///< configuration parameter DMAX_NUM_HS_IF is set to 0. x = 44 if DMAC_NUM_HS_IF
    ///< is 1 x = ceil(log2(DMAC_NUM_HS_IF)) + 43 if DMAC_NUM_HS_IF is greater
    ///< than 1 Bits 47: (x+1) do not exist and return 0 on a read.
    ///< AccessType="RW/V" BitOffset="44" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_47_44 : 1;
    ///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+44)
    ///< to 47) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="47" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_48 : 1;
    ///< DMAC Channelx Transfer Configuration Register (48bit) Reserved bit
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="48" ResetValue="0x0"
    uint64_t CH_PRIOR : 3;
    ///< Channel Priority A priority of DMAX_NUM_CHANNELS-1 is the highest
    ///< priority, and 0 is the lowest. This field must be programmed within
    ///< the following range:       0: DMAX_NUM_CHANNELS-1 A programmed value
    ///< outside this range will cause erroneous behavior.
    ///< AccessType="RW/V" BitOffset="49" ResetValue="0x0"
    uint64_t LOCK_CH : 1;
    ///< Channel Lock bit When the channel is granted control of the manager
    ///< bus interface and if the CHx_CFG.LOCK_CH bit is asserted, then no
    ///< other channels are granted control of the manager bus interface for
    ///< the duration specified in CHx_CFG.LOCK_CH_L. Indicates to the manager
    ///< bus interface arbiter that this channel wants exclusive access to
    ///< the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L.
    ///< This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN
    ///< is set to False; in this case, the read-back value is always 0. Locking
    ///< the channel locks AXI Read Address, Write Address and Write Data channels
    ///< on the corresponding manager interface. Note: Channel locking feature
    ///< is supported only for memory-to-memory transfer at Block Transfer
    ///< and DMA Transfer levels. Hardware does not check for the validity
    ///< of channel locking setting, hence the software must take care of enabling
    ///< the channel locking only for memory-to-memory transfers at Block Transfer
    ///< or DMA Transfer levels. Illegal programming of channel locking might
    ///< result in unpredictable behavior.
    ///< AccessType="RO/V" BitOffset="52" ResetValue="0x0"
    uint64_t LOCK_CH_L : 2;
    ///< Channel Lock Level This bit indicates the duration over which CHx_CFG.LOCK_CH
    ///< bit applies.  - 00: Over complete DMA transfer  - 01: Over DMA block
    ///< transfer  - 1x: Reserved This field does not exist if the configuration
    ///< parameter DMAX_CHx_LOCK_EN is set to False; in that case, the read-back
    ///< value is always 0.
    ///< AccessType="RO/V" BitOffset="53" ResetValue="0x0"
    uint64_t SRC_OSR_LMT : 4;
    ///< Source Outstanding Request Limit  - Maximum outstanding request supported
    ///< is 16.  - Source Outstanding Request Limit = SRC_OSR_LMT + 1
    ///< AccessType="RW/V" BitOffset="55" ResetValue="0x0"
    uint64_t DST_OSR_LMT : 4;
    ///< Destination Outstanding Request Limit  - Maximum outstanding request
    ///< supported is 16.  - Destination Outstanding Request Limit = DST_OSR_LMT
    ///< + 1
    ///< AccessType="RW/V" BitOffset="59" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_63 : 1;
    ///< DMAC Channelx Transfer Configuration Register (63bit) Reserved bit
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="63" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_cfg_reg_t;

#define RCS_DMAC_CH2_CFG_DEFAULT (0x0000001b00000000ULL)
#define RCS_DMAC_CH2_CFG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_CFG_WR_MASK (0x7f8e739f0000000fULL)


///< Source Multi Block Transfer Type. These bits define the type of multi-block
///< transfer used for source peripheral.  - 00: Contiguous  - 01: Reload
///< - 10: Shadow Register  - 11: Linked List If the type selected is Contiguous,
///< the CHx_SAR register is loaded with the value of the end source address
///< of previous block + 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. If the type selected is Reload,
///< the CHx_SAR register is reloaded from the initial value of SAR at
///< the end of every block for multi-block transfers. A new block transfer
///< is then initiated. If the type selected is Shadow Register, the CHx_SAR
///< register is loaded from the content of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid
///< bit is set to 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. If the type selected is Linked
///< List, the CHx_SAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
///< bit is set to 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
///< are loaded from their initial values or from the contents of their
///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
///< to 1) at the end of every block for multi-block transfers based on
///< the multi-block transfer type programmed for source and destination
///< peripherals. Contiguous transfer on both source and destination peripheral
///< is not a valid multi-block transfer configuration. This field does
///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
///< not selected; in that case, the read-back value is always 0.
#define RCS_DMAC_CH2_CFG_SRC_MULTBLK_TYPE_BF_OFF ( 0)
#define RCS_DMAC_CH2_CFG_SRC_MULTBLK_TYPE_BF_WID ( 2)
#define RCS_DMAC_CH2_CFG_SRC_MULTBLK_TYPE_BF_MSK (0x00000003)
#define RCS_DMAC_CH2_CFG_SRC_MULTBLK_TYPE_BF_DEF (0x00000000)

///< Destination Multi Block Transfer Type. These bits define the type
///< of multi-block transfer used for destination peripheral.  - 00: Contiguous
///< - 01: Reload  - 10: Shadow Register  - 11: Linked List If the type
///< selected is Contiguous, the CHx_DAR register is loaded with the value
///< of the end source address of previous block + 1 at the end of every
///< block for multi-block transfers. A new block transfer is then initiated.
///< If the type selected is Reload, the CHx_DAR register is reloaded from
///< the initial value of DAR at the end of every block for multi-block
///< transfers. A new block transfer is then initiated. If the type selected
///< is Shadow Register, the CHx_DAR register is loaded from the content
///< of its shadow register if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set
///< to 1 at the end of every block for multi-block transfers. A new block
///< transfer is then initiated. If the type selected is Linked List, the
///< CHx_DAR register is loaded from the Linked List if CTL.ShadowReg_Or_LLI_Valid
///< bit is set to 1 at the end of every block for multi-block transfers.
///< A new block transfer is then initiated. CHx_CTL and CHx_BLOCK_TS registers
///< are loaded from their initial values or from the contents of their
///< shadow registers (if CHx_CTL.ShadowReg_Or_LLI_Valid bit is set to
///< 1) or from the linked list (if CTL.ShadowReg_Or_LLI_Valid bit is set
///< to 1) at the end of every block for multi-block transfers based on
///< the multi-block transfer type programmed for source and destination
///< peripherals. Contiguous transfer on both source and destination peripheral
///< is not a valid multi-block transfer configuration. This field does
///< not exist if the configuration parameter DMAX_CHx_MULTI_BLK_EN is
///< not selected; in that case, the read-back value is always 0.
#define RCS_DMAC_CH2_CFG_DST_MULTBLK_TYPE_BF_OFF ( 2)
#define RCS_DMAC_CH2_CFG_DST_MULTBLK_TYPE_BF_WID ( 2)
#define RCS_DMAC_CH2_CFG_DST_MULTBLK_TYPE_BF_MSK (0x0000000C)
#define RCS_DMAC_CH2_CFG_DST_MULTBLK_TYPE_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits 4to17) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_OFF ( 4)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_WID (14)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_MSK (0x0003FFF0)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_4TO17_BF_DEF (0x00000000)

///< Defines the number of AXI Unique ID's supported for the AXI Read Channel.
///< The value programmed must be less than or equal to DMAX_CH(x)_RD_UID.
///< Otherwise, it is limited by the value DMAX_CH(x)_RD_UID.
#define RCS_DMAC_CH2_CFG_RD_UID_BF_OFF (18)
#define RCS_DMAC_CH2_CFG_RD_UID_BF_WID ( 4)
#define RCS_DMAC_CH2_CFG_RD_UID_BF_MSK (0x003C0000)
#define RCS_DMAC_CH2_CFG_RD_UID_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits 22to24) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_OFF (22)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_WID ( 3)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_MSK (0x01C00000)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_22TO24_BF_DEF (0x00000000)

///< Defines the number of AXI Unique ID's supported for the AXI Write
///< Channel. The value programmed must be less than or equal to DMAX_CH(x)_WR_UID.
///< Otherwise, it is limited by the value DMAX_CH(x)_WR_UID.
#define RCS_DMAC_CH2_CFG_WR_UID_BF_OFF (25)
#define RCS_DMAC_CH2_CFG_WR_UID_BF_WID ( 4)
#define RCS_DMAC_CH2_CFG_WR_UID_BF_MSK (0x1E000000)
#define RCS_DMAC_CH2_CFG_WR_UID_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits 29to31) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_OFF (29)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_WID ( 3)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_MSK (0xE0000000)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_29TO31_BF_DEF (0x00000000)

///< Transfer Type and Flow Control. The following transfer types are supported.
///< - Memory to Memory   - Memory to Peripheral   - Peripheral to Memory
///< - Peripheral to Peripheral   Flow Control can be assigned to the DW_axi_dmac,
///< the source peripheral, or the destination peripheral.
#define RCS_DMAC_CH2_CFG_TT_FC_BF_OFF (32)
#define RCS_DMAC_CH2_CFG_TT_FC_BF_WID ( 3)
#define RCS_DMAC_CH2_CFG_TT_FC_BF_MSK (0x700000000)
#define RCS_DMAC_CH2_CFG_TT_FC_BF_DEF (0x300000000)

///< Source Software or Hardware Handshaking Select. This register selects
///< which of the handshaking interfaces (hardware or software) is active
///< for source requests on this channel.  - 0: Hardware handshaking interface.
///< Software-initiated transaction requests are ignored.  - 1: Software
///< handshaking interface. Hardware-initiated transaction requests are
///< ignored. If the source peripheral is memory, then this bit is ignored.
#define RCS_DMAC_CH2_CFG_HS_SEL_SRC_BF_OFF (35)
#define RCS_DMAC_CH2_CFG_HS_SEL_SRC_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_HS_SEL_SRC_BF_MSK (0x800000000)
#define RCS_DMAC_CH2_CFG_HS_SEL_SRC_BF_DEF (0x800000000)

///< Destination Software or Hardware Handshaking Select. This register
///< selects which of the handshaking interfaces (hardware or software)
///< is active for destination requests on this channel.  - 0: Hardware
///< handshaking interface. Software-initiated transaction requests are
///< ignored.  - 1: Software handshaking interface. Hardware-initiated
///< transaction requests are ignored. If the destination peripheral is
///< memory, then this bit is ignored.
#define RCS_DMAC_CH2_CFG_HS_SEL_DST_BF_OFF (36)
#define RCS_DMAC_CH2_CFG_HS_SEL_DST_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_HS_SEL_DST_BF_MSK (0x1000000000)
#define RCS_DMAC_CH2_CFG_HS_SEL_DST_BF_DEF (0x1000000000)

///< Source Hardware Handshaking Interface Polarity.  - 0: ACTIVE HIGH
///< - 1: ACTIVE LOW  Note: This field is reserved for future use and currently
///< this is always active high.
#define RCS_DMAC_CH2_CFG_SRC_HWHS_POL_BF_OFF (37)
#define RCS_DMAC_CH2_CFG_SRC_HWHS_POL_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_SRC_HWHS_POL_BF_MSK (0x2000000000)
#define RCS_DMAC_CH2_CFG_SRC_HWHS_POL_BF_DEF (0x00000000)

///< Destination Hardware Handshaking Interface Polarity.  - 0: ACTIVE
///< HIGH  - 1: ACTIVE LOW  Note: This field is reserved for future use
///< and currently this is always active high.
#define RCS_DMAC_CH2_CFG_DST_HWHS_POL_BF_OFF (38)
#define RCS_DMAC_CH2_CFG_DST_HWHS_POL_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_DST_HWHS_POL_BF_MSK (0x4000000000)
#define RCS_DMAC_CH2_CFG_DST_HWHS_POL_BF_DEF (0x00000000)

///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
///< the source of Channelx if the CHx_CFG.HS_SEL_SRC field is 0; otherwise,
///< this field is ignored. The channel can then communicate with the source
///< peripheral connected to that interface through the assigned hardware
///< handshaking interface.  Note: For correct DW_axi_dmac operation, only
///< one peripheral (source or destination) should be assigned to the same
///< handshaking interface. This field does not exist if the configuration
///< parameter DMAX_NUM_HS_IF is set to 0. x = 39 if DMAC_NUM_HS_IF is
///< 1 x = ceil(log2(DMAC_NUM_HS_IF) + 38 if DMAC_NUM_HS_IF is greater
///< than 1. Bits 42: (x+1) do not exist and return 0 on a read.
#define RCS_DMAC_CH2_CFG_SRC_PER_BF_OFF (39)
#define RCS_DMAC_CH2_CFG_SRC_PER_BF_WID ( 3)
#define RCS_DMAC_CH2_CFG_SRC_PER_BF_MSK (0x38000000000)
#define RCS_DMAC_CH2_CFG_SRC_PER_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+39)
///< to 42) Reserved bits - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_OFF (42)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_MSK (0x40000000000)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_42_39_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (43bit) Reserved bit
///< - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_43_BF_OFF (43)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_43_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_43_BF_MSK (0x80000000000)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_43_BF_DEF (0x00000000)

///< Assigns a hardware handshaking interface (0 - DMAX_NUM_HS_IF-1) to
///< the destination of Channelx if the CHx_CFG.HS_SEL_DST field is 0;
///< otherwise, this field is ignored. The channel can then communicate
///< with the destination peripheral connected to that interface through
///< the assigned hardware handshaking interface.  Note: For correct DW_axi_dmac
///< operation, only one peripheral (source or destination) should be assigned
///< to the same handshaking interface.  This field does not exist if the
///< configuration parameter DMAX_NUM_HS_IF is set to 0. x = 44 if DMAC_NUM_HS_IF
///< is 1 x = ceil(log2(DMAC_NUM_HS_IF)) + 43 if DMAC_NUM_HS_IF is greater
///< than 1 Bits 47: (x+1) do not exist and return 0 on a read.
#define RCS_DMAC_CH2_CFG_DST_PER_BF_OFF (44)
#define RCS_DMAC_CH2_CFG_DST_PER_BF_WID ( 3)
#define RCS_DMAC_CH2_CFG_DST_PER_BF_MSK (0x700000000000)
#define RCS_DMAC_CH2_CFG_DST_PER_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (bits (LOG2_DMAX_NUM_HS_IF+44)
///< to 47) Reserved bits - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_OFF (47)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_MSK (0x800000000000)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_47_44_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (48bit) Reserved bit
///< - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_48_BF_OFF (48)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_48_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_48_BF_MSK (0x1000000000000)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_48_BF_DEF (0x00000000)

///< Channel Priority A priority of DMAX_NUM_CHANNELS-1 is the highest
///< priority, and 0 is the lowest. This field must be programmed within
///< the following range:       0: DMAX_NUM_CHANNELS-1 A programmed value
///< outside this range will cause erroneous behavior.
#define RCS_DMAC_CH2_CFG_CH_PRIOR_BF_OFF (49)
#define RCS_DMAC_CH2_CFG_CH_PRIOR_BF_WID ( 3)
#define RCS_DMAC_CH2_CFG_CH_PRIOR_BF_MSK (0xE000000000000)
#define RCS_DMAC_CH2_CFG_CH_PRIOR_BF_DEF (0x00000000)

///< Channel Lock bit When the channel is granted control of the manager
///< bus interface and if the CHx_CFG.LOCK_CH bit is asserted, then no
///< other channels are granted control of the manager bus interface for
///< the duration specified in CHx_CFG.LOCK_CH_L. Indicates to the manager
///< bus interface arbiter that this channel wants exclusive access to
///< the manager bus interface for the duration specified in CHx_CFG.LOCK_CH_L.
///< This field does not exist if the configuration parameter DMAX_CHx_LOCK_EN
///< is set to False; in this case, the read-back value is always 0. Locking
///< the channel locks AXI Read Address, Write Address and Write Data channels
///< on the corresponding manager interface. Note: Channel locking feature
///< is supported only for memory-to-memory transfer at Block Transfer
///< and DMA Transfer levels. Hardware does not check for the validity
///< of channel locking setting, hence the software must take care of enabling
///< the channel locking only for memory-to-memory transfers at Block Transfer
///< or DMA Transfer levels. Illegal programming of channel locking might
///< result in unpredictable behavior.
#define RCS_DMAC_CH2_CFG_LOCK_CH_BF_OFF (52)
#define RCS_DMAC_CH2_CFG_LOCK_CH_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_LOCK_CH_BF_MSK (0x10000000000000)
#define RCS_DMAC_CH2_CFG_LOCK_CH_BF_DEF (0x00000000)

///< Channel Lock Level This bit indicates the duration over which CHx_CFG.LOCK_CH
///< bit applies.  - 00: Over complete DMA transfer  - 01: Over DMA block
///< transfer  - 1x: Reserved This field does not exist if the configuration
///< parameter DMAX_CHx_LOCK_EN is set to False; in that case, the read-back
///< value is always 0.
#define RCS_DMAC_CH2_CFG_LOCK_CH_L_BF_OFF (53)
#define RCS_DMAC_CH2_CFG_LOCK_CH_L_BF_WID ( 2)
#define RCS_DMAC_CH2_CFG_LOCK_CH_L_BF_MSK (0x60000000000000)
#define RCS_DMAC_CH2_CFG_LOCK_CH_L_BF_DEF (0x00000000)

///< Source Outstanding Request Limit  - Maximum outstanding request supported
///< is 16.  - Source Outstanding Request Limit = SRC_OSR_LMT + 1
#define RCS_DMAC_CH2_CFG_SRC_OSR_LMT_BF_OFF (55)
#define RCS_DMAC_CH2_CFG_SRC_OSR_LMT_BF_WID ( 4)
#define RCS_DMAC_CH2_CFG_SRC_OSR_LMT_BF_MSK (0x780000000000000)
#define RCS_DMAC_CH2_CFG_SRC_OSR_LMT_BF_DEF (0x00000000)

///< Destination Outstanding Request Limit  - Maximum outstanding request
///< supported is 16.  - Destination Outstanding Request Limit = DST_OSR_LMT
///< + 1
#define RCS_DMAC_CH2_CFG_DST_OSR_LMT_BF_OFF (59)
#define RCS_DMAC_CH2_CFG_DST_OSR_LMT_BF_WID ( 4)
#define RCS_DMAC_CH2_CFG_DST_OSR_LMT_BF_MSK (0x7800000000000000)
#define RCS_DMAC_CH2_CFG_DST_OSR_LMT_BF_DEF (0x00000000)

///< DMAC Channelx Transfer Configuration Register (63bit) Reserved bit
///< - Read Only
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_63_BF_OFF (63)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_63_BF_WID ( 1)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_63_BF_MSK (0x8000000000000000)
#define RCS_DMAC_CH2_CFG_RSVD_DMAC_CHX_CFG_63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_LLP register description at address offset 0x228
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_LLP
  * DW_axi_dmac Channel $i Linked List Pointer Register
  */

typedef union {
  struct {
    uint64_t LMS : 1;
    ///< LLI manager Select This bit identifies the AXI layer/interface where
    ///< the memory device that stores the next linked list item resides.
    ///< - 0: AXI Manager 1  - 1: AXI Manager 2 This field does not exist if
    ///< the configuration parameter DMAX_CHx_LMS is not set to NO_HARDCODE.
    ///< In this case, the read-back value is always the hardcoded value. The
    ///< maximum value of this field that can be read back is 'DMAX_NUM_MASTER_IF-1'.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_LLP_1TO5 : 5;
    ///< DMAC Channelx Linked List Pointer Register (bits 1to5) Reserved bits
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint64_t LOC : 58;
    ///< Starting Address Memory of LLI block Starting Address In Memory of
    ///< next LLI if block chaining is enabled. The six LSBs of the starting
    ///< address are not stored because the address is assumed to be aligned
    ///< to a 64-byte boundary. LLI access always uses the burst size (arsize/awsize)
    ///< that is same as the data bus width and cannot be changed or programmed
    ///< to anything other than this. Burst length (awlen/arlen) is chosen
    ///< based on the data bus width so that the access does not cross one
    ///< complete LLI structure of 64 bytes. DW_axi_dmac will fetch the entire
    ///< LLI (40 bytes) in one AXI burst if the burst length is not limited
    ///< by other settings.
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_llp_reg_t;

#define RCS_DMAC_CH2_LLP_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_LLP_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_LLP_WR_MASK (0xffffffffffffffc0ULL)


///< LLI manager Select This bit identifies the AXI layer/interface where
///< the memory device that stores the next linked list item resides.
///< - 0: AXI Manager 1  - 1: AXI Manager 2 This field does not exist if
///< the configuration parameter DMAX_CHx_LMS is not set to NO_HARDCODE.
///< In this case, the read-back value is always the hardcoded value. The
///< maximum value of this field that can be read back is 'DMAX_NUM_MASTER_IF-1'.
#define RCS_DMAC_CH2_LLP_LMS_BF_OFF ( 0)
#define RCS_DMAC_CH2_LLP_LMS_BF_WID ( 1)
#define RCS_DMAC_CH2_LLP_LMS_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_LLP_LMS_BF_DEF (0x00000000)

///< DMAC Channelx Linked List Pointer Register (bits 1to5) Reserved bits
///< - Read Only
#define RCS_DMAC_CH2_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_OFF ( 1)
#define RCS_DMAC_CH2_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_WID ( 5)
#define RCS_DMAC_CH2_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_MSK (0x0000003E)
#define RCS_DMAC_CH2_LLP_RSVD_DMAC_CHX_LLP_1TO5_BF_DEF (0x00000000)

///< Starting Address Memory of LLI block Starting Address In Memory of
///< next LLI if block chaining is enabled. The six LSBs of the starting
///< address are not stored because the address is assumed to be aligned
///< to a 64-byte boundary. LLI access always uses the burst size (arsize/awsize)
///< that is same as the data bus width and cannot be changed or programmed
///< to anything other than this. Burst length (awlen/arlen) is chosen
///< based on the data bus width so that the access does not cross one
///< complete LLI structure of 64 bytes. DW_axi_dmac will fetch the entire
///< LLI (40 bytes) in one AXI burst if the burst length is not limited
///< by other settings.
#define RCS_DMAC_CH2_LLP_LOC_BF_OFF ( 6)
#define RCS_DMAC_CH2_LLP_LOC_BF_WID (58)
#define RCS_DMAC_CH2_LLP_LOC_BF_MSK (0xFFFFFFFFFFFFFFC0)
#define RCS_DMAC_CH2_LLP_LOC_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_STATUSREG register description at address offset 0x230
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_STATUSREG
  * DW_axi_dmac Channel $i Status Register
  */

typedef union {
  struct {
    uint64_t CMPLTD_BLK_TFR_SIZE : 22;
    ///< Completed Block Transfer Size. The Completed Block Transfer Size status
    ///< indicates the total number of data items transferred from the Source
    ///< memory/peripheral to the Destination memory/peripheral at any point
    ///< in the DMA block transfer. The completed block transfer size or data
    ///< items is defined as follows:  - When DMA or Source is a Flow controller,
    ///< this field is defined in terms of the CHx_CTL.SRC_TR_WIDTH.  - When
    ///< Destination is a Flow Controller, this field is defined in terms of
    ///< the CHx_CTL.DST_TR_WIDTH. For more information, see  DMA Status Register
    ///< - CHx_STATUSREG  section of the databook.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_STATUSREG_22TO31 : 10;
    ///< DMAC Channelx Status Register (bits 22to31) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t DATA_LEFT_IN_FIFO : 15;
    ///< Data Left in FIFO.  The data left in the FIFO status indicates the
    ///< total number of data left in the channel FIFO after completing the
    ///< current DMA block transfer or DMA block abnormal termination due to
    ///< the following reasons:   - AXI Transfer Error response (SLVERR or
    ///< DECERR) reception   - Channel Terminate The width of the data in channel
    ///< FIFO is defined in terms of CHx_CTL.SRC_TR_WIDTH. For more information,
    ///< see  DMA Status Register - CHx_STATUSREG  section of the databook.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_STATUSREG_47TO63 : 17;
    ///< DMAC Channelx Status Register (bits 47to63) Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="47" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_statreg_reg_t;

#define RCS_DMAC_CH2_STATREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_STATREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_STATREG_WR_MASK (0x0000000000000000ULL)


///< Completed Block Transfer Size. The Completed Block Transfer Size status
///< indicates the total number of data items transferred from the Source
///< memory/peripheral to the Destination memory/peripheral at any point
///< in the DMA block transfer. The completed block transfer size or data
///< items is defined as follows:  - When DMA or Source is a Flow controller,
///< this field is defined in terms of the CHx_CTL.SRC_TR_WIDTH.  - When
///< Destination is a Flow Controller, this field is defined in terms of
///< the CHx_CTL.DST_TR_WIDTH. For more information, see  DMA Status Register
///< - CHx_STATUSREG  section of the databook.
#define RCS_DMAC_CH2_STATREG_CMPLTD_BLK_TFR_SIZE_BF_OFF ( 0)
#define RCS_DMAC_CH2_STATREG_CMPLTD_BLK_TFR_SIZE_BF_WID (22)
#define RCS_DMAC_CH2_STATREG_CMPLTD_BLK_TFR_SIZE_BF_MSK (0x003FFFFF)
#define RCS_DMAC_CH2_STATREG_CMPLTD_BLK_TFR_SIZE_BF_DEF (0x00000000)

///< DMAC Channelx Status Register (bits 22to31) Reserved bits - Read Only
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_OFF (22)
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_WID (10)
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_MSK (0xFFC00000)
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_22TO31_BF_DEF (0x00000000)

///< Data Left in FIFO.  The data left in the FIFO status indicates the
///< total number of data left in the channel FIFO after completing the
///< current DMA block transfer or DMA block abnormal termination due to
///< the following reasons:   - AXI Transfer Error response (SLVERR or
///< DECERR) reception   - Channel Terminate The width of the data in channel
///< FIFO is defined in terms of CHx_CTL.SRC_TR_WIDTH. For more information,
///< see  DMA Status Register - CHx_STATUSREG  section of the databook.
#define RCS_DMAC_CH2_STATREG_DATA_LEFT_IN_FIFO_BF_OFF (32)
#define RCS_DMAC_CH2_STATREG_DATA_LEFT_IN_FIFO_BF_WID (15)
#define RCS_DMAC_CH2_STATREG_DATA_LEFT_IN_FIFO_BF_MSK (0x7FFF00000000)
#define RCS_DMAC_CH2_STATREG_DATA_LEFT_IN_FIFO_BF_DEF (0x00000000)

///< DMAC Channelx Status Register (bits 47to63) Reserved bits - Read Only
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_OFF (47)
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_WID (17)
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_MSK (0xFFFF800000000000)
#define RCS_DMAC_CH2_STATREG_RSVD_DMAC_CHX_STATREG_47TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_SWHSSRCREG register description at address offset 0x238
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_SWHSSRCREG
  * DW_axi_dmac Channel $i Software Handshake Source Register
  */

typedef union {
  struct {
    uint64_t SWHS_REQ_SRC : 1;
    ///< Software Handshake Request for Channel Source. This bit is used to
    ///< request dma source data transfer if software handshaking method is
    ///< selected for the source of the corresponding channel. This bit is
    ///< ignored if software handshaking is not enabled for the source of the
    ///< Channelx. The functionality of this field depends on whether the peripheral
    ///< is the flow controller or not. Software can only set this bit to 1;
    ///< it is not allowed to clear this bit to 0; only DW_axi_dmac can clear
    ///< this bit. Note: SWHS_Req_Src bit is written only if the corresponding
    ///< write enable bit, SWHS_Req_Src_WE is asserted on the same register
    ///< write operation and if the Channelx is enabled in the DMAC_ChEnReg
    ///< register. This allows software to set a bit in the CHx_SWHSSrcReg
    ///< register without performing a read-modified write operation.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t SWHS_REQ_SRC_WE : 1;
    ///< Write Enable bit for Software Handshake Request for Channel Source.
    ///< Note: This bit always returns 0 on a read back.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_SRC : 1;
    ///< Software Handshake Single Request for Channel Source. This bit is
    ///< used to request SINGLE (AXI burst length = 1) dma source data transfer
    ///< if software handshaking method is selected for the source of the corresponding
    ///< channel. This bit is ignored if software handshaking is not enabled
    ///< for the source of the Channelx. The functionality of this field depends
    ///< on whether the peripheral is the flow controller. Software can only
    ///< set this bit to 1; it is not allowed to clear this bit to 0; only
    ///< DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Src bit is written
    ///< only if the corresponding write enable bit, SWHS_SglReq_Src_WE is
    ///< asserted on the same register write operation and if the Channelx
    ///< is enabled in the DMAC_ChEnReg register. This allows software to set
    ///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
    ///< write operation.
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_SRC_WE : 1;
    ///< Write Enable bit for Software Handshake Single Request for Channel
    ///< Source.
    ///< AccessType="WS/V" BitOffset="3" ResetValue="0x0"
    uint64_t SWHS_LST_SRC : 1;
    ///< Software Handshake Last Request for Channel Source. This bit is used
    ///< to request LAST dma source data transfer if software handshaking method
    ///< is selected for the source of the corresponding channel. This bit
    ///< is ignored if software handshaking is not enabled for the source of
    ///< the Channelx or if the source of Channelx is not the flow controller.
    ///< CHx_SWHSSrcReg.SWHS_Req_Src bit must be set to 1 for DW_axi_dmac to
    ///< treat it as a valid software handshaking request. If CHx_SWHSSrcReg.SWHS_SglReq_Src
    ///< is set to 1, the LAST request is for SINGLE dma transaction (AXI burst
    ///< length = 1), else the request is treated as a BURST transaction request.
    ///< Software can only set this bit to 1; it is not allowed to clear this
    ///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_Lst_Src
    ///< bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE
    ///< is asserted on the same register write operation and if the Channelx
    ///< is enabled in the DMAC_ChEnReg register. This allows software to set
    ///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
    ///< write operation.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint64_t SWHS_LST_SRC_WE : 1;
    ///< Write Enable bit for Software Handshake Last Request for Channel Source.
    ///< AccessType="WS/V" BitOffset="5" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_SWHSSRCREG_6TO63 : 58;
    ///< DMAC Channelx Software Handshake Source Register (bits 6to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_swhssrcreg_reg_t;

#define RCS_DMAC_CH2_SWHSSRCREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_SWHSSRCREG_RD_MASK (0xffffffffffffffd5ULL)
#define RCS_DMAC_CH2_SWHSSRCREG_WR_MASK (0x000000000000003fULL)


///< Software Handshake Request for Channel Source. This bit is used to
///< request dma source data transfer if software handshaking method is
///< selected for the source of the corresponding channel. This bit is
///< ignored if software handshaking is not enabled for the source of the
///< Channelx. The functionality of this field depends on whether the peripheral
///< is the flow controller or not. Software can only set this bit to 1;
///< it is not allowed to clear this bit to 0; only DW_axi_dmac can clear
///< this bit. Note: SWHS_Req_Src bit is written only if the corresponding
///< write enable bit, SWHS_Req_Src_WE is asserted on the same register
///< write operation and if the Channelx is enabled in the DMAC_ChEnReg
///< register. This allows software to set a bit in the CHx_SWHSSrcReg
///< register without performing a read-modified write operation.
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_BF_OFF ( 0)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Request for Channel Source.
///< Note: This bit always returns 0 on a read back.
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_OFF ( 1)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_MSK (0x00000002)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_REQ_SRC_WE_BF_DEF (0x00000000)

///< Software Handshake Single Request for Channel Source. This bit is
///< used to request SINGLE (AXI burst length = 1) dma source data transfer
///< if software handshaking method is selected for the source of the corresponding
///< channel. This bit is ignored if software handshaking is not enabled
///< for the source of the Channelx. The functionality of this field depends
///< on whether the peripheral is the flow controller. Software can only
///< set this bit to 1; it is not allowed to clear this bit to 0; only
///< DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Src bit is written
///< only if the corresponding write enable bit, SWHS_SglReq_Src_WE is
///< asserted on the same register write operation and if the Channelx
///< is enabled in the DMAC_ChEnReg register. This allows software to set
///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
///< write operation.
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_OFF ( 2)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_MSK (0x00000004)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Single Request for Channel
///< Source.
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_OFF ( 3)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_MSK (0x00000008)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_SGLREQ_SRC_WE_BF_DEF (0x00000000)

///< Software Handshake Last Request for Channel Source. This bit is used
///< to request LAST dma source data transfer if software handshaking method
///< is selected for the source of the corresponding channel. This bit
///< is ignored if software handshaking is not enabled for the source of
///< the Channelx or if the source of Channelx is not the flow controller.
///< CHx_SWHSSrcReg.SWHS_Req_Src bit must be set to 1 for DW_axi_dmac to
///< treat it as a valid software handshaking request. If CHx_SWHSSrcReg.SWHS_SglReq_Src
///< is set to 1, the LAST request is for SINGLE dma transaction (AXI burst
///< length = 1), else the request is treated as a BURST transaction request.
///< Software can only set this bit to 1; it is not allowed to clear this
///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_Lst_Src
///< bit is written only if the corresponding write enable bit, SWHS_Lst_Src_WE
///< is asserted on the same register write operation and if the Channelx
///< is enabled in the DMAC_ChEnReg register. This allows software to set
///< a bit in the CHx_SWHSSrcReg register without performing a read-modified
///< write operation.
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_BF_OFF ( 4)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_BF_MSK (0x00000010)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Last Request for Channel Source.
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_WE_BF_OFF ( 5)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_WE_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_WE_BF_MSK (0x00000020)
#define RCS_DMAC_CH2_SWHSSRCREG_SWHS_LST_SRC_WE_BF_DEF (0x00000000)

///< DMAC Channelx Software Handshake Source Register (bits 6to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_OFF ( 6)
#define RCS_DMAC_CH2_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_WID (58)
#define RCS_DMAC_CH2_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_MSK (0xFFFFFFFFFFFFFFC0)
#define RCS_DMAC_CH2_SWHSSRCREG_RSVD_DMAC_CHX_SWHSSRCREG_6TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_SWHSDSTREG register description at address offset 0x240
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_SWHSDSTREG
  * DW_axi_dmac Channel $i Software Handshake Destination Register
  */

typedef union {
  struct {
    uint64_t SWHS_REQ_DST : 1;
    ///< Software Handshake Request for Channel Destination. This bit is used
    ///< to request dma destination data transfer if software handshaking method
    ///< is selected for the destination of the corresponding channel. This
    ///< bit is ignored if software handshaking is not enabled for the source
    ///< of the Channelx. The functionality of this field depends on whether
    ///< the peripheral is the flow controller. Software can only set this
    ///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
    ///< can clear this bit. Note: SWHS_Req_Dst bit is written only if the
    ///< corresponding write enable bit, SWHS_Req_Dst_WE is asserted on the
    ///< same register write operation and if the Channelx is enabled in the
    ///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
    ///< register without performing a read-modified write operation.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint64_t SWHS_REQ_DST_WE : 1;
    ///< Write Enable bit for Software Handshake Request for Channel Destination.
    ///< Note: This bit always returns 0 on a read block.
    ///< AccessType="WS/V" BitOffset="1" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_DST : 1;
    ///< Software Handshake Single Request for Channel Destination. This bit
    ///< is used to request SINGLE (AXI burst length = 1) dma destination data
    ///< transfer if software handshaking method is selected for the destination
    ///< of the corresponding channel. This bit is ignored if software handshaking
    ///< is not enabled for the destination of the Channelx. The functionality
    ///< of this field depends on whether the peripheral is the flow controller.
    ///< Software can only set this bit to 1; it is not allowed to clear this
    ///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Dst
    ///< bit is written only if the corresponding write enable bit, SWHS_SglReq_Dst_WE
    ///< is asserted on the same register write operation and if the Channelx
    ///< is enabled in the DMAC_ChEnReg register. This allows software to set
    ///< a bit in the CHx_SWHSDstReg register without performing a read-modified
    ///< write operation.
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint64_t SWHS_SGLREQ_DST_WE : 1;
    ///< Write Enable bit for Software Handshake Single Request for Channel
    ///< Destination. Note: This bit always returns 0 on a read block.
    ///< AccessType="WS/V" BitOffset="3" ResetValue="0x0"
    uint64_t SWHS_LST_DST : 1;
    ///< Software Handshake Last Request for Channel Destination. This bit
    ///< is used to request LAST dma destination data transfer if software
    ///< handshaking method is selected for the destination of the corresponding
    ///< channel. This bit is ignored if software handshaking is not enabled
    ///< for the destination of the Channelx or if the destination of Channelx
    ///< is not the flow controller. CHx_SWHSDstReg.SWHS_Req_Dst bit must be
    ///< set to 1 for DW_axi_dmac to treat it as a valid software handshaking
    ///< request. If CHx_SWHSDstReg.SWHS_SglReq_Dst is set to 1, the LAST request
    ///< is for SINGLE dma transaction (AXI burst length = 1), else the request
    ///< is treated as a BURST transaction request. Software can only set this
    ///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
    ///< can clear this bit. Note: SWHS_Lst_Src bit is written only if the
    ///< corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the
    ///< same register write operation and if the Channelx is enabled in the
    ///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
    ///< register without performing a read-modified write operation.
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint64_t SWHS_LST_DST_WE : 1;
    ///< Write Enable bit for Software Handshake Last Request for Channel Destination.
    ///< Note: This bit always returns 0 on a read back.
    ///< AccessType="WS/V" BitOffset="5" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_SWHSDSTREG_6TO63 : 58;
    ///< DMAC Channelx Software Handshake Destination Register (bits 6to63)
    ///< Reserved bits - Read Only
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_swhsdstreg_reg_t;

#define RCS_DMAC_CH2_SWHSDSTREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_SWHSDSTREG_RD_MASK (0xffffffffffffffd5ULL)
#define RCS_DMAC_CH2_SWHSDSTREG_WR_MASK (0x000000000000003fULL)


///< Software Handshake Request for Channel Destination. This bit is used
///< to request dma destination data transfer if software handshaking method
///< is selected for the destination of the corresponding channel. This
///< bit is ignored if software handshaking is not enabled for the source
///< of the Channelx. The functionality of this field depends on whether
///< the peripheral is the flow controller. Software can only set this
///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
///< can clear this bit. Note: SWHS_Req_Dst bit is written only if the
///< corresponding write enable bit, SWHS_Req_Dst_WE is asserted on the
///< same register write operation and if the Channelx is enabled in the
///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
///< register without performing a read-modified write operation.
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_BF_OFF ( 0)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Request for Channel Destination.
///< Note: This bit always returns 0 on a read block.
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_WE_BF_OFF ( 1)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_WE_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_WE_BF_MSK (0x00000002)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_REQ_DST_WE_BF_DEF (0x00000000)

///< Software Handshake Single Request for Channel Destination. This bit
///< is used to request SINGLE (AXI burst length = 1) dma destination data
///< transfer if software handshaking method is selected for the destination
///< of the corresponding channel. This bit is ignored if software handshaking
///< is not enabled for the destination of the Channelx. The functionality
///< of this field depends on whether the peripheral is the flow controller.
///< Software can only set this bit to 1; it is not allowed to clear this
///< bit to 0; only DW_axi_dmac can clear this bit. Note: SWHS_SglReq_Dst
///< bit is written only if the corresponding write enable bit, SWHS_SglReq_Dst_WE
///< is asserted on the same register write operation and if the Channelx
///< is enabled in the DMAC_ChEnReg register. This allows software to set
///< a bit in the CHx_SWHSDstReg register without performing a read-modified
///< write operation.
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_BF_OFF ( 2)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_BF_MSK (0x00000004)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Single Request for Channel
///< Destination. Note: This bit always returns 0 on a read block.
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_OFF ( 3)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_MSK (0x00000008)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_SGLREQ_DST_WE_BF_DEF (0x00000000)

///< Software Handshake Last Request for Channel Destination. This bit
///< is used to request LAST dma destination data transfer if software
///< handshaking method is selected for the destination of the corresponding
///< channel. This bit is ignored if software handshaking is not enabled
///< for the destination of the Channelx or if the destination of Channelx
///< is not the flow controller. CHx_SWHSDstReg.SWHS_Req_Dst bit must be
///< set to 1 for DW_axi_dmac to treat it as a valid software handshaking
///< request. If CHx_SWHSDstReg.SWHS_SglReq_Dst is set to 1, the LAST request
///< is for SINGLE dma transaction (AXI burst length = 1), else the request
///< is treated as a BURST transaction request. Software can only set this
///< bit to 1; it is not allowed to clear this bit to 0; only DW_axi_dmac
///< can clear this bit. Note: SWHS_Lst_Src bit is written only if the
///< corresponding write enable bit, SWHS_Lst_Src_WE is asserted on the
///< same register write operation and if the Channelx is enabled in the
///< DMAC_ChEnReg register. This allows software to set a bit in the CHx_SWHSDstReg
///< register without performing a read-modified write operation.
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_BF_OFF ( 4)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_BF_MSK (0x00000010)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_BF_DEF (0x00000000)

///< Write Enable bit for Software Handshake Last Request for Channel Destination.
///< Note: This bit always returns 0 on a read back.
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_WE_BF_OFF ( 5)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_WE_BF_WID ( 1)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_WE_BF_MSK (0x00000020)
#define RCS_DMAC_CH2_SWHSDSTREG_SWHS_LST_DST_WE_BF_DEF (0x00000000)

///< DMAC Channelx Software Handshake Destination Register (bits 6to63)
///< Reserved bits - Read Only
#define RCS_DMAC_CH2_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_OFF ( 6)
#define RCS_DMAC_CH2_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_WID (58)
#define RCS_DMAC_CH2_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_MSK (0xFFFFFFFFFFFFFFC0)
#define RCS_DMAC_CH2_SWHSDSTREG_RSVD_DMAC_CHX_SWHSDSTREG_6TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_BLK_TFR_RESUMEREQREG register description at address offset 0x248
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_BLK_TFR_RESUMEREQREG
  * DW_axi_dmac Channel $i Block Transfer Resume Request Register
  */

typedef union {
  struct {
    uint64_t BLK_TFR_RESUMEREQ : 1;
    ///< Block Transfer Resume Request during Linked-List or Shadow-Register-based
    ///< multi-block transfer.
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63 : 63;
    ///< DMAC Channelx Block Transfer Resume Request Register (bits 1to63)
    ///< Reserved bits - Read Only
    ///< AccessType="WS" BitOffset="1" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_blk_tfr_resumereqreg_reg_t;

#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_RD_MASK (0x0000000000000000ULL)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_WR_MASK (0xffffffffffffffffULL)


///< Block Transfer Resume Request during Linked-List or Shadow-Register-based
///< multi-block transfer.
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_OFF ( 0)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_WID ( 1)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_BLK_TFR_RESUMEREQ_BF_DEF (0x00000000)

///< DMAC Channelx Block Transfer Resume Request Register (bits 1to63)
///< Reserved bits - Read Only
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_OFF ( 1)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_WID (63)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_MSK (0xFFFFFFFFFFFFFFFE)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_RSVD_DMAC_CHX_BLK_TFR_RESUMEREQREG_1TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_AXI_IDREG register description at address offset 0x250
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_AXI_IDREG
  * DW_axi_dmac Channel $i AXI ID Register
  */

typedef union {
  struct {
    uint64_t AXI_READ_ID_SUFFIX : 2;
    ///< AXI Read ID Suffix These bits form part of the ARID output of AXI3/AXI4
    ///< manager interface.       IDW = DMAX_M_ID_WIDTH       L2NC = log2(DMAX_NUM_CHANNELS)
    ///< The upper L2NC+1 bits of aridN is derived from the channel number
    ///< which is currently accessing the manager interface. This varies for
    ///< LLI fetch and source data transfer. For source data transfer, aridN
    ///< for channel1 4'b0000, aridN for channel8 4'b0111 and so on. For LLI
    ///< fetch access, aridN  for channel1 4'b1000, aridN for channel8 4'b1111
    ///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Read_ID_Suffix
    ///< filed.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_IDREG_IDW_L2NCM1TO31 : 14;
    ///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to31) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint64_t AXI_WRITE_ID_SUFFIX : 2;
    ///< AXI Write ID Suffix. These bits form part of the AWID output of AXI3/AXI4
    ///< manager interface.      IDW = DMAX_M_ID_WIDTH      L2NC = log2(DMAX_NUM_CHANNELS)
    ///< The upper L2NC+1 bits of awidN is derived from the channel number
    ///< which is currently accessing the manager interface. This varies for
    ///< LLI fetch and source data transfer. For source data transfer, awidN
    ///< for channel1 4'b0000, awidN for channel8 4'b0111 and so on. For LLI
    ///< fetch access, awidN for channel1 4'b1000, awidN for channel8 4'b1111
    ///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Write_ID_Suffix
    ///< filed.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_IDREG_IDW_L2NCM32TO63 : 14;
    ///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to32) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_IDREG_32TO63 : 32;
    ///< DMAC Channelx AXI ID Register (bits 32to63) Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="32" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_idreg_reg_t;

#define RCS_DMAC_CH2_IDREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_IDREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_IDREG_WR_MASK (0x0000000000030003ULL)


///< AXI Read ID Suffix These bits form part of the ARID output of AXI3/AXI4
///< manager interface.       IDW = DMAX_M_ID_WIDTH       L2NC = log2(DMAX_NUM_CHANNELS)
///< The upper L2NC+1 bits of aridN is derived from the channel number
///< which is currently accessing the manager interface. This varies for
///< LLI fetch and source data transfer. For source data transfer, aridN
///< for channel1 4'b0000, aridN for channel8 4'b0111 and so on. For LLI
///< fetch access, aridN  for channel1 4'b1000, aridN for channel8 4'b1111
///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Read_ID_Suffix
///< filed.
#define RCS_DMAC_CH2_IDREG_READ_ID_SUFFIX_BF_OFF ( 0)
#define RCS_DMAC_CH2_IDREG_READ_ID_SUFFIX_BF_WID ( 2)
#define RCS_DMAC_CH2_IDREG_READ_ID_SUFFIX_BF_MSK (0x00000003)
#define RCS_DMAC_CH2_IDREG_READ_ID_SUFFIX_BF_DEF (0x00000000)

///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to31) Reserved bits
///< - Read Only
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_OFF ( 2)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_WID (14)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_MSK (0x0000FFFC)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM1TO31_BF_DEF (0x00000000)

///< AXI Write ID Suffix. These bits form part of the AWID output of AXI3/AXI4
///< manager interface.      IDW = DMAX_M_ID_WIDTH      L2NC = log2(DMAX_NUM_CHANNELS)
///< The upper L2NC+1 bits of awidN is derived from the channel number
///< which is currently accessing the manager interface. This varies for
///< LLI fetch and source data transfer. For source data transfer, awidN
///< for channel1 4'b0000, awidN for channel8 4'b0111 and so on. For LLI
///< fetch access, awidN for channel1 4'b1000, awidN for channel8 4'b1111
///< and so on. Lower bits are same as the value programmed in CHx_AXI_IDReg.AXI_Write_ID_Suffix
///< filed.
#define RCS_DMAC_CH2_IDREG_WRITE_ID_SUFFIX_BF_OFF (16)
#define RCS_DMAC_CH2_IDREG_WRITE_ID_SUFFIX_BF_WID ( 2)
#define RCS_DMAC_CH2_IDREG_WRITE_ID_SUFFIX_BF_MSK (0x00030000)
#define RCS_DMAC_CH2_IDREG_WRITE_ID_SUFFIX_BF_DEF (0x00000000)

///< DMAC Channelx AXI ID Register (bits (IDW-L2NC-1)to32) Reserved bits
///< - Read Only
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_OFF (18)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_WID (14)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_MSK (0xFFFC0000)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_IDW_L2NCM32TO63_BF_DEF (0x00000000)

///< DMAC Channelx AXI ID Register (bits 32to63) Reserved bits - Read Only
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_OFF (32)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_WID (32)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_MSK (0xFFFFFFFF00000000)
#define RCS_DMAC_CH2_IDREG_RSVD_DMAC_CHX_IDREG_32TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_AXI_QOSREG register description at address offset 0x258
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_AXI_QOSREG
  * DW_axi_dmac Channel $i AXI QoS Register
  */

typedef union {
  struct {
    uint64_t AXI_AWQOS : 4;
    ///< AXI AWQOS. These bits form the awqos output of AXI4 manager interface.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint64_t AXI_ARQOS : 4;
    ///< AXI ARQOS. These bits form the arqos output of AXI4 manager interface.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_AXI_QOSREG_8TO63 : 56;
    ///< DMAC Channelx AXI QOS Register (bits 8to63) Reserved bits - Read Only
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_qosreg_reg_t;

#define RCS_DMAC_CH2_QOSREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_QOSREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_QOSREG_WR_MASK (0x0000000000000000ULL)


///< AXI AWQOS. These bits form the awqos output of AXI4 manager interface.
#define RCS_DMAC_CH2_QOSREG_AWQOS_BF_OFF ( 0)
#define RCS_DMAC_CH2_QOSREG_AWQOS_BF_WID ( 4)
#define RCS_DMAC_CH2_QOSREG_AWQOS_BF_MSK (0x0000000F)
#define RCS_DMAC_CH2_QOSREG_AWQOS_BF_DEF (0x00000000)

///< AXI ARQOS. These bits form the arqos output of AXI4 manager interface.
#define RCS_DMAC_CH2_QOSREG_ARQOS_BF_OFF ( 4)
#define RCS_DMAC_CH2_QOSREG_ARQOS_BF_WID ( 4)
#define RCS_DMAC_CH2_QOSREG_ARQOS_BF_MSK (0x000000F0)
#define RCS_DMAC_CH2_QOSREG_ARQOS_BF_DEF (0x00000000)

///< DMAC Channelx AXI QOS Register (bits 8to63) Reserved bits - Read Only
#define RCS_DMAC_CH2_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_OFF ( 8)
#define RCS_DMAC_CH2_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_WID (56)
#define RCS_DMAC_CH2_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_MSK (0xFFFFFFFFFFFFFF00)
#define RCS_DMAC_CH2_QOSREG_RSVD_DMAC_CHX_QOSREG_8TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_INTSTATUS_ENABLEREG register description at address offset 0x280
  *
  * Register default value:        0xFFFFFFFFFFFFFFFF
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_INTSTATUS_ENABLEREG
  * DW_axi_dmac Channel $i Interrupt Status Enable Register
  */

typedef union {
  struct {
    uint64_t ENABLE_BLOCK_TFR_DONE_INTSTAT : 1;
    ///< Block Transfer Done Interrupt Status Enable.  - 0: Disable the generation
    ///< of Block Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint64_t ENABLE_DMA_TFR_DONE_INTSTAT : 1;
    ///< DMA Transfer Done Interrupt Status Enable.  - 0: Disable the generation
    ///< of DMA Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_2 : 1;
    ///< DMAC Channelx Interrupt Status Register (bit 2) Reserved bit - Read
    ///< Only
    ///< AccessType="RO" BitOffset="2" ResetValue="0x1"
    uint64_t ENABLE_SRC_TRANSCOMP_INTSTAT : 1;
    ///< Source Transaction Completed Status Enable.  - 0: Disable the generation
    ///< of Source Transaction Complete Interrupt in CHx_INTSTATUSREG  - 1:
    ///< Enable the generation of Source Transaction Complete Interrupt in
    ///< CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint64_t ENABLE_DST_TRANSCOMP_INTSTAT : 1;
    ///< Destination Transaction Completed Status Enable.  - 0: Disable the
    ///< generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG
    ///< - 1: Enable the generation of Destination Transaction complete Interrupt
    ///< in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint64_t ENABLE_SRC_DEC_ERR_INTSTAT : 1;
    ///< Source Decode Error Status Enable.  - 0: Disable the generation of
    ///< Source Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of Source Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint64_t ENABLE_DST_DEC_ERR_INTSTAT : 1;
    ///< Destination Decode Error Status Enable.  - 0: Disable the generation
    ///< of Destination Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint64_t ENABLE_SRC_SLV_ERR_INTSTAT : 1;
    ///< Source Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of Source Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint64_t ENABLE_DST_SLV_ERR_INTSTAT : 1;
    ///< Destination Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG  -
    ///< 1: Enable the generation of Destination Subordinate Error Interrupt
    ///< in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_DEC_ERR_INTSTAT : 1;
    ///< LLI Read Decode Error Status Enable.  - 0: Disable the generation
    ///< of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_DEC_ERR_INTSTAT : 1;
    ///< LLI WRITE Decode Error Status Enable.  - 0: Disable the generation
    ///< of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="10" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_SLV_ERR_INTSTAT : 1;
    ///< LLI Read Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
    ///< Enable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="11" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_SLV_ERR_INTSTAT : 1;
    ///< LLI WRITE Subordinate Error Status Enable.  - 0: Disable the generation
    ///< of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
    ///< Enable the generation of LLI WRITE Subordinate Error Interrupt in
    ///< CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint64_t ENABLE_SHADOWREG_OR_LLI_INVALID_ERR_INTSTAT : 1;
    ///< Shadow register or LLI Invalid Error Status Enable.  - 0: Disable
    ///< the generation of Shadow Register or LLI Invalid Error Interrupt in
    ///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow Register or
    ///< LLI Invalid  Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_MULTIBLKTYPE_ERR_INTSTAT : 1;
    ///< Register Bus Interface Multi Block type Error Status Enable.  - 0:
    ///< Disable the generation of Register Bus Interface Multi Block type
    ///< Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation of
    ///< Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_15 : 1;
    ///< DMAC Channelx Interrupt Status Register (bit 15) Reserved bit - Read
    ///< Only
    ///< AccessType="RO" BitOffset="15" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Decode Error Status Enable.  - 0: Disable the
    ///< generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG
    ///< - 1: Enable the generation of Register Bus Interface Decode Error
    ///< Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write to Read Only Error Status Enable.  -
    ///< 0: Disable the generation of Register Bus Interface Write to Read
    ///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Register Bus Interface Write to Read Only Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_RD2RWO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Read to write Only Error Status Enable.  -
    ///< 0: Disable the generation of Register Bus Interface Read to Write
    ///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Register Bus Interface Read to Write Only Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONCHEN_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Channel Enabled Error Status Enable.
    ///< - 0: Disable the generation of Register Bus Interface Write On Channel
    ///< enabled Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Register Bus Interface Write On Channel enabled Error Interrupt
    ///< in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="19" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_INTSTAT : 1;
    ///< Shadow Register Write On Valid Error Status Enable.  - 0: Disable
    ///< the generation of Shadow Register Write On Valid Error Interrupt in
    ///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow register Write
    ///< On Valid Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="20" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Hold Error Status Enable.  - 0: Disable
    ///< the generation of Register Bus Interface Write On Hold Error Interrupt
    ///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
    ///< Write On Hold Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_22TO23 : 2;
    ///< DMAC Channelx Interrupt Status Register (bits 22to23) Reserved bits
    ///< - Read Only
    ///< AccessType="RO" BitOffset="22" ResetValue="0x3"
    uint64_t ENABLE_SLVIF_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Address Parity Error Enable.  - 0: Disable
    ///< the generation of Register Bus Interface Address Parity Error Interrupt
    ///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
    ///< Address Parity Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RO" BitOffset="24" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write Parity Error Enable.  - 0: Disable the
    ///< generation of Register Bus Interface Write Parity Error Interrupt
    ///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
    ///< Write Parity Error Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RO" BitOffset="25" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_26 : 1;
    ///< DMAC Channelx Interrupt Status Register (bit 26) Reserved bit - Read
    ///< Only
    ///< AccessType="RO" BitOffset="26" ResetValue="0x1"
    uint64_t ENABLE_CH_LOCK_CLEARED_INTSTAT : 1;
    ///< Channel Lock Cleared Status Enable.  - 0: Disable the generation of
    ///< Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint64_t ENABLE_CH_SRC_SUSPENDED_INTSTAT : 1;
    ///< Channel Source Suspended Status Enable.  - 0: Disable the generation
    ///< of Channel Source Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable
    ///< the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint64_t ENABLE_CH_SUSPENDED_INTSTAT : 1;
    ///< Channel Suspended Status Enable.  - 0: Disable the generation of Channel
    ///< Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Channel Suspended Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="29" ResetValue="0x1"
    uint64_t ENABLE_CH_DISABLED_INTSTAT : 1;
    ///< Channel Disabled Status Enable.  - 0: Disable the generation of Channel
    ///< Disabled Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
    ///< of Channel Disabled Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint64_t ENABLE_CH_ABORTED_INTSTAT : 1;
    ///< Channel Terminated Status Enable.  - 0: Disable the generation of
    ///< Channel Terminated Interrupt in CHx_INTSTATUSREG  - 1: Enable the
    ///< generation of Channel Terminated Interrupt in CHx_INTSTATUSREG
    ///< AccessType="RW" BitOffset="31" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_CORRERR_INTSTAT : 1;
    ///< Channel x Channel Memory Interface ECC Protection Correctable Error
    ///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
    ///< Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.
    ///< - 1: Enable the generation of Channel x Channel Memory Interface Correctable
    ///< Error Interrupt in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="32" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
    ///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
    ///< Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
    ///< - 1: Enable the generation Channel x Channel Memory Interface Uncorrectable
    ///< Error Interrupt in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="33" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_CORRERR_INTSTAT : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
    ///< Interrupt enable.  - 0: Disable the generation of Channel x UID Memory
    ///< Interface Correctable Error Interrupt in CHx_INTSTATUSREG.  - 1: Enable
    ///< the generation Channel x UID Memory Interface Correctable Error Interrupt
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="34" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
    ///< Error Interrupt enable.  - 0: Disable the generation of Channel x
    ///< UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
    ///< - 1: Enable the generation Channel x UID Memory Interface Uncorrectable
    ///< Error Interrupt in CHx_INTSTATUSREG.
    ///< AccessType="RO" BitOffset="35" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_32TO63 : 28;
    ///< DMAC Channelx Interrupt Status Enable Register (bits 32to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="36" ResetValue="0xFFFFFFF"
  } ;
  uint64_t value;
} rcs_dmac_ch2_intstat_enreg_reg_t;

#define RCS_DMAC_CH2_INTSTAT_ENREG_DEFAULT (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_INTSTAT_ENREG_WR_MASK (0x00000000f83f7ffbULL)


///< Block Transfer Done Interrupt Status Enable.  - 0: Disable the generation
///< of Block Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Block Transfer Done Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_BLK_TFR_DONE_INTSTAT_BF_DEF (0x00000001)

///< DMA Transfer Done Interrupt Status Enable.  - 0: Disable the generation
///< of DMA Transfer Done Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of DMA Transfer Done Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DMA_TFR_DONE_INTSTAT_BF_DEF (0x00000002)

///< DMAC Channelx Interrupt Status Register (bit 2) Reserved bit - Read
///< Only
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_DEF (0x00000004)

///< Source Transaction Completed Status Enable.  - 0: Disable the generation
///< of Source Transaction Complete Interrupt in CHx_INTSTATUSREG  - 1:
///< Enable the generation of Source Transaction Complete Interrupt in
///< CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_TRANSCOMP_INTSTAT_BF_DEF (0x00000008)

///< Destination Transaction Completed Status Enable.  - 0: Disable the
///< generation of Destination Transaction complete Interrupt in CHx_INTSTATUSREG
///< - 1: Enable the generation of Destination Transaction complete Interrupt
///< in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_OFF ( 4)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_MSK (0x00000010)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_TRANSCOMP_INTSTAT_BF_DEF (0x00000010)

///< Source Decode Error Status Enable.  - 0: Disable the generation of
///< Source Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of Source Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_OFF ( 5)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_MSK (0x00000020)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_DEC_ERR_INTSTAT_BF_DEF (0x00000020)

///< Destination Decode Error Status Enable.  - 0: Disable the generation
///< of Destination Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Destination Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_DEC_ERR_INTSTAT_BF_DEF (0x00000040)

///< Source Subordinate Error Status Enable.  - 0: Disable the generation
///< of Source Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Source Subordinate Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SRC_SLV_ERR_INTSTAT_BF_DEF (0x00000080)

///< Destination Subordinate Error Status Enable.  - 0: Disable the generation
///< of Destination Subordinate Error Interrupt in CHx_INTSTATUSREG  -
///< 1: Enable the generation of Destination Subordinate Error Interrupt
///< in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_DST_SLV_ERR_INTSTAT_BF_DEF (0x00000100)

///< LLI Read Decode Error Status Enable.  - 0: Disable the generation
///< of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of LLI Read Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_DEC_ERR_INTSTAT_BF_DEF (0x00000200)

///< LLI WRITE Decode Error Status Enable.  - 0: Disable the generation
///< of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of LLI WRITE Decode Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_DEC_ERR_INTSTAT_BF_DEF (0x00000400)

///< LLI Read Subordinate Error Status Enable.  - 0: Disable the generation
///< of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
///< Enable the generation of LLI Read Subordinate Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_RD_SLV_ERR_INTSTAT_BF_DEF (0x00000800)

///< LLI WRITE Subordinate Error Status Enable.  - 0: Disable the generation
///< of LLI WRITE Subordinate Error Interrupt in CHx_INTSTATUSREG  - 1:
///< Enable the generation of LLI WRITE Subordinate Error Interrupt in
///< CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_LLI_WR_SLV_ERR_INTSTAT_BF_DEF (0x00001000)

///< Shadow register or LLI Invalid Error Status Enable.  - 0: Disable
///< the generation of Shadow Register or LLI Invalid Error Interrupt in
///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow Register or
///< LLI Invalid  Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_DEF (0x00002000)

///< Register Bus Interface Multi Block type Error Status Enable.  - 0:
///< Disable the generation of Register Bus Interface Multi Block type
///< Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation of
///< Register Bus Interface Multi Block type Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_DEF (0x00004000)

///< DMAC Channelx Interrupt Status Register (bit 15) Reserved bit - Read
///< Only
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_OFF (15)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_DEF (0x00008000)

///< Register Bus Interface Decode Error Status Enable.  - 0: Disable the
///< generation of Register Bus Interface Decode Error Interrupt in CHx_INTSTATUSREG
///< - 1: Enable the generation of Register Bus Interface Decode Error
///< Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_DEC_ERR_INTSTAT_BF_DEF (0x00010000)

///< Register Bus Interface Write to Read Only Error Status Enable.  -
///< 0: Disable the generation of Register Bus Interface Write to Read
///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Register Bus Interface Write to Read Only Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WR2RO_ERR_INTSTAT_BF_DEF (0x00020000)

///< Register Bus Interface Read to write Only Error Status Enable.  -
///< 0: Disable the generation of Register Bus Interface Read to Write
///< only Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Register Bus Interface Read to Write Only Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_RD2RWO_ERR_INTSTAT_BF_DEF (0x00040000)

///< Register Bus Interface Write On Channel Enabled Error Status Enable.
///< - 0: Disable the generation of Register Bus Interface Write On Channel
///< enabled Error Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Register Bus Interface Write On Channel enabled Error Interrupt
///< in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSTAT_BF_DEF (0x00080000)

///< Shadow Register Write On Valid Error Status Enable.  - 0: Disable
///< the generation of Shadow Register Write On Valid Error Interrupt in
///< CHx_INTSTATUSREG  - 1: Enable the generation of Shadow register Write
///< On Valid Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_DEF (0x00100000)

///< Register Bus Interface Write On Hold Error Status Enable.  - 0: Disable
///< the generation of Register Bus Interface Write On Hold Error Interrupt
///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
///< Write On Hold Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00200000)

///< DMAC Channelx Interrupt Status Register (bits 22to23) Reserved bits
///< - Read Only
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_22TO23_BF_DEF (0x00C00000)

///< Register Bus Interface Address Parity Error Enable.  - 0: Disable
///< the generation of Register Bus Interface Address Parity Error Interrupt
///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
///< Address Parity Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x01000000)

///< Register Bus Interface Write Parity Error Enable.  - 0: Disable the
///< generation of Register Bus Interface Write Parity Error Interrupt
///< in CHx_INTSTATUSREG  - 1: Enable the generation of Register Bus Interface
///< Write Parity Error Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_SLVIF_WRPARITY_ERR_INTSTAT_BF_DEF (0x02000000)

///< DMAC Channelx Interrupt Status Register (bit 26) Reserved bit - Read
///< Only
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_OFF (26)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_26_BF_DEF (0x04000000)

///< Channel Lock Cleared Status Enable.  - 0: Disable the generation of
///< Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of Channel LOCK CLEARED Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_LOCK_CLRED_INTSTAT_BF_DEF (0x08000000)

///< Channel Source Suspended Status Enable.  - 0: Disable the generation
///< of Channel Source Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable
///< the generation of Channel Source Suspended Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SRC_SUSPENDED_INTSTAT_BF_DEF (0x10000000)

///< Channel Suspended Status Enable.  - 0: Disable the generation of Channel
///< Suspended Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Channel Suspended Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_SUSPENDED_INTSTAT_BF_DEF (0x20000000)

///< Channel Disabled Status Enable.  - 0: Disable the generation of Channel
///< Disabled Interrupt in CHx_INTSTATUSREG  - 1: Enable the generation
///< of Channel Disabled Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_DISD_INTSTAT_BF_DEF (0x40000000)

///< Channel Terminated Status Enable.  - 0: Disable the generation of
///< Channel Terminated Interrupt in CHx_INTSTATUSREG  - 1: Enable the
///< generation of Channel Terminated Interrupt in CHx_INTSTATUSREG
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_OFF (31)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_MSK (0x80000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_CH_ABORTED_INTSTAT_BF_DEF (0x80000000)

///< Channel x Channel Memory Interface ECC Protection Correctable Error
///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
///< Memory Interface Correctable Error Interrupt in CHx_INTSTATUSREG.
///< - 1: Enable the generation of Channel x Channel Memory Interface Correctable
///< Error Interrupt in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_OFF (32)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_MSK (0x100000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_DEF (0x100000000)

///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
///< Interrupt enable.  - 0: Disable the generation of Channel x Channel
///< Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
///< - 1: Enable the generation Channel x Channel Memory Interface Uncorrectable
///< Error Interrupt in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_OFF (33)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_MSK (0x200000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_DEF (0x200000000)

///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
///< Interrupt enable.  - 0: Disable the generation of Channel x UID Memory
///< Interface Correctable Error Interrupt in CHx_INTSTATUSREG.  - 1: Enable
///< the generation Channel x UID Memory Interface Correctable Error Interrupt
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_OFF (34)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_MSK (0x400000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_DEF (0x400000000)

///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
///< Error Interrupt enable.  - 0: Disable the generation of Channel x
///< UID Memory Interface Uncorrectable Error Interrupt in CHx_INTSTATUSREG.
///< - 1: Enable the generation Channel x UID Memory Interface Uncorrectable
///< Error Interrupt in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_OFF (35)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_MSK (0x800000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_DEF (0x800000000)

///< DMAC Channelx Interrupt Status Enable Register (bits 32to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_OFF (36)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_WID (28)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH2_INTSTAT_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_32TO63_BF_DEF (0xFFFFFFF000000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_INTSTATUS register description at address offset 0x288
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_INTSTATUS
  * DW_axi_dmac Channel $i Interrupt Status Register
  */

typedef union {
  struct {
    uint64_t BLOCK_TFR_DONE_INTSTAT : 1;
    ///< Block Transfer Done. This indicates to the software that the DW_axi_dmac
    ///< has completed the requested block transfer. The DW_axi_dmac sets this
    ///< bit to 1 when the transfer is successfully completed.  - 0: Block
    ///< Transfer not completed.  - 1: Block Transfer completed. This bit is
    ///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
    ///< bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint64_t DMA_TFR_DONE_INTSTAT : 1;
    ///< DMA Transfer Done. This indicates to the software that the DW_axi_dmac
    ///< has completed the requested DMA transfer. The DW_axi_dmac sets this
    ///< bit to 1 along with setting CHx_INTSTATUS.BLOCK_TFR_DONE bit to 1
    ///< when the last block transfer is completed.  - 0: DMA Transfer not
    ///< completed.  - 1: DMA Transfer Completed  This bit is cleared to 0
    ///< on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_2 : 1;
    ///< DMAC Channelx Specific Interrupt Register (bit 2) Reserved bit - Read
    ///< Only
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint64_t SRC_TRANSCOMP_INTSTAT : 1;
    ///< Source Transaction Completed.      This bit is cleared to 0 on writing
    ///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register or on enabling the channel (needed when interrupt is not
    ///< enabled.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint64_t DST_TRANSCOMP_INTSTAT : 1;
    ///< Destination Transaction Completed.      This bit is cleared to 0 on
    ///< writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register or on enabling the channel (needed when interrupt is not
    ///< enabled.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint64_t SRC_DEC_ERR_INTSTAT : 1;
    ///< Source Decode Error. Decode Error detected by Manager Interface during
    ///< source data transfer. This error occurs if the access is to invalid
    ///< address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
    ///< channel which received the error is set to 0.  - 0: No Source Decode
    ///< Errors.  - 1: Source Decode Error detected. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint64_t DST_DEC_ERR_INTSTAT : 1;
    ///< Destination Decode Error. Decode Error detected by Manager Interface
    ///< during destination data transfer. This error occurs if the access
    ///< is to invalid address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
    ///< channel which received the error is set to 0.  - 0: No destination
    ///< Decode Errors.  - 1: Destination Decode Error Detected This bit is
    ///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
    ///< bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint64_t SRC_SLV_ERR_INTSTAT : 1;
    ///< Source Subordinate Error. Subordinate Error detected by Manager Interface
    ///< during source data transfer. This error occurs if the register bus
    ///< interface from which the data is read issues a Subordinate Error.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
    ///< channel which received the error is set to 0.   - 0: No Source Subordinate
    ///< Errors  - 1: Source Subordinate Error Detected  This bit is cleared
    ///< to 0 on writing 1 to the corresponding channel interrupt clear bit
    ///< in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint64_t DST_SLV_ERR_INTSTAT : 1;
    ///< Destination Subordinate Error. Subordinate Error detected by Manager
    ///< Interface during destination data transfer. This error occurs if the
    ///< register bus interface to which the data is written issues a Subordinate
    ///< Error. This error condition causes the DW_axi_dmac to disable the
    ///< corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding
    ///< to the channel which received the error is set to 0.  - 0: No Destination
    ///< Subordinate Errors  - 1: Destination Subordinate Errors Detected
    ///< This bit is cleared to 0 on writing 1 to the corresponding channel
    ///< interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint64_t LLI_RD_DEC_ERR_INTSTAT : 1;
    ///< LLI Read Decode Error. Decode Error detected by Manager Interface
    ///< during LLI read operation. This error occurs if the access is to invalid
    ///< address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
    ///< error is set to 0.  - 0: NO LLI Read Decode Errors.  - 1: LLI Read
    ///< Decode Error detected Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled.      This bit is cleared
    ///< to 0 on writing 1 to the corresponding channel interrupt clear bit
    ///< in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint64_t LLI_WR_DEC_ERR_INTSTAT : 1;
    ///< LLI WRITE Decode Error. Decode Error detected by Manager Interface
    ///< during LLI write-back operation. This error occurs if the access is
    ///< to invalid address and a Decode Error is returned from interconnect/subordinate.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
    ///< error is set to 0.  - 0: NO LLI Write Decode Errors.  - 1: LLI write
    ///< Decode Error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint64_t LLI_RD_SLV_ERR_INTSTAT : 1;
    ///< LLI Read Subordinate Error. Subordinate Error detected by Manager
    ///< Interface during LLI read operation. This error occurs if the register
    ///< bus interface on which LLI resides issues a Subordinate Error. This
    ///< error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
    ///< error is set to 0.  - 0: No LLI Read Subordinate Errors.  - 1: LLI
    ///< read Subordinate Error detected. Error Interrupt is generated if the
    ///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
    ///< is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint64_t LLI_WR_SLV_ERR_INTSTAT : 1;
    ///< LLI WRITE Subordinate Error. Subordinate Error detected by Manager
    ///< Interface during LLI write-back operation. This error occurs if the
    ///< register bus interface on which LLI resides issues a Subordinate Error.
    ///< This error condition causes the DW_axi_dmac to disable the corresponding
    ///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
    ///< error is set to 0.  - 0: No LLI write Subordinate Errors.  - 1: LLI
    ///< Write SUBORDINATE Error detected. Error Interrupt is generated if
    ///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint64_t SHADOWREG_OR_LLI_INVALID_ERR_INTSTAT : 1;
    ///< Shadow register or LLI Invalid Error. This error occurs if CHx_CTL.ShadowReg_Or_LLI_Valid
    ///< bit is seen to be 0 during DW_axi_dmac Shadow Register / LLI fetch
    ///< phase. This error condition causes the DW_axi_dmac to halt the corresponding
    ///< channel gracefully; Error Interrupt is generated if the corresponding
    ///< channel error interrupt mask bit is set to 0 and the channel waits
    ///< till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
    ///< valid Shadow Register availability. In the case of LLI pre-fetching,
    ///< ShadowReg_Or_LLI_Invalid_ERR Interrupt is not generated even if ShadowReg_Or_LLI_Valid
    ///< bit is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac
    ///< re-attempts the LLI fetch operation after completing the current block
    ///< transfer and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt only
    ///< if ShadowReg_Or_LLI_Valid bit is still seen to be 0.  - 0: No Shadow
    ///< Register / LLI Invalid errors.  - 1: Shadow Register / LLI Invalid
    ///< error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint64_t SLVIF_MULTIBLKTYPE_ERR_INTSTAT : 1;
    ///< Register Bus Interface Multi Block type Error. This error occurs if
    ///< multi-block transfer type programmed in CHx_CFG register (SRC_MLTBLK_TYPE
    ///< and DST_MLTBLK_TYPE) is invalid. This error condition causes the DW_axi_dmac
    ///< to halt the corresponding channel gracefully; Error Interrupt is generated
    ///< if the corresponding channel error interrupt mask bit is set to 0
    ///< and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg
    ///< to indicate valid multi-block transfer type availability.  - 0: No
    ///< Multi-block transfer type Errors.  - 1: Multi-block transfer type
    ///< Error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_15 : 1;
    ///< DMAC Channelx Specific Interrupt Register (bit 15) Reserved bit -
    ///< Read Only
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint64_t SLVIF_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Decode Error. Decode Error generated by DW_axi_dmac
    ///< during register access. This error occurs if the register access is
    ///< to invalid address in Channelx register space resulting in error response
    ///< by DW_axi_dmac register bus interface.  - 0: No Register Bus Interface
    ///< Decode errors.  - 1: Register Bus Interface Decode Error detected.
    ///< Error Interrupt is generated if the corresponding bit in CHxINTSTATUS_ENABLEReg
    ///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
    ///< channel interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint64_t SLVIF_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write to Read Only Error. This error occurs
    ///< if write operation is performed to a Read Only register.  - 0: No
    ///< Register Bus Interface Write to Read Only Errors.  - 1: Register Bus
    ///< Interface Write to Read Only Error detected. Error Interrupt is generated
    ///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint64_t SLVIF_RD2RWO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Read to write Only Error. This error occurs
    ///< if read operation is performed to a Write Only register.  - 0: No
    ///< Register Bus Interface Read to Write Only Errors.  - 1: Register Bus
    ///< Interface Read to Write Only Error detected. Error Interrupt is generated
    ///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint64_t SLVIF_WRONCHEN_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Channel Enabled Error. This error
    ///< occurs if an illegal write operation is performed on a register; this
    ///< happens if a write operation is performed on a register when the channel
    ///< is enabled and if it is not allowed for the corresponding register
    ///< as per the DW_axi_dmac specification.  - 0: No Register Bus Interface
    ///< Write On Channel Enabled Errors.  - 1: Register Bus Interface Write
    ///< On Channel Enabled Error detected. Error Interrupt is generated if
    ///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint64_t SLVIF_SHADOWREG_WRON_VALID_ERR_INTSTAT : 1;
    ///< Shadow Register Write On Valid Error. This error occurs if shadow
    ///< register based multi-block transfer is enabled and software tries
    ///< to write to the shadow register when CHx_CTL.ShadowReg_Or_LLI_Valid
    ///< bit is 1.  - 0: No Register Bus Interface Shadow Register Write On
    ///< Valid Errors.  - 1: Register Bus Interface Shadow Register Write On
    ///< Valid Error detected. Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint64_t SLVIF_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Hold Error. This error occurs if an
    ///< illegal write operation is performed on a register; this happens if
    ///< a write operation is performed on a channel register when DW_axi_dmac
    ///< is in Hold mode.  - 0: No Register Bus Interface Write On Hold Errors.
    ///< - 1: Register Bus Interface Write On Hold Error detected. Error Interrupt
    ///< is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is
    ///< enabled. This bit is cleared to 0 on writing 1 to the corresponding
    ///< channel interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_22TO23 : 2;
    ///< DMAC Channelx Specific Interrupt Register (bits 22to23) Reserved bits
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint64_t SLVIF_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Address Parity Error. This error occurs if
    ///< address is used to do write/read operation on a channel register;
    ///< But the Address fails the even/odd parity check.  - 0: No Register
    ///< Bus Interface Address Parity Errors.  - 1: Register Bus Interface
    ///< Address Parity Error detected. Error Interrupt is generated if the
    ///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
    ///< is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint64_t SLVIF_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write Parity Error. This error occurs if a
    ///< Write operation is performed on a channel register; But the Write
    ///< data fails the even/odd parity check.  - 0: No Register Bus Interface
    ///< Write Parity Errors.  - 1: Register Bus Interface Write Parity Error
    ///< detected. Error Interrupt is generated if the corresponding bit in
    ///< CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing
    ///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
    ///< register.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_26 : 1;
    ///< DMAC Channelx Specific Interrupt Register (bit 26) Reserved bit -
    ///< Read Only
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint64_t CH_LOCK_CLEARED_INTSTAT : 1;
    ///< Channel Lock Cleared. This indicates to the software that the locking
    ///< of the corresponding channel in DW_axi_dmac is cleared.  - 0: Channel
    ///< locking is not cleared.  - 1: Channel locking is cleared.  Channel
    ///< locking is cleared by DW_axi_dmac during the following situations:
    ///< - Channel locking is cleared and the channel locking settings in CHx_CFG
    ///< register is reset if DW_axi_dmac disables the channel upon request
    ///< from software.  - Channel locking is cleared and the channel locking
    ///< settings in CHx_CFG register is reset if DW_axi_dmac disables the
    ///< channel upon receiving error response on the manager interface.  This
    ///< bit is cleared to 0 on enabling the channel.
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint64_t CH_SRC_SUSPENDED_INTSTAT : 1;
    ///< Channel Source Suspended. This indicates to the software that the
    ///< corresponding channel source data transfer in DW_axi_dmac is suspended.
    ///< - 0: Channel source is not suspended  - 1: Channel Source is suspended.
    ///< Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg
    ///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
    ///< channel interrupt clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint64_t CH_SUSPENDED_INTSTAT : 1;
    ///< Channel Suspended. This indicates to the software that the corresponding
    ///< channel in DW_axi_dmac is suspended.  - 0: Channel is not suspended.
    ///< - 1: Channel is suspended.  Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint64_t CH_DISABLED_INTSTAT : 1;
    ///< Channel Disabled. This indicates to the software that the corresponding
    ///< channel in DW_axi_dmac is disabled.  - 0: Channel is not disabled.
    ///< - 1: Channel is disabled.     Error Interrupt is generated if the
    ///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.      This
    ///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
    ///< clear bit in CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint64_t CH_ABORTED_INTSTAT : 1;
    ///< Channel Terminated. This indicates to the software that the corresponding
    ///< channel in DW_axi_dmac is terminated.  - 0: Channel is not terminated
    ///< - 1: Channel is terminated  Error Interrupt is generated if the corresponding
    ///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
    ///< 0 on writing 1 to the corresponding channel interrupt clear bit in
    ///< CHx_IntClearReg register.
    ///< AccessType="RO/V" BitOffset="31" ResetValue="0x0"
    uint64_t ECC_PROT_CHMEM_CORRERR_INTSTAT : 1;
    ///< Channel x FIFO Memory Interface ECC Protection related Correctable
    ///< Error Interrupt Status bit.  This error occurs if ECC correctable
    ///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
    ///< x FIFO Memory Interface correctable Error.  - 1: Channel x FIFO Memory
    ///< Interface correctable Error detected.   Error Interrupt status is
    ///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="32" ResetValue="0x0"
    uint64_t ECC_PROT_CHMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x FIFO Memory Interface ECC Protection related Uncorrectable
    ///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
    ///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
    ///< x FIFO Memory Interface Uncorrectable Error.  - 1: Channel x FIFO
    ///< Memory Interface Uncorrectable Error detected.   Error Interrupt status
    ///< is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="33" ResetValue="0x0"
    uint64_t ECC_PROT_UIDMEM_CORRERR_INTSTAT : 1;
    ///< Channel x UID Memory Interface ECC Protection related Correctable
    ///< Error Interrupt Status bit.  This error occurs if ECC correctable
    ///< error is detected on the UID Memory Interface data.    - 0: No Channel
    ///< x UID Memory Interface correctable Error.  - 1: Channel x UID Memory
    ///< Interface correctable Error detected.   Error Interrupt status is
    ///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="34" ResetValue="0x0"
    uint64_t ECC_PROT_UIDMEM_UNCORRERR_INTSTAT : 1;
    ///< Channel x UID Memory Interface ECC Protection related Uncorrectable
    ///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
    ///< error is detected on the UID Memory Interface data.    - 0: No Channel
    ///< x UID Memory Interface Uncorrectable Error.  - 1: Channel x UID Memory
    ///< Interface Uncorrectable Error detected.   Error Interrupt status is
    ///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
    ///< register is set to 1. This bit is cleared to 0 on writing 1 to the
    ///< corresponding interrupt clear bit in CHx_IntClearReg.
    ///< AccessType="RO/V" BitOffset="35" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTSTATUSREG_36TO63 : 28;
    ///< DMAC Channelx Specific Interrupt Register (bits 36to63) Reserved bits
    ///< - Read Only
    ///< AccessType="RO/V" BitOffset="36" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_intstat_reg_t;

#define RCS_DMAC_CH2_INTSTAT_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_INTSTAT_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_INTSTAT_WR_MASK (0x0000000000000000ULL)


///< Block Transfer Done. This indicates to the software that the DW_axi_dmac
///< has completed the requested block transfer. The DW_axi_dmac sets this
///< bit to 1 when the transfer is successfully completed.  - 0: Block
///< Transfer not completed.  - 1: Block Transfer completed. This bit is
///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
///< bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CH2_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_INTSTAT_BLK_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMA Transfer Done. This indicates to the software that the DW_axi_dmac
///< has completed the requested DMA transfer. The DW_axi_dmac sets this
///< bit to 1 along with setting CHx_INTSTATUS.BLOCK_TFR_DONE bit to 1
///< when the last block transfer is completed.  - 0: DMA Transfer not
///< completed.  - 1: DMA Transfer Completed  This bit is cleared to 0
///< on writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register.
#define RCS_DMAC_CH2_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CH2_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CH2_INTSTAT_DMA_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bit 2) Reserved bit - Read
///< Only
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_2_BF_DEF (0x00000000)

///< Source Transaction Completed.      This bit is cleared to 0 on writing
///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register or on enabling the channel (needed when interrupt is not
///< enabled.
#define RCS_DMAC_CH2_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CH2_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CH2_INTSTAT_SRC_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Destination Transaction Completed.      This bit is cleared to 0 on
///< writing 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register or on enabling the channel (needed when interrupt is not
///< enabled.
#define RCS_DMAC_CH2_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_OFF ( 4)
#define RCS_DMAC_CH2_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_MSK (0x00000010)
#define RCS_DMAC_CH2_INTSTAT_DST_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Source Decode Error. Decode Error detected by Manager Interface during
///< source data transfer. This error occurs if the access is to invalid
///< address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
///< channel which received the error is set to 0.  - 0: No Source Decode
///< Errors.  - 1: Source Decode Error detected. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_OFF ( 5)
#define RCS_DMAC_CH2_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_MSK (0x00000020)
#define RCS_DMAC_CH2_INTSTAT_SRC_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Decode Error. Decode Error detected by Manager Interface
///< during destination data transfer. This error occurs if the access
///< is to invalid address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
///< channel which received the error is set to 0.  - 0: No destination
///< Decode Errors.  - 1: Destination Decode Error Detected This bit is
///< cleared to 0 on writing 1 to the corresponding channel interrupt clear
///< bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_DST_DEC_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CH2_INTSTAT_DST_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_DST_DEC_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CH2_INTSTAT_DST_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Source Subordinate Error. Subordinate Error detected by Manager Interface
///< during source data transfer. This error occurs if the register bus
///< interface from which the data is read issues a Subordinate Error.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding to the
///< channel which received the error is set to 0.   - 0: No Source Subordinate
///< Errors  - 1: Source Subordinate Error Detected  This bit is cleared
///< to 0 on writing 1 to the corresponding channel interrupt clear bit
///< in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CH2_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CH2_INTSTAT_SRC_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Subordinate Error. Subordinate Error detected by Manager
///< Interface during destination data transfer. This error occurs if the
///< register bus interface to which the data is written issues a Subordinate
///< Error. This error condition causes the DW_axi_dmac to disable the
///< corresponding channel gracefully; the DMAC_ChEnReg.CH_EN bit corresponding
///< to the channel which received the error is set to 0.  - 0: No Destination
///< Subordinate Errors  - 1: Destination Subordinate Errors Detected
///< This bit is cleared to 0 on writing 1 to the corresponding channel
///< interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_DST_SLV_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CH2_INTSTAT_DST_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_DST_SLV_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CH2_INTSTAT_DST_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Decode Error. Decode Error detected by Manager Interface
///< during LLI read operation. This error occurs if the access is to invalid
///< address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
///< error is set to 0.  - 0: NO LLI Read Decode Errors.  - 1: LLI Read
///< Decode Error detected Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled.      This bit is cleared
///< to 0 on writing 1 to the corresponding channel interrupt clear bit
///< in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Decode Error. Decode Error detected by Manager Interface
///< during LLI write-back operation. This error occurs if the access is
///< to invalid address and a Decode Error is returned from interconnect/subordinate.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
///< error is set to 0.  - 0: NO LLI Write Decode Errors.  - 1: LLI write
///< Decode Error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Subordinate Error. Subordinate Error detected by Manager
///< Interface during LLI read operation. This error occurs if the register
///< bus interface on which LLI resides issues a Subordinate Error. This
///< error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
///< error is set to 0.  - 0: No LLI Read Subordinate Errors.  - 1: LLI
///< read Subordinate Error detected. Error Interrupt is generated if the
///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
///< is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CH2_INTSTAT_LLI_RD_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Subordinate Error. Subordinate Error detected by Manager
///< Interface during LLI write-back operation. This error occurs if the
///< register bus interface on which LLI resides issues a Subordinate Error.
///< This error condition causes the DW_axi_dmac to disable the corresponding
///< channel gracefully; the DMAC_ChEnReg.CH_EN2 bit which received the
///< error is set to 0.  - 0: No LLI write Subordinate Errors.  - 1: LLI
///< Write SUBORDINATE Error detected. Error Interrupt is generated if
///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CH2_INTSTAT_LLI_WR_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow register or LLI Invalid Error. This error occurs if CHx_CTL.ShadowReg_Or_LLI_Valid
///< bit is seen to be 0 during DW_axi_dmac Shadow Register / LLI fetch
///< phase. This error condition causes the DW_axi_dmac to halt the corresponding
///< channel gracefully; Error Interrupt is generated if the corresponding
///< channel error interrupt mask bit is set to 0 and the channel waits
///< till software writes (any value) to CHx_BLK_TFR_ResumeReqReg to indicate
///< valid Shadow Register availability. In the case of LLI pre-fetching,
///< ShadowReg_Or_LLI_Invalid_ERR Interrupt is not generated even if ShadowReg_Or_LLI_Valid
///< bit is seen to be 0 for the pre-fetched LLI. In this case, DW_axi_dmac
///< re-attempts the LLI fetch operation after completing the current block
///< transfer and generates ShadowReg_Or_LLI_Invalid_ERR Interrupt only
///< if ShadowReg_Or_LLI_Valid bit is still seen to be 0.  - 0: No Shadow
///< Register / LLI Invalid errors.  - 1: Shadow Register / LLI Invalid
///< error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CH2_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CH2_INTSTAT_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Multi Block type Error. This error occurs if
///< multi-block transfer type programmed in CHx_CFG register (SRC_MLTBLK_TYPE
///< and DST_MLTBLK_TYPE) is invalid. This error condition causes the DW_axi_dmac
///< to halt the corresponding channel gracefully; Error Interrupt is generated
///< if the corresponding channel error interrupt mask bit is set to 0
///< and the channel waits till software writes (any value) to CHx_BLK_TFR_ResumeReqReg
///< to indicate valid multi-block transfer type availability.  - 0: No
///< Multi-block transfer type Errors.  - 1: Multi-block transfer type
///< Error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bit 15) Reserved bit -
///< Read Only
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_OFF (15)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_15_BF_DEF (0x00000000)

///< Register Bus Interface Decode Error. Decode Error generated by DW_axi_dmac
///< during register access. This error occurs if the register access is
///< to invalid address in Channelx register space resulting in error response
///< by DW_axi_dmac register bus interface.  - 0: No Register Bus Interface
///< Decode errors.  - 1: Register Bus Interface Decode Error detected.
///< Error Interrupt is generated if the corresponding bit in CHxINTSTATUS_ENABLEReg
///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
///< channel interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write to Read Only Error. This error occurs
///< if write operation is performed to a Read Only register.  - 0: No
///< Register Bus Interface Write to Read Only Errors.  - 1: Register Bus
///< Interface Write to Read Only Error detected. Error Interrupt is generated
///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WR2RO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Read to write Only Error. This error occurs
///< if read operation is performed to a Write Only register.  - 0: No
///< Register Bus Interface Read to Write Only Errors.  - 1: Register Bus
///< Interface Read to Write Only Error detected. Error Interrupt is generated
///< if the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_RD2RWO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Channel Enabled Error. This error
///< occurs if an illegal write operation is performed on a register; this
///< happens if a write operation is performed on a register when the channel
///< is enabled and if it is not allowed for the corresponding register
///< as per the DW_axi_dmac specification.  - 0: No Register Bus Interface
///< Write On Channel Enabled Errors.  - 1: Register Bus Interface Write
///< On Channel Enabled Error detected. Error Interrupt is generated if
///< the corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONCHEN_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow Register Write On Valid Error. This error occurs if shadow
///< register based multi-block transfer is enabled and software tries
///< to write to the shadow register when CHx_CTL.ShadowReg_Or_LLI_Valid
///< bit is 1.  - 0: No Register Bus Interface Shadow Register Write On
///< Valid Errors.  - 1: Register Bus Interface Shadow Register Write On
///< Valid Error detected. Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Hold Error. This error occurs if an
///< illegal write operation is performed on a register; this happens if
///< a write operation is performed on a channel register when DW_axi_dmac
///< is in Hold mode.  - 0: No Register Bus Interface Write On Hold Errors.
///< - 1: Register Bus Interface Write On Hold Error detected. Error Interrupt
///< is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg is
///< enabled. This bit is cleared to 0 on writing 1 to the corresponding
///< channel interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bits 22to23) Reserved bits
///< - Read Only
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_22TO23_BF_DEF (0x00000000)

///< Register Bus Interface Address Parity Error. This error occurs if
///< address is used to do write/read operation on a channel register;
///< But the Address fails the even/odd parity check.  - 0: No Register
///< Bus Interface Address Parity Errors.  - 1: Register Bus Interface
///< Address Parity Error detected. Error Interrupt is generated if the
///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit
///< is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write Parity Error. This error occurs if a
///< Write operation is performed on a channel register; But the Write
///< data fails the even/odd parity check.  - 0: No Register Bus Interface
///< Write Parity Errors.  - 1: Register Bus Interface Write Parity Error
///< detected. Error Interrupt is generated if the corresponding bit in
///< CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to 0 on writing
///< 1 to the corresponding channel interrupt clear bit in CHx_IntClearReg
///< register.
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CH2_INTSTAT_SLVIF_WRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bit 26) Reserved bit -
///< Read Only
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_OFF (26)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_26_BF_DEF (0x00000000)

///< Channel Lock Cleared. This indicates to the software that the locking
///< of the corresponding channel in DW_axi_dmac is cleared.  - 0: Channel
///< locking is not cleared.  - 1: Channel locking is cleared.  Channel
///< locking is cleared by DW_axi_dmac during the following situations:
///< - Channel locking is cleared and the channel locking settings in CHx_CFG
///< register is reset if DW_axi_dmac disables the channel upon request
///< from software.  - Channel locking is cleared and the channel locking
///< settings in CHx_CFG register is reset if DW_axi_dmac disables the
///< channel upon receiving error response on the manager interface.  This
///< bit is cleared to 0 on enabling the channel.
#define RCS_DMAC_CH2_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CH2_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CH2_INTSTAT_CH_LOCK_CLRED_INTSTAT_BF_DEF (0x00000000)

///< Channel Source Suspended. This indicates to the software that the
///< corresponding channel source data transfer in DW_axi_dmac is suspended.
///< - 0: Channel source is not suspended  - 1: Channel Source is suspended.
///< Error Interrupt is generated if the corresponding bit in CHx_INTSTATUS_ENABLEReg
///< is enabled. This bit is cleared to 0 on writing 1 to the corresponding
///< channel interrupt clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CH2_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CH2_INTSTAT_CH_SRC_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Suspended. This indicates to the software that the corresponding
///< channel in DW_axi_dmac is suspended.  - 0: Channel is not suspended.
///< - 1: Channel is suspended.  Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_CH_SUSPENDED_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CH2_INTSTAT_CH_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_CH_SUSPENDED_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CH2_INTSTAT_CH_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Disabled. This indicates to the software that the corresponding
///< channel in DW_axi_dmac is disabled.  - 0: Channel is not disabled.
///< - 1: Channel is disabled.     Error Interrupt is generated if the
///< corresponding bit in CHx_INTSTATUS_ENABLEReg is enabled.      This
///< bit is cleared to 0 on writing 1 to the corresponding channel interrupt
///< clear bit in CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_CH_DISD_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CH2_INTSTAT_CH_DISD_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_CH_DISD_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CH2_INTSTAT_CH_DISD_INTSTAT_BF_DEF (0x00000000)

///< Channel Terminated. This indicates to the software that the corresponding
///< channel in DW_axi_dmac is terminated.  - 0: Channel is not terminated
///< - 1: Channel is terminated  Error Interrupt is generated if the corresponding
///< bit in CHx_INTSTATUS_ENABLEReg is enabled. This bit is cleared to
///< 0 on writing 1 to the corresponding channel interrupt clear bit in
///< CHx_IntClearReg register.
#define RCS_DMAC_CH2_INTSTAT_CH_ABORTED_INTSTAT_BF_OFF (31)
#define RCS_DMAC_CH2_INTSTAT_CH_ABORTED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_CH_ABORTED_INTSTAT_BF_MSK (0x80000000)
#define RCS_DMAC_CH2_INTSTAT_CH_ABORTED_INTSTAT_BF_DEF (0x00000000)

///< Channel x FIFO Memory Interface ECC Protection related Correctable
///< Error Interrupt Status bit.  This error occurs if ECC correctable
///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
///< x FIFO Memory Interface correctable Error.  - 1: Channel x FIFO Memory
///< Interface correctable Error detected.   Error Interrupt status is
///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_OFF (32)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_MSK (0x100000000)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< Channel x FIFO Memory Interface ECC Protection related Uncorrectable
///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
///< error is detected on the FIFO Memory Interface data.    - 0: No Channel
///< x FIFO Memory Interface Uncorrectable Error.  - 1: Channel x FIFO
///< Memory Interface Uncorrectable Error detected.   Error Interrupt status
///< is generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_OFF (33)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_MSK (0x200000000)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< Channel x UID Memory Interface ECC Protection related Correctable
///< Error Interrupt Status bit.  This error occurs if ECC correctable
///< error is detected on the UID Memory Interface data.    - 0: No Channel
///< x UID Memory Interface correctable Error.  - 1: Channel x UID Memory
///< Interface correctable Error detected.   Error Interrupt status is
///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_OFF (34)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_MSK (0x400000000)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< Channel x UID Memory Interface ECC Protection related Uncorrectable
///< Error Interrupt Status bit.  This error occurs if ECC Uncorrectable
///< error is detected on the UID Memory Interface data.    - 0: No Channel
///< x UID Memory Interface Uncorrectable Error.  - 1: Channel x UID Memory
///< Interface Uncorrectable Error detected.   Error Interrupt status is
///< generated if the corresponding Status Enable bit in CHx_INTSTATUS_ENABLEReg
///< register is set to 1. This bit is cleared to 0 on writing 1 to the
///< corresponding interrupt clear bit in CHx_IntClearReg.
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_OFF (35)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_MSK (0x800000000)
#define RCS_DMAC_CH2_INTSTAT_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Specific Interrupt Register (bits 36to63) Reserved bits
///< - Read Only
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_OFF (36)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_WID (28)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH2_INTSTAT_RSVD_DMAC_CHX_INTSTATREG_36TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_INTSIGNAL_ENABLEREG register description at address offset 0x290
  *
  * Register default value:        0xFFFFFFFFFFFFFFFF
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_INTSIGNAL_ENABLEREG
  * DW_axi_dmac Channel $i Interrupt Signal Enable Register
  */

typedef union {
  struct {
    uint64_t ENABLE_BLOCK_TFR_DONE_INTSIGNAL : 1;
    ///< Block Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
    ///< of Block Transfer Done Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Block Transfer Done Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint64_t ENABLE_DMA_TFR_DONE_INTSIGNAL : 1;
    ///< DMA Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
    ///< of DMA Transfer Done Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of DMA Transfer Done Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_2 : 1;
    ///< DMAC Channelx Interrupt Status Enable Register (bit 2) Reserved bit
    ///< - Read Only
    ///< AccessType="RO" BitOffset="2" ResetValue="0x1"
    uint64_t ENABLE_SRC_TRANSCOMP_INTSIGNAL : 1;
    ///< Source Transaction Completed Signal Enable.  - 0: Disable the propagation
    ///< of Source Transaction Complete Interrupt to generate a port level
    ///< interrupt  - 1: Enable the propagation of Source Transaction Complete
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint64_t ENABLE_DST_TRANSCOMP_INTSIGNAL : 1;
    ///< Destination Transaction Completed Signal Enable.  - 0: Disable the
    ///< propagation of Destination Transaction complete Interrupt to generate
    ///< a port level interrupt  - 1: Enable the propagation of Destination
    ///< Transaction complete Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint64_t ENABLE_SRC_DEC_ERR_INTSIGNAL : 1;
    ///< Source Decode Error Signal Enable.  - 0: Disable the propagation of
    ///< Source Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Source Decode Error Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint64_t ENABLE_DST_DEC_ERR_INTSIGNAL : 1;
    ///< Destination Decode Error Signal Enable.  - 0: Disable the propagation
    ///< of Destination Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Destination Decode Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint64_t ENABLE_SRC_SLV_ERR_INTSIGNAL : 1;
    ///< Source Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of Source Subordinate Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Source Subordinate Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint64_t ENABLE_DST_SLV_ERR_INTSIGNAL : 1;
    ///< Destination Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of Destination Subordinate Error Interrupt to generate a port level
    ///< interrupt  - 1: Enable the propagation of Destination Subordinate
    ///< Error Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_DEC_ERR_INTSIGNAL : 1;
    ///< LLI Read Decode Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI Read Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of LLI Read Decode Error Interrupt to
    ///< generate a port level interrupt
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_DEC_ERR_INTSIGNAL : 1;
    ///< LLI WRITE Decode Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI WRITE Decode Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of LLI WRITE Decode Error Interrupt to
    ///< generate a port level interrupt
    ///< AccessType="RW" BitOffset="10" ResetValue="0x1"
    uint64_t ENABLE_LLI_RD_SLV_ERR_INTSIGNAL : 1;
    ///< LLI Read Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI Read Subordinate Error Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of LLI Read Subordinate Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="11" ResetValue="0x1"
    uint64_t ENABLE_LLI_WR_SLV_ERR_INTSIGNAL : 1;
    ///< LLI WRITE Subordinate Error Signal Enable.  - 0: Disable the propagation
    ///< of LLI WRITE Subordinate Error Interrupt to generate a port level
    ///< interrupt  - 1: Enable the propagation of LLI WRITE Subordinate Error
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint64_t ENABLE_SHADOWREG_OR_LLI_INVALID_ERR_INTSIGNAL : 1;
    ///< Shadow register or LLI Invalid Error Signal Enable.  - 0: Disable
    ///< the propagation of Shadow Register or LLI Invalid Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Shadow Register or LLI Invalid  Error Interrupt to generate a port
    ///< level interrupt
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Multi Block type Error Signal Enable.  - 0:
    ///< Disable the propagation of Register Bus Interface Multi Block type
    ///< Error Interrupt to generate a port level interrupt  - 1: Enable the
    ///< propagation of Register Bus Interface Multi Block type Error Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSTATUS_ENABLEREG_15 : 1;
    ///< DMAC Channelx Interrupt Status Enable Register (bit 15) Reserved bit
    ///< - Read Only
    ///< AccessType="RO" BitOffset="15" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_DEC_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Decode Error Signal Enable.  - 0: Disable the
    ///< propagation of Register Bus Interface Decode Error Interrupt to generate
    ///< a port level interrupt  - 1: Enable the propagation of Register Bus
    ///< Interface Decode Error Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WR2RO_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write to Read Only Error Signal Enable.  -
    ///< 0: Disable the propagation of Register Bus Interface Write to Read
    ///< only Error Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Register Bus Interface Write to Read Only Error
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_RD2RWO_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Read to write Only Error Signal Enable.  -
    ///< 0: Disable the propagation of Register Bus Interface Read to Write
    ///< only Error Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Register Bus Interface Read to Write Only Error
    ///< Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONCHEN_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write On Channel Enabled Error Signal Enable.
    ///< - 0: Disable the propagation of Register Bus Interface Write On Channel
    ///< enabled Error Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Register Bus Interface Write On Channel enabled
    ///< Error Interrupt to generate a port level interrupt
    ///< AccessType="RW" BitOffset="19" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_SHADOWREG_WRON_VALID_ERR_INTSIGNAL : 1;
    ///< Shadow Register Write On Valid Error Signal Enable.  - 0: Disable
    ///< the propagation of Shadow Register Write On Valid Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Shadow register Write On Valid Error Interrupt to generate a port
    ///< level interrupt
    ///< AccessType="RW" BitOffset="20" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRONHOLD_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write On Hold Error Signal Enable.  - 0: Disable
    ///< the propagation of Register Bus Interface Write On Hold Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Register Bus Interface Write On Hold Error Interrupt to generate a
    ///< port level interrupt
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSIGNAL_ENABLEREG_22TO23 : 2;
    ///< DMAC Channelx Interrupt Signal Enable Register (bits 22to23) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="22" ResetValue="0x3"
    uint64_t ENABLE_SLVIF_ADDRPARITY_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Address Parity Error Signal Enable.  - 0: Disable
    ///< the propagation of Register Bus Interface Address Parity Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Register Bus Interface Address Parity Error Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RO" BitOffset="24" ResetValue="0x1"
    uint64_t ENABLE_SLVIF_WRPARITY_ERR_INTSIGNAL : 1;
    ///< Register Bus Interface Write Parity Error Signal Enable.  - 0: Disable
    ///< the propagation of Register Bus Interface Write Parity Error Interrupt
    ///< to generate a port level interrupt  - 1: Enable the propagation of
    ///< Register Bus Interface Write Parity Error Interrupt to generate a
    ///< port level interrupt
    ///< AccessType="RO" BitOffset="25" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSIGNAL_ENABLEREG_26 : 1;
    ///< DMAC Channelx Interrupt Signal Enable Register (bit 26) Reserved bit
    ///< - Read Only
    ///< AccessType="RO" BitOffset="26" ResetValue="0x1"
    uint64_t ENABLE_CH_LOCK_CLEARED_INTSIGNAL : 1;
    ///< Channel Lock Cleared Signal Enable.  - 0: Disable the propagation
    ///< of Channel Lock Cleared Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Channel Lock Cleared Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint64_t ENABLE_CH_SRC_SUSPENDED_INTSIGNAL : 1;
    ///< Channel Source Suspended Signal Enable.  - 0: Disable the propagation
    ///< of Channel Source Suspended Interrupt to generate a port level interrupt
    ///< - 1: Enable the propagation of Channel Source Suspended Interrupt
    ///< to generate a port level interrupt
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint64_t ENABLE_CH_SUSPENDED_INTSIGNAL : 1;
    ///< Channel Suspended Signal Enable.  - 0: Disable the propagation of
    ///< Channel Suspended Interrupt to generate a port level interrupt  -
    ///< 1: Enable the propagation of Channel Suspended Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="29" ResetValue="0x1"
    uint64_t ENABLE_CH_DISABLED_INTSIGNAL : 1;
    ///< Channel Disabled Signal Enable.  - 0: Disable the propagation of Channel
    ///< Disabled Interrupt to generate a port level interrupt  - 1: Enable
    ///< the propagation of Channel Disabled Interrupt to generate a port level
    ///< interrupt
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint64_t ENABLE_CH_ABORTED_INTSIGNAL : 1;
    ///< Channel Terminated Signal Enable.  - 0: Disable the propagation of
    ///< Channel Terminated Interrupt to generate a port level interrupt  -
    ///< 1: Enable the propagation of Channel Terminated Interrupt to generate
    ///< a port level interrupt
    ///< AccessType="RW" BitOffset="31" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_CORRERR_INTSIGNAL : 1;
    ///< Channel x Channel Memory Interface ECC Protection Correctable Error
    ///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x Channel Memory Interface Correctable Error to generate a port level
    ///< interrupt.  - 1: Enable the propagation of Channel x Channel Memory
    ///< Interface Correctable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="32" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL : 1;
    ///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
    ///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x Channel Memory Interface Uncorrectable Error to generate a port
    ///< level interrupt.  - 1: Enable the propagation of Channel x Channel
    ///< Memory Interface Uncorrectable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="33" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
    ///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x UID Memory Interface Correctable Error to generate a port level
    ///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
    ///< Correctable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="34" ResetValue="0x1"
    uint64_t ENABLE_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL : 1;
    ///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
    ///< Error Interrupt Signal enable.  - 0: Disable the propagation of Channel
    ///< x UID Memory Interface Uncorrectable Error to generate a port level
    ///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
    ///< Uncorrectable Error to generate a port level interrupt.
    ///< AccessType="RO" BitOffset="35" ResetValue="0x1"
    uint64_t RSVD_DMAC_CHX_INTSIGNAL_ENABLEREG_36TO63 : 28;
    ///< DMAC Channelx Interrupt Signal Enable Register (bits 36to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="36" ResetValue="0xFFFFFFF"
  } ;
  uint64_t value;
} rcs_dmac_ch2_intsignal_enreg_reg_t;

#define RCS_DMAC_CH2_INTSIGNAL_ENREG_DEFAULT (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_WR_MASK (0x00000000f83f7ffbULL)


///< Block Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
///< of Block Transfer Done Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Block Transfer Done Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_OFF ( 0)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_BLK_TFR_DONE_INTSIGNAL_BF_DEF (0x00000001)

///< DMA Transfer Done Interrupt Signal Enable.  - 0: Disable the propagation
///< of DMA Transfer Done Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of DMA Transfer Done Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_OFF ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_MSK (0x00000002)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DMA_TFR_DONE_INTSIGNAL_BF_DEF (0x00000002)

///< DMAC Channelx Interrupt Status Enable Register (bit 2) Reserved bit
///< - Read Only
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_2_BF_DEF (0x00000004)

///< Source Transaction Completed Signal Enable.  - 0: Disable the propagation
///< of Source Transaction Complete Interrupt to generate a port level
///< interrupt  - 1: Enable the propagation of Source Transaction Complete
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_OFF ( 3)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_MSK (0x00000008)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_TRANSCOMP_INTSIGNAL_BF_DEF (0x00000008)

///< Destination Transaction Completed Signal Enable.  - 0: Disable the
///< propagation of Destination Transaction complete Interrupt to generate
///< a port level interrupt  - 1: Enable the propagation of Destination
///< Transaction complete Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_OFF ( 4)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_MSK (0x00000010)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_TRANSCOMP_INTSIGNAL_BF_DEF (0x00000010)

///< Source Decode Error Signal Enable.  - 0: Disable the propagation of
///< Source Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Source Decode Error Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_OFF ( 5)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_MSK (0x00000020)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_DEC_ERR_INTSIGNAL_BF_DEF (0x00000020)

///< Destination Decode Error Signal Enable.  - 0: Disable the propagation
///< of Destination Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Destination Decode Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_OFF ( 6)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_MSK (0x00000040)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_DEC_ERR_INTSIGNAL_BF_DEF (0x00000040)

///< Source Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of Source Subordinate Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Source Subordinate Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_OFF ( 7)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_MSK (0x00000080)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SRC_SLV_ERR_INTSIGNAL_BF_DEF (0x00000080)

///< Destination Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of Destination Subordinate Error Interrupt to generate a port level
///< interrupt  - 1: Enable the propagation of Destination Subordinate
///< Error Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_OFF ( 8)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_MSK (0x00000100)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_DST_SLV_ERR_INTSIGNAL_BF_DEF (0x00000100)

///< LLI Read Decode Error Signal Enable.  - 0: Disable the propagation
///< of LLI Read Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of LLI Read Decode Error Interrupt to
///< generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_OFF ( 9)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_MSK (0x00000200)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_DEC_ERR_INTSIGNAL_BF_DEF (0x00000200)

///< LLI WRITE Decode Error Signal Enable.  - 0: Disable the propagation
///< of LLI WRITE Decode Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of LLI WRITE Decode Error Interrupt to
///< generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_OFF (10)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_MSK (0x00000400)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_DEC_ERR_INTSIGNAL_BF_DEF (0x00000400)

///< LLI Read Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of LLI Read Subordinate Error Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of LLI Read Subordinate Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_OFF (11)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_MSK (0x00000800)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_RD_SLV_ERR_INTSIGNAL_BF_DEF (0x00000800)

///< LLI WRITE Subordinate Error Signal Enable.  - 0: Disable the propagation
///< of LLI WRITE Subordinate Error Interrupt to generate a port level
///< interrupt  - 1: Enable the propagation of LLI WRITE Subordinate Error
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_OFF (12)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_MSK (0x00001000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_LLI_WR_SLV_ERR_INTSIGNAL_BF_DEF (0x00001000)

///< Shadow register or LLI Invalid Error Signal Enable.  - 0: Disable
///< the propagation of Shadow Register or LLI Invalid Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Shadow Register or LLI Invalid  Error Interrupt to generate a port
///< level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_OFF (13)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_MSK (0x00002000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SHDWREG_OR_LLI_INVALID_ERR_INTSIGNAL_BF_DEF (0x00002000)

///< Register Bus Interface Multi Block type Error Signal Enable.  - 0:
///< Disable the propagation of Register Bus Interface Multi Block type
///< Error Interrupt to generate a port level interrupt  - 1: Enable the
///< propagation of Register Bus Interface Multi Block type Error Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_OFF (14)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_MSK (0x00004000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_MULTIBLKTYPE_ERR_INTSIGNAL_BF_DEF (0x00004000)

///< DMAC Channelx Interrupt Status Enable Register (bit 15) Reserved bit
///< - Read Only
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_OFF (15)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSTAT_ENREG_15_BF_DEF (0x00008000)

///< Register Bus Interface Decode Error Signal Enable.  - 0: Disable the
///< propagation of Register Bus Interface Decode Error Interrupt to generate
///< a port level interrupt  - 1: Enable the propagation of Register Bus
///< Interface Decode Error Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_OFF (16)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_MSK (0x00010000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_DEC_ERR_INTSIGNAL_BF_DEF (0x00010000)

///< Register Bus Interface Write to Read Only Error Signal Enable.  -
///< 0: Disable the propagation of Register Bus Interface Write to Read
///< only Error Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Register Bus Interface Write to Read Only Error
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_OFF (17)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_MSK (0x00020000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WR2RO_ERR_INTSIGNAL_BF_DEF (0x00020000)

///< Register Bus Interface Read to write Only Error Signal Enable.  -
///< 0: Disable the propagation of Register Bus Interface Read to Write
///< only Error Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Register Bus Interface Read to Write Only Error
///< Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_OFF (18)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_MSK (0x00040000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_RD2RWO_ERR_INTSIGNAL_BF_DEF (0x00040000)

///< Register Bus Interface Write On Channel Enabled Error Signal Enable.
///< - 0: Disable the propagation of Register Bus Interface Write On Channel
///< enabled Error Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Register Bus Interface Write On Channel enabled
///< Error Interrupt to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_OFF (19)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_MSK (0x00080000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONCHEN_ERR_INTSIGNAL_BF_DEF (0x00080000)

///< Shadow Register Write On Valid Error Signal Enable.  - 0: Disable
///< the propagation of Shadow Register Write On Valid Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Shadow register Write On Valid Error Interrupt to generate a port
///< level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_OFF (20)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_MSK (0x00100000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_SHDWREG_WRON_VALID_ERR_INTSIGNAL_BF_DEF (0x00100000)

///< Register Bus Interface Write On Hold Error Signal Enable.  - 0: Disable
///< the propagation of Register Bus Interface Write On Hold Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Register Bus Interface Write On Hold Error Interrupt to generate a
///< port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_OFF (21)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_MSK (0x00200000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRONHOLD_ERR_INTSIGNAL_BF_DEF (0x00200000)

///< DMAC Channelx Interrupt Signal Enable Register (bits 22to23) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_22TO23_BF_DEF (0x00C00000)

///< Register Bus Interface Address Parity Error Signal Enable.  - 0: Disable
///< the propagation of Register Bus Interface Address Parity Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Register Bus Interface Address Parity Error Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_OFF (24)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_MSK (0x01000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_ADDRPARITY_ERR_INTSIGNAL_BF_DEF (0x01000000)

///< Register Bus Interface Write Parity Error Signal Enable.  - 0: Disable
///< the propagation of Register Bus Interface Write Parity Error Interrupt
///< to generate a port level interrupt  - 1: Enable the propagation of
///< Register Bus Interface Write Parity Error Interrupt to generate a
///< port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_OFF (25)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_MSK (0x02000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_SLVIF_WRPARITY_ERR_INTSIGNAL_BF_DEF (0x02000000)

///< DMAC Channelx Interrupt Signal Enable Register (bit 26) Reserved bit
///< - Read Only
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_OFF (26)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_26_BF_DEF (0x04000000)

///< Channel Lock Cleared Signal Enable.  - 0: Disable the propagation
///< of Channel Lock Cleared Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Channel Lock Cleared Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_OFF (27)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_MSK (0x08000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_LOCK_CLRED_INTSIGNAL_BF_DEF (0x08000000)

///< Channel Source Suspended Signal Enable.  - 0: Disable the propagation
///< of Channel Source Suspended Interrupt to generate a port level interrupt
///< - 1: Enable the propagation of Channel Source Suspended Interrupt
///< to generate a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_OFF (28)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_MSK (0x10000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SRC_SUSPENDED_INTSIGNAL_BF_DEF (0x10000000)

///< Channel Suspended Signal Enable.  - 0: Disable the propagation of
///< Channel Suspended Interrupt to generate a port level interrupt  -
///< 1: Enable the propagation of Channel Suspended Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_OFF (29)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_MSK (0x20000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_SUSPENDED_INTSIGNAL_BF_DEF (0x20000000)

///< Channel Disabled Signal Enable.  - 0: Disable the propagation of Channel
///< Disabled Interrupt to generate a port level interrupt  - 1: Enable
///< the propagation of Channel Disabled Interrupt to generate a port level
///< interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_OFF (30)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_MSK (0x40000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_DISD_INTSIGNAL_BF_DEF (0x40000000)

///< Channel Terminated Signal Enable.  - 0: Disable the propagation of
///< Channel Terminated Interrupt to generate a port level interrupt  -
///< 1: Enable the propagation of Channel Terminated Interrupt to generate
///< a port level interrupt
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_OFF (31)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_MSK (0x80000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_CH_ABORTED_INTSIGNAL_BF_DEF (0x80000000)

///< Channel x Channel Memory Interface ECC Protection Correctable Error
///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x Channel Memory Interface Correctable Error to generate a port level
///< interrupt.  - 1: Enable the propagation of Channel x Channel Memory
///< Interface Correctable Error to generate a port level interrupt.
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_OFF (32)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_MSK (0x100000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_CORRERR_INTSIGNAL_BF_DEF (0x100000000)

///< Channel x Channel Memory Interface ECC Protection Uncorrectable Error
///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x Channel Memory Interface Uncorrectable Error to generate a port
///< level interrupt.  - 1: Enable the propagation of Channel x Channel
///< Memory Interface Uncorrectable Error to generate a port level interrupt.
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_OFF (33)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_MSK (0x200000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_CHMEM_UNCORRERR_INTSIGNAL_BF_DEF (0x200000000)

///< Channel x Unique ID Memory Interface ECC Protection Correctable Error
///< Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x UID Memory Interface Correctable Error to generate a port level
///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
///< Correctable Error to generate a port level interrupt.
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_OFF (34)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_MSK (0x400000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_CORRERR_INTSIGNAL_BF_DEF (0x400000000)

///< Channel x Unique ID Memory Interface ECC Protection Uncorrectable
///< Error Interrupt Signal enable.  - 0: Disable the propagation of Channel
///< x UID Memory Interface Uncorrectable Error to generate a port level
///< interrupt.  - 1: Enable the propagation of Channel x UID Memory Interface
///< Uncorrectable Error to generate a port level interrupt.
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_OFF (35)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_WID ( 1)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_MSK (0x800000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_EN_ECC_PROT_UIDMEM_UNCORRERR_INTSIGNAL_BF_DEF (0x800000000)

///< DMAC Channelx Interrupt Signal Enable Register (bits 36to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_OFF (36)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_WID (28)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_RSVD_DMAC_CHX_INTSIGNAL_ENREG_36TO63_BF_DEF (0xFFFFFFF000000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_INTCLEARREG register description at address offset 0x298
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_INTCLEARREG
  * DW_axi_dmac Channel $i Interrupt Status Clear Register
  */

typedef union {
  struct {
    uint64_t CLEAR_BLOCK_TFR_DONE_INTSTAT : 1;
    ///< Block Transfer Done Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CH2_INTSTATUSREG
    ///< AccessType="WS" BitOffset="0" ResetValue="0x0"
    uint64_t CLEAR_DMA_TFR_DONE_INTSTAT : 1;
    ///< DMA Transfer Done Interrupt Clear Bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="1" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_2 : 1;
    ///< DMAC Channelx Interrupt Clear Register (bit 2) Reserved bit - Write
    ///< Only
    ///< AccessType="WS" BitOffset="2" ResetValue="0x0"
    uint64_t CLEAR_SRC_TRANSCOMP_INTSTAT : 1;
    ///< Source Transaction Completed Interrupt Clear Bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="3" ResetValue="0x0"
    uint64_t CLEAR_DST_TRANSCOMP_INTSTAT : 1;
    ///< Destination Transaction Completed Interrupt Clear Bit. This bit is
    ///< used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="4" ResetValue="0x0"
    uint64_t CLEAR_SRC_DEC_ERR_INTSTAT : 1;
    ///< Source Decode Error Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="5" ResetValue="0x0"
    uint64_t CLEAR_DST_DEC_ERR_INTSTAT : 1;
    ///< Destination Decode Error Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="6" ResetValue="0x0"
    uint64_t CLEAR_SRC_SLV_ERR_INTSTAT : 1;
    ///< Source Subordinate Error Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="7" ResetValue="0x0"
    uint64_t CLEAR_DST_SLV_ERR_INTSTAT : 1;
    ///< Destination Subordinate Error Interrupt Clear Bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="8" ResetValue="0x0"
    uint64_t CLEAR_LLI_RD_DEC_ERR_INTSTAT : 1;
    ///< LLI Read Decode Error Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="9" ResetValue="0x0"
    uint64_t CLEAR_LLI_WR_DEC_ERR_INTSTAT : 1;
    ///< LLI WRITE Decode Error Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="10" ResetValue="0x0"
    uint64_t CLEAR_LLI_RD_SLV_ERR_INTSTAT : 1;
    ///< LLI Read Subordinate Error Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="11" ResetValue="0x0"
    uint64_t CLEAR_LLI_WR_SLV_ERR_INTSTAT : 1;
    ///< LLI WRITE Subordinate Error Interrupt Clear Bit. This bit is used
    ///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="12" ResetValue="0x0"
    uint64_t CLEAR_SHADOWREG_OR_LLI_INVALID_ERR_INTSTAT : 1;
    ///< Shadow register or LLI Invalid Error Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="13" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT : 1;
    ///< Register Bus Interface Multi Block type Error Interrupt Clear Bit.
    ///< This bit is used to clear the corresponding channel interrupt status
    ///< bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="14" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_15 : 1;
    ///< DMAC Channelx Interrupt Clear Register (bit 15) Reserved bit - Write
    ///< Only
    ///< AccessType="WS" BitOffset="15" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_DEC_ERR_INTSTAT : 1;
    ///< Register Bus Interface Decode Error Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="16" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WR2RO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write to Read Only Error Interrupt Clear Bit.
    ///< This bit is used to clear the corresponding channel interrupt status
    ///< bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="17" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_RD2RWO_ERR_INTSTAT : 1;
    ///< Register Bus Interface Read to write Only Error Interrupt Clear Bit.
    ///< This bit is used to clear the corresponding channel interrupt status
    ///< bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="18" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WRONCHEN_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Channel Enabled Error Interrupt Clear
    ///< Bit. This bit is used to clear the corresponding channel interrupt
    ///< status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="19" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_SHADOWREG_WRON_VALID_ERR_INTSTAT : 1;
    ///< Shadow Register Write On Valid Error Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="20" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WRONHOLD_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write On Hold Error Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="21" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_22TO23 : 2;
    ///< DMAC Channelx Interrupt Clear Register (bits 22to23) Reserved bit
    ///< - Write Only
    ///< AccessType="WS" BitOffset="22" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_ADDRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Address Parity Error Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="24" ResetValue="0x0"
    uint64_t CLEAR_SLVIF_WRPARITY_ERR_INTSTAT : 1;
    ///< Register Bus Interface Write Parity Error Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="25" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_26 : 1;
    ///< DMAC Channelx Interrupt Clear Register (bit 26) Reserved bit - Write
    ///< Only
    ///< AccessType="WS" BitOffset="26" ResetValue="0x0"
    uint64_t CLEAR_CH_LOCK_CLEARED_INTSTAT : 1;
    ///< Channel Lock Cleared Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="27" ResetValue="0x0"
    uint64_t CLEAR_CH_SRC_SUSPENDED_INTSTAT : 1;
    ///< Channel Source Suspended Interrupt Clear Bit. This bit is used to
    ///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="28" ResetValue="0x0"
    uint64_t CLEAR_CH_SUSPENDED_INTSTAT : 1;
    ///< Channel Suspended Interrupt Clear Bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="29" ResetValue="0x0"
    uint64_t CLEAR_CH_DISABLED_INTSTAT : 1;
    ///< Channel Disabled Interrupt Clear Bit. This bit is used to clear the
    ///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="30" ResetValue="0x0"
    uint64_t CLEAR_CH_ABORTED_INTSTAT : 1;
    ///< Channel Terminated Interrupt Clear Bit. This bit is used to clear
    ///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="31" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_CHMEM_CORRERR_INTSTAT : 1;
    ///< ECC Protection Correctable Channel Memory Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="32" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT : 1;
    ///< ECC Protection Uncorrectable Channel Memory Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="33" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_UIDMEM_CORRERR_INTSTAT : 1;
    ///< ECC Protection Correctable UID Memory Interrupt Clear Bit. This bit
    ///< is used to clear the corresponding channel interrupt status bit in
    ///< CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="34" ResetValue="0x0"
    uint64_t CLEAR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT : 1;
    ///< ECC Protection Uncorrectable UID Memory Interrupt Clear Bit. This
    ///< bit is used to clear the corresponding channel interrupt status bit
    ///< in CHx_INTSTATUSREG.
    ///< AccessType="WS" BitOffset="35" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_INTCLEARREG_36TO63 : 28;
    ///< DMAC Channelx Interrupt Clear Register (bits 36to63) Reserved bit
    ///< - Write Only
    ///< AccessType="WS" BitOffset="36" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_intclrreg_reg_t;

#define RCS_DMAC_CH2_INTCLRREG_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_INTCLRREG_RD_MASK (0x0000000000000000ULL)
#define RCS_DMAC_CH2_INTCLRREG_WR_MASK (0xffffffffffffffffULL)


///< Block Transfer Done Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CH2_INTSTATUSREG
#define RCS_DMAC_CH2_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_OFF ( 0)
#define RCS_DMAC_CH2_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_MSK (0x00000001)
#define RCS_DMAC_CH2_INTCLRREG_CLR_BLK_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMA Transfer Done Interrupt Clear Bit. This bit is used to clear the
///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_OFF ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_MSK (0x00000002)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DMA_TFR_DONE_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bit 2) Reserved bit - Write
///< Only
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_OFF ( 2)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_MSK (0x00000004)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_2_BF_DEF (0x00000000)

///< Source Transaction Completed Interrupt Clear Bit. This bit is used
///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_OFF ( 3)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_MSK (0x00000008)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Destination Transaction Completed Interrupt Clear Bit. This bit is
///< used to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_OFF ( 4)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_MSK (0x00000010)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_TRANSCOMP_INTSTAT_BF_DEF (0x00000000)

///< Source Decode Error Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_OFF ( 5)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_MSK (0x00000020)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Decode Error Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_OFF ( 6)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_MSK (0x00000040)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Source Subordinate Error Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_OFF ( 7)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_MSK (0x00000080)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SRC_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Destination Subordinate Error Interrupt Clear Bit. This bit is used
///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_OFF ( 8)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_MSK (0x00000100)
#define RCS_DMAC_CH2_INTCLRREG_CLR_DST_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Decode Error Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_OFF ( 9)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_MSK (0x00000200)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Decode Error Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_OFF (10)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_MSK (0x00000400)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI Read Subordinate Error Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_OFF (11)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_MSK (0x00000800)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_RD_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< LLI WRITE Subordinate Error Interrupt Clear Bit. This bit is used
///< to clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_OFF (12)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_MSK (0x00001000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_LLI_WR_SLV_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow register or LLI Invalid Error Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_OFF (13)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_MSK (0x00002000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SHDWREG_OR_LLI_INVALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Multi Block type Error Interrupt Clear Bit.
///< This bit is used to clear the corresponding channel interrupt status
///< bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_OFF (14)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_MSK (0x00004000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_MULTIBLKTYPE_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bit 15) Reserved bit - Write
///< Only
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_OFF (15)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_MSK (0x00008000)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_15_BF_DEF (0x00000000)

///< Register Bus Interface Decode Error Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_OFF (16)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_MSK (0x00010000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_DEC_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write to Read Only Error Interrupt Clear Bit.
///< This bit is used to clear the corresponding channel interrupt status
///< bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_OFF (17)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_MSK (0x00020000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WR2RO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Read to write Only Error Interrupt Clear Bit.
///< This bit is used to clear the corresponding channel interrupt status
///< bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_OFF (18)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_MSK (0x00040000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_RD2RWO_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Channel Enabled Error Interrupt Clear
///< Bit. This bit is used to clear the corresponding channel interrupt
///< status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_OFF (19)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_MSK (0x00080000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONCHEN_ERR_INTSTAT_BF_DEF (0x00000000)

///< Shadow Register Write On Valid Error Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_OFF (20)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_MSK (0x00100000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_SHDWREG_WRON_VALID_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write On Hold Error Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_OFF (21)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_MSK (0x00200000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRONHOLD_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bits 22to23) Reserved bit
///< - Write Only
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_OFF (22)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_WID ( 2)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_MSK (0x00C00000)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_22TO23_BF_DEF (0x00000000)

///< Register Bus Interface Address Parity Error Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_OFF (24)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_MSK (0x01000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_ADDRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< Register Bus Interface Write Parity Error Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_OFF (25)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_MSK (0x02000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_SLVIF_WRPARITY_ERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bit 26) Reserved bit - Write
///< Only
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_OFF (26)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_MSK (0x04000000)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_26_BF_DEF (0x00000000)

///< Channel Lock Cleared Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_OFF (27)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_MSK (0x08000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_LOCK_CLRED_INTSTAT_BF_DEF (0x00000000)

///< Channel Source Suspended Interrupt Clear Bit. This bit is used to
///< clear the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_OFF (28)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_MSK (0x10000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SRC_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Suspended Interrupt Clear Bit. This bit is used to clear the
///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_OFF (29)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_MSK (0x20000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_SUSPENDED_INTSTAT_BF_DEF (0x00000000)

///< Channel Disabled Interrupt Clear Bit. This bit is used to clear the
///< corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_OFF (30)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_MSK (0x40000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_DISD_INTSTAT_BF_DEF (0x00000000)

///< Channel Terminated Interrupt Clear Bit. This bit is used to clear
///< the corresponding channel interrupt status bit in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_OFF (31)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_MSK (0x80000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_CH_ABORTED_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Correctable Channel Memory Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_OFF (32)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_MSK (0x100000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Uncorrectable Channel Memory Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_OFF (33)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_MSK (0x200000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_CHMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Correctable UID Memory Interrupt Clear Bit. This bit
///< is used to clear the corresponding channel interrupt status bit in
///< CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_OFF (34)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_MSK (0x400000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_CORRERR_INTSTAT_BF_DEF (0x00000000)

///< ECC Protection Uncorrectable UID Memory Interrupt Clear Bit. This
///< bit is used to clear the corresponding channel interrupt status bit
///< in CHx_INTSTATUSREG.
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_OFF (35)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_WID ( 1)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_MSK (0x800000000)
#define RCS_DMAC_CH2_INTCLRREG_CLR_ECC_PROT_UIDMEM_UNCORRERR_INTSTAT_BF_DEF (0x00000000)

///< DMAC Channelx Interrupt Clear Register (bits 36to63) Reserved bit
///< - Write Only
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_OFF (36)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_WID (28)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_MSK (0xFFFFFFF000000000)
#define RCS_DMAC_CH2_INTCLRREG_RSVD_DMAC_CHX_INTCLRREG_36TO63_BF_DEF (0x00000000)


/** @brief RCS_DW_AXI_DMAC_REG_CHANNEL2_REGISTERS_ADDRESS_BLOCK_CH2_CFG_EXTD register description at address offset 0x2a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: rcs_DW_axi_dmac/reg/Channel2_Registers_Address_Block/CH2_CFG_EXTD
  * DW_axi_dmac Channel $i Extended Configuration Register
  */

typedef union {
  struct {
    uint64_t LLI_AXPROT : 3;
    ///< LLI Fetch and LLI Writeback AXI AxPROT. These bits form the arprot/awprot
    ///< output of AXI manager interface.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint64_t LLI_AXCACHE : 4;
    ///< LLI Fetch and LLI Writeback AXI AxCACHE. These bits form the arcache/awcache
    ///< output of AXI manager interface.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint64_t RSVD_DMAC_CHX_CFG_EXTD_7TO63 : 57;
    ///< DMAC Channel x Extended Configuration Register (bits 7to63) Reserved
    ///< bits - Read Only
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
  } ;
  uint64_t value;
} rcs_dmac_ch2_cfg_extd_reg_t;

#define RCS_DMAC_CH2_CFG_EXTD_DEFAULT (0x0000000000000000ULL)
#define RCS_DMAC_CH2_CFG_EXTD_RD_MASK (0xffffffffffffffffULL)
#define RCS_DMAC_CH2_CFG_EXTD_WR_MASK (0x000000000000007fULL)


///< LLI Fetch and LLI Writeback AXI AxPROT. These bits form the arprot/awprot
///< output of AXI manager interface.
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXPROT_BF_OFF ( 0)
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXPROT_BF_WID ( 3)
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXPROT_BF_MSK (0x00000007)
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXPROT_BF_DEF (0x00000000)

///< LLI Fetch and LLI Writeback AXI AxCACHE. These bits form the arcache/awcache
///< output of AXI manager interface.
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXCACHE_BF_OFF ( 3)
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXCACHE_BF_WID ( 4)
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXCACHE_BF_MSK (0x00000078)
#define RCS_DMAC_CH2_CFG_EXTD_LLI_AXCACHE_BF_DEF (0x00000000)

///< DMAC Channel x Extended Configuration Register (bits 7to63) Reserved
///< bits - Read Only
#define RCS_DMAC_CH2_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_OFF ( 7)
#define RCS_DMAC_CH2_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_WID (57)
#define RCS_DMAC_CH2_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_MSK (0xFFFFFFFFFFFFFF80)
#define RCS_DMAC_CH2_CFG_EXTD_RSVD_DMAC_CHX_CFG_EXTD_7TO63_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define RCS_DMAC_IDREG_REG ((rcs_dmac_idreg_reg_t*) RCS_DMAC_IDREG_ADR)
#define RCS_DMAC_COMPVERREG_REG ((rcs_dmac_compverreg_reg_t*) RCS_DMAC_COMPVERREG_ADR)
#define RCS_DMAC_CFGREG_REG ((rcs_dmac_cfgreg_reg_t*) RCS_DMAC_CFGREG_ADR)
#define RCS_DMAC_CHENREG_REG ((rcs_dmac_chenreg_reg_t*) RCS_DMAC_CHENREG_ADR)
#define RCS_DMAC_INTSTATREG_REG ((rcs_dmac_intstatreg_reg_t*) RCS_DMAC_INTSTATREG_ADR)
#define RCS_DMAC_CMNREG_INTCLRREG_REG ((rcs_dmac_cmnreg_intclrreg_reg_t*) RCS_DMAC_CMNREG_INTCLRREG_ADR)
#define RCS_DMAC_CMNREG_INTSTAT_ENREG_REG ((rcs_dmac_cmnreg_intstat_enreg_reg_t*) RCS_DMAC_CMNREG_INTSTAT_ENREG_ADR)
#define RCS_DMAC_CMNREG_INTSIGNAL_ENREG_REG ((rcs_dmac_cmnreg_intsignal_enreg_reg_t*) RCS_DMAC_CMNREG_INTSIGNAL_ENREG_ADR)
#define RCS_DMAC_CMNREG_INTSTATREG_REG ((rcs_dmac_cmnreg_intstatreg_reg_t*) RCS_DMAC_CMNREG_INTSTATREG_ADR)
#define RCS_DMAC_RSTREG_REG ((rcs_dmac_rstreg_reg_t*) RCS_DMAC_RSTREG_ADR)
#define RCS_DMAC_CH1_SAR_REG ((rcs_dmac_ch1_sar_reg_t*) RCS_DMAC_CH1_SAR_ADR)
#define RCS_DMAC_CH1_DAR_REG ((rcs_dmac_ch1_dar_reg_t*) RCS_DMAC_CH1_DAR_ADR)
#define RCS_DMAC_CH1_BLK_TS_REG ((rcs_dmac_ch1_blk_ts_reg_t*) RCS_DMAC_CH1_BLK_TS_ADR)
#define RCS_DMAC_CH1_CTL_REG ((rcs_dmac_ch1_ctl_reg_t*) RCS_DMAC_CH1_CTL_ADR)
#define RCS_DMAC_CH1_CFG_REG ((rcs_dmac_ch1_cfg_reg_t*) RCS_DMAC_CH1_CFG_ADR)
#define RCS_DMAC_CH1_LLP_REG ((rcs_dmac_ch1_llp_reg_t*) RCS_DMAC_CH1_LLP_ADR)
#define RCS_DMAC_CH1_STATREG_REG ((rcs_dmac_ch1_statreg_reg_t*) RCS_DMAC_CH1_STATREG_ADR)
#define RCS_DMAC_CH1_SWHSSRCREG_REG ((rcs_dmac_ch1_swhssrcreg_reg_t*) RCS_DMAC_CH1_SWHSSRCREG_ADR)
#define RCS_DMAC_CH1_SWHSDSTREG_REG ((rcs_dmac_ch1_swhsdstreg_reg_t*) RCS_DMAC_CH1_SWHSDSTREG_ADR)
#define RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_REG ((rcs_dmac_ch1_blk_tfr_resumereqreg_reg_t*) RCS_DMAC_CH1_BLK_TFR_RESUMEREQREG_ADR)
#define RCS_DMAC_CH1_IDREG_REG ((rcs_dmac_ch1_idreg_reg_t*) RCS_DMAC_CH1_IDREG_ADR)
#define RCS_DMAC_CH1_QOSREG_REG ((rcs_dmac_ch1_qosreg_reg_t*) RCS_DMAC_CH1_QOSREG_ADR)
#define RCS_DMAC_CH1_INTSTAT_ENREG_REG ((rcs_dmac_ch1_intstat_enreg_reg_t*) RCS_DMAC_CH1_INTSTAT_ENREG_ADR)
#define RCS_DMAC_CH1_INTSTAT_REG ((rcs_dmac_ch1_intstat_reg_t*) RCS_DMAC_CH1_INTSTAT_ADR)
#define RCS_DMAC_CH1_INTSIGNAL_ENREG_REG ((rcs_dmac_ch1_intsignal_enreg_reg_t*) RCS_DMAC_CH1_INTSIGNAL_ENREG_ADR)
#define RCS_DMAC_CH1_INTCLRREG_REG ((rcs_dmac_ch1_intclrreg_reg_t*) RCS_DMAC_CH1_INTCLRREG_ADR)
#define RCS_DMAC_CH1_CFG_EXTD_REG ((rcs_dmac_ch1_cfg_extd_reg_t*) RCS_DMAC_CH1_CFG_EXTD_ADR)
#define RCS_DMAC_CH2_SAR_REG ((rcs_dmac_ch2_sar_reg_t*) RCS_DMAC_CH2_SAR_ADR)
#define RCS_DMAC_CH2_DAR_REG ((rcs_dmac_ch2_dar_reg_t*) RCS_DMAC_CH2_DAR_ADR)
#define RCS_DMAC_CH2_BLK_TS_REG ((rcs_dmac_ch2_blk_ts_reg_t*) RCS_DMAC_CH2_BLK_TS_ADR)
#define RCS_DMAC_CH2_CTL_REG ((rcs_dmac_ch2_ctl_reg_t*) RCS_DMAC_CH2_CTL_ADR)
#define RCS_DMAC_CH2_CFG_REG ((rcs_dmac_ch2_cfg_reg_t*) RCS_DMAC_CH2_CFG_ADR)
#define RCS_DMAC_CH2_LLP_REG ((rcs_dmac_ch2_llp_reg_t*) RCS_DMAC_CH2_LLP_ADR)
#define RCS_DMAC_CH2_STATREG_REG ((rcs_dmac_ch2_statreg_reg_t*) RCS_DMAC_CH2_STATREG_ADR)
#define RCS_DMAC_CH2_SWHSSRCREG_REG ((rcs_dmac_ch2_swhssrcreg_reg_t*) RCS_DMAC_CH2_SWHSSRCREG_ADR)
#define RCS_DMAC_CH2_SWHSDSTREG_REG ((rcs_dmac_ch2_swhsdstreg_reg_t*) RCS_DMAC_CH2_SWHSDSTREG_ADR)
#define RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_REG ((rcs_dmac_ch2_blk_tfr_resumereqreg_reg_t*) RCS_DMAC_CH2_BLK_TFR_RESUMEREQREG_ADR)
#define RCS_DMAC_CH2_IDREG_REG ((rcs_dmac_ch2_idreg_reg_t*) RCS_DMAC_CH2_IDREG_ADR)
#define RCS_DMAC_CH2_QOSREG_REG ((rcs_dmac_ch2_qosreg_reg_t*) RCS_DMAC_CH2_QOSREG_ADR)
#define RCS_DMAC_CH2_INTSTAT_ENREG_REG ((rcs_dmac_ch2_intstat_enreg_reg_t*) RCS_DMAC_CH2_INTSTAT_ENREG_ADR)
#define RCS_DMAC_CH2_INTSTAT_REG ((rcs_dmac_ch2_intstat_reg_t*) RCS_DMAC_CH2_INTSTAT_ADR)
#define RCS_DMAC_CH2_INTSIGNAL_ENREG_REG ((rcs_dmac_ch2_intsignal_enreg_reg_t*) RCS_DMAC_CH2_INTSIGNAL_ENREG_ADR)
#define RCS_DMAC_CH2_INTCLRREG_REG ((rcs_dmac_ch2_intclrreg_reg_t*) RCS_DMAC_CH2_INTCLRREG_ADR)
#define RCS_DMAC_CH2_CFG_EXTD_REG ((rcs_dmac_ch2_cfg_extd_reg_t*) RCS_DMAC_CH2_CFG_EXTD_ADR)

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    rcs_dmac_idreg_reg_t IDREG; /*< Address offset = 0x0 */
    rcs_dmac_compverreg_reg_t COMPVERREG; /*< Address offset = 0x8 */
    rcs_dmac_cfgreg_reg_t CFGREG; /*< Address offset = 0x10 */
    rcs_dmac_chenreg_reg_t CHENREG; /*< Address offset = 0x18 */
    const uint8_t        reservedArea0 [16];  /*< Address offset = 0x20 */
    rcs_dmac_intstatreg_reg_t INTSTATREG; /*< Address offset = 0x30 */
    rcs_dmac_cmnreg_intclrreg_reg_t CMNREG_INTCLRREG; /*< Address offset = 0x38 */
    rcs_dmac_cmnreg_intstat_enreg_reg_t CMNREG_INTSTAT_ENREG; /*< Address offset = 0x40 */
    rcs_dmac_cmnreg_intsignal_enreg_reg_t CMNREG_INTSIGNAL_ENREG; /*< Address offset = 0x48 */
    rcs_dmac_cmnreg_intstatreg_reg_t CMNREG_INTSTATREG; /*< Address offset = 0x50 */
    rcs_dmac_rstreg_reg_t RSTREG; /*< Address offset = 0x58 */
    const uint8_t        reservedArea1 [160]; /*< Address offset = 0x60 */
    rcs_dmac_ch1_sar_reg_t CH1_SAR; /*< Address offset = 0x100 */
    rcs_dmac_ch1_dar_reg_t CH1_DAR; /*< Address offset = 0x108 */
    rcs_dmac_ch1_blk_ts_reg_t CH1_BLK_TS; /*< Address offset = 0x110 */
    rcs_dmac_ch1_ctl_reg_t CH1_CTL; /*< Address offset = 0x118 */
    rcs_dmac_ch1_cfg_reg_t CH1_CFG; /*< Address offset = 0x120 */
    rcs_dmac_ch1_llp_reg_t CH1_LLP; /*< Address offset = 0x128 */
    rcs_dmac_ch1_statreg_reg_t CH1_STATREG; /*< Address offset = 0x130 */
    rcs_dmac_ch1_swhssrcreg_reg_t CH1_SWHSSRCREG; /*< Address offset = 0x138 */
    rcs_dmac_ch1_swhsdstreg_reg_t CH1_SWHSDSTREG; /*< Address offset = 0x140 */
    rcs_dmac_ch1_blk_tfr_resumereqreg_reg_t CH1_BLK_TFR_RESUMEREQREG; /*< Address offset = 0x148 */
    rcs_dmac_ch1_idreg_reg_t CH1_IDREG; /*< Address offset = 0x150 */
    rcs_dmac_ch1_qosreg_reg_t CH1_QOSREG; /*< Address offset = 0x158 */
    const uint8_t        reservedArea2 [32];  /*< Address offset = 0x160 */
    rcs_dmac_ch1_intstat_enreg_reg_t CH1_INTSTAT_ENREG; /*< Address offset = 0x180 */
    rcs_dmac_ch1_intstat_reg_t CH1_INTSTAT; /*< Address offset = 0x188 */
    rcs_dmac_ch1_intsignal_enreg_reg_t CH1_INTSIGNAL_ENREG; /*< Address offset = 0x190 */
    rcs_dmac_ch1_intclrreg_reg_t CH1_INTCLRREG; /*< Address offset = 0x198 */
    rcs_dmac_ch1_cfg_extd_reg_t CH1_CFG_EXTD; /*< Address offset = 0x1a0 */
    const uint8_t        reservedArea3 [88];  /*< Address offset = 0x1a8 */
    rcs_dmac_ch2_sar_reg_t CH2_SAR; /*< Address offset = 0x200 */
    rcs_dmac_ch2_dar_reg_t CH2_DAR; /*< Address offset = 0x208 */
    rcs_dmac_ch2_blk_ts_reg_t CH2_BLK_TS; /*< Address offset = 0x210 */
    rcs_dmac_ch2_ctl_reg_t CH2_CTL; /*< Address offset = 0x218 */
    rcs_dmac_ch2_cfg_reg_t CH2_CFG; /*< Address offset = 0x220 */
    rcs_dmac_ch2_llp_reg_t CH2_LLP; /*< Address offset = 0x228 */
    rcs_dmac_ch2_statreg_reg_t CH2_STATREG; /*< Address offset = 0x230 */
    rcs_dmac_ch2_swhssrcreg_reg_t CH2_SWHSSRCREG; /*< Address offset = 0x238 */
    rcs_dmac_ch2_swhsdstreg_reg_t CH2_SWHSDSTREG; /*< Address offset = 0x240 */
    rcs_dmac_ch2_blk_tfr_resumereqreg_reg_t CH2_BLK_TFR_RESUMEREQREG; /*< Address offset = 0x248 */
    rcs_dmac_ch2_idreg_reg_t CH2_IDREG; /*< Address offset = 0x250 */
    rcs_dmac_ch2_qosreg_reg_t CH2_QOSREG; /*< Address offset = 0x258 */
    const uint8_t        reservedArea4 [32];  /*< Address offset = 0x260 */
    rcs_dmac_ch2_intstat_enreg_reg_t CH2_INTSTAT_ENREG; /*< Address offset = 0x280 */
    rcs_dmac_ch2_intstat_reg_t CH2_INTSTAT; /*< Address offset = 0x288 */
    rcs_dmac_ch2_intsignal_enreg_reg_t CH2_INTSIGNAL_ENREG; /*< Address offset = 0x290 */
    rcs_dmac_ch2_intclrreg_reg_t CH2_INTCLRREG; /*< Address offset = 0x298 */
    rcs_dmac_ch2_cfg_extd_reg_t CH2_CFG_EXTD; /*< Address offset = 0x2a0 */
} rcs_dmac_t;     // size: 0x0160

// AddressSpace struct pointer
//
#define RCS_DMAC         ((rcs_dmac_t*) RCS_DMAC_BASE)

// ******************************************* /Address Space

#endif      // _RCS_DMAC_H_

