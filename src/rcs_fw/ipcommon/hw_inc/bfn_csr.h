#ifndef _BFN_CSR_H_
#define _BFN_CSR_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define V2D0_BFN_CSR_BASE     ( 0x0383c000 )
#define V2D1_BFN_CSR_BASE     ( 0x0387c000 )
#define V2D2_BFN_CSR_BASE     ( 0x038bc000 )
#define V2D3_BFN_CSR_BASE     ( 0x038fc000 )
#define V2D4_BFN_CSR_BASE     ( 0x0393c000 )
#define V2D5_BFN_CSR_BASE     ( 0x0397c000 )
#define V2D6_BFN_CSR_BASE     ( 0x039bc000 )
#define V2D7_BFN_CSR_BASE     ( 0x039fc000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define BFN_CSR_BFN_SCRATCH_OFFSET ( 0x00000000U )
#define BFN_CSR_APB_BRI_STAT_OFFSET ( 0x00000004U )
#define BFN_CSR_GENERAL_CSR_OFFSET ( 0x00000008U )
#define BFN_CSR_CAP_BFN0_OFFSET  ( 0x00000010U )
#define BFN_CSR_CAP_BFN1_OFFSET  ( 0x00000014U )
#define BFN_CSR_CAP_BFN2_OFFSET  ( 0x00000018U )
#define BFN_CSR_CAP_BFN3_OFFSET  ( 0x0000001cU )
#define BFN_CSR_CAP_BFN4_OFFSET  ( 0x00000020U )
#define BFN_CSR_CAP_BFN5_OFFSET  ( 0x00000024U )
#define BFN_CSR_CAP_BFN6_OFFSET  ( 0x00000028U )
#define BFN_CSR_CAP_BFN7_OFFSET  ( 0x0000002cU )
#define BFN_CSR_CAP_BFN8_OFFSET  ( 0x00000030U )
#define BFN_CSR_CAP_BFN9_OFFSET  ( 0x00000034U )
#define BFN_CSR_CAP_BFN10_OFFSET ( 0x00000038U )
#define BFN_CSR_CAP_BFN11_OFFSET ( 0x0000003cU )
#define BFN_CSR_AW_ISYNC_CTRL_OFFSET ( 0x00000040U )
#define BFN_CSR_AW_ISYNC_LCNT_INC_OFFSET ( 0x00000044U )
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_OFFSET ( 0x00000048U )
#define BFN_CSR_AW_ISYNC_INC_PRE_OFFSET ( 0x0000004cU )
#define BFN_CSR_AW_ISYNC_CNT_ADJ_OFFSET ( 0x00000050U )
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_OFFSET ( 0x00000054U )
#define BFN_CSR_AW_ISYNC_BFN_CNT_OFFSET ( 0x00000058U )
#define BFN_CSR_BFNE_CFG0_OFFSET ( 0x00000060U )
#define BFN_CSR_BFNE_CFG1_OFFSET ( 0x00000064U )
#define BFN_CSR_BFNE_CFG2_OFFSET ( 0x00000068U )
#define BFN_CSR_BFNE_CFG3_OFFSET ( 0x0000006cU )
#define BFN_CSR_BFNE_INCR0_OFFSET ( 0x00000070U )
#define BFN_CSR_BFNE_INCR1_OFFSET ( 0x00000074U )
#define BFN_CSR_BFNE_INCR2_OFFSET ( 0x00000078U )
#define BFN_CSR_BFNE_INCR3_OFFSET ( 0x0000007cU )
#define BFN_CSR_BFNE_START0_OFFSET ( 0x00000080U )
#define BFN_CSR_BFNE_START1_OFFSET ( 0x00000084U )
#define BFN_CSR_BFNE_START2_OFFSET ( 0x00000088U )
#define BFN_CSR_BFNE_START3_OFFSET ( 0x0000008cU )
#define BFN_CSR_BFNE_STAT0_OFFSET ( 0x00000090U )
#define BFN_CSR_BFNE_STAT1_OFFSET ( 0x00000094U )
#define BFN_CSR_BFNE_STAT2_OFFSET ( 0x00000098U )
#define BFN_CSR_BFNE_STAT3_OFFSET ( 0x0000009cU )
#define BFN_CSR_START_LM0_OFFSET ( 0x000000d0U )
#define BFN_CSR_START_LM1_OFFSET ( 0x000000d4U )
#define BFN_CSR_START_LM2_OFFSET ( 0x000000d8U )
#define BFN_CSR_START_LM3_OFFSET ( 0x000000dcU )
#define BFN_CSR_START_L_CNT0_OFFSET ( 0x000000e0U )
#define BFN_CSR_START_L_CNT1_OFFSET ( 0x000000e4U )
#define BFN_CSR_START_L_CNT2_OFFSET ( 0x000000e8U )
#define BFN_CSR_START_L_CNT3_OFFSET ( 0x000000ecU )
#define BFN_CSR_CAP_MODE_CTRL_OFFSET ( 0x000000f8U )
#define BFN_CSR_CAP_DATA_CTRL_OFFSET ( 0x000000fcU )
#define BFN_CSR_SMON_R0_OFFSET ( 0x00000100U )
#define BFN_CSR_SMON_R1_OFFSET ( 0x00000104U )
#define BFN_CSR_SMON_R2_OFFSET ( 0x00000108U )
#define BFN_CSR_SMON_R3_OFFSET ( 0x0000010cU )
#define BFN_CSR_SMON_R4_OFFSET ( 0x00000110U )
#define BFN_CSR_SMON_R5_OFFSET ( 0x00000114U )
#define BFN_CSR_SMON_R6_OFFSET ( 0x00000118U )
#define BFN_CSR_SMON_R7_OFFSET ( 0x0000011cU )
#define BFN_CSR_SUBB_LO_INTR_OFFSET ( 0x00000120U )
#define BFN_CSR_SUBB_HI_INTR_OFFSET ( 0x00000124U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define BFN_CSR_BFN_SCRATCH_ADR(_BASE)  (( ( _BASE ) + ( BFN_CSR_BFN_SCRATCH_OFFSET ) ))
#define BFN_CSR_APB_BRI_STAT_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_APB_BRI_STAT_OFFSET ) ))
#define BFN_CSR_GENERAL_CSR_ADR(_BASE)  (( ( _BASE ) + ( BFN_CSR_GENERAL_CSR_OFFSET ) ))
#define BFN_CSR_CAP_BFN0_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN0_OFFSET ) ))
#define BFN_CSR_CAP_BFN1_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN1_OFFSET ) ))
#define BFN_CSR_CAP_BFN2_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN2_OFFSET ) ))
#define BFN_CSR_CAP_BFN3_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN3_OFFSET ) ))
#define BFN_CSR_CAP_BFN4_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN4_OFFSET ) ))
#define BFN_CSR_CAP_BFN5_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN5_OFFSET ) ))
#define BFN_CSR_CAP_BFN6_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN6_OFFSET ) ))
#define BFN_CSR_CAP_BFN7_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN7_OFFSET ) ))
#define BFN_CSR_CAP_BFN8_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN8_OFFSET ) ))
#define BFN_CSR_CAP_BFN9_ADR(_BASE)     (( ( _BASE ) + ( BFN_CSR_CAP_BFN9_OFFSET ) ))
#define BFN_CSR_CAP_BFN10_ADR(_BASE)    (( ( _BASE ) + ( BFN_CSR_CAP_BFN10_OFFSET ) ))
#define BFN_CSR_CAP_BFN11_ADR(_BASE)    (( ( _BASE ) + ( BFN_CSR_CAP_BFN11_OFFSET ) ))
#define BFN_CSR_AW_ISYNC_CTRL_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_AW_ISYNC_CTRL_OFFSET ) ))
#define BFN_CSR_AW_ISYNC_LCNT_INC_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_AW_ISYNC_LCNT_INC_OFFSET ) ))
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_AW_ISYNC_TEN_MS_CNT_OFFSET ) ))
#define BFN_CSR_AW_ISYNC_INC_PRE_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_AW_ISYNC_INC_PRE_OFFSET ) ))
#define BFN_CSR_AW_ISYNC_CNT_ADJ_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_AW_ISYNC_CNT_ADJ_OFFSET ) ))
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_OFFSET ) ))
#define BFN_CSR_AW_ISYNC_BFN_CNT_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_AW_ISYNC_BFN_CNT_OFFSET ) ))
#define BFN_CSR_BFNE_CFG0_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_CFG0_OFFSET ) ))
#define BFN_CSR_BFNE_CFG1_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_CFG1_OFFSET ) ))
#define BFN_CSR_BFNE_CFG2_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_CFG2_OFFSET ) ))
#define BFN_CSR_BFNE_CFG3_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_CFG3_OFFSET ) ))
#define BFN_CSR_BFNE_INCR0_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_INCR0_OFFSET ) ))
#define BFN_CSR_BFNE_INCR1_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_INCR1_OFFSET ) ))
#define BFN_CSR_BFNE_INCR2_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_INCR2_OFFSET ) ))
#define BFN_CSR_BFNE_INCR3_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_INCR3_OFFSET ) ))
#define BFN_CSR_BFNE_START0_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_START0_OFFSET ) ))
#define BFN_CSR_BFNE_START1_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_START1_OFFSET ) ))
#define BFN_CSR_BFNE_START2_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_START2_OFFSET ) ))
#define BFN_CSR_BFNE_START3_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_START3_OFFSET ) ))
#define BFN_CSR_BFNE_STAT0_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_STAT0_OFFSET ) ))
#define BFN_CSR_BFNE_STAT1_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_STAT1_OFFSET ) ))
#define BFN_CSR_BFNE_STAT2_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_STAT2_OFFSET ) ))
#define BFN_CSR_BFNE_STAT3_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_BFNE_STAT3_OFFSET ) ))
#define BFN_CSR_START_LM0_ADR(_BASE)    (( ( _BASE ) + ( BFN_CSR_START_LM0_OFFSET ) ))
#define BFN_CSR_START_LM1_ADR(_BASE)    (( ( _BASE ) + ( BFN_CSR_START_LM1_OFFSET ) ))
#define BFN_CSR_START_LM2_ADR(_BASE)    (( ( _BASE ) + ( BFN_CSR_START_LM2_OFFSET ) ))
#define BFN_CSR_START_LM3_ADR(_BASE)    (( ( _BASE ) + ( BFN_CSR_START_LM3_OFFSET ) ))
#define BFN_CSR_START_L_CNT0_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_START_L_CNT0_OFFSET ) ))
#define BFN_CSR_START_L_CNT1_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_START_L_CNT1_OFFSET ) ))
#define BFN_CSR_START_L_CNT2_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_START_L_CNT2_OFFSET ) ))
#define BFN_CSR_START_L_CNT3_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_START_L_CNT3_OFFSET ) ))
#define BFN_CSR_CAP_MODE_CTRL_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_CAP_MODE_CTRL_OFFSET ) ))
#define BFN_CSR_CAP_DATA_CTRL_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_CAP_DATA_CTRL_OFFSET ) ))
#define BFN_CSR_SMON_R0_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R0_OFFSET ) ))
#define BFN_CSR_SMON_R1_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R1_OFFSET ) ))
#define BFN_CSR_SMON_R2_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R2_OFFSET ) ))
#define BFN_CSR_SMON_R3_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R3_OFFSET ) ))
#define BFN_CSR_SMON_R4_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R4_OFFSET ) ))
#define BFN_CSR_SMON_R5_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R5_OFFSET ) ))
#define BFN_CSR_SMON_R6_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R6_OFFSET ) ))
#define BFN_CSR_SMON_R7_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SMON_R7_OFFSET ) ))
#define BFN_CSR_SUBB_LO_INTR_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SUBB_LO_INTR_OFFSET ) ))
#define BFN_CSR_SUBB_HI_INTR_ADR(_BASE) (( ( _BASE ) + ( BFN_CSR_SUBB_HI_INTR_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief BFN_CSR_COM_REG_BFN_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/BFN_SCRATCH
  * Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Scratch pad
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_bfn_scratch_reg_t;

#define BFN_CSR_BFN_SCRATCH_DEFAULT (0x00000000U)
#define BFN_CSR_BFN_SCRATCH_RD_MASK (0xffffffffU)
#define BFN_CSR_BFN_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch pad
#define BFN_CSR_BFN_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define BFN_CSR_BFN_SCRATCH_SCRATCHPAD_BF_WID (32)
#define BFN_CSR_BFN_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define BFN_CSR_BFN_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_APB_BRI_STATUS register description at address offset 0x4
  *
  * Register default value:        0x00010000
  * Register full path in IP: bfn_csr_com/reg/APB_BRI_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW/L" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW/1S/V/L" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_apb_bri_stat_reg_t;

#define BFN_CSR_APB_BRI_STAT_DEFAULT (0x00010000U)
#define BFN_CSR_APB_BRI_STAT_RD_MASK (0xffffffffU)
#define BFN_CSR_APB_BRI_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_WID (20)
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define BFN_CSR_APB_BRI_STAT_REVISION_BF_OFF (20)
#define BFN_CSR_APB_BRI_STAT_REVISION_BF_WID ( 8)
#define BFN_CSR_APB_BRI_STAT_REVISION_BF_MSK (0x0FF00000)
#define BFN_CSR_APB_BRI_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define BFN_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define BFN_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define BFN_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define BFN_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define BFN_CSR_APB_BRI_STAT_UNSOL_ACK_BF_OFF (29)
#define BFN_CSR_APB_BRI_STAT_UNSOL_ACK_BF_WID ( 1)
#define BFN_CSR_APB_BRI_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define BFN_CSR_APB_BRI_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define BFN_CSR_APB_BRI_STAT_ACK_ERR_BF_OFF (30)
#define BFN_CSR_APB_BRI_STAT_ACK_ERR_BF_WID ( 1)
#define BFN_CSR_APB_BRI_STAT_ACK_ERR_BF_MSK (0x40000000)
#define BFN_CSR_APB_BRI_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_BF_OFF (31)
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_BF_WID ( 1)
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_BF_MSK (0x80000000)
#define BFN_CSR_APB_BRI_STAT_TIMEOUT_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_GENERAL_CSR register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/GENERAL_CSR
  * V2D BFN General Control and Statue Register
  */

typedef union {
  struct {
    uint32_t BFN_START_EN : 1;
    ///< When high, this bit enables BFN to control TX/PDPD start. When low,
    ///< DRF synchronized JESD start signal, i_drf_quad_start, is used to control
    ///< TX/PDPD start. The selected start control will go through DRF clock
    ///< latency count, START_LM_CTL, to generate final start signal. This
    ///< bit is only useful in even numbered V2Ds, e.g. V2D 0/2/4/6.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DIE_MODE : 1;
    ///< This bit tells the mode of the die. 1=4016, VEX exists, 0=0016, there
    ///< are no VEX and PDPD.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t CHANNEL_0_CRUX_CLK_EN : 1;
    ///< Channel CRUX Clock Enable. When high, this bit enables CRUX clock
    ///< to the corresponding V2D channel. When low, the clock to the channel
    ///< is gated.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CHANNEL_1_CRUX_CLK_EN : 1;
    ///< Channel CRUX Clock Enable. When high, this bit enables CRUX clock
    ///< to the corresponding V2D channel. When low, the clock to the channel
    ///< is gated.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CHANNEL_0_DRF_CLK_EN : 1;
    ///< Channel DRF Clock Enable. When high, this bit enables DRF clock to
    ///< the corresponding V2D channel. When low, the clock to the channel
    ///< is gated.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CHANNEL_1_DRF_CLK_EN : 1;
    ///< Channel DRF Clock Enable. When high, this bit enables DRF clock to
    ///< the corresponding V2D channel. When low, the clock to the channel
    ///< is gated.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t PDPD_0_CLK_EN : 1;
    ///< PDPD Clock Enable. When high, this bit enables DRF clock to the corresponding
    ///< PDPD. When low, the clock to the PDPD is gated.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t PDPD_1_CLK_EN : 1;
    ///< PDPD Clock Enable. When high, this bit enables DRF clock to the corresponding
    ///< PDPD. When low, the clock to the PDPD is gated.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t CHANNEL_0_HALT : 1;
    ///< Channel Halt. When set, this bit enables the corresponding V2D channel
    ///< to do halt operation, which is needed before a channel soft reset.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t CHANNEL_1_HALT : 1;
    ///< Channel Halt. When set, this bit enables the corresponding V2D channel
    ///< to do halt operation, which is needed before a channel soft reset.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t CHANNEL_0_HALT_DONE : 1;
    ///< Channel Halt Done. When high, this bit indicates that the corresponding
    ///< V2D channel has completed halt operation.
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint32_t CHANNEL_1_HALT_DONE : 1;
    ///< Channel Halt Done. When high, this bit indicates that the corresponding
    ///< V2D channel has completed halt operation.
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint32_t CHANNEL_0_DP_INIT_DONE : 1;
    ///< Channel Datapath Initialization Done. When set, this bit indicates
    ///< that the corresponding V2D channel initialization is done. It will
    ///< be reset when the corresponding CHANNEL_DP_INIT bit is cleared.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint32_t CHANNEL_1_DP_INIT_DONE : 1;
    ///< Channel Datapath Initialization Done. When set, this bit indicates
    ///< that the corresponding V2D channel initialization is done. It will
    ///< be reset when the corresponding CHANNEL_DP_INIT bit is cleared.
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint32_t CHANNEL_0_DP_INIT : 1;
    ///< Channel Datapath Initialization. When set, this bit resets synchronously
    ///< corresponding V2D channel. This bit should be set after corresponding
    ///< CHANNEL_HALT_DONE bit is set.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t CHANNEL_1_DP_INIT : 1;
    ///< Channel Datapath Initialization. When set, this bit resets synchronously
    ///< corresponding V2D channel. This bit should be set after corresponding
    ///< CHANNEL_HALT_DONE bit is set.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_general_csr_reg_t;

#define BFN_CSR_GENERAL_CSR_DEFAULT (0x00000000U)
#define BFN_CSR_GENERAL_CSR_RD_MASK (0xff0003f3U)
#define BFN_CSR_GENERAL_CSR_WR_MASK (0xc30003f1U)


///< When high, this bit enables BFN to control TX/PDPD start. When low,
///< DRF synchronized JESD start signal, i_drf_quad_start, is used to control
///< TX/PDPD start. The selected start control will go through DRF clock
///< latency count, START_LM_CTL, to generate final start signal. This
///< bit is only useful in even numbered V2Ds, e.g. V2D 0/2/4/6.
#define BFN_CSR_GENERAL_CSR_BFN_START_EN_BF_OFF ( 0)
#define BFN_CSR_GENERAL_CSR_BFN_START_EN_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_BFN_START_EN_BF_MSK (0x00000001)
#define BFN_CSR_GENERAL_CSR_BFN_START_EN_BF_DEF (0x00000000)

///< This bit tells the mode of the die. 1=4016, VEX exists, 0=0016, there
///< are no VEX and PDPD.
#define BFN_CSR_GENERAL_CSR_DIE_MODE_BF_OFF ( 1)
#define BFN_CSR_GENERAL_CSR_DIE_MODE_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_DIE_MODE_BF_MSK (0x00000002)
#define BFN_CSR_GENERAL_CSR_DIE_MODE_BF_DEF (0x00000000)

///< Channel CRUX Clock Enable. When high, this bit enables CRUX clock
///< to the corresponding V2D channel. When low, the clock to the channel
///< is gated.
#define BFN_CSR_GENERAL_CSR_CH_0_CRUX_CLK_EN_BF_OFF ( 4)
#define BFN_CSR_GENERAL_CSR_CH_0_CRUX_CLK_EN_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_0_CRUX_CLK_EN_BF_MSK (0x00000010)
#define BFN_CSR_GENERAL_CSR_CH_0_CRUX_CLK_EN_BF_DEF (0x00000000)

///< Channel CRUX Clock Enable. When high, this bit enables CRUX clock
///< to the corresponding V2D channel. When low, the clock to the channel
///< is gated.
#define BFN_CSR_GENERAL_CSR_CH_1_CRUX_CLK_EN_BF_OFF ( 5)
#define BFN_CSR_GENERAL_CSR_CH_1_CRUX_CLK_EN_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_1_CRUX_CLK_EN_BF_MSK (0x00000020)
#define BFN_CSR_GENERAL_CSR_CH_1_CRUX_CLK_EN_BF_DEF (0x00000000)

///< Channel DRF Clock Enable. When high, this bit enables DRF clock to
///< the corresponding V2D channel. When low, the clock to the channel
///< is gated.
#define BFN_CSR_GENERAL_CSR_CH_0_DRF_CLK_EN_BF_OFF ( 6)
#define BFN_CSR_GENERAL_CSR_CH_0_DRF_CLK_EN_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_0_DRF_CLK_EN_BF_MSK (0x00000040)
#define BFN_CSR_GENERAL_CSR_CH_0_DRF_CLK_EN_BF_DEF (0x00000000)

///< Channel DRF Clock Enable. When high, this bit enables DRF clock to
///< the corresponding V2D channel. When low, the clock to the channel
///< is gated.
#define BFN_CSR_GENERAL_CSR_CH_1_DRF_CLK_EN_BF_OFF ( 7)
#define BFN_CSR_GENERAL_CSR_CH_1_DRF_CLK_EN_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_1_DRF_CLK_EN_BF_MSK (0x00000080)
#define BFN_CSR_GENERAL_CSR_CH_1_DRF_CLK_EN_BF_DEF (0x00000000)

///< PDPD Clock Enable. When high, this bit enables DRF clock to the corresponding
///< PDPD. When low, the clock to the PDPD is gated.
#define BFN_CSR_GENERAL_CSR_PDPD_0_CLK_EN_BF_OFF ( 8)
#define BFN_CSR_GENERAL_CSR_PDPD_0_CLK_EN_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_PDPD_0_CLK_EN_BF_MSK (0x00000100)
#define BFN_CSR_GENERAL_CSR_PDPD_0_CLK_EN_BF_DEF (0x00000000)

///< PDPD Clock Enable. When high, this bit enables DRF clock to the corresponding
///< PDPD. When low, the clock to the PDPD is gated.
#define BFN_CSR_GENERAL_CSR_PDPD_1_CLK_EN_BF_OFF ( 9)
#define BFN_CSR_GENERAL_CSR_PDPD_1_CLK_EN_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_PDPD_1_CLK_EN_BF_MSK (0x00000200)
#define BFN_CSR_GENERAL_CSR_PDPD_1_CLK_EN_BF_DEF (0x00000000)

///< Channel Halt. When set, this bit enables the corresponding V2D channel
///< to do halt operation, which is needed before a channel soft reset.
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_BF_OFF (24)
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_BF_MSK (0x01000000)
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_BF_DEF (0x00000000)

///< Channel Halt. When set, this bit enables the corresponding V2D channel
///< to do halt operation, which is needed before a channel soft reset.
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_BF_OFF (25)
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_BF_MSK (0x02000000)
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_BF_DEF (0x00000000)

///< Channel Halt Done. When high, this bit indicates that the corresponding
///< V2D channel has completed halt operation.
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_DONE_BF_OFF (26)
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_DONE_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_DONE_BF_MSK (0x04000000)
#define BFN_CSR_GENERAL_CSR_CH_0_HALT_DONE_BF_DEF (0x00000000)

///< Channel Halt Done. When high, this bit indicates that the corresponding
///< V2D channel has completed halt operation.
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_DONE_BF_OFF (27)
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_DONE_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_DONE_BF_MSK (0x08000000)
#define BFN_CSR_GENERAL_CSR_CH_1_HALT_DONE_BF_DEF (0x00000000)

///< Channel Datapath Initialization Done. When set, this bit indicates
///< that the corresponding V2D channel initialization is done. It will
///< be reset when the corresponding CHANNEL_DP_INIT bit is cleared.
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_DONE_BF_OFF (28)
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_DONE_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_DONE_BF_MSK (0x10000000)
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_DONE_BF_DEF (0x00000000)

///< Channel Datapath Initialization Done. When set, this bit indicates
///< that the corresponding V2D channel initialization is done. It will
///< be reset when the corresponding CHANNEL_DP_INIT bit is cleared.
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_DONE_BF_OFF (29)
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_DONE_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_DONE_BF_MSK (0x20000000)
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_DONE_BF_DEF (0x00000000)

///< Channel Datapath Initialization. When set, this bit resets synchronously
///< corresponding V2D channel. This bit should be set after corresponding
///< CHANNEL_HALT_DONE bit is set.
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_BF_OFF (30)
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_BF_MSK (0x40000000)
#define BFN_CSR_GENERAL_CSR_CH_0_DP_INIT_BF_DEF (0x00000000)

///< Channel Datapath Initialization. When set, this bit resets synchronously
///< corresponding V2D channel. This bit should be set after corresponding
///< CHANNEL_HALT_DONE bit is set.
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_BF_OFF (31)
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_BF_WID ( 1)
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_BF_MSK (0x80000000)
#define BFN_CSR_GENERAL_CSR_CH_1_DP_INIT_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_CAP_BFN[12] register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/CAP_BFN
  * Captured BFN Count Value.
  */

typedef union {
  struct {
    uint32_t CAP_BFN_LO_VAL : 24;
    ///< Captured BFN Lower Count Value. This is the captured BFN value of
    ///< lower part of the BFN counter. This value should not be more than
    ///< the value in TEN_MS_CNT register.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t CAP_BFN_UP8_VAL : 8;
    ///< Captured 8 LSBs of BFN Upper Count Value. This is the 8 LSBs of captured
    ///< BFN upper count value.
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_cap_bfn_reg_t;

#define BFN_CSR_CAP_BFN_DEFAULT (0x00000000U)
#define BFN_CSR_CAP_BFN_RD_MASK (0xffffffffU)
#define BFN_CSR_CAP_BFN_WR_MASK (0x00000000U)


///< Captured BFN Lower Count Value. This is the captured BFN value of
///< lower part of the BFN counter. This value should not be more than
///< the value in TEN_MS_CNT register.
#define BFN_CSR_CAP_BFN_CAP_BFN_LO_VAL_BF_OFF ( 0)
#define BFN_CSR_CAP_BFN_CAP_BFN_LO_VAL_BF_WID (24)
#define BFN_CSR_CAP_BFN_CAP_BFN_LO_VAL_BF_MSK (0x00FFFFFF)
#define BFN_CSR_CAP_BFN_CAP_BFN_LO_VAL_BF_DEF (0x00000000)

///< Captured 8 LSBs of BFN Upper Count Value. This is the 8 LSBs of captured
///< BFN upper count value.
#define BFN_CSR_CAP_BFN_CAP_BFN_UP8_VAL_BF_OFF (24)
#define BFN_CSR_CAP_BFN_CAP_BFN_UP8_VAL_BF_WID ( 8)
#define BFN_CSR_CAP_BFN_CAP_BFN_UP8_VAL_BF_MSK (0xFF000000)
#define BFN_CSR_CAP_BFN_CAP_BFN_UP8_VAL_BF_DEF (0x00000000)
#define BFN_CSR_CAP_BFN_ARR_SZ0 (12)
#define BFN_CSR_CAP_BFN_ARRAY_STRIDE0 (0x0004)


/** @brief BFN_CSR_COM_REG_AW_ISYNC_ISYNC_CTRL register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/AW_ISYNC/ISYNC_CTRL
  * ISYNC Control Register
  */

typedef union {
  struct {
    uint32_t TIMER_CMD : 3;
    ///< When i_isync value is 11, the command programmed in this register
    ///< is executed.  3'b000, 3'b100, 3'b110 -> bfn_lower_cnt is incremented
    ///< with the value in BFN_LOWER_CNT_INC. If the  lower count value equals
    ///< the TEN_MS_CNT value the bfn_upper_cnt value is incremented by 1.
    ///< 3'b001 -> bfn_lower_cnt and bfn_upper_cnt are preset to the value
    ///< in the TIMER_INC_PRE register.  3'b010 -> The internal registers corresponding
    ///< to BFN_LOWER_CNT_INC., TIMER_INC_PRE, TIMER_INC_ADJ  TEN_MS_CNT are
    ///< all initialized to their corresponding input values.  If the current
    ///< bfn_lower_cnt value is equal to the TEN_MS_CNT value, the bfn_upper_cnt
    ///< is incremented by 1. If not, bfn_lower_cnt is incremented by the value
    ///< in BFN_LOWER_CNT_INC.  register.  3'b011 -> Increment the bfn_lower_cnt
    ///< value with the value in the TIMER_INC_PRE register.  3'b101 -> If
    ///< bfn_lower_cnt value equals the TEN_MS_CNT value, reset the bfn_lower_cnt
    ///< to zero and  increment the bfn_upper_cnt by 1. If not, increment bfn_lower_cnt
    ///< by a value  in the BFN_LOWER_CNT_INC. register. A sync_adj_pulse is
    ///< also generated so that when the  bfn_lower_cnt value is equal to the
    ///< TEN_MS_CNT and the bfn_upper_cnt equals timer_cnt_adj  the bfn_lower_cnt
    ///< is preset to the value in TIMER_INC_PRE and the bfn_upper_cnt is
    ///< incremented by the value in TIMER_INC_PRE register.  3'b111 -> The
    ///< current value in the bfn_lower_cnt and bfn_upper_cnt is captured and
    ///< made available  in a register for the application to read.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
    uint32_t LOAD_READ : 1;
    ///< When 1, load BFN count into the manager counter at the first timesync
    ///< pulse, when 0, read BFN count from the Manager BFN counter at every
    ///< timesync pulse.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t BFN_CNT_SAMPLE : 1;
    ///< Write to 1 (regardless of the current value) causes the circuit to
    ///< sample the BFN_CNT and synchronize it into the register clock domain.
    ///< After waiting 3-4 BFN clock cycles plus 3-4 register clock cycles,
    ///< the sample is available to read in the ISYNC_BFN_CNT register
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
    uint32_t SOFT_RESET : 1;
    ///< Soft Reset for the entire AW_isync. Active high.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_aw_isync_ctrl_reg_t;

#define BFN_CSR_AW_ISYNC_CTRL_DEFAULT (0x00000000U)
#define BFN_CSR_AW_ISYNC_CTRL_RD_MASK (0x00008037U)
#define BFN_CSR_AW_ISYNC_CTRL_WR_MASK (0x00008037U)


///< When i_isync value is 11, the command programmed in this register
///< is executed.  3'b000, 3'b100, 3'b110 -> bfn_lower_cnt is incremented
///< with the value in BFN_LOWER_CNT_INC. If the  lower count value equals
///< the TEN_MS_CNT value the bfn_upper_cnt value is incremented by 1.
///< 3'b001 -> bfn_lower_cnt and bfn_upper_cnt are preset to the value
///< in the TIMER_INC_PRE register.  3'b010 -> The internal registers corresponding
///< to BFN_LOWER_CNT_INC., TIMER_INC_PRE, TIMER_INC_ADJ  TEN_MS_CNT are
///< all initialized to their corresponding input values.  If the current
///< bfn_lower_cnt value is equal to the TEN_MS_CNT value, the bfn_upper_cnt
///< is incremented by 1. If not, bfn_lower_cnt is incremented by the value
///< in BFN_LOWER_CNT_INC.  register.  3'b011 -> Increment the bfn_lower_cnt
///< value with the value in the TIMER_INC_PRE register.  3'b101 -> If
///< bfn_lower_cnt value equals the TEN_MS_CNT value, reset the bfn_lower_cnt
///< to zero and  increment the bfn_upper_cnt by 1. If not, increment bfn_lower_cnt
///< by a value  in the BFN_LOWER_CNT_INC. register. A sync_adj_pulse is
///< also generated so that when the  bfn_lower_cnt value is equal to the
///< TEN_MS_CNT and the bfn_upper_cnt equals timer_cnt_adj  the bfn_lower_cnt
///< is preset to the value in TIMER_INC_PRE and the bfn_upper_cnt is
///< incremented by the value in TIMER_INC_PRE register.  3'b111 -> The
///< current value in the bfn_lower_cnt and bfn_upper_cnt is captured and
///< made available  in a register for the application to read.
#define BFN_CSR_AW_ISYNC_CTRL_TIMER_CMD_BF_OFF ( 0)
#define BFN_CSR_AW_ISYNC_CTRL_TIMER_CMD_BF_WID ( 3)
#define BFN_CSR_AW_ISYNC_CTRL_TIMER_CMD_BF_MSK (0x00000007)
#define BFN_CSR_AW_ISYNC_CTRL_TIMER_CMD_BF_DEF (0x00000000)

///< When 1, load BFN count into the manager counter at the first timesync
///< pulse, when 0, read BFN count from the Manager BFN counter at every
///< timesync pulse.
#define BFN_CSR_AW_ISYNC_CTRL_LOAD_READ_BF_OFF ( 4)
#define BFN_CSR_AW_ISYNC_CTRL_LOAD_READ_BF_WID ( 1)
#define BFN_CSR_AW_ISYNC_CTRL_LOAD_READ_BF_MSK (0x00000010)
#define BFN_CSR_AW_ISYNC_CTRL_LOAD_READ_BF_DEF (0x00000000)

///< Write to 1 (regardless of the current value) causes the circuit to
///< sample the BFN_CNT and synchronize it into the register clock domain.
///< After waiting 3-4 BFN clock cycles plus 3-4 register clock cycles,
///< the sample is available to read in the ISYNC_BFN_CNT register
#define BFN_CSR_AW_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_OFF ( 5)
#define BFN_CSR_AW_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_WID ( 1)
#define BFN_CSR_AW_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_MSK (0x00000020)
#define BFN_CSR_AW_ISYNC_CTRL_BFN_CNT_SAMPLE_BF_DEF (0x00000000)

///< Soft Reset for the entire AW_isync. Active high.
#define BFN_CSR_AW_ISYNC_CTRL_SOFT_RST_BF_OFF (15)
#define BFN_CSR_AW_ISYNC_CTRL_SOFT_RST_BF_WID ( 1)
#define BFN_CSR_AW_ISYNC_CTRL_SOFT_RST_BF_MSK (0x00008000)
#define BFN_CSR_AW_ISYNC_CTRL_SOFT_RST_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_AW_ISYNC_ISYNC_LCNT_INC register description at address offset 0x44
  *
  * Register default value:        0x00000001
  * Register full path in IP: bfn_csr_com/reg/AW_ISYNC/ISYNC_LCNT_INC
  * Isync Lower Count Increment Register
  */

typedef union {
  struct {
    uint32_t BFN_LOWER_CNT_INC : 24;
    ///< Increment for the Offset Counter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_aw_isync_lcnt_inc_reg_t;

#define BFN_CSR_AW_ISYNC_LCNT_INC_DEFAULT (0x00000001U)
#define BFN_CSR_AW_ISYNC_LCNT_INC_RD_MASK (0x00ffffffU)
#define BFN_CSR_AW_ISYNC_LCNT_INC_WR_MASK (0x00ffffffU)


///< Increment for the Offset Counter.
#define BFN_CSR_AW_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_OFF ( 0)
#define BFN_CSR_AW_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_WID (24)
#define BFN_CSR_AW_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_MSK (0x00FFFFFF)
#define BFN_CSR_AW_ISYNC_LCNT_INC_BFN_LOWER_CNT_INC_BF_DEF (0x00000001)


/** @brief BFN_CSR_COM_REG_AW_ISYNC_ISYNC_TEN_MS_CNT register description at address offset 0x48
  *
  * Register default value:        0x0095FFFF
  * Register full path in IP: bfn_csr_com/reg/AW_ISYNC/ISYNC_TEN_MS_CNT
  * Isync 10ms Counter Register
  */

typedef union {
  struct {
    uint32_t TEN_MS_CNT : 24;
    ///< Number of clock cycles in 10ms (minus 1).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x95FFFF"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_aw_isync_ten_ms_cnt_reg_t;

#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_DEFAULT (0x0095ffffU)
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_RD_MASK (0x00ffffffU)
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_WR_MASK (0x00ffffffU)


///< Number of clock cycles in 10ms (minus 1).
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_OFF ( 0)
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_WID (24)
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_MSK (0x00FFFFFF)
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_TEN_MS_CNT_BF_DEF (0x0095FFFF)


/** @brief BFN_CSR_COM_REG_AW_ISYNC_ISYNC_INC_PRE register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/AW_ISYNC/ISYNC_INC_PRE
  * Isync Timer Increment/Preset Register
  */

typedef union {
  struct {
    uint32_t OFFSET_INCR : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME_INCR : 8;
    ///< Bits [7:0] of the 10ms frame counter.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_aw_isync_inc_pre_reg_t;

#define BFN_CSR_AW_ISYNC_INC_PRE_DEFAULT (0x00000000U)
#define BFN_CSR_AW_ISYNC_INC_PRE_RD_MASK (0xffffffffU)
#define BFN_CSR_AW_ISYNC_INC_PRE_WR_MASK (0xffffffffU)


///< Offset from nearest 10ms frame, in clock cycles.
#define BFN_CSR_AW_ISYNC_INC_PRE_OFFSET_INCR_BF_OFF ( 0)
#define BFN_CSR_AW_ISYNC_INC_PRE_OFFSET_INCR_BF_WID (24)
#define BFN_CSR_AW_ISYNC_INC_PRE_OFFSET_INCR_BF_MSK (0x00FFFFFF)
#define BFN_CSR_AW_ISYNC_INC_PRE_OFFSET_INCR_BF_DEF (0x00000000)

///< Bits [7:0] of the 10ms frame counter.
#define BFN_CSR_AW_ISYNC_INC_PRE_FRAME_INCR_BF_OFF (24)
#define BFN_CSR_AW_ISYNC_INC_PRE_FRAME_INCR_BF_WID ( 8)
#define BFN_CSR_AW_ISYNC_INC_PRE_FRAME_INCR_BF_MSK (0xFF000000)
#define BFN_CSR_AW_ISYNC_INC_PRE_FRAME_INCR_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_AW_ISYNC_ISYNC_CNT_ADJ register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/AW_ISYNC/ISYNC_CNT_ADJ
  * Isync Timer Count Adjustment Register
  */

typedef union {
  struct {
    uint32_t FRAME_ADJ : 8;
    ///< Bits [7:0] of the 10ms frame counter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_aw_isync_cnt_adj_reg_t;

#define BFN_CSR_AW_ISYNC_CNT_ADJ_DEFAULT (0x00000000U)
#define BFN_CSR_AW_ISYNC_CNT_ADJ_RD_MASK (0x000000ffU)
#define BFN_CSR_AW_ISYNC_CNT_ADJ_WR_MASK (0x000000ffU)


///< Bits [7:0] of the 10ms frame counter.
#define BFN_CSR_AW_ISYNC_CNT_ADJ_FRAME_ADJ_BF_OFF ( 0)
#define BFN_CSR_AW_ISYNC_CNT_ADJ_FRAME_ADJ_BF_WID ( 8)
#define BFN_CSR_AW_ISYNC_CNT_ADJ_FRAME_ADJ_BF_MSK (0x000000FF)
#define BFN_CSR_AW_ISYNC_CNT_ADJ_FRAME_ADJ_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_AW_ISYNC_ISYNC_BFN_CNT_SYNC register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/AW_ISYNC/ISYNC_BFN_CNT_SYNC
  * BFN Count Sync
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< Bits [7:0] fo the count of 10ms frames.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_aw_isync_bfn_cnt_sync_reg_t;

#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_DEFAULT (0x00000000U)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_RD_MASK (0xffffffffU)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_WR_MASK (0x00000000U)


///< Offset from nearest 10ms frame, in clock cycles.
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_OFFSET_BF_OFF ( 0)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_OFFSET_BF_WID (24)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_OFFSET_BF_MSK (0x00FFFFFF)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_OFFSET_BF_DEF (0x00000000)

///< Bits [7:0] fo the count of 10ms frames.
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_FRAME_BF_OFF (24)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_FRAME_BF_WID ( 8)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_FRAME_BF_MSK (0xFF000000)
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_FRAME_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_AW_ISYNC_ISYNC_BFN_CNT register description at address offset 0x58
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/AW_ISYNC/ISYNC_BFN_CNT
  * BFN Count
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< LSB's of Count of 10ms frames.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_aw_isync_bfn_cnt_reg_t;

#define BFN_CSR_AW_ISYNC_BFN_CNT_DEFAULT (0x00000000U)
#define BFN_CSR_AW_ISYNC_BFN_CNT_RD_MASK (0xffffffffU)
#define BFN_CSR_AW_ISYNC_BFN_CNT_WR_MASK (0x00000000U)


///< Offset from nearest 10ms frame, in clock cycles.
#define BFN_CSR_AW_ISYNC_BFN_CNT_OFFSET_BF_OFF ( 0)
#define BFN_CSR_AW_ISYNC_BFN_CNT_OFFSET_BF_WID (24)
#define BFN_CSR_AW_ISYNC_BFN_CNT_OFFSET_BF_MSK (0x00FFFFFF)
#define BFN_CSR_AW_ISYNC_BFN_CNT_OFFSET_BF_DEF (0x00000000)

///< LSB's of Count of 10ms frames.
#define BFN_CSR_AW_ISYNC_BFN_CNT_FRAME_BF_OFF (24)
#define BFN_CSR_AW_ISYNC_BFN_CNT_FRAME_BF_WID ( 8)
#define BFN_CSR_AW_ISYNC_BFN_CNT_FRAME_BF_MSK (0xFF000000)
#define BFN_CSR_AW_ISYNC_BFN_CNT_FRAME_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_BFN_EVENTS_BFNE_CONFIG[4] register description at address offset 0x60
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/BFN_EVENTS/BFNE_CONFIG
  * BFN Event Config Register
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< Set to 1 to enable the operation of the bfn_event module. When running
    ///< in repeat mode, set this back to zero to immediately halt the operation.
    ///< NOte that this must be set to 1 for the force mechanism (See BFN_START
    ///< register) to work.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MODE : 2;
    ///< Selects the mode of operation. Note that the force mechanism can be
    ///< triggered (see BFNE_START) regardless of which mode is selected here.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t OUTPUT_MODE : 1;
    ///< Selects whether the BFN_EVENT output toggles at each event, or produces
    ///< a single cycle pulse.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DEBUG_MODE : 2;
    ///< Controls what appears in BFN_EVENT_STAT DEBUG field, which is 28 bits.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_bfne_cfg_reg_t;

#define BFN_CSR_BFNE_CFG_DEFAULT (0x00000000U)
#define BFN_CSR_BFNE_CFG_RD_MASK (0x0000003fU)
#define BFN_CSR_BFNE_CFG_WR_MASK (0x0000003fU)


///< Set to 1 to enable the operation of the bfn_event module. When running
///< in repeat mode, set this back to zero to immediately halt the operation.
///< NOte that this must be set to 1 for the force mechanism (See BFN_START
///< register) to work.
#define BFN_CSR_BFNE_CFG_EN_BF_OFF ( 0)
#define BFN_CSR_BFNE_CFG_EN_BF_WID ( 1)
#define BFN_CSR_BFNE_CFG_EN_BF_MSK (0x00000001)
#define BFN_CSR_BFNE_CFG_EN_BF_DEF (0x00000000)

///< Selects the mode of operation. Note that the force mechanism can be
///< triggered (see BFNE_START) regardless of which mode is selected here.
#define BFN_CSR_BFNE_CFG_MODE_BF_OFF ( 1)
#define BFN_CSR_BFNE_CFG_MODE_BF_WID ( 2)
#define BFN_CSR_BFNE_CFG_MODE_BF_MSK (0x00000006)
#define BFN_CSR_BFNE_CFG_MODE_BF_DEF (0x00000000)

///< Selects whether the BFN_EVENT output toggles at each event, or produces
///< a single cycle pulse.
#define BFN_CSR_BFNE_CFG_OUTPUT_MODE_BF_OFF ( 3)
#define BFN_CSR_BFNE_CFG_OUTPUT_MODE_BF_WID ( 1)
#define BFN_CSR_BFNE_CFG_OUTPUT_MODE_BF_MSK (0x00000008)
#define BFN_CSR_BFNE_CFG_OUTPUT_MODE_BF_DEF (0x00000000)

///< Controls what appears in BFN_EVENT_STAT DEBUG field, which is 28 bits.
#define BFN_CSR_BFNE_CFG_DBG_MODE_BF_OFF ( 4)
#define BFN_CSR_BFNE_CFG_DBG_MODE_BF_WID ( 2)
#define BFN_CSR_BFNE_CFG_DBG_MODE_BF_MSK (0x00000030)
#define BFN_CSR_BFNE_CFG_DBG_MODE_BF_DEF (0x00000000)
#define BFN_CSR_BFNE_CFG_ARR_SZ0 (4)
#define BFN_CSR_BFNE_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief BFN_CSR_COM_REG_BFN_EVENTS_BFNE_INCR[4] register description at address offset 0x70
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/BFN_EVENTS/BFNE_INCR
  * BFN Event Increment
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< Count of 10ms frames.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_bfne_incr_reg_t;

#define BFN_CSR_BFNE_INCR_DEFAULT (0x00000000U)
#define BFN_CSR_BFNE_INCR_RD_MASK (0xffffffffU)
#define BFN_CSR_BFNE_INCR_WR_MASK (0xffffffffU)


///< Offset from nearest 10ms frame, in clock cycles.
#define BFN_CSR_BFNE_INCR_OFFSET_BF_OFF ( 0)
#define BFN_CSR_BFNE_INCR_OFFSET_BF_WID (24)
#define BFN_CSR_BFNE_INCR_OFFSET_BF_MSK (0x00FFFFFF)
#define BFN_CSR_BFNE_INCR_OFFSET_BF_DEF (0x00000000)

///< Count of 10ms frames.
#define BFN_CSR_BFNE_INCR_FRAME_BF_OFF (24)
#define BFN_CSR_BFNE_INCR_FRAME_BF_WID ( 8)
#define BFN_CSR_BFNE_INCR_FRAME_BF_MSK (0xFF000000)
#define BFN_CSR_BFNE_INCR_FRAME_BF_DEF (0x00000000)
#define BFN_CSR_BFNE_INCR_ARR_SZ0 (4)
#define BFN_CSR_BFNE_INCR_ARRAY_STRIDE0 (0x0004)


/** @brief BFN_CSR_COM_REG_BFN_EVENTS_BFNE_START[4] register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/BFN_EVENTS/BFNE_START
  * BFN Event Start
  */

typedef union {
  struct {
    uint32_t OFFSET : 24;
    ///< Offset from nearest 10ms frame, in clock cycles.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FRAME : 8;
    ///< Count of 10ms frames.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_bfne_start_reg_t;

#define BFN_CSR_BFNE_START_DEFAULT (0x00000000U)
#define BFN_CSR_BFNE_START_RD_MASK (0xffffffffU)
#define BFN_CSR_BFNE_START_WR_MASK (0xffffffffU)


///< Offset from nearest 10ms frame, in clock cycles.
#define BFN_CSR_BFNE_START_OFFSET_BF_OFF ( 0)
#define BFN_CSR_BFNE_START_OFFSET_BF_WID (24)
#define BFN_CSR_BFNE_START_OFFSET_BF_MSK (0x00FFFFFF)
#define BFN_CSR_BFNE_START_OFFSET_BF_DEF (0x00000000)

///< Count of 10ms frames.
#define BFN_CSR_BFNE_START_FRAME_BF_OFF (24)
#define BFN_CSR_BFNE_START_FRAME_BF_WID ( 8)
#define BFN_CSR_BFNE_START_FRAME_BF_MSK (0xFF000000)
#define BFN_CSR_BFNE_START_FRAME_BF_DEF (0x00000000)
#define BFN_CSR_BFNE_START_ARR_SZ0 (4)
#define BFN_CSR_BFNE_START_ARRAY_STRIDE0 (0x0004)


/** @brief BFN_CSR_COM_REG_BFN_EVENTS_BFNE_STAT[4] register description at address offset 0x90
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/BFN_EVENTS/BFNE_STAT
  * BFN Event Status Register
  */

typedef union {
  struct {
    uint32_t CURRENT_VALUE : 1;
    ///< This bit shows the current output value of the bfn_event module
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t WAITING : 1;
    ///< This bit indicates when the bfn_event module is waiting for the programmed
    ///< bfn_start time. In Repeat mode, this will only toggle low during the
    ///< single cycle of each event, so is not useful.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t DONE : 1;
    ///< This bit indicates that the bfn_module has reached its programmed
    ///< bfn time. In Repeate mode, this will only toggle high during the single
    ///< cycle of each event, so is not usefule.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t DEBUG : 29;
    ///< This field is different based on the DEBUG_MODE setting in the BFNE_CONFIG
    ///< register.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_bfne_stat_reg_t;

#define BFN_CSR_BFNE_STAT_DEFAULT (0x00000000U)
#define BFN_CSR_BFNE_STAT_RD_MASK (0xffffffffU)
#define BFN_CSR_BFNE_STAT_WR_MASK (0x00000000U)


///< This bit shows the current output value of the bfn_event module
#define BFN_CSR_BFNE_STAT_CURRENT_VAL_BF_OFF ( 0)
#define BFN_CSR_BFNE_STAT_CURRENT_VAL_BF_WID ( 1)
#define BFN_CSR_BFNE_STAT_CURRENT_VAL_BF_MSK (0x00000001)
#define BFN_CSR_BFNE_STAT_CURRENT_VAL_BF_DEF (0x00000000)

///< This bit indicates when the bfn_event module is waiting for the programmed
///< bfn_start time. In Repeat mode, this will only toggle low during the
///< single cycle of each event, so is not useful.
#define BFN_CSR_BFNE_STAT_WAITING_BF_OFF ( 1)
#define BFN_CSR_BFNE_STAT_WAITING_BF_WID ( 1)
#define BFN_CSR_BFNE_STAT_WAITING_BF_MSK (0x00000002)
#define BFN_CSR_BFNE_STAT_WAITING_BF_DEF (0x00000000)

///< This bit indicates that the bfn_module has reached its programmed
///< bfn time. In Repeate mode, this will only toggle high during the single
///< cycle of each event, so is not usefule.
#define BFN_CSR_BFNE_STAT_DONE_BF_OFF ( 2)
#define BFN_CSR_BFNE_STAT_DONE_BF_WID ( 1)
#define BFN_CSR_BFNE_STAT_DONE_BF_MSK (0x00000004)
#define BFN_CSR_BFNE_STAT_DONE_BF_DEF (0x00000000)

///< This field is different based on the DEBUG_MODE setting in the BFNE_CONFIG
///< register.
#define BFN_CSR_BFNE_STAT_DBG_BF_OFF ( 3)
#define BFN_CSR_BFNE_STAT_DBG_BF_WID (29)
#define BFN_CSR_BFNE_STAT_DBG_BF_MSK (0xFFFFFFF8)
#define BFN_CSR_BFNE_STAT_DBG_BF_DEF (0x00000000)
#define BFN_CSR_BFNE_STAT_ARR_SZ0 (4)
#define BFN_CSR_BFNE_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief BFN_CSR_COM_REG_START_LM[4] register description at address offset 0xd0
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/START_LM
  * START Latency Match Register
  */

typedef union {
  struct {
    uint32_t MATCH_VALUE : 18;
    ///< This is the value used to compare with Start latency count. If matched,
    ///< a start signal will assert to control the start of data transmission
    ///< if enabled. This value must be configured no later than MATCH_EN is
    ///< set.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 13;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
    uint32_t MATCH_EN : 1;
    ///< When high, this bit enables the use of MATCH_VALUE to compare with
    ///< START_L_CNT to generate start control. After setting this bit to high,
    ///< software should not clear this bit.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_start_lm_reg_t;

#define BFN_CSR_START_LM_DEFAULT (0x00000000U)
#define BFN_CSR_START_LM_RD_MASK (0x8003ffffU)
#define BFN_CSR_START_LM_WR_MASK (0x8003ffffU)


///< This is the value used to compare with Start latency count. If matched,
///< a start signal will assert to control the start of data transmission
///< if enabled. This value must be configured no later than MATCH_EN is
///< set.
#define BFN_CSR_START_LM_MATCH_VAL_BF_OFF ( 0)
#define BFN_CSR_START_LM_MATCH_VAL_BF_WID (18)
#define BFN_CSR_START_LM_MATCH_VAL_BF_MSK (0x0003FFFF)
#define BFN_CSR_START_LM_MATCH_VAL_BF_DEF (0x00000000)

///< When high, this bit enables the use of MATCH_VALUE to compare with
///< START_L_CNT to generate start control. After setting this bit to high,
///< software should not clear this bit.
#define BFN_CSR_START_LM_MATCH_EN_BF_OFF (31)
#define BFN_CSR_START_LM_MATCH_EN_BF_WID ( 1)
#define BFN_CSR_START_LM_MATCH_EN_BF_MSK (0x80000000)
#define BFN_CSR_START_LM_MATCH_EN_BF_DEF (0x00000000)
#define BFN_CSR_START_LM_ARR_SZ0 (4)
#define BFN_CSR_START_LM_ARRAY_STRIDE0 (0x0004)


/** @brief BFN_CSR_COM_REG_START_L_CNT[4] register description at address offset 0xe0
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/START_L_CNT
  * Start Latency Count Register
  */

typedef union {
  struct {
    uint32_t LATENCY_VALUE : 18;
    ///< This is the value of latency count of start signal from either DRF
    ///< synchronized JESD start signal or optionally BFN. The count is number
    ///< of cycles in DRF clock.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_start_l_cnt_reg_t;

#define BFN_CSR_START_L_CNT_DEFAULT (0x00000000U)
#define BFN_CSR_START_L_CNT_RD_MASK (0x0003ffffU)
#define BFN_CSR_START_L_CNT_WR_MASK (0x00000000U)


///< This is the value of latency count of start signal from either DRF
///< synchronized JESD start signal or optionally BFN. The count is number
///< of cycles in DRF clock.
#define BFN_CSR_START_L_CNT_LATENCY_VAL_BF_OFF ( 0)
#define BFN_CSR_START_L_CNT_LATENCY_VAL_BF_WID (18)
#define BFN_CSR_START_L_CNT_LATENCY_VAL_BF_MSK (0x0003FFFF)
#define BFN_CSR_START_L_CNT_LATENCY_VAL_BF_DEF (0x00000000)
#define BFN_CSR_START_L_CNT_ARR_SZ0 (4)
#define BFN_CSR_START_L_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief BFN_CSR_COM_REG_CAP_MODE_CTRL register description at address offset 0xf8
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/CAP_MODE_CTRL
  * Data Capture Mode Control Register
  */

typedef union {
  struct {
    uint32_t ON_SET_COUNT : 10;
    ///< This defines the number of repeating capture data block sets for ON
    ///< state, which sends data to Capture Memory. 0 = 1 set, and 0x3ff =
    ///< 1k sets.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t OFF_SET_COUNT : 10;
    ///< This defines the number of repeating capture data block sets for OFF
    ///< state, which stops sending data to Capture Memory. 0 = 1 set, and
    ///< 0x3ff = 1k sets.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
    uint32_t CONTINUOUS_MODE : 1;
    ///< When set, this bit enables the mode of capturing data continuously.
    ///< The data source is selected by CAPTURE_EN_* in CAP_DATA_CTRL register,
    ///< and CAPTURE_SIZE_* is ignored.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t ONOFF_MODE_EN : 1;
    ///< When set, this bit enables ON/OFF mode of data capture.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_cap_mode_ctrl_reg_t;

#define BFN_CSR_CAP_MODE_CTRL_DEFAULT (0x00000000U)
#define BFN_CSR_CAP_MODE_CTRL_RD_MASK (0xc3ff03ffU)
#define BFN_CSR_CAP_MODE_CTRL_WR_MASK (0xc3ff03ffU)


///< This defines the number of repeating capture data block sets for ON
///< state, which sends data to Capture Memory. 0 = 1 set, and 0x3ff =
///< 1k sets.
#define BFN_CSR_CAP_MODE_CTRL_ON_SET_CNT_BF_OFF ( 0)
#define BFN_CSR_CAP_MODE_CTRL_ON_SET_CNT_BF_WID (10)
#define BFN_CSR_CAP_MODE_CTRL_ON_SET_CNT_BF_MSK (0x000003FF)
#define BFN_CSR_CAP_MODE_CTRL_ON_SET_CNT_BF_DEF (0x00000000)

///< This defines the number of repeating capture data block sets for OFF
///< state, which stops sending data to Capture Memory. 0 = 1 set, and
///< 0x3ff = 1k sets.
#define BFN_CSR_CAP_MODE_CTRL_OFF_SET_CNT_BF_OFF (16)
#define BFN_CSR_CAP_MODE_CTRL_OFF_SET_CNT_BF_WID (10)
#define BFN_CSR_CAP_MODE_CTRL_OFF_SET_CNT_BF_MSK (0x03FF0000)
#define BFN_CSR_CAP_MODE_CTRL_OFF_SET_CNT_BF_DEF (0x00000000)

///< When set, this bit enables the mode of capturing data continuously.
///< The data source is selected by CAPTURE_EN_* in CAP_DATA_CTRL register,
///< and CAPTURE_SIZE_* is ignored.
#define BFN_CSR_CAP_MODE_CTRL_CONTINUOUS_MODE_BF_OFF (30)
#define BFN_CSR_CAP_MODE_CTRL_CONTINUOUS_MODE_BF_WID ( 1)
#define BFN_CSR_CAP_MODE_CTRL_CONTINUOUS_MODE_BF_MSK (0x40000000)
#define BFN_CSR_CAP_MODE_CTRL_CONTINUOUS_MODE_BF_DEF (0x00000000)

///< When set, this bit enables ON/OFF mode of data capture.
#define BFN_CSR_CAP_MODE_CTRL_ONOFF_MODE_EN_BF_OFF (31)
#define BFN_CSR_CAP_MODE_CTRL_ONOFF_MODE_EN_BF_WID ( 1)
#define BFN_CSR_CAP_MODE_CTRL_ONOFF_MODE_EN_BF_MSK (0x80000000)
#define BFN_CSR_CAP_MODE_CTRL_ONOFF_MODE_EN_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_CAP_DATA_CTRL register description at address offset 0xfc
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/CAP_DATA_CTRL
  * Capture Memory Data Control Register
  */

typedef union {
  struct {
    uint32_t CAPTURE_SIZE_0 : 15;
    ///< This defines capture data block size for data from PDPD 0. It's in
    ///< number of 256-bit data(8 samples). 0 = 1 256-bit data(8 samples),
    ///< 0x7fff = 32k 256-bit data(256k samples).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CAPTURE_EN_0 : 1;
    ///< When set, this bit enables data capture from PDPD 0.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t CAPTURE_SIZE_1 : 15;
    ///< This defines capture data block size for data from PDPD 1. It's in
    ///< number of 256-bit data(8 samples). 0 = 1 256-bit data(8 samples),
    ///< 0x7fff = 32k 256-bit data(256k samples).
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CAPTURE_EN_1 : 1;
    ///< When set, this bit enables data capture from PDPD 1.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_cap_data_ctrl_reg_t;

#define BFN_CSR_CAP_DATA_CTRL_DEFAULT (0x00000000U)
#define BFN_CSR_CAP_DATA_CTRL_RD_MASK (0xffffffffU)
#define BFN_CSR_CAP_DATA_CTRL_WR_MASK (0xffffffffU)


///< This defines capture data block size for data from PDPD 0. It's in
///< number of 256-bit data(8 samples). 0 = 1 256-bit data(8 samples),
///< 0x7fff = 32k 256-bit data(256k samples).
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_0_BF_OFF ( 0)
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_0_BF_WID (15)
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_0_BF_MSK (0x00007FFF)
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_0_BF_DEF (0x00000000)

///< When set, this bit enables data capture from PDPD 0.
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_0_BF_OFF (15)
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_0_BF_WID ( 1)
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_0_BF_MSK (0x00008000)
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_0_BF_DEF (0x00000000)

///< This defines capture data block size for data from PDPD 1. It's in
///< number of 256-bit data(8 samples). 0 = 1 256-bit data(8 samples),
///< 0x7fff = 32k 256-bit data(256k samples).
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_1_BF_OFF (16)
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_1_BF_WID (15)
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_1_BF_MSK (0x7FFF0000)
#define BFN_CSR_CAP_DATA_CTRL_CAP_SIZE_1_BF_DEF (0x00000000)

///< When set, this bit enables data capture from PDPD 1.
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_1_BF_OFF (31)
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_1_BF_WID ( 1)
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_1_BF_MSK (0x80000000)
#define BFN_CSR_CAP_DATA_CTRL_CAP_EN_1_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R0 register description at address offset 0x100
  *
  * Register default value:        0x40000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r0
  * AW_smon CONTROL0 register
  */

typedef union {
  struct {
    uint32_t SMON_ENABLE : 1;
    ///< enable the SMON counters
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t RSVD0 : 3;
    ///< reserved
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SMON0_FUNCTION : 3;
    ///< SMON0 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SMON0_FUNCTION_COMPARE : 1;
    ///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t SMON1_FUNCTION : 3;
    ///< SMON1 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t SMON1_FUNCTION_COMPARE : 1;
    ///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t SMON_MODE : 4;
    ///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
    ///< independantly as their function is configured.       4'h1 = Average
    ///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
    ///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
    ///< values. For multiple stop for a single start, accumulate  start_to_stop1,
    ///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
    ///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
    ///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
    ///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
    ///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
    ///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
    ///< the first start_to_stop1 if there are multiple stop for each start.
    ///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
    ///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
    ///< stop for each start.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t STOPCOUNTEROVFL : 1;
    ///< configure to stop on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INTCOUNTEROVFL : 1;
    ///< configure to interupt on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t STATCOUNTER0OVFL : 1;
    ///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
    ///< AccessType="RW/V" BitOffset="18" ResetValue="0x0"
    uint32_t STATCOUNTER1OVFL : 1;
    ///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
    ///< AccessType="RW/V" BitOffset="19" ResetValue="0x0"
    uint32_t STOPTIMEROVFL : 1;
    ///< configure to stop on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t INTTIMEROVFL : 1;
    ///< configure to interrupt on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t STATTIMEROVFL : 1;
    ///< status of timer overflow. A value of '1' signifies timer overflow,
    ///< or timer>maxvalue.
    ///< AccessType="RW/V" BitOffset="22" ResetValue="0x0"
    uint32_t RSVD1 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t TIMER_PRESCALE : 5;
    ///< timer prescale    5'h00 = mode00, increment timer every      1 clock
    ///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
    ///< increment timer every      4 clocks    5'h03 = mode03, increment timer
    ///< every      8 clocks    5'h04 = mode04, increment timer every     16
    ///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
    ///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
    ///< timer every    128 clocks    5'h08 = mode08, increment timer every
    ///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
    ///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
    ///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
    ///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
    ///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
    ///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
    ///< timer every  65536 clocks    5'h11 = mode17, increment timer every
    ///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
    ///< 5'h13 = mode19, increment timer every 524288 clocks
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t RSVD2 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t VERSION : 2;
    ///< version
    ///< AccessType="RO" BitOffset="30" ResetValue="0x1"
  } ;
  uint32_t value;
} bfn_csr_smon_r0_reg_t;

#define BFN_CSR_SMON_R0_DEFAULT (0x40000000U)
#define BFN_CSR_SMON_R0_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R0_WR_MASK (0x3fffffffU)


///< enable the SMON counters
#define BFN_CSR_SMON_R0_SMON_EN_BF_OFF ( 0)
#define BFN_CSR_SMON_R0_SMON_EN_BF_WID ( 1)
#define BFN_CSR_SMON_R0_SMON_EN_BF_MSK (0x00000001)
#define BFN_CSR_SMON_R0_SMON_EN_BF_DEF (0x00000000)

///< reserved
#define BFN_CSR_SMON_R0_RSVD0_BF_OFF ( 1)
#define BFN_CSR_SMON_R0_RSVD0_BF_WID ( 3)
#define BFN_CSR_SMON_R0_RSVD0_BF_MSK (0x0000000E)
#define BFN_CSR_SMON_R0_RSVD0_BF_DEF (0x00000000)

///< SMON0 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_BF_OFF ( 4)
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_BF_WID ( 3)
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_BF_MSK (0x00000070)
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_BF_DEF (0x00000000)

///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_OFF ( 7)
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_WID ( 1)
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_MSK (0x00000080)
#define BFN_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON1 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_BF_OFF ( 8)
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_BF_WID ( 3)
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_BF_MSK (0x00000700)
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_BF_DEF (0x00000000)

///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_OFF (11)
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_WID ( 1)
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_MSK (0x00000800)
#define BFN_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
///< independantly as their function is configured.       4'h1 = Average
///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
///< values. For multiple stop for a single start, accumulate  start_to_stop1,
///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
///< the first start_to_stop1 if there are multiple stop for each start.
///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
///< stop for each start.
#define BFN_CSR_SMON_R0_SMON_MODE_BF_OFF (12)
#define BFN_CSR_SMON_R0_SMON_MODE_BF_WID ( 4)
#define BFN_CSR_SMON_R0_SMON_MODE_BF_MSK (0x0000F000)
#define BFN_CSR_SMON_R0_SMON_MODE_BF_DEF (0x00000000)

///< configure to stop on counter0 or counter1 overflow
#define BFN_CSR_SMON_R0_STOPCNTEROVFL_BF_OFF (16)
#define BFN_CSR_SMON_R0_STOPCNTEROVFL_BF_WID ( 1)
#define BFN_CSR_SMON_R0_STOPCNTEROVFL_BF_MSK (0x00010000)
#define BFN_CSR_SMON_R0_STOPCNTEROVFL_BF_DEF (0x00000000)

///< configure to interupt on counter0 or counter1 overflow
#define BFN_CSR_SMON_R0_INTCNTEROVFL_BF_OFF (17)
#define BFN_CSR_SMON_R0_INTCNTEROVFL_BF_WID ( 1)
#define BFN_CSR_SMON_R0_INTCNTEROVFL_BF_MSK (0x00020000)
#define BFN_CSR_SMON_R0_INTCNTEROVFL_BF_DEF (0x00000000)

///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
#define BFN_CSR_SMON_R0_STATCNTER0OVFL_BF_OFF (18)
#define BFN_CSR_SMON_R0_STATCNTER0OVFL_BF_WID ( 1)
#define BFN_CSR_SMON_R0_STATCNTER0OVFL_BF_MSK (0x00040000)
#define BFN_CSR_SMON_R0_STATCNTER0OVFL_BF_DEF (0x00000000)

///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
#define BFN_CSR_SMON_R0_STATCNTER1OVFL_BF_OFF (19)
#define BFN_CSR_SMON_R0_STATCNTER1OVFL_BF_WID ( 1)
#define BFN_CSR_SMON_R0_STATCNTER1OVFL_BF_MSK (0x00080000)
#define BFN_CSR_SMON_R0_STATCNTER1OVFL_BF_DEF (0x00000000)

///< configure to stop on timer overflow or timer>maxvalue
#define BFN_CSR_SMON_R0_STOPTIMEROVFL_BF_OFF (20)
#define BFN_CSR_SMON_R0_STOPTIMEROVFL_BF_WID ( 1)
#define BFN_CSR_SMON_R0_STOPTIMEROVFL_BF_MSK (0x00100000)
#define BFN_CSR_SMON_R0_STOPTIMEROVFL_BF_DEF (0x00000000)

///< configure to interrupt on timer overflow or timer>maxvalue
#define BFN_CSR_SMON_R0_INTTIMEROVFL_BF_OFF (21)
#define BFN_CSR_SMON_R0_INTTIMEROVFL_BF_WID ( 1)
#define BFN_CSR_SMON_R0_INTTIMEROVFL_BF_MSK (0x00200000)
#define BFN_CSR_SMON_R0_INTTIMEROVFL_BF_DEF (0x00000000)

///< status of timer overflow. A value of '1' signifies timer overflow,
///< or timer>maxvalue.
#define BFN_CSR_SMON_R0_STATTIMEROVFL_BF_OFF (22)
#define BFN_CSR_SMON_R0_STATTIMEROVFL_BF_WID ( 1)
#define BFN_CSR_SMON_R0_STATTIMEROVFL_BF_MSK (0x00400000)
#define BFN_CSR_SMON_R0_STATTIMEROVFL_BF_DEF (0x00000000)

///< reserved
#define BFN_CSR_SMON_R0_RSVD1_BF_OFF (23)
#define BFN_CSR_SMON_R0_RSVD1_BF_WID ( 1)
#define BFN_CSR_SMON_R0_RSVD1_BF_MSK (0x00800000)
#define BFN_CSR_SMON_R0_RSVD1_BF_DEF (0x00000000)

///< timer prescale    5'h00 = mode00, increment timer every      1 clock
///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
///< increment timer every      4 clocks    5'h03 = mode03, increment timer
///< every      8 clocks    5'h04 = mode04, increment timer every     16
///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
///< timer every    128 clocks    5'h08 = mode08, increment timer every
///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
///< timer every  65536 clocks    5'h11 = mode17, increment timer every
///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
///< 5'h13 = mode19, increment timer every 524288 clocks
#define BFN_CSR_SMON_R0_TIMER_PRESCALE_BF_OFF (24)
#define BFN_CSR_SMON_R0_TIMER_PRESCALE_BF_WID ( 5)
#define BFN_CSR_SMON_R0_TIMER_PRESCALE_BF_MSK (0x1F000000)
#define BFN_CSR_SMON_R0_TIMER_PRESCALE_BF_DEF (0x00000000)

///< reserved
#define BFN_CSR_SMON_R0_RSVD2_BF_OFF (29)
#define BFN_CSR_SMON_R0_RSVD2_BF_WID ( 1)
#define BFN_CSR_SMON_R0_RSVD2_BF_MSK (0x20000000)
#define BFN_CSR_SMON_R0_RSVD2_BF_DEF (0x00000000)

///< version
#define BFN_CSR_SMON_R0_VER_BF_OFF (30)
#define BFN_CSR_SMON_R0_VER_BF_WID ( 2)
#define BFN_CSR_SMON_R0_VER_BF_MSK (0xC0000000)
#define BFN_CSR_SMON_R0_VER_BF_DEF (0x40000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R1 register description at address offset 0x104
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r1
  * AW_smon CONTROL1 register
  */

typedef union {
  struct {
    uint32_t MODE0 : 8;
    ///< select input signal for SMON0 engine. <br/> 0x0  = Triggered by PDPD
    ///< 0 start signal from V2D BFN module, pd_start[0]. Counter input is
    ///< connected to 1. <br/> 0x1  = Triggered by PDPD 1 start signal from
    ///< V2D BFN module, pd_start[1]. Counter input is connected to 1. <br/>
    ///< 0x2  = Triggered by Tx A path 0 start signal from V2D BFN module,
    ///< tx_start[0]. Counter input is connected to 1. <br/> 0x3  = Triggered
    ///< by Tx A path 1 start signal from V2D BFN module, tx_start[1]. Counter
    ///< input is connected to 1. <br/> 0x4  = Triggered by Quad start signal
    ///< from JESD or even numbered V2D, i_drf_quad_start. Counter input is
    ///< connected to 1. <br/> 0x5  = Triggered by V2D start signal from even
    ///< numbered V2D, i_drf_quad_start. Counter input is connected to 1. <br/>
    ///< 0x6  = Triggered by PDPD 0 ingress main data valid signal from V2D
    ///< 0, pd_data_main_in_v[0]. Counter input is connected to ingress main
    ///< data[31:0]. <br/> 0x7  = Triggered by PDPD 1 ingress main data valid
    ///< signal from V2D 1, pd_data_main_in_v[1]. Counter input is connected
    ///< to ingress main data[31:0]. <br/> 0x8  = Triggered by PDPD 0 egress
    ///< main data valid signal from PDPD 0, pd_data_main_out_v[0]. Counter
    ///< input is connected to egress main data[31:0]. <br/> 0x9  = Triggered
    ///< by PDPD 1 egress main data valid signal from PDPD 1, pd_data_main_out_v[1].
    ///< Counter input is connected to egress main data[31:0]. <br/> 0xA  =
    ///< Triggered by PDPD 0 ingress extra data valid signal from V2D 0, pd_data_extra_in_v[0].
    ///< Counter input is connected to ingress extra data[31:0]. <br/> 0xB
    ///< = Triggered by PDPD 1 ingress extra data valid signal from V2D 1,
    ///< pd_data_extra_in_v[1]. Counter input is connected to ingress extra
    ///< data[31:0]. <br/> 0xC  = Triggered by PDPD 0 ganging input data valid
    ///< signal from PDPD 1, pd_data_gang_in_v[0]. Counter input is connected
    ///< to ganging input data[31:0]. <br/> 0xD  = Triggered by PDPD 1 ganging
    ///< input data valid signal tied to 0, pd_data_gang_in_v[1]. Counter input
    ///< is connected to 0. <br/> 0xE  = Triggered by PDPD 0 Coefficient Update
    ///< valid signal from V2D 0, pd_data_coeff_in_v[0]. Counter input is connected
    ///< to Coefficient Update data[31:0]. <br/> 0xF  = Triggered by PDPD 1
    ///< Coefficient Update valid signal from V2D 1, pd_data_coeff_in_v[1].
    ///< Counter input is connected to Coefficient Update data[31:0]. <br/>
    ///< 0x10 = Triggered by PDPD 0 Coefficient Update last cycle signal from
    ///< V2D 0, pd_data_coeff_in_v[0] AND pd_data_coeff_in_last[0]. Counter
    ///< input is connected to  31d0, pd_data_coeff_in_err[0] . <br/> 0x11
    ///< = Triggered by PDPD 1 Coefficient Update last cycle signal from V2D
    ///< 1, pd_data_coeff_in_v[1] AND pd_data_coeff_in_last[1]. Counter input
    ///< is connected to  31d0, pd_data_coeff_in_err[1] . <br/> 0x12 = Triggered
    ///< by DRF Tx Channel 0 data valid signal to DRF, o_drf_tx_0_v. Counter
    ///< input is connected to DRF Tx data[31:0]. <br/> 0x13 = Triggered by
    ///< DRF Rx Channel 0 data valid signal from DRF, i_drf_rx_0_v. Counter
    ///< input is connected to DRF Rx data[31:0]. <br/> 0x14 = Triggered by
    ///< DRF Tx Channel 1 data valid signal to DRF, o_drf_tx_1_v. Counter input
    ///< is connected to DRF Tx data[31:0]. <br/> 0x15 = Triggered by DRF Rx
    ///< Channel 1 data valid signal from DRF, i_drf_rx_1_v. Counter input
    ///< is connected to DRF Rx data[31:0]. <br/> 0x16 = Triggered by Capture
    ///< Memory data valid signal from odd numbered V2D, i_mem_v. Counter input
    ///< is connected to Capture Memory data[31:0]. <br/> 0x17 = Triggered
    ///< by Capture Memory data valid signal from odd numbered V2D, i_mem_v.
    ///< Counter input is connected to  i_v2d_odd, 29d0, i_mem_id . <br/> 0x18
    ///< = Triggered by Capture Memory output data valid signal from V2D, o_mem_v.
    ///< Counter input is connected to Capture Memory data[31:0]. <br/> 0x19
    ///< = Triggered by Capture Memory otuput data valid signal from V2D, o_mem_v.
    ///< Counter input is connected to  i_v2d_odd, 29d0, o_mem_id .
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MODE1 : 8;
    ///< select input signal for SMON1 engine. <br/> 0x0  = Triggered by PDPD
    ///< 0 start signal from V2D BFN module, pd_start[0]. Counter input is
    ///< connected to 1. <br/> 0x1  = Triggered by PDPD 1 start signal from
    ///< V2D BFN module, pd_start[1]. Counter input is connected to 1. <br/>
    ///< 0x2  = Triggered by Tx A path 0 start signal from V2D BFN module,
    ///< tx_start[0]. Counter input is connected to 1. <br/> 0x3  = Triggered
    ///< by Tx A path 1 start signal from V2D BFN module, tx_start[1]. Counter
    ///< input is connected to 1. <br/> 0x4  = Triggered by Quad start signal
    ///< from JESD or even numbered V2D, i_drf_quad_start. Counter input is
    ///< connected to 1. <br/> 0x5  = Triggered by V2D start signal from even
    ///< numbered V2D, i_drf_quad_start. Counter input is connected to 1. <br/>
    ///< 0x6  = Triggered by PDPD 0 ingress main data valid signal from V2D
    ///< 0, pd_data_main_in_v[0]. Counter input is connected to ingress main
    ///< data[31:0]. <br/> 0x7  = Triggered by PDPD 1 ingress main data valid
    ///< signal from V2D 1, pd_data_main_in_v[1]. Counter input is connected
    ///< to ingress main data[31:0]. <br/> 0x8  = Triggered by PDPD 0 egress
    ///< main data valid signal from PDPD 0, pd_data_main_out_v[0]. Counter
    ///< input is connected to egress main data[31:0]. <br/> 0x9  = Triggered
    ///< by PDPD 1 egress main data valid signal from PDPD 1, pd_data_main_out_v[1].
    ///< Counter input is connected to egress main data[31:0]. <br/> 0xA  =
    ///< Triggered by PDPD 0 ingress extra data valid signal from V2D 0, pd_data_extra_in_v[0].
    ///< Counter input is connected to ingress extra data[31:0]. <br/> 0xB
    ///< = Triggered by PDPD 1 ingress extra data valid signal from V2D 1,
    ///< pd_data_extra_in_v[1]. Counter input is connected to ingress extra
    ///< data[31:0]. <br/> 0xC  = Triggered by PDPD 0 ganging input data valid
    ///< signal from PDPD 1, pd_data_gang_in_v[0]. Counter input is connected
    ///< to ganging input data[31:0]. <br/> 0xD  = Triggered by PDPD 1 ganging
    ///< input data valid signal tied to 0, pd_data_gang_in_v[1]. Counter input
    ///< is connected to 0. <br/> 0xE  = Triggered by PDPD 0 Coefficient Update
    ///< valid signal from V2D 0, pd_data_coeff_in_v[0]. Counter input is connected
    ///< to Coefficient Update data[31:0]. <br/> 0xF  = Triggered by PDPD 1
    ///< Coefficient Update valid signal from V2D 1, pd_data_coeff_in_v[1].
    ///< Counter input is connected to Coefficient Update data[31:0]. <br/>
    ///< 0x10 = Triggered by PDPD 0 Coefficient Update last cycle signal from
    ///< V2D 0, pd_data_coeff_in_v[0] AND pd_data_coeff_in_last[0]. Counter
    ///< input is connected to  31d0, pd_data_coeff_in_err[0] . <br/> 0x11
    ///< = Triggered by PDPD 1 Coefficient Update last cycle signal from V2D
    ///< 1, pd_data_coeff_in_v[1] AND pd_data_coeff_in_last[1]. Counter input
    ///< is connected to  31d0, pd_data_coeff_in_err[1] . <br/> 0x12 = Triggered
    ///< by DRF Tx Channel 0 data valid signal to DRF, o_drf_tx_0_v. Counter
    ///< input is connected to DRF Tx data[31:0]. <br/> 0x13 = Triggered by
    ///< DRF Rx Channel 0 data valid signal from DRF, i_drf_rx_0_v. Counter
    ///< input is connected to DRF Rx data[31:0]. <br/> 0x14 = Triggered by
    ///< DRF Tx Channel 1 data valid signal to DRF, o_drf_tx_1_v. Counter input
    ///< is connected to DRF Tx data[31:0]. <br/> 0x15 = Triggered by DRF Rx
    ///< Channel 1 data valid signal from DRF, i_drf_rx_1_v. Counter input
    ///< is connected to DRF Rx data[31:0]. <br/> 0x16 = Triggered by Capture
    ///< Memory data valid signal from odd numbered V2D, i_mem_v. Counter input
    ///< is connected to Capture Memory data[31:0]. <br/> 0x17 = Triggered
    ///< by Capture Memory data valid signal from odd numbered V2D, i_mem_v.
    ///< Counter input is connected to  i_v2d_odd, 29d0, i_mem_id . <br/> 0x18
    ///< = Triggered by Capture Memory output data valid signal from V2D, o_mem_v.
    ///< Counter input is connected to Capture Memory data[31:0]. <br/> 0x19
    ///< = Triggered by Capture Memory otuput data valid signal from V2D, o_mem_v.
    ///< Counter input is connected to  i_v2d_odd, 29d0, o_mem_id .
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t RSVD : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_smon_r1_reg_t;

#define BFN_CSR_SMON_R1_DEFAULT (0x00000000U)
#define BFN_CSR_SMON_R1_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R1_WR_MASK (0xffffffffU)


///< select input signal for SMON0 engine. <br/> 0x0  = Triggered by PDPD
///< 0 start signal from V2D BFN module, pd_start[0]. Counter input is
///< connected to 1. <br/> 0x1  = Triggered by PDPD 1 start signal from
///< V2D BFN module, pd_start[1]. Counter input is connected to 1. <br/>
///< 0x2  = Triggered by Tx A path 0 start signal from V2D BFN module,
///< tx_start[0]. Counter input is connected to 1. <br/> 0x3  = Triggered
///< by Tx A path 1 start signal from V2D BFN module, tx_start[1]. Counter
///< input is connected to 1. <br/> 0x4  = Triggered by Quad start signal
///< from JESD or even numbered V2D, i_drf_quad_start. Counter input is
///< connected to 1. <br/> 0x5  = Triggered by V2D start signal from even
///< numbered V2D, i_drf_quad_start. Counter input is connected to 1. <br/>
///< 0x6  = Triggered by PDPD 0 ingress main data valid signal from V2D
///< 0, pd_data_main_in_v[0]. Counter input is connected to ingress main
///< data[31:0]. <br/> 0x7  = Triggered by PDPD 1 ingress main data valid
///< signal from V2D 1, pd_data_main_in_v[1]. Counter input is connected
///< to ingress main data[31:0]. <br/> 0x8  = Triggered by PDPD 0 egress
///< main data valid signal from PDPD 0, pd_data_main_out_v[0]. Counter
///< input is connected to egress main data[31:0]. <br/> 0x9  = Triggered
///< by PDPD 1 egress main data valid signal from PDPD 1, pd_data_main_out_v[1].
///< Counter input is connected to egress main data[31:0]. <br/> 0xA  =
///< Triggered by PDPD 0 ingress extra data valid signal from V2D 0, pd_data_extra_in_v[0].
///< Counter input is connected to ingress extra data[31:0]. <br/> 0xB
///< = Triggered by PDPD 1 ingress extra data valid signal from V2D 1,
///< pd_data_extra_in_v[1]. Counter input is connected to ingress extra
///< data[31:0]. <br/> 0xC  = Triggered by PDPD 0 ganging input data valid
///< signal from PDPD 1, pd_data_gang_in_v[0]. Counter input is connected
///< to ganging input data[31:0]. <br/> 0xD  = Triggered by PDPD 1 ganging
///< input data valid signal tied to 0, pd_data_gang_in_v[1]. Counter input
///< is connected to 0. <br/> 0xE  = Triggered by PDPD 0 Coefficient Update
///< valid signal from V2D 0, pd_data_coeff_in_v[0]. Counter input is connected
///< to Coefficient Update data[31:0]. <br/> 0xF  = Triggered by PDPD 1
///< Coefficient Update valid signal from V2D 1, pd_data_coeff_in_v[1].
///< Counter input is connected to Coefficient Update data[31:0]. <br/>
///< 0x10 = Triggered by PDPD 0 Coefficient Update last cycle signal from
///< V2D 0, pd_data_coeff_in_v[0] AND pd_data_coeff_in_last[0]. Counter
///< input is connected to  31d0, pd_data_coeff_in_err[0] . <br/> 0x11
///< = Triggered by PDPD 1 Coefficient Update last cycle signal from V2D
///< 1, pd_data_coeff_in_v[1] AND pd_data_coeff_in_last[1]. Counter input
///< is connected to  31d0, pd_data_coeff_in_err[1] . <br/> 0x12 = Triggered
///< by DRF Tx Channel 0 data valid signal to DRF, o_drf_tx_0_v. Counter
///< input is connected to DRF Tx data[31:0]. <br/> 0x13 = Triggered by
///< DRF Rx Channel 0 data valid signal from DRF, i_drf_rx_0_v. Counter
///< input is connected to DRF Rx data[31:0]. <br/> 0x14 = Triggered by
///< DRF Tx Channel 1 data valid signal to DRF, o_drf_tx_1_v. Counter input
///< is connected to DRF Tx data[31:0]. <br/> 0x15 = Triggered by DRF Rx
///< Channel 1 data valid signal from DRF, i_drf_rx_1_v. Counter input
///< is connected to DRF Rx data[31:0]. <br/> 0x16 = Triggered by Capture
///< Memory data valid signal from odd numbered V2D, i_mem_v. Counter input
///< is connected to Capture Memory data[31:0]. <br/> 0x17 = Triggered
///< by Capture Memory data valid signal from odd numbered V2D, i_mem_v.
///< Counter input is connected to  i_v2d_odd, 29d0, i_mem_id . <br/> 0x18
///< = Triggered by Capture Memory output data valid signal from V2D, o_mem_v.
///< Counter input is connected to Capture Memory data[31:0]. <br/> 0x19
///< = Triggered by Capture Memory otuput data valid signal from V2D, o_mem_v.
///< Counter input is connected to  i_v2d_odd, 29d0, o_mem_id .
#define BFN_CSR_SMON_R1_MODE0_BF_OFF ( 0)
#define BFN_CSR_SMON_R1_MODE0_BF_WID ( 8)
#define BFN_CSR_SMON_R1_MODE0_BF_MSK (0x000000FF)
#define BFN_CSR_SMON_R1_MODE0_BF_DEF (0x00000000)

///< select input signal for SMON1 engine. <br/> 0x0  = Triggered by PDPD
///< 0 start signal from V2D BFN module, pd_start[0]. Counter input is
///< connected to 1. <br/> 0x1  = Triggered by PDPD 1 start signal from
///< V2D BFN module, pd_start[1]. Counter input is connected to 1. <br/>
///< 0x2  = Triggered by Tx A path 0 start signal from V2D BFN module,
///< tx_start[0]. Counter input is connected to 1. <br/> 0x3  = Triggered
///< by Tx A path 1 start signal from V2D BFN module, tx_start[1]. Counter
///< input is connected to 1. <br/> 0x4  = Triggered by Quad start signal
///< from JESD or even numbered V2D, i_drf_quad_start. Counter input is
///< connected to 1. <br/> 0x5  = Triggered by V2D start signal from even
///< numbered V2D, i_drf_quad_start. Counter input is connected to 1. <br/>
///< 0x6  = Triggered by PDPD 0 ingress main data valid signal from V2D
///< 0, pd_data_main_in_v[0]. Counter input is connected to ingress main
///< data[31:0]. <br/> 0x7  = Triggered by PDPD 1 ingress main data valid
///< signal from V2D 1, pd_data_main_in_v[1]. Counter input is connected
///< to ingress main data[31:0]. <br/> 0x8  = Triggered by PDPD 0 egress
///< main data valid signal from PDPD 0, pd_data_main_out_v[0]. Counter
///< input is connected to egress main data[31:0]. <br/> 0x9  = Triggered
///< by PDPD 1 egress main data valid signal from PDPD 1, pd_data_main_out_v[1].
///< Counter input is connected to egress main data[31:0]. <br/> 0xA  =
///< Triggered by PDPD 0 ingress extra data valid signal from V2D 0, pd_data_extra_in_v[0].
///< Counter input is connected to ingress extra data[31:0]. <br/> 0xB
///< = Triggered by PDPD 1 ingress extra data valid signal from V2D 1,
///< pd_data_extra_in_v[1]. Counter input is connected to ingress extra
///< data[31:0]. <br/> 0xC  = Triggered by PDPD 0 ganging input data valid
///< signal from PDPD 1, pd_data_gang_in_v[0]. Counter input is connected
///< to ganging input data[31:0]. <br/> 0xD  = Triggered by PDPD 1 ganging
///< input data valid signal tied to 0, pd_data_gang_in_v[1]. Counter input
///< is connected to 0. <br/> 0xE  = Triggered by PDPD 0 Coefficient Update
///< valid signal from V2D 0, pd_data_coeff_in_v[0]. Counter input is connected
///< to Coefficient Update data[31:0]. <br/> 0xF  = Triggered by PDPD 1
///< Coefficient Update valid signal from V2D 1, pd_data_coeff_in_v[1].
///< Counter input is connected to Coefficient Update data[31:0]. <br/>
///< 0x10 = Triggered by PDPD 0 Coefficient Update last cycle signal from
///< V2D 0, pd_data_coeff_in_v[0] AND pd_data_coeff_in_last[0]. Counter
///< input is connected to  31d0, pd_data_coeff_in_err[0] . <br/> 0x11
///< = Triggered by PDPD 1 Coefficient Update last cycle signal from V2D
///< 1, pd_data_coeff_in_v[1] AND pd_data_coeff_in_last[1]. Counter input
///< is connected to  31d0, pd_data_coeff_in_err[1] . <br/> 0x12 = Triggered
///< by DRF Tx Channel 0 data valid signal to DRF, o_drf_tx_0_v. Counter
///< input is connected to DRF Tx data[31:0]. <br/> 0x13 = Triggered by
///< DRF Rx Channel 0 data valid signal from DRF, i_drf_rx_0_v. Counter
///< input is connected to DRF Rx data[31:0]. <br/> 0x14 = Triggered by
///< DRF Tx Channel 1 data valid signal to DRF, o_drf_tx_1_v. Counter input
///< is connected to DRF Tx data[31:0]. <br/> 0x15 = Triggered by DRF Rx
///< Channel 1 data valid signal from DRF, i_drf_rx_1_v. Counter input
///< is connected to DRF Rx data[31:0]. <br/> 0x16 = Triggered by Capture
///< Memory data valid signal from odd numbered V2D, i_mem_v. Counter input
///< is connected to Capture Memory data[31:0]. <br/> 0x17 = Triggered
///< by Capture Memory data valid signal from odd numbered V2D, i_mem_v.
///< Counter input is connected to  i_v2d_odd, 29d0, i_mem_id . <br/> 0x18
///< = Triggered by Capture Memory output data valid signal from V2D, o_mem_v.
///< Counter input is connected to Capture Memory data[31:0]. <br/> 0x19
///< = Triggered by Capture Memory otuput data valid signal from V2D, o_mem_v.
///< Counter input is connected to  i_v2d_odd, 29d0, o_mem_id .
#define BFN_CSR_SMON_R1_MODE1_BF_OFF ( 8)
#define BFN_CSR_SMON_R1_MODE1_BF_WID ( 8)
#define BFN_CSR_SMON_R1_MODE1_BF_MSK (0x0000FF00)
#define BFN_CSR_SMON_R1_MODE1_BF_DEF (0x00000000)

///< reserved
#define BFN_CSR_SMON_R1_RSVD_BF_OFF (16)
#define BFN_CSR_SMON_R1_RSVD_BF_WID (16)
#define BFN_CSR_SMON_R1_RSVD_BF_MSK (0xFFFF0000)
#define BFN_CSR_SMON_R1_RSVD_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R2 register description at address offset 0x108
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r2
  * AW_smon SMON0_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE0 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_smon_r2_reg_t;

#define BFN_CSR_SMON_R2_DEFAULT (0x00000000U)
#define BFN_CSR_SMON_R2_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R2_WR_MASK (0xffffffffU)


///< Comparison value.
#define BFN_CSR_SMON_R2_CMP0_BF_OFF ( 0)
#define BFN_CSR_SMON_R2_CMP0_BF_WID (32)
#define BFN_CSR_SMON_R2_CMP0_BF_MSK (0xFFFFFFFF)
#define BFN_CSR_SMON_R2_CMP0_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R3 register description at address offset 0x10c
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r3
  * AW_smon SMON1_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE1 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_smon_r3_reg_t;

#define BFN_CSR_SMON_R3_DEFAULT (0x00000000U)
#define BFN_CSR_SMON_R3_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R3_WR_MASK (0xffffffffU)


///< Comparison value.
#define BFN_CSR_SMON_R3_CMP1_BF_OFF ( 0)
#define BFN_CSR_SMON_R3_CMP1_BF_WID (32)
#define BFN_CSR_SMON_R3_CMP1_BF_MSK (0xFFFFFFFF)
#define BFN_CSR_SMON_R3_CMP1_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R4 register description at address offset 0x110
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r4
  * AW_smon SMON0_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER0 : 32;
    ///< counter0
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_smon_r4_reg_t;

#define BFN_CSR_SMON_R4_DEFAULT (0x00000000U)
#define BFN_CSR_SMON_R4_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R4_WR_MASK (0xffffffffU)


///< counter0
#define BFN_CSR_SMON_R4_CNTER0_BF_OFF ( 0)
#define BFN_CSR_SMON_R4_CNTER0_BF_WID (32)
#define BFN_CSR_SMON_R4_CNTER0_BF_MSK (0xFFFFFFFF)
#define BFN_CSR_SMON_R4_CNTER0_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R5 register description at address offset 0x114
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r5
  * AW_smon SMON1_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER1 : 32;
    ///< counter1
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_smon_r5_reg_t;

#define BFN_CSR_SMON_R5_DEFAULT (0x00000000U)
#define BFN_CSR_SMON_R5_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R5_WR_MASK (0xffffffffU)


///< counter1
#define BFN_CSR_SMON_R5_CNTER1_BF_OFF ( 0)
#define BFN_CSR_SMON_R5_CNTER1_BF_WID (32)
#define BFN_CSR_SMON_R5_CNTER1_BF_MSK (0xFFFFFFFF)
#define BFN_CSR_SMON_R5_CNTER1_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R6 register description at address offset 0x118
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r6
  * AW_smon TIMER register
  */

typedef union {
  struct {
    uint32_t TIMER : 32;
    ///< timer
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_smon_r6_reg_t;

#define BFN_CSR_SMON_R6_DEFAULT (0x00000000U)
#define BFN_CSR_SMON_R6_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R6_WR_MASK (0xffffffffU)


///< timer
#define BFN_CSR_SMON_R6_TIMER_BF_OFF ( 0)
#define BFN_CSR_SMON_R6_TIMER_BF_WID (32)
#define BFN_CSR_SMON_R6_TIMER_BF_MSK (0xFFFFFFFF)
#define BFN_CSR_SMON_R6_TIMER_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SMON_CSR_SMON_R7 register description at address offset 0x11c
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SMON_CSR/SMON_r7
  * AW_smon TIMERMAXVAL register
  */

typedef union {
  struct {
    uint32_t MAXVALUE : 32;
    ///< maxvalue
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} bfn_csr_smon_r7_reg_t;

#define BFN_CSR_SMON_R7_DEFAULT (0x00000000U)
#define BFN_CSR_SMON_R7_RD_MASK (0xffffffffU)
#define BFN_CSR_SMON_R7_WR_MASK (0xffffffffU)


///< maxvalue
#define BFN_CSR_SMON_R7_MAXVAL_BF_OFF ( 0)
#define BFN_CSR_SMON_R7_MAXVAL_BF_WID (32)
#define BFN_CSR_SMON_R7_MAXVAL_BF_MSK (0xFFFFFFFF)
#define BFN_CSR_SMON_R7_MAXVAL_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SUBB_LO_INTR register description at address offset 0x120
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SUBB_LO_INTR
  * Subblock Low Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t CH0_NSIP0_LO_INTR : 1;
    ///< Channel 0 nsip_hbi 0 Low Interrupt. This bit shows the value of Channel
    ///< 0 nsip_hbi 0 low interrupt.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CH0_NSIP1_LO_INTR : 1;
    ///< Channel 0 nsip_hbi 1 Low Interrupt. This bit shows the value of Channel
    ///< 0 nsip_hbi 1 low interrupt.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t CH0_AV2D_LO_INTR : 1;
    ///< Channel 0 abc_v2d Low Interrupt. This bit shows the value of Channel
    ///< 0 abc_v2d low interrupt.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t CH0_PDPD_LO_INTR : 1;
    ///< Channel 0 PDPD Low Interrupt. This bit shows the value of Channel
    ///< 0 PDPD low interrupt.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t CH1_NSIP0_LO_INTR : 1;
    ///< Channel 1 nsip_hbi 0 Low Interrupt. This bit shows the value of Channel
    ///< 1 nsip_hbi 0 low interrupt.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t CH1_NSIP1_LO_INTR : 1;
    ///< Channel 1 nsip_hbi 1 Low Interrupt. This bit shows the value of Channel
    ///< 1 nsip_hbi 1 low interrupt.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t CH1_AV2D_LO_INTR : 1;
    ///< Channel 1 abc_v2d Low Interrupt. This bit shows the value of Channel
    ///< 1 abc_v2d low interrupt.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t CH1_PDPD_LO_INTR : 1;
    ///< Channel 1 PDPD Low Interrupt. This bit shows the value of Channel
    ///< 1 PDPD low interrupt.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t SMON_INTR : 1;
    ///< SMON Interrupt. This bit shows the value of hcm_v2d's AW_smon interrupt
    ///< output.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_subb_lo_intr_reg_t;

#define BFN_CSR_SUBB_LO_INTR_DEFAULT (0x00000000U)
#define BFN_CSR_SUBB_LO_INTR_RD_MASK (0x000001ffU)
#define BFN_CSR_SUBB_LO_INTR_WR_MASK (0x00000000U)


///< Channel 0 nsip_hbi 0 Low Interrupt. This bit shows the value of Channel
///< 0 nsip_hbi 0 low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP0_LO_INTR_BF_OFF ( 0)
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP0_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP0_LO_INTR_BF_MSK (0x00000001)
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP0_LO_INTR_BF_DEF (0x00000000)

///< Channel 0 nsip_hbi 1 Low Interrupt. This bit shows the value of Channel
///< 0 nsip_hbi 1 low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP1_LO_INTR_BF_OFF ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP1_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP1_LO_INTR_BF_MSK (0x00000002)
#define BFN_CSR_SUBB_LO_INTR_CH0_NSIP1_LO_INTR_BF_DEF (0x00000000)

///< Channel 0 abc_v2d Low Interrupt. This bit shows the value of Channel
///< 0 abc_v2d low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH0_AV2D_LO_INTR_BF_OFF ( 2)
#define BFN_CSR_SUBB_LO_INTR_CH0_AV2D_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH0_AV2D_LO_INTR_BF_MSK (0x00000004)
#define BFN_CSR_SUBB_LO_INTR_CH0_AV2D_LO_INTR_BF_DEF (0x00000000)

///< Channel 0 PDPD Low Interrupt. This bit shows the value of Channel
///< 0 PDPD low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH0_PDPD_LO_INTR_BF_OFF ( 3)
#define BFN_CSR_SUBB_LO_INTR_CH0_PDPD_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH0_PDPD_LO_INTR_BF_MSK (0x00000008)
#define BFN_CSR_SUBB_LO_INTR_CH0_PDPD_LO_INTR_BF_DEF (0x00000000)

///< Channel 1 nsip_hbi 0 Low Interrupt. This bit shows the value of Channel
///< 1 nsip_hbi 0 low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP0_LO_INTR_BF_OFF ( 4)
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP0_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP0_LO_INTR_BF_MSK (0x00000010)
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP0_LO_INTR_BF_DEF (0x00000000)

///< Channel 1 nsip_hbi 1 Low Interrupt. This bit shows the value of Channel
///< 1 nsip_hbi 1 low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP1_LO_INTR_BF_OFF ( 5)
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP1_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP1_LO_INTR_BF_MSK (0x00000020)
#define BFN_CSR_SUBB_LO_INTR_CH1_NSIP1_LO_INTR_BF_DEF (0x00000000)

///< Channel 1 abc_v2d Low Interrupt. This bit shows the value of Channel
///< 1 abc_v2d low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH1_AV2D_LO_INTR_BF_OFF ( 6)
#define BFN_CSR_SUBB_LO_INTR_CH1_AV2D_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH1_AV2D_LO_INTR_BF_MSK (0x00000040)
#define BFN_CSR_SUBB_LO_INTR_CH1_AV2D_LO_INTR_BF_DEF (0x00000000)

///< Channel 1 PDPD Low Interrupt. This bit shows the value of Channel
///< 1 PDPD low interrupt.
#define BFN_CSR_SUBB_LO_INTR_CH1_PDPD_LO_INTR_BF_OFF ( 7)
#define BFN_CSR_SUBB_LO_INTR_CH1_PDPD_LO_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_CH1_PDPD_LO_INTR_BF_MSK (0x00000080)
#define BFN_CSR_SUBB_LO_INTR_CH1_PDPD_LO_INTR_BF_DEF (0x00000000)

///< SMON Interrupt. This bit shows the value of hcm_v2d's AW_smon interrupt
///< output.
#define BFN_CSR_SUBB_LO_INTR_SMON_INTR_BF_OFF ( 8)
#define BFN_CSR_SUBB_LO_INTR_SMON_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_LO_INTR_SMON_INTR_BF_MSK (0x00000100)
#define BFN_CSR_SUBB_LO_INTR_SMON_INTR_BF_DEF (0x00000000)


/** @brief BFN_CSR_COM_REG_SUBB_HI_INTR register description at address offset 0x124
  *
  * Register default value:        0x00000000
  * Register full path in IP: bfn_csr_com/reg/SUBB_HI_INTR
  * Subblock High Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t CH0_NSIP0_HI_INTR : 1;
    ///< Channel 0 nsip_hbi 0 High Interrupt. This bit shows the value of Channel
    ///< 0 nsip_hbi 0 high interrupt.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CH0_NSIP1_HI_INTR : 1;
    ///< Channel 0 nsip_hbi 1 High Interrupt. This bit shows the value of Channel
    ///< 0 nsip_hbi 1 high interrupt.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t CH0_AV2D_HI_INTR : 1;
    ///< Channel 0 abc_v2d High Interrupt. This bit shows the value of Channel
    ///< 0 abc_v2d high interrupt.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t CH0_PDPD_HI_INTR : 1;
    ///< Channel 0 PDPD High Interrupt. This bit shows the value of Channel
    ///< 0 PDPD high interrupt.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t CH1_NSIP0_HI_INTR : 1;
    ///< Channel 1 nsip_hbi 0 High Interrupt. This bit shows the value of Channel
    ///< 1 nsip_hbi 0 high interrupt.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t CH1_NSIP1_HI_INTR : 1;
    ///< Channel 1 nsip_hbi 1 High Interrupt. This bit shows the value of Channel
    ///< 1 nsip_hbi 1 high interrupt.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t CH1_AV2D_HI_INTR : 1;
    ///< Channel 1 abc_v2d High Interrupt. This bit shows the value of Channel
    ///< 1 abc_v2d high interrupt.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t CH1_PDPD_HI_INTR : 1;
    ///< Channel 1 PDPD High Interrupt. This bit shows the value of Channel
    ///< 1 PDPD high interrupt.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} bfn_csr_subb_hi_intr_reg_t;

#define BFN_CSR_SUBB_HI_INTR_DEFAULT (0x00000000U)
#define BFN_CSR_SUBB_HI_INTR_RD_MASK (0x000000ffU)
#define BFN_CSR_SUBB_HI_INTR_WR_MASK (0x00000000U)


///< Channel 0 nsip_hbi 0 High Interrupt. This bit shows the value of Channel
///< 0 nsip_hbi 0 high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP0_HI_INTR_BF_OFF ( 0)
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP0_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP0_HI_INTR_BF_MSK (0x00000001)
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP0_HI_INTR_BF_DEF (0x00000000)

///< Channel 0 nsip_hbi 1 High Interrupt. This bit shows the value of Channel
///< 0 nsip_hbi 1 high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP1_HI_INTR_BF_OFF ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP1_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP1_HI_INTR_BF_MSK (0x00000002)
#define BFN_CSR_SUBB_HI_INTR_CH0_NSIP1_HI_INTR_BF_DEF (0x00000000)

///< Channel 0 abc_v2d High Interrupt. This bit shows the value of Channel
///< 0 abc_v2d high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH0_AV2D_HI_INTR_BF_OFF ( 2)
#define BFN_CSR_SUBB_HI_INTR_CH0_AV2D_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH0_AV2D_HI_INTR_BF_MSK (0x00000004)
#define BFN_CSR_SUBB_HI_INTR_CH0_AV2D_HI_INTR_BF_DEF (0x00000000)

///< Channel 0 PDPD High Interrupt. This bit shows the value of Channel
///< 0 PDPD high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH0_PDPD_HI_INTR_BF_OFF ( 3)
#define BFN_CSR_SUBB_HI_INTR_CH0_PDPD_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH0_PDPD_HI_INTR_BF_MSK (0x00000008)
#define BFN_CSR_SUBB_HI_INTR_CH0_PDPD_HI_INTR_BF_DEF (0x00000000)

///< Channel 1 nsip_hbi 0 High Interrupt. This bit shows the value of Channel
///< 1 nsip_hbi 0 high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP0_HI_INTR_BF_OFF ( 4)
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP0_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP0_HI_INTR_BF_MSK (0x00000010)
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP0_HI_INTR_BF_DEF (0x00000000)

///< Channel 1 nsip_hbi 1 High Interrupt. This bit shows the value of Channel
///< 1 nsip_hbi 1 high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP1_HI_INTR_BF_OFF ( 5)
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP1_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP1_HI_INTR_BF_MSK (0x00000020)
#define BFN_CSR_SUBB_HI_INTR_CH1_NSIP1_HI_INTR_BF_DEF (0x00000000)

///< Channel 1 abc_v2d High Interrupt. This bit shows the value of Channel
///< 1 abc_v2d high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH1_AV2D_HI_INTR_BF_OFF ( 6)
#define BFN_CSR_SUBB_HI_INTR_CH1_AV2D_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH1_AV2D_HI_INTR_BF_MSK (0x00000040)
#define BFN_CSR_SUBB_HI_INTR_CH1_AV2D_HI_INTR_BF_DEF (0x00000000)

///< Channel 1 PDPD High Interrupt. This bit shows the value of Channel
///< 1 PDPD high interrupt.
#define BFN_CSR_SUBB_HI_INTR_CH1_PDPD_HI_INTR_BF_OFF ( 7)
#define BFN_CSR_SUBB_HI_INTR_CH1_PDPD_HI_INTR_BF_WID ( 1)
#define BFN_CSR_SUBB_HI_INTR_CH1_PDPD_HI_INTR_BF_MSK (0x00000080)
#define BFN_CSR_SUBB_HI_INTR_CH1_PDPD_HI_INTR_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define BFN_CSR_BFN_SCRATCH_REG(_BASE) ((bfn_csr_bfn_scratch_reg_t*) BFN_CSR_BFN_SCRATCH_ADR(_BASE))
#define BFN_CSR_APB_BRI_STAT_REG(_BASE) ((bfn_csr_apb_bri_stat_reg_t*) BFN_CSR_APB_BRI_STAT_ADR(_BASE))
#define BFN_CSR_GENERAL_CSR_REG(_BASE) ((bfn_csr_general_csr_reg_t*) BFN_CSR_GENERAL_CSR_ADR(_BASE))
#define BFN_CSR_CAP_BFN0_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN0_ADR(_BASE))
#define BFN_CSR_CAP_BFN1_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN1_ADR(_BASE))
#define BFN_CSR_CAP_BFN2_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN2_ADR(_BASE))
#define BFN_CSR_CAP_BFN3_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN3_ADR(_BASE))
#define BFN_CSR_CAP_BFN4_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN4_ADR(_BASE))
#define BFN_CSR_CAP_BFN5_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN5_ADR(_BASE))
#define BFN_CSR_CAP_BFN6_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN6_ADR(_BASE))
#define BFN_CSR_CAP_BFN7_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN7_ADR(_BASE))
#define BFN_CSR_CAP_BFN8_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN8_ADR(_BASE))
#define BFN_CSR_CAP_BFN9_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN9_ADR(_BASE))
#define BFN_CSR_CAP_BFN10_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN10_ADR(_BASE))
#define BFN_CSR_CAP_BFN11_REG(_BASE) ((bfn_csr_cap_bfn_reg_t*) BFN_CSR_CAP_BFN11_ADR(_BASE))
#define BFN_CSR_AW_ISYNC_CTRL_REG(_BASE) ((bfn_csr_aw_isync_ctrl_reg_t*) BFN_CSR_AW_ISYNC_CTRL_ADR(_BASE))
#define BFN_CSR_AW_ISYNC_LCNT_INC_REG(_BASE) ((bfn_csr_aw_isync_lcnt_inc_reg_t*) BFN_CSR_AW_ISYNC_LCNT_INC_ADR(_BASE))
#define BFN_CSR_AW_ISYNC_TEN_MS_CNT_REG(_BASE) ((bfn_csr_aw_isync_ten_ms_cnt_reg_t*) BFN_CSR_AW_ISYNC_TEN_MS_CNT_ADR(_BASE))
#define BFN_CSR_AW_ISYNC_INC_PRE_REG(_BASE) ((bfn_csr_aw_isync_inc_pre_reg_t*) BFN_CSR_AW_ISYNC_INC_PRE_ADR(_BASE))
#define BFN_CSR_AW_ISYNC_CNT_ADJ_REG(_BASE) ((bfn_csr_aw_isync_cnt_adj_reg_t*) BFN_CSR_AW_ISYNC_CNT_ADJ_ADR(_BASE))
#define BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_REG(_BASE) ((bfn_csr_aw_isync_bfn_cnt_sync_reg_t*) BFN_CSR_AW_ISYNC_BFN_CNT_SYNC_ADR(_BASE))
#define BFN_CSR_AW_ISYNC_BFN_CNT_REG(_BASE) ((bfn_csr_aw_isync_bfn_cnt_reg_t*) BFN_CSR_AW_ISYNC_BFN_CNT_ADR(_BASE))
#define BFN_CSR_BFNE_CFG0_REG(_BASE) ((bfn_csr_bfne_cfg_reg_t*) BFN_CSR_BFNE_CFG0_ADR(_BASE))
#define BFN_CSR_BFNE_CFG1_REG(_BASE) ((bfn_csr_bfne_cfg_reg_t*) BFN_CSR_BFNE_CFG1_ADR(_BASE))
#define BFN_CSR_BFNE_CFG2_REG(_BASE) ((bfn_csr_bfne_cfg_reg_t*) BFN_CSR_BFNE_CFG2_ADR(_BASE))
#define BFN_CSR_BFNE_CFG3_REG(_BASE) ((bfn_csr_bfne_cfg_reg_t*) BFN_CSR_BFNE_CFG3_ADR(_BASE))
#define BFN_CSR_BFNE_INCR0_REG(_BASE) ((bfn_csr_bfne_incr_reg_t*) BFN_CSR_BFNE_INCR0_ADR(_BASE))
#define BFN_CSR_BFNE_INCR1_REG(_BASE) ((bfn_csr_bfne_incr_reg_t*) BFN_CSR_BFNE_INCR1_ADR(_BASE))
#define BFN_CSR_BFNE_INCR2_REG(_BASE) ((bfn_csr_bfne_incr_reg_t*) BFN_CSR_BFNE_INCR2_ADR(_BASE))
#define BFN_CSR_BFNE_INCR3_REG(_BASE) ((bfn_csr_bfne_incr_reg_t*) BFN_CSR_BFNE_INCR3_ADR(_BASE))
#define BFN_CSR_BFNE_START0_REG(_BASE) ((bfn_csr_bfne_start_reg_t*) BFN_CSR_BFNE_START0_ADR(_BASE))
#define BFN_CSR_BFNE_START1_REG(_BASE) ((bfn_csr_bfne_start_reg_t*) BFN_CSR_BFNE_START1_ADR(_BASE))
#define BFN_CSR_BFNE_START2_REG(_BASE) ((bfn_csr_bfne_start_reg_t*) BFN_CSR_BFNE_START2_ADR(_BASE))
#define BFN_CSR_BFNE_START3_REG(_BASE) ((bfn_csr_bfne_start_reg_t*) BFN_CSR_BFNE_START3_ADR(_BASE))
#define BFN_CSR_BFNE_STAT0_REG(_BASE) ((bfn_csr_bfne_stat_reg_t*) BFN_CSR_BFNE_STAT0_ADR(_BASE))
#define BFN_CSR_BFNE_STAT1_REG(_BASE) ((bfn_csr_bfne_stat_reg_t*) BFN_CSR_BFNE_STAT1_ADR(_BASE))
#define BFN_CSR_BFNE_STAT2_REG(_BASE) ((bfn_csr_bfne_stat_reg_t*) BFN_CSR_BFNE_STAT2_ADR(_BASE))
#define BFN_CSR_BFNE_STAT3_REG(_BASE) ((bfn_csr_bfne_stat_reg_t*) BFN_CSR_BFNE_STAT3_ADR(_BASE))
#define BFN_CSR_START_LM0_REG(_BASE) ((bfn_csr_start_lm_reg_t*) BFN_CSR_START_LM0_ADR(_BASE))
#define BFN_CSR_START_LM1_REG(_BASE) ((bfn_csr_start_lm_reg_t*) BFN_CSR_START_LM1_ADR(_BASE))
#define BFN_CSR_START_LM2_REG(_BASE) ((bfn_csr_start_lm_reg_t*) BFN_CSR_START_LM2_ADR(_BASE))
#define BFN_CSR_START_LM3_REG(_BASE) ((bfn_csr_start_lm_reg_t*) BFN_CSR_START_LM3_ADR(_BASE))
#define BFN_CSR_START_L_CNT0_REG(_BASE) ((bfn_csr_start_l_cnt_reg_t*) BFN_CSR_START_L_CNT0_ADR(_BASE))
#define BFN_CSR_START_L_CNT1_REG(_BASE) ((bfn_csr_start_l_cnt_reg_t*) BFN_CSR_START_L_CNT1_ADR(_BASE))
#define BFN_CSR_START_L_CNT2_REG(_BASE) ((bfn_csr_start_l_cnt_reg_t*) BFN_CSR_START_L_CNT2_ADR(_BASE))
#define BFN_CSR_START_L_CNT3_REG(_BASE) ((bfn_csr_start_l_cnt_reg_t*) BFN_CSR_START_L_CNT3_ADR(_BASE))
#define BFN_CSR_CAP_MODE_CTRL_REG(_BASE) ((bfn_csr_cap_mode_ctrl_reg_t*) BFN_CSR_CAP_MODE_CTRL_ADR(_BASE))
#define BFN_CSR_CAP_DATA_CTRL_REG(_BASE) ((bfn_csr_cap_data_ctrl_reg_t*) BFN_CSR_CAP_DATA_CTRL_ADR(_BASE))
#define BFN_CSR_SMON_R0_REG(_BASE) ((bfn_csr_smon_r0_reg_t*) BFN_CSR_SMON_R0_ADR(_BASE))
#define BFN_CSR_SMON_R1_REG(_BASE) ((bfn_csr_smon_r1_reg_t*) BFN_CSR_SMON_R1_ADR(_BASE))
#define BFN_CSR_SMON_R2_REG(_BASE) ((bfn_csr_smon_r2_reg_t*) BFN_CSR_SMON_R2_ADR(_BASE))
#define BFN_CSR_SMON_R3_REG(_BASE) ((bfn_csr_smon_r3_reg_t*) BFN_CSR_SMON_R3_ADR(_BASE))
#define BFN_CSR_SMON_R4_REG(_BASE) ((bfn_csr_smon_r4_reg_t*) BFN_CSR_SMON_R4_ADR(_BASE))
#define BFN_CSR_SMON_R5_REG(_BASE) ((bfn_csr_smon_r5_reg_t*) BFN_CSR_SMON_R5_ADR(_BASE))
#define BFN_CSR_SMON_R6_REG(_BASE) ((bfn_csr_smon_r6_reg_t*) BFN_CSR_SMON_R6_ADR(_BASE))
#define BFN_CSR_SMON_R7_REG(_BASE) ((bfn_csr_smon_r7_reg_t*) BFN_CSR_SMON_R7_ADR(_BASE))
#define BFN_CSR_SUBB_LO_INTR_REG(_BASE) ((bfn_csr_subb_lo_intr_reg_t*) BFN_CSR_SUBB_LO_INTR_ADR(_BASE))
#define BFN_CSR_SUBB_HI_INTR_REG(_BASE) ((bfn_csr_subb_hi_intr_reg_t*) BFN_CSR_SUBB_HI_INTR_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    bfn_csr_bfn_scratch_reg_t BFN_SCRATCH;     /*< Address offset = 0x0 */
    bfn_csr_apb_bri_stat_reg_t APB_BRI_STAT;  /*< Address offset = 0x4 */
    bfn_csr_general_csr_reg_t GENERAL_CSR;     /*< Address offset = 0x8 */
    const uint8_t        reservedArea0 [4];   /*< Address offset = 0xc */
    bfn_csr_cap_bfn_reg_t CAP_BFN[12];     /*< Address offset = 0x10 */
    bfn_csr_aw_isync_ctrl_reg_t AW_ISYNC_CTRL; /*< Address offset = 0x40 */
    bfn_csr_aw_isync_lcnt_inc_reg_t AW_ISYNC_LCNT_INC; /*< Address offset = 0x44 */
    bfn_csr_aw_isync_ten_ms_cnt_reg_t AW_ISYNC_TEN_MS_CNT; /*< Address offset = 0x48 */
    bfn_csr_aw_isync_inc_pre_reg_t AW_ISYNC_INC_PRE; /*< Address offset = 0x4c */
    bfn_csr_aw_isync_cnt_adj_reg_t AW_ISYNC_CNT_ADJ; /*< Address offset = 0x50 */
    bfn_csr_aw_isync_bfn_cnt_sync_reg_t AW_ISYNC_BFN_CNT_SYNC; /*< Address offset = 0x54 */
    bfn_csr_aw_isync_bfn_cnt_reg_t AW_ISYNC_BFN_CNT; /*< Address offset = 0x58 */
    const uint8_t        reservedArea1 [4];   /*< Address offset = 0x5c */
    bfn_csr_bfne_cfg_reg_t BFNE_CFG[4]; /*< Address offset = 0x60 */
    bfn_csr_bfne_incr_reg_t BFNE_INCR[4]; /*< Address offset = 0x70 */
    bfn_csr_bfne_start_reg_t BFNE_START[4]; /*< Address offset = 0x80 */
    bfn_csr_bfne_stat_reg_t BFNE_STAT[4]; /*< Address offset = 0x90 */
    const uint8_t        reservedArea2 [48];  /*< Address offset = 0xa0 */
    bfn_csr_start_lm_reg_t START_LM[4];     /*< Address offset = 0xd0 */
    bfn_csr_start_l_cnt_reg_t START_L_CNT[4];  /*< Address offset = 0xe0 */
    const uint8_t        reservedArea3 [8];   /*< Address offset = 0xf0 */
    bfn_csr_cap_mode_ctrl_reg_t CAP_MODE_CTRL;   /*< Address offset = 0xf8 */
    bfn_csr_cap_data_ctrl_reg_t CAP_DATA_CTRL;   /*< Address offset = 0xfc */
    bfn_csr_smon_r0_reg_t SMON_R0; /*< Address offset = 0x100 */
    bfn_csr_smon_r1_reg_t SMON_R1; /*< Address offset = 0x104 */
    bfn_csr_smon_r2_reg_t SMON_R2; /*< Address offset = 0x108 */
    bfn_csr_smon_r3_reg_t SMON_R3; /*< Address offset = 0x10c */
    bfn_csr_smon_r4_reg_t SMON_R4; /*< Address offset = 0x110 */
    bfn_csr_smon_r5_reg_t SMON_R5; /*< Address offset = 0x114 */
    bfn_csr_smon_r6_reg_t SMON_R6; /*< Address offset = 0x118 */
    bfn_csr_smon_r7_reg_t SMON_R7; /*< Address offset = 0x11c */
    bfn_csr_subb_lo_intr_reg_t SUBB_LO_INTR;    /*< Address offset = 0x120 */
    bfn_csr_subb_hi_intr_reg_t SUBB_HI_INTR;    /*< Address offset = 0x124 */
} bfn_csr_t;     // size: 0x0074

// AddressSpace struct pointer
//
#define V2D0_BFN_CSR     ((bfn_csr_t*) V2D0_BFN_CSR_BASE)
#define V2D1_BFN_CSR     ((bfn_csr_t*) V2D1_BFN_CSR_BASE)
#define V2D2_BFN_CSR     ((bfn_csr_t*) V2D2_BFN_CSR_BASE)
#define V2D3_BFN_CSR     ((bfn_csr_t*) V2D3_BFN_CSR_BASE)
#define V2D4_BFN_CSR     ((bfn_csr_t*) V2D4_BFN_CSR_BASE)
#define V2D5_BFN_CSR     ((bfn_csr_t*) V2D5_BFN_CSR_BASE)
#define V2D6_BFN_CSR     ((bfn_csr_t*) V2D6_BFN_CSR_BASE)
#define V2D7_BFN_CSR     ((bfn_csr_t*) V2D7_BFN_CSR_BASE)

// ******************************************* /Address Space

#endif      // _BFN_CSR_H_

