#ifndef _CSS600_APBROM_HWC_JTAG_H_
#define _CSS600_APBROM_HWC_JTAG_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
//    Soc ver:
//        abc_soc-srvrgen4-0p6_emul-23ww51a
//
//
//    Tool Version:
//        23.38.4p2
//
//    Generation Date:
//        2024-01-02
//
// ******************************************************************************

// ******************************************* Base address macros

// Stepping: A0
//

#define SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE  0x01f00000

// ******************************************* /Base address macros


// ******************************************* Register offset macros

// Stepping: A0
//
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_OFFSET ( 0x00000000U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_OFFSET ( 0x00000004U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_OFFSET ( 0x00000008U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_OFFSET ( 0x0000000cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_OFFSET ( 0x00000010U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_OFFSET ( 0x00000014U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_OFFSET ( 0x00000018U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_OFFSET ( 0x0000001cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_OFFSET ( 0x00000020U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_OFFSET ( 0x00000024U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_OFFSET ( 0x00000028U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_OFFSET ( 0x0000002cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_OFFSET ( 0x00000030U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_OFFSET ( 0x00000034U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_OFFSET ( 0x00000038U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_OFFSET ( 0x0000003cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_OFFSET ( 0x00000040U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_OFFSET ( 0x00000044U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_OFFSET ( 0x00000048U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_OFFSET ( 0x0000004cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_OFFSET ( 0x00000050U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_OFFSET ( 0x00000054U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_OFFSET ( 0x00000058U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_OFFSET ( 0x0000005cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_OFFSET ( 0x00000060U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_OFFSET ( 0x00000064U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_OFFSET ( 0x00000068U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_OFFSET ( 0x0000006cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_OFFSET ( 0x00000070U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_OFFSET ( 0x00000074U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_OFFSET ( 0x00000078U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_OFFSET ( 0x0000007cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_OFFSET ( 0x00000080U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_OFFSET ( 0x00000084U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_OFFSET ( 0x00000088U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_OFFSET ( 0x0000008cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_OFFSET ( 0x00000090U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_OFFSET ( 0x00000094U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_OFFSET ( 0x00000098U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_OFFSET ( 0x0000009cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_OFFSET ( 0x000000a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_OFFSET ( 0x000000a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_OFFSET ( 0x000000a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_OFFSET ( 0x000000acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_OFFSET ( 0x000000b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_OFFSET ( 0x000000b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_OFFSET ( 0x000000b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_OFFSET ( 0x000000bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_OFFSET ( 0x000000c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_OFFSET ( 0x000000c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_OFFSET ( 0x000000c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_OFFSET ( 0x000000ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_OFFSET ( 0x000000d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_OFFSET ( 0x000000d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_OFFSET ( 0x000000d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_OFFSET ( 0x000000dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_OFFSET ( 0x000000e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_OFFSET ( 0x000000e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_OFFSET ( 0x000000e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_OFFSET ( 0x000000ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_OFFSET ( 0x000000f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_OFFSET ( 0x000000f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_OFFSET ( 0x000000f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_OFFSET ( 0x000000fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_OFFSET ( 0x00000100U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_OFFSET ( 0x00000104U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_OFFSET ( 0x00000108U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_OFFSET ( 0x0000010cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_OFFSET ( 0x00000110U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_OFFSET ( 0x00000114U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_OFFSET ( 0x00000118U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_OFFSET ( 0x0000011cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_OFFSET ( 0x00000120U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_OFFSET ( 0x00000124U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_OFFSET ( 0x00000128U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_OFFSET ( 0x0000012cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_OFFSET ( 0x00000130U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_OFFSET ( 0x00000134U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_OFFSET ( 0x00000138U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_OFFSET ( 0x0000013cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_OFFSET ( 0x00000140U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_OFFSET ( 0x00000144U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_OFFSET ( 0x00000148U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_OFFSET ( 0x0000014cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_OFFSET ( 0x00000150U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_OFFSET ( 0x00000154U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_OFFSET ( 0x00000158U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_OFFSET ( 0x0000015cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_OFFSET ( 0x00000160U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_OFFSET ( 0x00000164U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_OFFSET ( 0x00000168U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_OFFSET ( 0x0000016cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_OFFSET ( 0x00000170U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_OFFSET ( 0x00000174U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_OFFSET ( 0x00000178U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_OFFSET ( 0x0000017cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_OFFSET ( 0x00000180U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_OFFSET ( 0x00000184U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_OFFSET ( 0x00000188U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_OFFSET ( 0x0000018cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_OFFSET ( 0x00000190U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_OFFSET ( 0x00000194U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_OFFSET ( 0x00000198U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_OFFSET ( 0x0000019cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_OFFSET ( 0x000001a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_OFFSET ( 0x000001a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_OFFSET ( 0x000001a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_OFFSET ( 0x000001acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_OFFSET ( 0x000001b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_OFFSET ( 0x000001b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_OFFSET ( 0x000001b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_OFFSET ( 0x000001bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_OFFSET ( 0x000001c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_OFFSET ( 0x000001c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_OFFSET ( 0x000001c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_OFFSET ( 0x000001ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_OFFSET ( 0x000001d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_OFFSET ( 0x000001d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_OFFSET ( 0x000001d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_OFFSET ( 0x000001dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_OFFSET ( 0x000001e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_OFFSET ( 0x000001e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_OFFSET ( 0x000001e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_OFFSET ( 0x000001ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_OFFSET ( 0x000001f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_OFFSET ( 0x000001f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_OFFSET ( 0x000001f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_OFFSET ( 0x000001fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_OFFSET ( 0x00000200U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_OFFSET ( 0x00000204U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_OFFSET ( 0x00000208U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_OFFSET ( 0x0000020cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_OFFSET ( 0x00000210U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_OFFSET ( 0x00000214U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_OFFSET ( 0x00000218U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_OFFSET ( 0x0000021cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_OFFSET ( 0x00000220U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_OFFSET ( 0x00000224U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_OFFSET ( 0x00000228U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_OFFSET ( 0x0000022cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_OFFSET ( 0x00000230U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_OFFSET ( 0x00000234U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_OFFSET ( 0x00000238U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_OFFSET ( 0x0000023cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_OFFSET ( 0x00000240U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_OFFSET ( 0x00000244U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_OFFSET ( 0x00000248U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_OFFSET ( 0x0000024cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_OFFSET ( 0x00000250U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_OFFSET ( 0x00000254U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_OFFSET ( 0x00000258U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_OFFSET ( 0x0000025cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_OFFSET ( 0x00000260U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_OFFSET ( 0x00000264U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_OFFSET ( 0x00000268U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_OFFSET ( 0x0000026cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_OFFSET ( 0x00000270U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_OFFSET ( 0x00000274U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_OFFSET ( 0x00000278U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_OFFSET ( 0x0000027cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_OFFSET ( 0x00000280U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_OFFSET ( 0x00000284U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_OFFSET ( 0x00000288U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_OFFSET ( 0x0000028cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_OFFSET ( 0x00000290U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_OFFSET ( 0x00000294U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_OFFSET ( 0x00000298U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_OFFSET ( 0x0000029cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_OFFSET ( 0x000002a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_OFFSET ( 0x000002a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_OFFSET ( 0x000002a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_OFFSET ( 0x000002acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_OFFSET ( 0x000002b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_OFFSET ( 0x000002b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_OFFSET ( 0x000002b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_OFFSET ( 0x000002bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_OFFSET ( 0x000002c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_OFFSET ( 0x000002c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_OFFSET ( 0x000002c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_OFFSET ( 0x000002ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_OFFSET ( 0x000002d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_OFFSET ( 0x000002d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_OFFSET ( 0x000002d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_OFFSET ( 0x000002dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_OFFSET ( 0x000002e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_OFFSET ( 0x000002e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_OFFSET ( 0x000002e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_OFFSET ( 0x000002ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_OFFSET ( 0x000002f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_OFFSET ( 0x000002f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_OFFSET ( 0x000002f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_OFFSET ( 0x000002fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_OFFSET ( 0x00000300U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_OFFSET ( 0x00000304U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_OFFSET ( 0x00000308U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_OFFSET ( 0x0000030cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_OFFSET ( 0x00000310U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_OFFSET ( 0x00000314U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_OFFSET ( 0x00000318U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_OFFSET ( 0x0000031cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_OFFSET ( 0x00000320U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_OFFSET ( 0x00000324U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_OFFSET ( 0x00000328U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_OFFSET ( 0x0000032cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_OFFSET ( 0x00000330U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_OFFSET ( 0x00000334U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_OFFSET ( 0x00000338U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_OFFSET ( 0x0000033cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_OFFSET ( 0x00000340U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_OFFSET ( 0x00000344U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_OFFSET ( 0x00000348U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_OFFSET ( 0x0000034cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_OFFSET ( 0x00000350U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_OFFSET ( 0x00000354U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_OFFSET ( 0x00000358U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_OFFSET ( 0x0000035cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_OFFSET ( 0x00000360U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_OFFSET ( 0x00000364U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_OFFSET ( 0x00000368U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_OFFSET ( 0x0000036cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_OFFSET ( 0x00000370U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_OFFSET ( 0x00000374U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_OFFSET ( 0x00000378U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_OFFSET ( 0x0000037cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_OFFSET ( 0x00000380U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_OFFSET ( 0x00000384U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_OFFSET ( 0x00000388U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_OFFSET ( 0x0000038cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_OFFSET ( 0x00000390U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_OFFSET ( 0x00000394U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_OFFSET ( 0x00000398U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_OFFSET ( 0x0000039cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_OFFSET ( 0x000003a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_OFFSET ( 0x000003a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_OFFSET ( 0x000003a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_OFFSET ( 0x000003acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_OFFSET ( 0x000003b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_OFFSET ( 0x000003b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_OFFSET ( 0x000003b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_OFFSET ( 0x000003bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_OFFSET ( 0x000003c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_OFFSET ( 0x000003c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_OFFSET ( 0x000003c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_OFFSET ( 0x000003ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_OFFSET ( 0x000003d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_OFFSET ( 0x000003d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_OFFSET ( 0x000003d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_OFFSET ( 0x000003dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_OFFSET ( 0x000003e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_OFFSET ( 0x000003e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_OFFSET ( 0x000003e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_OFFSET ( 0x000003ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_OFFSET ( 0x000003f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_OFFSET ( 0x000003f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_OFFSET ( 0x000003f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_OFFSET ( 0x000003fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_OFFSET ( 0x00000400U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_OFFSET ( 0x00000404U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_OFFSET ( 0x00000408U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_OFFSET ( 0x0000040cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_OFFSET ( 0x00000410U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_OFFSET ( 0x00000414U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_OFFSET ( 0x00000418U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_OFFSET ( 0x0000041cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_OFFSET ( 0x00000420U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_OFFSET ( 0x00000424U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_OFFSET ( 0x00000428U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_OFFSET ( 0x0000042cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_OFFSET ( 0x00000430U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_OFFSET ( 0x00000434U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_OFFSET ( 0x00000438U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_OFFSET ( 0x0000043cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_OFFSET ( 0x00000440U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_OFFSET ( 0x00000444U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_OFFSET ( 0x00000448U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_OFFSET ( 0x0000044cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_OFFSET ( 0x00000450U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_OFFSET ( 0x00000454U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_OFFSET ( 0x00000458U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_OFFSET ( 0x0000045cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_OFFSET ( 0x00000460U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_OFFSET ( 0x00000464U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_OFFSET ( 0x00000468U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_OFFSET ( 0x0000046cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_OFFSET ( 0x00000470U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_OFFSET ( 0x00000474U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_OFFSET ( 0x00000478U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_OFFSET ( 0x0000047cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_OFFSET ( 0x00000480U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_OFFSET ( 0x00000484U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_OFFSET ( 0x00000488U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_OFFSET ( 0x0000048cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_OFFSET ( 0x00000490U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_OFFSET ( 0x00000494U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_OFFSET ( 0x00000498U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_OFFSET ( 0x0000049cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_OFFSET ( 0x000004a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_OFFSET ( 0x000004a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_OFFSET ( 0x000004a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_OFFSET ( 0x000004acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_OFFSET ( 0x000004b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_OFFSET ( 0x000004b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_OFFSET ( 0x000004b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_OFFSET ( 0x000004bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_OFFSET ( 0x000004c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_OFFSET ( 0x000004c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_OFFSET ( 0x000004c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_OFFSET ( 0x000004ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_OFFSET ( 0x000004d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_OFFSET ( 0x000004d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_OFFSET ( 0x000004d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_OFFSET ( 0x000004dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_OFFSET ( 0x000004e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_OFFSET ( 0x000004e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_OFFSET ( 0x000004e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_OFFSET ( 0x000004ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_OFFSET ( 0x000004f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_OFFSET ( 0x000004f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_OFFSET ( 0x000004f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_OFFSET ( 0x000004fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_OFFSET ( 0x00000500U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_OFFSET ( 0x00000504U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_OFFSET ( 0x00000508U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_OFFSET ( 0x0000050cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_OFFSET ( 0x00000510U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_OFFSET ( 0x00000514U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_OFFSET ( 0x00000518U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_OFFSET ( 0x0000051cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_OFFSET ( 0x00000520U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_OFFSET ( 0x00000524U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_OFFSET ( 0x00000528U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_OFFSET ( 0x0000052cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_OFFSET ( 0x00000530U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_OFFSET ( 0x00000534U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_OFFSET ( 0x00000538U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_OFFSET ( 0x0000053cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_OFFSET ( 0x00000540U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_OFFSET ( 0x00000544U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_OFFSET ( 0x00000548U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_OFFSET ( 0x0000054cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_OFFSET ( 0x00000550U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_OFFSET ( 0x00000554U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_OFFSET ( 0x00000558U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_OFFSET ( 0x0000055cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_OFFSET ( 0x00000560U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_OFFSET ( 0x00000564U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_OFFSET ( 0x00000568U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_OFFSET ( 0x0000056cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_OFFSET ( 0x00000570U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_OFFSET ( 0x00000574U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_OFFSET ( 0x00000578U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_OFFSET ( 0x0000057cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_OFFSET ( 0x00000580U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_OFFSET ( 0x00000584U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_OFFSET ( 0x00000588U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_OFFSET ( 0x0000058cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_OFFSET ( 0x00000590U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_OFFSET ( 0x00000594U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_OFFSET ( 0x00000598U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_OFFSET ( 0x0000059cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_OFFSET ( 0x000005a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_OFFSET ( 0x000005a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_OFFSET ( 0x000005a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_OFFSET ( 0x000005acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_OFFSET ( 0x000005b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_OFFSET ( 0x000005b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_OFFSET ( 0x000005b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_OFFSET ( 0x000005bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_OFFSET ( 0x000005c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_OFFSET ( 0x000005c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_OFFSET ( 0x000005c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_OFFSET ( 0x000005ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_OFFSET ( 0x000005d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_OFFSET ( 0x000005d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_OFFSET ( 0x000005d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_OFFSET ( 0x000005dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_OFFSET ( 0x000005e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_OFFSET ( 0x000005e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_OFFSET ( 0x000005e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_OFFSET ( 0x000005ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_OFFSET ( 0x000005f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_OFFSET ( 0x000005f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_OFFSET ( 0x000005f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_OFFSET ( 0x000005fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_OFFSET ( 0x00000600U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_OFFSET ( 0x00000604U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_OFFSET ( 0x00000608U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_OFFSET ( 0x0000060cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_OFFSET ( 0x00000610U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_OFFSET ( 0x00000614U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_OFFSET ( 0x00000618U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_OFFSET ( 0x0000061cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_OFFSET ( 0x00000620U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_OFFSET ( 0x00000624U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_OFFSET ( 0x00000628U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_OFFSET ( 0x0000062cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_OFFSET ( 0x00000630U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_OFFSET ( 0x00000634U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_OFFSET ( 0x00000638U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_OFFSET ( 0x0000063cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_OFFSET ( 0x00000640U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_OFFSET ( 0x00000644U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_OFFSET ( 0x00000648U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_OFFSET ( 0x0000064cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_OFFSET ( 0x00000650U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_OFFSET ( 0x00000654U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_OFFSET ( 0x00000658U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_OFFSET ( 0x0000065cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_OFFSET ( 0x00000660U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_OFFSET ( 0x00000664U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_OFFSET ( 0x00000668U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_OFFSET ( 0x0000066cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_OFFSET ( 0x00000670U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_OFFSET ( 0x00000674U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_OFFSET ( 0x00000678U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_OFFSET ( 0x0000067cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_OFFSET ( 0x00000680U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_OFFSET ( 0x00000684U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_OFFSET ( 0x00000688U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_OFFSET ( 0x0000068cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_OFFSET ( 0x00000690U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_OFFSET ( 0x00000694U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_OFFSET ( 0x00000698U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_OFFSET ( 0x0000069cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_OFFSET ( 0x000006a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_OFFSET ( 0x000006a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_OFFSET ( 0x000006a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_OFFSET ( 0x000006acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_OFFSET ( 0x000006b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_OFFSET ( 0x000006b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_OFFSET ( 0x000006b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_OFFSET ( 0x000006bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_OFFSET ( 0x000006c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_OFFSET ( 0x000006c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_OFFSET ( 0x000006c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_OFFSET ( 0x000006ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_OFFSET ( 0x000006d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_OFFSET ( 0x000006d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_OFFSET ( 0x000006d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_OFFSET ( 0x000006dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_OFFSET ( 0x000006e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_OFFSET ( 0x000006e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_OFFSET ( 0x000006e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_OFFSET ( 0x000006ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_OFFSET ( 0x000006f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_OFFSET ( 0x000006f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_OFFSET ( 0x000006f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_OFFSET ( 0x000006fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_OFFSET ( 0x00000700U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_OFFSET ( 0x00000704U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_OFFSET ( 0x00000708U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_OFFSET ( 0x0000070cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_OFFSET ( 0x00000710U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_OFFSET ( 0x00000714U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_OFFSET ( 0x00000718U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_OFFSET ( 0x0000071cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_OFFSET ( 0x00000720U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_OFFSET ( 0x00000724U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_OFFSET ( 0x00000728U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_OFFSET ( 0x0000072cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_OFFSET ( 0x00000730U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_OFFSET ( 0x00000734U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_OFFSET ( 0x00000738U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_OFFSET ( 0x0000073cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_OFFSET ( 0x00000740U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_OFFSET ( 0x00000744U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_OFFSET ( 0x00000748U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_OFFSET ( 0x0000074cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_OFFSET ( 0x00000750U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_OFFSET ( 0x00000754U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_OFFSET ( 0x00000758U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_OFFSET ( 0x0000075cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_OFFSET ( 0x00000760U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_OFFSET ( 0x00000764U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_OFFSET ( 0x00000768U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_OFFSET ( 0x0000076cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_OFFSET ( 0x00000770U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_OFFSET ( 0x00000774U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_OFFSET ( 0x00000778U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_OFFSET ( 0x0000077cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_OFFSET ( 0x00000780U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_OFFSET ( 0x00000784U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_OFFSET ( 0x00000788U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_OFFSET ( 0x0000078cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_OFFSET ( 0x00000790U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_OFFSET ( 0x00000794U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_OFFSET ( 0x00000798U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_OFFSET ( 0x0000079cU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_OFFSET ( 0x000007a0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_OFFSET ( 0x000007a4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_OFFSET ( 0x000007a8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_OFFSET ( 0x000007acU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_OFFSET ( 0x000007b0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_OFFSET ( 0x000007b4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_OFFSET ( 0x000007b8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_OFFSET ( 0x000007bcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_OFFSET ( 0x000007c0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_OFFSET ( 0x000007c4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_OFFSET ( 0x000007c8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_OFFSET ( 0x000007ccU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_OFFSET ( 0x000007d0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_OFFSET ( 0x000007d4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_OFFSET ( 0x000007d8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_OFFSET ( 0x000007dcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_OFFSET ( 0x000007e0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_OFFSET ( 0x000007e4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_OFFSET ( 0x000007e8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_OFFSET ( 0x000007ecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_OFFSET ( 0x000007f0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_OFFSET ( 0x000007f4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_OFFSET ( 0x000007f8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_OFFSET ( 0x000007fcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_OFFSET ( 0x00000fb8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_OFFSET ( 0x00000fbcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_OFFSET ( 0x00000fc8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_OFFSET ( 0x00000fd0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_OFFSET ( 0x00000fd4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_OFFSET ( 0x00000fd8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_OFFSET ( 0x00000fdcU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_OFFSET ( 0x00000fe0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_OFFSET ( 0x00000fe4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_OFFSET ( 0x00000fe8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_OFFSET ( 0x00000fecU )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_OFFSET ( 0x00000ff0U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_OFFSET ( 0x00000ff4U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_OFFSET ( 0x00000ff8U )
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_OFFSET ( 0x00000ffcU )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
// Stepping: A0
//
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_OFFSET ) ))
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_ADR (( ( SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE ) + ( CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY0 register description at address offset 0x0
  *
  * Register default value:        0x00010003
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry0
  * ROM Entries register 0
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x3"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x10"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry0_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_DEFAULT (0x00010003U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_PRESENT_BF_DEF (0x00000003)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_OFFSET_BF_DEF (0x00010000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY1 register description at address offset 0x4
  *
  * Register default value:        0x00020003
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry1
  * ROM Entries register 1
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x3"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x20"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry1_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_DEFAULT (0x00020003U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_PRESENT_BF_DEF (0x00000003)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_OFFSET_BF_DEF (0x00020000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY2 register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry2
  * ROM Entries register 2
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry2_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY3 register description at address offset 0xc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry3
  * ROM Entries register 3
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry3_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY4 register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry4
  * ROM Entries register 4
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry4_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY5 register description at address offset 0x14
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry5
  * ROM Entries register 5
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry5_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY6 register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry6
  * ROM Entries register 6
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry6_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY7 register description at address offset 0x1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry7
  * ROM Entries register 7
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry7_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY8 register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry8
  * ROM Entries register 8
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry8_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY9 register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry9
  * ROM Entries register 9
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry9_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY10 register description at address offset 0x28
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry10
  * ROM Entries register 10
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry10_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY11 register description at address offset 0x2c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry11
  * ROM Entries register 11
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry11_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY12 register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry12
  * ROM Entries register 12
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry12_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY13 register description at address offset 0x34
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry13
  * ROM Entries register 13
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry13_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY14 register description at address offset 0x38
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry14
  * ROM Entries register 14
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry14_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY15 register description at address offset 0x3c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry15
  * ROM Entries register 15
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry15_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY16 register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry16
  * ROM Entries register 16
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry16_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY17 register description at address offset 0x44
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry17
  * ROM Entries register 17
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry17_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY18 register description at address offset 0x48
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry18
  * ROM Entries register 18
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry18_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY19 register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry19
  * ROM Entries register 19
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry19_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY20 register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry20
  * ROM Entries register 20
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry20_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY21 register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry21
  * ROM Entries register 21
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry21_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY22 register description at address offset 0x58
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry22
  * ROM Entries register 22
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry22_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY23 register description at address offset 0x5c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry23
  * ROM Entries register 23
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry23_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY24 register description at address offset 0x60
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry24
  * ROM Entries register 24
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry24_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY25 register description at address offset 0x64
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry25
  * ROM Entries register 25
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry25_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY26 register description at address offset 0x68
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry26
  * ROM Entries register 26
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry26_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY27 register description at address offset 0x6c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry27
  * ROM Entries register 27
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry27_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY28 register description at address offset 0x70
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry28
  * ROM Entries register 28
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry28_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY29 register description at address offset 0x74
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry29
  * ROM Entries register 29
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry29_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY30 register description at address offset 0x78
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry30
  * ROM Entries register 30
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry30_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY31 register description at address offset 0x7c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry31
  * ROM Entries register 31
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry31_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY32 register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry32
  * ROM Entries register 32
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry32_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY33 register description at address offset 0x84
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry33
  * ROM Entries register 33
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry33_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY34 register description at address offset 0x88
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry34
  * ROM Entries register 34
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry34_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY35 register description at address offset 0x8c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry35
  * ROM Entries register 35
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry35_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY36 register description at address offset 0x90
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry36
  * ROM Entries register 36
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry36_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY37 register description at address offset 0x94
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry37
  * ROM Entries register 37
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry37_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY38 register description at address offset 0x98
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry38
  * ROM Entries register 38
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry38_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY39 register description at address offset 0x9c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry39
  * ROM Entries register 39
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry39_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY40 register description at address offset 0xa0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry40
  * ROM Entries register 40
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry40_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY41 register description at address offset 0xa4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry41
  * ROM Entries register 41
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry41_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY42 register description at address offset 0xa8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry42
  * ROM Entries register 42
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry42_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY43 register description at address offset 0xac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry43
  * ROM Entries register 43
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry43_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY44 register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry44
  * ROM Entries register 44
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry44_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY45 register description at address offset 0xb4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry45
  * ROM Entries register 45
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry45_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY46 register description at address offset 0xb8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry46
  * ROM Entries register 46
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry46_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY47 register description at address offset 0xbc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry47
  * ROM Entries register 47
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry47_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY48 register description at address offset 0xc0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry48
  * ROM Entries register 48
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry48_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY49 register description at address offset 0xc4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry49
  * ROM Entries register 49
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry49_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY50 register description at address offset 0xc8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry50
  * ROM Entries register 50
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry50_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY51 register description at address offset 0xcc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry51
  * ROM Entries register 51
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry51_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY52 register description at address offset 0xd0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry52
  * ROM Entries register 52
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry52_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY53 register description at address offset 0xd4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry53
  * ROM Entries register 53
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry53_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY54 register description at address offset 0xd8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry54
  * ROM Entries register 54
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry54_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY55 register description at address offset 0xdc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry55
  * ROM Entries register 55
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry55_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY56 register description at address offset 0xe0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry56
  * ROM Entries register 56
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry56_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY57 register description at address offset 0xe4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry57
  * ROM Entries register 57
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry57_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY58 register description at address offset 0xe8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry58
  * ROM Entries register 58
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry58_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY59 register description at address offset 0xec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry59
  * ROM Entries register 59
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry59_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY60 register description at address offset 0xf0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry60
  * ROM Entries register 60
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry60_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY61 register description at address offset 0xf4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry61
  * ROM Entries register 61
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry61_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY62 register description at address offset 0xf8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry62
  * ROM Entries register 62
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry62_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY63 register description at address offset 0xfc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry63
  * ROM Entries register 63
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry63_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY64 register description at address offset 0x100
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry64
  * ROM Entries register 64
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry64_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY65 register description at address offset 0x104
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry65
  * ROM Entries register 65
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry65_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY66 register description at address offset 0x108
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry66
  * ROM Entries register 66
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry66_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY67 register description at address offset 0x10c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry67
  * ROM Entries register 67
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry67_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY68 register description at address offset 0x110
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry68
  * ROM Entries register 68
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry68_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY69 register description at address offset 0x114
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry69
  * ROM Entries register 69
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry69_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY70 register description at address offset 0x118
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry70
  * ROM Entries register 70
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry70_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY71 register description at address offset 0x11c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry71
  * ROM Entries register 71
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry71_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY72 register description at address offset 0x120
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry72
  * ROM Entries register 72
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry72_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY73 register description at address offset 0x124
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry73
  * ROM Entries register 73
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry73_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY74 register description at address offset 0x128
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry74
  * ROM Entries register 74
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry74_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY75 register description at address offset 0x12c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry75
  * ROM Entries register 75
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry75_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY76 register description at address offset 0x130
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry76
  * ROM Entries register 76
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry76_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY77 register description at address offset 0x134
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry77
  * ROM Entries register 77
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry77_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY78 register description at address offset 0x138
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry78
  * ROM Entries register 78
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry78_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY79 register description at address offset 0x13c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry79
  * ROM Entries register 79
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry79_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY80 register description at address offset 0x140
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry80
  * ROM Entries register 80
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry80_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY81 register description at address offset 0x144
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry81
  * ROM Entries register 81
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry81_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY82 register description at address offset 0x148
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry82
  * ROM Entries register 82
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry82_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY83 register description at address offset 0x14c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry83
  * ROM Entries register 83
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry83_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY84 register description at address offset 0x150
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry84
  * ROM Entries register 84
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry84_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY85 register description at address offset 0x154
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry85
  * ROM Entries register 85
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry85_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY86 register description at address offset 0x158
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry86
  * ROM Entries register 86
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry86_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY87 register description at address offset 0x15c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry87
  * ROM Entries register 87
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry87_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY88 register description at address offset 0x160
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry88
  * ROM Entries register 88
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry88_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY89 register description at address offset 0x164
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry89
  * ROM Entries register 89
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry89_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY90 register description at address offset 0x168
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry90
  * ROM Entries register 90
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry90_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY91 register description at address offset 0x16c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry91
  * ROM Entries register 91
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry91_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY92 register description at address offset 0x170
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry92
  * ROM Entries register 92
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry92_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY93 register description at address offset 0x174
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry93
  * ROM Entries register 93
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry93_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY94 register description at address offset 0x178
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry94
  * ROM Entries register 94
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry94_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY95 register description at address offset 0x17c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry95
  * ROM Entries register 95
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry95_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY96 register description at address offset 0x180
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry96
  * ROM Entries register 96
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry96_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY97 register description at address offset 0x184
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry97
  * ROM Entries register 97
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry97_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY98 register description at address offset 0x188
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry98
  * ROM Entries register 98
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry98_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY99 register description at address offset 0x18c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry99
  * ROM Entries register 99
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry99_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY100 register description at address offset 0x190
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry100
  * ROM Entries register 100
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry100_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY101 register description at address offset 0x194
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry101
  * ROM Entries register 101
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry101_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY102 register description at address offset 0x198
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry102
  * ROM Entries register 102
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry102_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY103 register description at address offset 0x19c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry103
  * ROM Entries register 103
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry103_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY104 register description at address offset 0x1a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry104
  * ROM Entries register 104
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry104_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY105 register description at address offset 0x1a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry105
  * ROM Entries register 105
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry105_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY106 register description at address offset 0x1a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry106
  * ROM Entries register 106
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry106_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY107 register description at address offset 0x1ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry107
  * ROM Entries register 107
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry107_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY108 register description at address offset 0x1b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry108
  * ROM Entries register 108
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry108_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY109 register description at address offset 0x1b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry109
  * ROM Entries register 109
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry109_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY110 register description at address offset 0x1b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry110
  * ROM Entries register 110
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry110_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY111 register description at address offset 0x1bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry111
  * ROM Entries register 111
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry111_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY112 register description at address offset 0x1c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry112
  * ROM Entries register 112
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry112_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY113 register description at address offset 0x1c4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry113
  * ROM Entries register 113
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry113_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY114 register description at address offset 0x1c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry114
  * ROM Entries register 114
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry114_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY115 register description at address offset 0x1cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry115
  * ROM Entries register 115
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry115_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY116 register description at address offset 0x1d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry116
  * ROM Entries register 116
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry116_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY117 register description at address offset 0x1d4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry117
  * ROM Entries register 117
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry117_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY118 register description at address offset 0x1d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry118
  * ROM Entries register 118
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry118_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY119 register description at address offset 0x1dc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry119
  * ROM Entries register 119
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry119_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY120 register description at address offset 0x1e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry120
  * ROM Entries register 120
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry120_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY121 register description at address offset 0x1e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry121
  * ROM Entries register 121
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry121_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY122 register description at address offset 0x1e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry122
  * ROM Entries register 122
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry122_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY123 register description at address offset 0x1ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry123
  * ROM Entries register 123
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry123_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY124 register description at address offset 0x1f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry124
  * ROM Entries register 124
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry124_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY125 register description at address offset 0x1f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry125
  * ROM Entries register 125
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry125_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY126 register description at address offset 0x1f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry126
  * ROM Entries register 126
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry126_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY127 register description at address offset 0x1fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry127
  * ROM Entries register 127
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry127_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY128 register description at address offset 0x200
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry128
  * ROM Entries register 128
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry128_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY129 register description at address offset 0x204
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry129
  * ROM Entries register 129
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry129_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY130 register description at address offset 0x208
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry130
  * ROM Entries register 130
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry130_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY131 register description at address offset 0x20c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry131
  * ROM Entries register 131
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry131_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY132 register description at address offset 0x210
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry132
  * ROM Entries register 132
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry132_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY133 register description at address offset 0x214
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry133
  * ROM Entries register 133
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry133_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY134 register description at address offset 0x218
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry134
  * ROM Entries register 134
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry134_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY135 register description at address offset 0x21c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry135
  * ROM Entries register 135
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry135_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY136 register description at address offset 0x220
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry136
  * ROM Entries register 136
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry136_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY137 register description at address offset 0x224
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry137
  * ROM Entries register 137
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry137_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY138 register description at address offset 0x228
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry138
  * ROM Entries register 138
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry138_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY139 register description at address offset 0x22c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry139
  * ROM Entries register 139
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry139_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY140 register description at address offset 0x230
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry140
  * ROM Entries register 140
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry140_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY141 register description at address offset 0x234
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry141
  * ROM Entries register 141
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry141_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY142 register description at address offset 0x238
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry142
  * ROM Entries register 142
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry142_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY143 register description at address offset 0x23c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry143
  * ROM Entries register 143
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry143_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY144 register description at address offset 0x240
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry144
  * ROM Entries register 144
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry144_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY145 register description at address offset 0x244
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry145
  * ROM Entries register 145
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry145_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY146 register description at address offset 0x248
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry146
  * ROM Entries register 146
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry146_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY147 register description at address offset 0x24c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry147
  * ROM Entries register 147
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry147_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY148 register description at address offset 0x250
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry148
  * ROM Entries register 148
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry148_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY149 register description at address offset 0x254
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry149
  * ROM Entries register 149
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry149_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY150 register description at address offset 0x258
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry150
  * ROM Entries register 150
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry150_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY151 register description at address offset 0x25c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry151
  * ROM Entries register 151
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry151_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY152 register description at address offset 0x260
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry152
  * ROM Entries register 152
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry152_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY153 register description at address offset 0x264
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry153
  * ROM Entries register 153
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry153_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY154 register description at address offset 0x268
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry154
  * ROM Entries register 154
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry154_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY155 register description at address offset 0x26c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry155
  * ROM Entries register 155
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry155_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY156 register description at address offset 0x270
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry156
  * ROM Entries register 156
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry156_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY157 register description at address offset 0x274
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry157
  * ROM Entries register 157
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry157_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY158 register description at address offset 0x278
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry158
  * ROM Entries register 158
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry158_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY159 register description at address offset 0x27c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry159
  * ROM Entries register 159
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry159_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY160 register description at address offset 0x280
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry160
  * ROM Entries register 160
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry160_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY161 register description at address offset 0x284
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry161
  * ROM Entries register 161
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry161_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY162 register description at address offset 0x288
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry162
  * ROM Entries register 162
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry162_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY163 register description at address offset 0x28c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry163
  * ROM Entries register 163
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry163_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY164 register description at address offset 0x290
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry164
  * ROM Entries register 164
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry164_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY165 register description at address offset 0x294
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry165
  * ROM Entries register 165
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry165_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY166 register description at address offset 0x298
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry166
  * ROM Entries register 166
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry166_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY167 register description at address offset 0x29c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry167
  * ROM Entries register 167
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry167_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY168 register description at address offset 0x2a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry168
  * ROM Entries register 168
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry168_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY169 register description at address offset 0x2a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry169
  * ROM Entries register 169
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry169_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY170 register description at address offset 0x2a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry170
  * ROM Entries register 170
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry170_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY171 register description at address offset 0x2ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry171
  * ROM Entries register 171
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry171_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY172 register description at address offset 0x2b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry172
  * ROM Entries register 172
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry172_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY173 register description at address offset 0x2b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry173
  * ROM Entries register 173
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry173_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY174 register description at address offset 0x2b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry174
  * ROM Entries register 174
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry174_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY175 register description at address offset 0x2bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry175
  * ROM Entries register 175
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry175_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY176 register description at address offset 0x2c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry176
  * ROM Entries register 176
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry176_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY177 register description at address offset 0x2c4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry177
  * ROM Entries register 177
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry177_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY178 register description at address offset 0x2c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry178
  * ROM Entries register 178
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry178_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY179 register description at address offset 0x2cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry179
  * ROM Entries register 179
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry179_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY180 register description at address offset 0x2d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry180
  * ROM Entries register 180
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry180_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY181 register description at address offset 0x2d4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry181
  * ROM Entries register 181
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry181_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY182 register description at address offset 0x2d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry182
  * ROM Entries register 182
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry182_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY183 register description at address offset 0x2dc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry183
  * ROM Entries register 183
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry183_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY184 register description at address offset 0x2e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry184
  * ROM Entries register 184
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry184_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY185 register description at address offset 0x2e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry185
  * ROM Entries register 185
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry185_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY186 register description at address offset 0x2e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry186
  * ROM Entries register 186
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry186_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY187 register description at address offset 0x2ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry187
  * ROM Entries register 187
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry187_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY188 register description at address offset 0x2f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry188
  * ROM Entries register 188
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry188_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY189 register description at address offset 0x2f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry189
  * ROM Entries register 189
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry189_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY190 register description at address offset 0x2f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry190
  * ROM Entries register 190
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry190_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY191 register description at address offset 0x2fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry191
  * ROM Entries register 191
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry191_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY192 register description at address offset 0x300
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry192
  * ROM Entries register 192
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry192_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY193 register description at address offset 0x304
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry193
  * ROM Entries register 193
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry193_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY194 register description at address offset 0x308
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry194
  * ROM Entries register 194
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry194_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY195 register description at address offset 0x30c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry195
  * ROM Entries register 195
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry195_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY196 register description at address offset 0x310
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry196
  * ROM Entries register 196
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry196_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY197 register description at address offset 0x314
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry197
  * ROM Entries register 197
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry197_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY198 register description at address offset 0x318
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry198
  * ROM Entries register 198
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry198_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY199 register description at address offset 0x31c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry199
  * ROM Entries register 199
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry199_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY200 register description at address offset 0x320
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry200
  * ROM Entries register 200
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry200_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY201 register description at address offset 0x324
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry201
  * ROM Entries register 201
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry201_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY202 register description at address offset 0x328
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry202
  * ROM Entries register 202
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry202_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY203 register description at address offset 0x32c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry203
  * ROM Entries register 203
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry203_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY204 register description at address offset 0x330
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry204
  * ROM Entries register 204
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry204_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY205 register description at address offset 0x334
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry205
  * ROM Entries register 205
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry205_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY206 register description at address offset 0x338
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry206
  * ROM Entries register 206
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry206_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY207 register description at address offset 0x33c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry207
  * ROM Entries register 207
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry207_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY208 register description at address offset 0x340
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry208
  * ROM Entries register 208
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry208_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY209 register description at address offset 0x344
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry209
  * ROM Entries register 209
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry209_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY210 register description at address offset 0x348
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry210
  * ROM Entries register 210
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry210_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY211 register description at address offset 0x34c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry211
  * ROM Entries register 211
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry211_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY212 register description at address offset 0x350
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry212
  * ROM Entries register 212
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry212_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY213 register description at address offset 0x354
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry213
  * ROM Entries register 213
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry213_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY214 register description at address offset 0x358
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry214
  * ROM Entries register 214
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry214_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY215 register description at address offset 0x35c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry215
  * ROM Entries register 215
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry215_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY216 register description at address offset 0x360
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry216
  * ROM Entries register 216
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry216_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY217 register description at address offset 0x364
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry217
  * ROM Entries register 217
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry217_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY218 register description at address offset 0x368
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry218
  * ROM Entries register 218
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry218_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY219 register description at address offset 0x36c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry219
  * ROM Entries register 219
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry219_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY220 register description at address offset 0x370
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry220
  * ROM Entries register 220
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry220_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY221 register description at address offset 0x374
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry221
  * ROM Entries register 221
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry221_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY222 register description at address offset 0x378
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry222
  * ROM Entries register 222
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry222_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY223 register description at address offset 0x37c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry223
  * ROM Entries register 223
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry223_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY224 register description at address offset 0x380
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry224
  * ROM Entries register 224
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry224_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY225 register description at address offset 0x384
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry225
  * ROM Entries register 225
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry225_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY226 register description at address offset 0x388
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry226
  * ROM Entries register 226
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry226_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY227 register description at address offset 0x38c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry227
  * ROM Entries register 227
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry227_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY228 register description at address offset 0x390
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry228
  * ROM Entries register 228
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry228_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY229 register description at address offset 0x394
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry229
  * ROM Entries register 229
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry229_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY230 register description at address offset 0x398
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry230
  * ROM Entries register 230
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry230_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY231 register description at address offset 0x39c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry231
  * ROM Entries register 231
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry231_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY232 register description at address offset 0x3a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry232
  * ROM Entries register 232
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry232_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY233 register description at address offset 0x3a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry233
  * ROM Entries register 233
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry233_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY234 register description at address offset 0x3a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry234
  * ROM Entries register 234
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry234_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY235 register description at address offset 0x3ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry235
  * ROM Entries register 235
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry235_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY236 register description at address offset 0x3b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry236
  * ROM Entries register 236
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry236_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY237 register description at address offset 0x3b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry237
  * ROM Entries register 237
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry237_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY238 register description at address offset 0x3b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry238
  * ROM Entries register 238
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry238_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY239 register description at address offset 0x3bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry239
  * ROM Entries register 239
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry239_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY240 register description at address offset 0x3c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry240
  * ROM Entries register 240
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry240_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY241 register description at address offset 0x3c4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry241
  * ROM Entries register 241
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry241_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY242 register description at address offset 0x3c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry242
  * ROM Entries register 242
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry242_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY243 register description at address offset 0x3cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry243
  * ROM Entries register 243
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry243_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY244 register description at address offset 0x3d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry244
  * ROM Entries register 244
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry244_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY245 register description at address offset 0x3d4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry245
  * ROM Entries register 245
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry245_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY246 register description at address offset 0x3d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry246
  * ROM Entries register 246
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry246_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY247 register description at address offset 0x3dc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry247
  * ROM Entries register 247
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry247_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY248 register description at address offset 0x3e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry248
  * ROM Entries register 248
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry248_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY249 register description at address offset 0x3e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry249
  * ROM Entries register 249
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry249_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY250 register description at address offset 0x3e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry250
  * ROM Entries register 250
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry250_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY251 register description at address offset 0x3ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry251
  * ROM Entries register 251
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry251_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY252 register description at address offset 0x3f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry252
  * ROM Entries register 252
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry252_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY253 register description at address offset 0x3f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry253
  * ROM Entries register 253
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry253_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY254 register description at address offset 0x3f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry254
  * ROM Entries register 254
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry254_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY255 register description at address offset 0x3fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry255
  * ROM Entries register 255
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry255_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY256 register description at address offset 0x400
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry256
  * ROM Entries register 256
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry256_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY257 register description at address offset 0x404
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry257
  * ROM Entries register 257
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry257_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY258 register description at address offset 0x408
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry258
  * ROM Entries register 258
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry258_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY259 register description at address offset 0x40c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry259
  * ROM Entries register 259
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry259_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY260 register description at address offset 0x410
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry260
  * ROM Entries register 260
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry260_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY261 register description at address offset 0x414
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry261
  * ROM Entries register 261
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry261_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY262 register description at address offset 0x418
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry262
  * ROM Entries register 262
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry262_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY263 register description at address offset 0x41c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry263
  * ROM Entries register 263
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry263_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY264 register description at address offset 0x420
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry264
  * ROM Entries register 264
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry264_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY265 register description at address offset 0x424
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry265
  * ROM Entries register 265
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry265_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY266 register description at address offset 0x428
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry266
  * ROM Entries register 266
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry266_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY267 register description at address offset 0x42c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry267
  * ROM Entries register 267
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry267_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY268 register description at address offset 0x430
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry268
  * ROM Entries register 268
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry268_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY269 register description at address offset 0x434
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry269
  * ROM Entries register 269
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry269_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY270 register description at address offset 0x438
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry270
  * ROM Entries register 270
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry270_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY271 register description at address offset 0x43c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry271
  * ROM Entries register 271
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry271_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY272 register description at address offset 0x440
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry272
  * ROM Entries register 272
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry272_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY273 register description at address offset 0x444
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry273
  * ROM Entries register 273
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry273_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY274 register description at address offset 0x448
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry274
  * ROM Entries register 274
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry274_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY275 register description at address offset 0x44c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry275
  * ROM Entries register 275
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry275_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY276 register description at address offset 0x450
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry276
  * ROM Entries register 276
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry276_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY277 register description at address offset 0x454
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry277
  * ROM Entries register 277
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry277_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY278 register description at address offset 0x458
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry278
  * ROM Entries register 278
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry278_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY279 register description at address offset 0x45c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry279
  * ROM Entries register 279
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry279_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY280 register description at address offset 0x460
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry280
  * ROM Entries register 280
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry280_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY281 register description at address offset 0x464
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry281
  * ROM Entries register 281
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry281_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY282 register description at address offset 0x468
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry282
  * ROM Entries register 282
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry282_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY283 register description at address offset 0x46c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry283
  * ROM Entries register 283
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry283_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY284 register description at address offset 0x470
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry284
  * ROM Entries register 284
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry284_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY285 register description at address offset 0x474
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry285
  * ROM Entries register 285
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry285_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY286 register description at address offset 0x478
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry286
  * ROM Entries register 286
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry286_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY287 register description at address offset 0x47c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry287
  * ROM Entries register 287
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry287_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY288 register description at address offset 0x480
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry288
  * ROM Entries register 288
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry288_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY289 register description at address offset 0x484
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry289
  * ROM Entries register 289
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry289_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY290 register description at address offset 0x488
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry290
  * ROM Entries register 290
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry290_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY291 register description at address offset 0x48c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry291
  * ROM Entries register 291
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry291_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY292 register description at address offset 0x490
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry292
  * ROM Entries register 292
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry292_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY293 register description at address offset 0x494
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry293
  * ROM Entries register 293
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry293_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY294 register description at address offset 0x498
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry294
  * ROM Entries register 294
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry294_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY295 register description at address offset 0x49c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry295
  * ROM Entries register 295
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry295_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY296 register description at address offset 0x4a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry296
  * ROM Entries register 296
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry296_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY297 register description at address offset 0x4a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry297
  * ROM Entries register 297
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry297_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY298 register description at address offset 0x4a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry298
  * ROM Entries register 298
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry298_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY299 register description at address offset 0x4ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry299
  * ROM Entries register 299
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry299_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY300 register description at address offset 0x4b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry300
  * ROM Entries register 300
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry300_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY301 register description at address offset 0x4b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry301
  * ROM Entries register 301
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry301_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY302 register description at address offset 0x4b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry302
  * ROM Entries register 302
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry302_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY303 register description at address offset 0x4bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry303
  * ROM Entries register 303
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry303_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY304 register description at address offset 0x4c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry304
  * ROM Entries register 304
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry304_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY305 register description at address offset 0x4c4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry305
  * ROM Entries register 305
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry305_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY306 register description at address offset 0x4c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry306
  * ROM Entries register 306
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry306_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY307 register description at address offset 0x4cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry307
  * ROM Entries register 307
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry307_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY308 register description at address offset 0x4d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry308
  * ROM Entries register 308
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry308_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY309 register description at address offset 0x4d4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry309
  * ROM Entries register 309
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry309_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY310 register description at address offset 0x4d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry310
  * ROM Entries register 310
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry310_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY311 register description at address offset 0x4dc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry311
  * ROM Entries register 311
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry311_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY312 register description at address offset 0x4e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry312
  * ROM Entries register 312
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry312_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY313 register description at address offset 0x4e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry313
  * ROM Entries register 313
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry313_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY314 register description at address offset 0x4e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry314
  * ROM Entries register 314
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry314_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY315 register description at address offset 0x4ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry315
  * ROM Entries register 315
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry315_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY316 register description at address offset 0x4f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry316
  * ROM Entries register 316
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry316_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY317 register description at address offset 0x4f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry317
  * ROM Entries register 317
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry317_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY318 register description at address offset 0x4f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry318
  * ROM Entries register 318
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry318_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY319 register description at address offset 0x4fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry319
  * ROM Entries register 319
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry319_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY320 register description at address offset 0x500
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry320
  * ROM Entries register 320
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry320_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY321 register description at address offset 0x504
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry321
  * ROM Entries register 321
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry321_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY322 register description at address offset 0x508
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry322
  * ROM Entries register 322
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry322_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY323 register description at address offset 0x50c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry323
  * ROM Entries register 323
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry323_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY324 register description at address offset 0x510
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry324
  * ROM Entries register 324
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry324_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY325 register description at address offset 0x514
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry325
  * ROM Entries register 325
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry325_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY326 register description at address offset 0x518
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry326
  * ROM Entries register 326
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry326_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY327 register description at address offset 0x51c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry327
  * ROM Entries register 327
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry327_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY328 register description at address offset 0x520
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry328
  * ROM Entries register 328
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry328_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY329 register description at address offset 0x524
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry329
  * ROM Entries register 329
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry329_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY330 register description at address offset 0x528
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry330
  * ROM Entries register 330
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry330_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY331 register description at address offset 0x52c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry331
  * ROM Entries register 331
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry331_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY332 register description at address offset 0x530
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry332
  * ROM Entries register 332
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry332_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY333 register description at address offset 0x534
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry333
  * ROM Entries register 333
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry333_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY334 register description at address offset 0x538
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry334
  * ROM Entries register 334
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry334_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY335 register description at address offset 0x53c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry335
  * ROM Entries register 335
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry335_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY336 register description at address offset 0x540
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry336
  * ROM Entries register 336
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry336_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY337 register description at address offset 0x544
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry337
  * ROM Entries register 337
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry337_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY338 register description at address offset 0x548
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry338
  * ROM Entries register 338
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry338_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY339 register description at address offset 0x54c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry339
  * ROM Entries register 339
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry339_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY340 register description at address offset 0x550
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry340
  * ROM Entries register 340
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry340_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY341 register description at address offset 0x554
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry341
  * ROM Entries register 341
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry341_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY342 register description at address offset 0x558
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry342
  * ROM Entries register 342
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry342_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY343 register description at address offset 0x55c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry343
  * ROM Entries register 343
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry343_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY344 register description at address offset 0x560
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry344
  * ROM Entries register 344
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry344_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY345 register description at address offset 0x564
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry345
  * ROM Entries register 345
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry345_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY346 register description at address offset 0x568
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry346
  * ROM Entries register 346
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry346_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY347 register description at address offset 0x56c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry347
  * ROM Entries register 347
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry347_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY348 register description at address offset 0x570
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry348
  * ROM Entries register 348
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry348_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY349 register description at address offset 0x574
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry349
  * ROM Entries register 349
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry349_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY350 register description at address offset 0x578
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry350
  * ROM Entries register 350
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry350_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY351 register description at address offset 0x57c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry351
  * ROM Entries register 351
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry351_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY352 register description at address offset 0x580
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry352
  * ROM Entries register 352
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry352_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY353 register description at address offset 0x584
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry353
  * ROM Entries register 353
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry353_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY354 register description at address offset 0x588
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry354
  * ROM Entries register 354
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry354_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY355 register description at address offset 0x58c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry355
  * ROM Entries register 355
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry355_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY356 register description at address offset 0x590
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry356
  * ROM Entries register 356
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry356_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY357 register description at address offset 0x594
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry357
  * ROM Entries register 357
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry357_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY358 register description at address offset 0x598
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry358
  * ROM Entries register 358
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry358_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY359 register description at address offset 0x59c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry359
  * ROM Entries register 359
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry359_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY360 register description at address offset 0x5a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry360
  * ROM Entries register 360
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry360_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY361 register description at address offset 0x5a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry361
  * ROM Entries register 361
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry361_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY362 register description at address offset 0x5a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry362
  * ROM Entries register 362
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry362_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY363 register description at address offset 0x5ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry363
  * ROM Entries register 363
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry363_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY364 register description at address offset 0x5b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry364
  * ROM Entries register 364
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry364_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY365 register description at address offset 0x5b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry365
  * ROM Entries register 365
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry365_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY366 register description at address offset 0x5b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry366
  * ROM Entries register 366
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry366_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY367 register description at address offset 0x5bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry367
  * ROM Entries register 367
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry367_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY368 register description at address offset 0x5c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry368
  * ROM Entries register 368
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry368_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY369 register description at address offset 0x5c4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry369
  * ROM Entries register 369
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry369_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY370 register description at address offset 0x5c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry370
  * ROM Entries register 370
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry370_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY371 register description at address offset 0x5cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry371
  * ROM Entries register 371
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry371_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY372 register description at address offset 0x5d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry372
  * ROM Entries register 372
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry372_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY373 register description at address offset 0x5d4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry373
  * ROM Entries register 373
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry373_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY374 register description at address offset 0x5d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry374
  * ROM Entries register 374
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry374_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY375 register description at address offset 0x5dc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry375
  * ROM Entries register 375
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry375_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY376 register description at address offset 0x5e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry376
  * ROM Entries register 376
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry376_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY377 register description at address offset 0x5e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry377
  * ROM Entries register 377
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry377_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY378 register description at address offset 0x5e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry378
  * ROM Entries register 378
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry378_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY379 register description at address offset 0x5ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry379
  * ROM Entries register 379
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry379_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY380 register description at address offset 0x5f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry380
  * ROM Entries register 380
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry380_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY381 register description at address offset 0x5f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry381
  * ROM Entries register 381
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry381_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY382 register description at address offset 0x5f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry382
  * ROM Entries register 382
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry382_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY383 register description at address offset 0x5fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry383
  * ROM Entries register 383
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry383_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY384 register description at address offset 0x600
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry384
  * ROM Entries register 384
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry384_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY385 register description at address offset 0x604
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry385
  * ROM Entries register 385
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry385_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY386 register description at address offset 0x608
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry386
  * ROM Entries register 386
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry386_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY387 register description at address offset 0x60c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry387
  * ROM Entries register 387
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry387_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY388 register description at address offset 0x610
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry388
  * ROM Entries register 388
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry388_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY389 register description at address offset 0x614
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry389
  * ROM Entries register 389
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry389_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY390 register description at address offset 0x618
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry390
  * ROM Entries register 390
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry390_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY391 register description at address offset 0x61c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry391
  * ROM Entries register 391
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry391_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY392 register description at address offset 0x620
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry392
  * ROM Entries register 392
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry392_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY393 register description at address offset 0x624
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry393
  * ROM Entries register 393
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry393_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY394 register description at address offset 0x628
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry394
  * ROM Entries register 394
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry394_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY395 register description at address offset 0x62c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry395
  * ROM Entries register 395
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry395_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY396 register description at address offset 0x630
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry396
  * ROM Entries register 396
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry396_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY397 register description at address offset 0x634
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry397
  * ROM Entries register 397
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry397_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY398 register description at address offset 0x638
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry398
  * ROM Entries register 398
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry398_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY399 register description at address offset 0x63c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry399
  * ROM Entries register 399
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry399_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY400 register description at address offset 0x640
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry400
  * ROM Entries register 400
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry400_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY401 register description at address offset 0x644
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry401
  * ROM Entries register 401
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry401_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY402 register description at address offset 0x648
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry402
  * ROM Entries register 402
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry402_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY403 register description at address offset 0x64c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry403
  * ROM Entries register 403
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry403_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY404 register description at address offset 0x650
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry404
  * ROM Entries register 404
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry404_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY405 register description at address offset 0x654
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry405
  * ROM Entries register 405
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry405_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY406 register description at address offset 0x658
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry406
  * ROM Entries register 406
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry406_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY407 register description at address offset 0x65c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry407
  * ROM Entries register 407
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry407_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY408 register description at address offset 0x660
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry408
  * ROM Entries register 408
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry408_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY409 register description at address offset 0x664
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry409
  * ROM Entries register 409
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry409_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY410 register description at address offset 0x668
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry410
  * ROM Entries register 410
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry410_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY411 register description at address offset 0x66c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry411
  * ROM Entries register 411
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry411_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY412 register description at address offset 0x670
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry412
  * ROM Entries register 412
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry412_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY413 register description at address offset 0x674
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry413
  * ROM Entries register 413
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry413_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY414 register description at address offset 0x678
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry414
  * ROM Entries register 414
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry414_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY415 register description at address offset 0x67c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry415
  * ROM Entries register 415
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry415_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY416 register description at address offset 0x680
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry416
  * ROM Entries register 416
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry416_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY417 register description at address offset 0x684
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry417
  * ROM Entries register 417
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry417_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY418 register description at address offset 0x688
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry418
  * ROM Entries register 418
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry418_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY419 register description at address offset 0x68c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry419
  * ROM Entries register 419
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry419_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY420 register description at address offset 0x690
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry420
  * ROM Entries register 420
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry420_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY421 register description at address offset 0x694
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry421
  * ROM Entries register 421
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry421_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY422 register description at address offset 0x698
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry422
  * ROM Entries register 422
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry422_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY423 register description at address offset 0x69c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry423
  * ROM Entries register 423
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry423_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY424 register description at address offset 0x6a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry424
  * ROM Entries register 424
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry424_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY425 register description at address offset 0x6a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry425
  * ROM Entries register 425
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry425_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY426 register description at address offset 0x6a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry426
  * ROM Entries register 426
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry426_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY427 register description at address offset 0x6ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry427
  * ROM Entries register 427
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry427_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY428 register description at address offset 0x6b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry428
  * ROM Entries register 428
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry428_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY429 register description at address offset 0x6b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry429
  * ROM Entries register 429
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry429_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY430 register description at address offset 0x6b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry430
  * ROM Entries register 430
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry430_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY431 register description at address offset 0x6bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry431
  * ROM Entries register 431
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry431_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY432 register description at address offset 0x6c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry432
  * ROM Entries register 432
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry432_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY433 register description at address offset 0x6c4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry433
  * ROM Entries register 433
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry433_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY434 register description at address offset 0x6c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry434
  * ROM Entries register 434
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry434_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY435 register description at address offset 0x6cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry435
  * ROM Entries register 435
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry435_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY436 register description at address offset 0x6d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry436
  * ROM Entries register 436
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry436_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY437 register description at address offset 0x6d4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry437
  * ROM Entries register 437
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry437_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY438 register description at address offset 0x6d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry438
  * ROM Entries register 438
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry438_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY439 register description at address offset 0x6dc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry439
  * ROM Entries register 439
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry439_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY440 register description at address offset 0x6e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry440
  * ROM Entries register 440
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry440_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY441 register description at address offset 0x6e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry441
  * ROM Entries register 441
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry441_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY442 register description at address offset 0x6e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry442
  * ROM Entries register 442
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry442_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY443 register description at address offset 0x6ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry443
  * ROM Entries register 443
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry443_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY444 register description at address offset 0x6f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry444
  * ROM Entries register 444
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry444_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY445 register description at address offset 0x6f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry445
  * ROM Entries register 445
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry445_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY446 register description at address offset 0x6f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry446
  * ROM Entries register 446
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry446_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY447 register description at address offset 0x6fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry447
  * ROM Entries register 447
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry447_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY448 register description at address offset 0x700
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry448
  * ROM Entries register 448
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry448_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY449 register description at address offset 0x704
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry449
  * ROM Entries register 449
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry449_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY450 register description at address offset 0x708
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry450
  * ROM Entries register 450
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry450_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY451 register description at address offset 0x70c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry451
  * ROM Entries register 451
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry451_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY452 register description at address offset 0x710
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry452
  * ROM Entries register 452
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry452_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY453 register description at address offset 0x714
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry453
  * ROM Entries register 453
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry453_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY454 register description at address offset 0x718
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry454
  * ROM Entries register 454
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry454_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY455 register description at address offset 0x71c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry455
  * ROM Entries register 455
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry455_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY456 register description at address offset 0x720
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry456
  * ROM Entries register 456
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry456_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY457 register description at address offset 0x724
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry457
  * ROM Entries register 457
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry457_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY458 register description at address offset 0x728
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry458
  * ROM Entries register 458
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry458_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY459 register description at address offset 0x72c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry459
  * ROM Entries register 459
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry459_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY460 register description at address offset 0x730
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry460
  * ROM Entries register 460
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry460_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY461 register description at address offset 0x734
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry461
  * ROM Entries register 461
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry461_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY462 register description at address offset 0x738
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry462
  * ROM Entries register 462
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry462_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY463 register description at address offset 0x73c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry463
  * ROM Entries register 463
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry463_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY464 register description at address offset 0x740
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry464
  * ROM Entries register 464
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry464_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY465 register description at address offset 0x744
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry465
  * ROM Entries register 465
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry465_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY466 register description at address offset 0x748
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry466
  * ROM Entries register 466
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry466_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY467 register description at address offset 0x74c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry467
  * ROM Entries register 467
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry467_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY468 register description at address offset 0x750
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry468
  * ROM Entries register 468
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry468_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY469 register description at address offset 0x754
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry469
  * ROM Entries register 469
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry469_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY470 register description at address offset 0x758
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry470
  * ROM Entries register 470
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry470_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY471 register description at address offset 0x75c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry471
  * ROM Entries register 471
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry471_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY472 register description at address offset 0x760
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry472
  * ROM Entries register 472
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry472_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY473 register description at address offset 0x764
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry473
  * ROM Entries register 473
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry473_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY474 register description at address offset 0x768
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry474
  * ROM Entries register 474
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry474_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY475 register description at address offset 0x76c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry475
  * ROM Entries register 475
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry475_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY476 register description at address offset 0x770
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry476
  * ROM Entries register 476
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry476_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY477 register description at address offset 0x774
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry477
  * ROM Entries register 477
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry477_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY478 register description at address offset 0x778
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry478
  * ROM Entries register 478
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry478_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY479 register description at address offset 0x77c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry479
  * ROM Entries register 479
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry479_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY480 register description at address offset 0x780
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry480
  * ROM Entries register 480
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry480_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY481 register description at address offset 0x784
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry481
  * ROM Entries register 481
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry481_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY482 register description at address offset 0x788
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry482
  * ROM Entries register 482
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry482_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY483 register description at address offset 0x78c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry483
  * ROM Entries register 483
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry483_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY484 register description at address offset 0x790
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry484
  * ROM Entries register 484
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry484_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY485 register description at address offset 0x794
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry485
  * ROM Entries register 485
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry485_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY486 register description at address offset 0x798
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry486
  * ROM Entries register 486
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry486_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY487 register description at address offset 0x79c
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry487
  * ROM Entries register 487
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry487_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY488 register description at address offset 0x7a0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry488
  * ROM Entries register 488
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry488_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY489 register description at address offset 0x7a4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry489
  * ROM Entries register 489
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry489_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY490 register description at address offset 0x7a8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry490
  * ROM Entries register 490
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry490_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY491 register description at address offset 0x7ac
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry491
  * ROM Entries register 491
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry491_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY492 register description at address offset 0x7b0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry492
  * ROM Entries register 492
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry492_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY493 register description at address offset 0x7b4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry493
  * ROM Entries register 493
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry493_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY494 register description at address offset 0x7b8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry494
  * ROM Entries register 494
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry494_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY495 register description at address offset 0x7bc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry495
  * ROM Entries register 495
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry495_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY496 register description at address offset 0x7c0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry496
  * ROM Entries register 496
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry496_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY497 register description at address offset 0x7c4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry497
  * ROM Entries register 497
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry497_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY498 register description at address offset 0x7c8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry498
  * ROM Entries register 498
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry498_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY499 register description at address offset 0x7cc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry499
  * ROM Entries register 499
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry499_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY500 register description at address offset 0x7d0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry500
  * ROM Entries register 500
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry500_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY501 register description at address offset 0x7d4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry501
  * ROM Entries register 501
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry501_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY502 register description at address offset 0x7d8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry502
  * ROM Entries register 502
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry502_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY503 register description at address offset 0x7dc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry503
  * ROM Entries register 503
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry503_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY504 register description at address offset 0x7e0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry504
  * ROM Entries register 504
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry504_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY505 register description at address offset 0x7e4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry505
  * ROM Entries register 505
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry505_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY506 register description at address offset 0x7e8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry506
  * ROM Entries register 506
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry506_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY507 register description at address offset 0x7ec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry507
  * ROM Entries register 507
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry507_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY508 register description at address offset 0x7f0
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry508
  * ROM Entries register 508
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry508_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY509 register description at address offset 0x7f4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry509
  * ROM Entries register 509
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry509_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY510 register description at address offset 0x7f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry510
  * ROM Entries register 510
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry510_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_ROMENTRY511 register description at address offset 0x7fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/ROMEntry511
  * ROM Entries register 511
  */

typedef union {
  struct {
    uint32_t PRESENT : 2;
    ///< Indicates whether the ROM table entry is present:
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t POWERIDVALID : 1;
    ///< Indicates whether there is a power domain ID specified in the ROM
    ///< table entry:
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t POWERID : 5;
    ///< Indicates the power domain ID of the component. Only valid if bit
    ///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
    ///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
    ///< pins of the component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_1 : 3;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t OFFSET : 20;
    ///< The component address, relative to the base address of this ROM table.
    ///< The component address is calculated using the following equation:
    ///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
    ///< component occupies more than a single 4KB block, OFFSET points to
    ///< the 4KB block which contains the Peripheral ID and Component ID registers
    ///< for the component. Negative values of OFFSET are permitted, using
    ///< two's complement.
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_romentry511_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_WR_MASK (0x00000000U)


///< Indicates whether the ROM table entry is present:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_PRESENT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_PRESENT_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_PRESENT_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_PRESENT_BF_DEF (0x00000000)

///< Indicates whether there is a power domain ID specified in the ROM
///< table entry:
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERIDVALID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERIDVALID_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERIDVALID_BF_MSK (0x00000004)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERIDVALID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_0_BF_DEF (0x00000000)

///< Indicates the power domain ID of the component. Only valid if bit
///< 2 is set. If bit 2 is clear then this field has a value of 0. Possible
///< values are 0 to 31, representing the 32 DBGPWRUPREQ/ACK interface
///< pins of the component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERID_BF_WID ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERID_BF_MSK (0x000001F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_POWERID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_1_BF_OFF ( 9)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_1_BF_MSK (0x00000E00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_RES0_1_BF_DEF (0x00000000)

///< The component address, relative to the base address of this ROM table.
///< The component address is calculated using the following equation:
///< Component Address = ROM Table Base Address + (OFFSET << 12). If a
///< component occupies more than a single 4KB block, OFFSET points to
///< the 4KB block which contains the Peripheral ID and Component ID registers
///< for the component. Negative values of OFFSET are permitted, using
///< two's complement.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_OFFSET_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_OFFSET_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_OFFSET_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_OFFSET_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_AUTHSTATUS register description at address offset 0xfb8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/AUTHSTATUS
  * Authentication Status Register
  */

typedef union {
  struct {
    uint32_t NSID : 2;
    ///< Non-secure invasive debug.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t NSNID : 2;
    ///< Non-secure non-invasive debug.
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t SID : 2;
    ///< Secure invasive debug.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t SNID : 2;
    ///< Secure non-invasive debug.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t HID : 2;
    ///< Hypervisor invasive debug.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t HNID : 2;
    ///< Hypervisor non-invasive debug.
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t RES0_0 : 20;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_authstatus_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_WR_MASK (0x00000000U)


///< Non-secure invasive debug.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSID_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSID_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSID_BF_MSK (0x00000003)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSID_BF_DEF (0x00000000)

///< Non-secure non-invasive debug.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSNID_BF_OFF ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSNID_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSNID_BF_MSK (0x0000000C)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_NSNID_BF_DEF (0x00000000)

///< Secure invasive debug.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SID_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SID_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SID_BF_MSK (0x00000030)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SID_BF_DEF (0x00000000)

///< Secure non-invasive debug.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SNID_BF_OFF ( 6)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SNID_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SNID_BF_MSK (0x000000C0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_SNID_BF_DEF (0x00000000)

///< Hypervisor invasive debug.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HID_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HID_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HID_BF_MSK (0x00000300)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HID_BF_DEF (0x00000000)

///< Hypervisor non-invasive debug.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HNID_BF_OFF (10)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HNID_BF_WID ( 2)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HNID_BF_MSK (0x00000C00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_HNID_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_RES0_0_BF_OFF (12)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_RES0_0_BF_WID (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_RES0_0_BF_MSK (0xFFFFF000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_DEVARCH register description at address offset 0xfbc
  *
  * Register default value:        0x47700AF7
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/DEVARCH
  * Device Architecture Register
  */

typedef union {
  struct {
    uint32_t ARCHID : 16;
    ///< Architecture ID. Returns 0x0af7, identifying ROM Table Architecture
    ///< v0.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xAF7"
    uint32_t REVISION : 4;
    ///< Architecture revision. Returns the revision of the architecture that
    ///< the ARCHID field specifies.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t PRESENT : 1;
    ///< Returns 1, indicating that the DEVARCH register is present
    ///< AccessType="RO" BitOffset="20" ResetValue="0x1"
    uint32_t ARCHITECT : 11;
    ///< Returns 0x23b, denoting Arm as architect of the component
    ///< AccessType="RO" BitOffset="21" ResetValue="0x23B"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_devarch_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_DEFAULT (0x47700af7U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_WR_MASK (0x00000000U)


///< Architecture ID. Returns 0x0af7, identifying ROM Table Architecture
///< v0.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHID_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHID_BF_WID (16)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHID_BF_MSK (0x0000FFFF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHID_BF_DEF (0x00000AF7)

///< Architecture revision. Returns the revision of the architecture that
///< the ARCHID field specifies.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_REVISION_BF_OFF (16)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_REVISION_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_REVISION_BF_MSK (0x000F0000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_REVISION_BF_DEF (0x00000000)

///< Returns 1, indicating that the DEVARCH register is present
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_PRESENT_BF_OFF (20)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_PRESENT_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_PRESENT_BF_MSK (0x00100000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_PRESENT_BF_DEF (0x00100000)

///< Returns 0x23b, denoting Arm as architect of the component
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHITECT_BF_OFF (21)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHITECT_BF_WID (11)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHITECT_BF_MSK (0xFFE00000)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ARCHITECT_BF_DEF (0x47600000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_DEVID register description at address offset 0xfc8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/DEVID
  * Device Configuration Register
  */

typedef union {
  struct {
    uint32_t FORMAT : 3;
    ///< Indicates that this is a 32-bit ROM table.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t RES0_0 : 1;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
    uint32_t SYSMEM : 1;
    ///< Indicates whether system memory is present on the bus. Set by the
    ///< SYSMEM parameter.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t PRR : 1;
    ///< Indicates that power request functionality is included. Set by the
    ///< GPR_PRESENT parameter.
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint32_t RES0_1 : 26;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_devid_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_WR_MASK (0x00000000U)


///< Indicates that this is a 32-bit ROM table.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_FORMAT_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_FORMAT_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_FORMAT_BF_MSK (0x00000007)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_FORMAT_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_0_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_0_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_0_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_0_BF_DEF (0x00000000)

///< Indicates whether system memory is present on the bus. Set by the
///< SYSMEM parameter.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_SYSMEM_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_SYSMEM_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_SYSMEM_BF_MSK (0x00000010)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_SYSMEM_BF_DEF (0x00000000)

///< Indicates that power request functionality is included. Set by the
///< GPR_PRESENT parameter.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_PRR_BF_OFF ( 5)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_PRR_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_PRR_BF_MSK (0x00000020)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_PRR_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_1_BF_OFF ( 6)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_1_BF_WID (26)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_1_BF_MSK (0xFFFFFFC0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_RES0_1_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR4 register description at address offset 0xfd0
  *
  * Register default value:        0x0000000F
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR4
  * Peripheral Identification Register 4
  */

typedef union {
  struct {
    uint32_t DES_2 : 4;
    ///< JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0,
    ///< they indicate the designer of the component and not the implementer,
    ///< except where the two are the same.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t SIZE : 4;
    ///< Indicates the memory size that is used by this component. Returns
    ///< 0 indicating that the component uses an UNKNOWN number of 4KB blocks.
    ///< Using the SIZE field to indicate the size of the component is deprecated.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr4_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_DEFAULT (0x0000000fU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_WR_MASK (0x00000000U)


///< JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0,
///< they indicate the designer of the component and not the implementer,
///< except where the two are the same.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_DES_2_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_DES_2_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_DES_2_BF_MSK (0x0000000F)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_DES_2_BF_DEF (0x0000000F)

///< Indicates the memory size that is used by this component. Returns
///< 0 indicating that the component uses an UNKNOWN number of 4KB blocks.
///< Using the SIZE field to indicate the size of the component is deprecated.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_SIZE_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_SIZE_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_SIZE_BF_MSK (0x000000F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_SIZE_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR5 register description at address offset 0xfd4
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR5
  * Peripheral Identification Register 5
  */

typedef union {
  struct {
    uint32_t PIDR5 : 8;
    ///< Reserved.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr5_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_WR_MASK (0x00000000U)


///< Reserved.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_BF_WID ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_BF_MSK (0x000000FF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR6 register description at address offset 0xfd8
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR6
  * Peripheral Identification Register 6
  */

typedef union {
  struct {
    uint32_t PIDR6 : 8;
    ///< Reserved.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr6_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_WR_MASK (0x00000000U)


///< Reserved.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_BF_WID ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_BF_MSK (0x000000FF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR7 register description at address offset 0xfdc
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR7
  * Peripheral Identification Register 7
  */

typedef union {
  struct {
    uint32_t PIDR7 : 8;
    ///< Reserved.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr7_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_WR_MASK (0x00000000U)


///< Reserved.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_BF_WID ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_BF_MSK (0x000000FF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR0 register description at address offset 0xfe0
  *
  * Register default value:        0x000000FF
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR0
  * Peripheral Identification Register 0
  */

typedef union {
  struct {
    uint32_t PART_0 : 8;
    ///< Part number, bits[7:0]. Set by the configuration inputs part_number[7:0]
    ///< AccessType="RO" BitOffset="0" ResetValue="0xFF"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr0_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_DEFAULT (0x000000ffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_WR_MASK (0x00000000U)


///< Part number, bits[7:0]. Set by the configuration inputs part_number[7:0]
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_PART_0_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_PART_0_BF_WID ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_PART_0_BF_MSK (0x000000FF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_PART_0_BF_DEF (0x000000FF)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR1 register description at address offset 0xfe4
  *
  * Register default value:        0x000000FF
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR1
  * Peripheral Identification Register 1
  */

typedef union {
  struct {
    uint32_t PART_1 : 4;
    ///< Part number, bits[11:8]. Set by the configuration inputs part_number[11:8].
    ///< AccessType="RO" BitOffset="0" ResetValue="0xF"
    uint32_t DES_0 : 4;
    ///< JEP106 identification code, bits[3:0]. Set by the configuration inputs
    ///< jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate
    ///< the designer of the component and not the implementer, except where
    ///< the two are the same.
    ///< AccessType="RO" BitOffset="4" ResetValue="0xF"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr1_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_DEFAULT (0x000000ffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_WR_MASK (0x00000000U)


///< Part number, bits[11:8]. Set by the configuration inputs part_number[11:8].
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_PART_1_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_PART_1_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_PART_1_BF_MSK (0x0000000F)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_PART_1_BF_DEF (0x0000000F)

///< JEP106 identification code, bits[3:0]. Set by the configuration inputs
///< jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate
///< the designer of the component and not the implementer, except where
///< the two are the same.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_DES_0_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_DES_0_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_DES_0_BF_MSK (0x000000F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_DES_0_BF_DEF (0x000000F0)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR2 register description at address offset 0xfe8
  *
  * Register default value:        0x000000FF
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR2
  * Peripheral Identification Register 2
  */

typedef union {
  struct {
    uint32_t DES_1 : 3;
    ///< JEP106 identification code, bits[6:4]. Set by the configuration inputs
    ///< jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate
    ///< the designer of the component and not the implementer, except where
    ///< the two are the same.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x7"
    uint32_t JEDEC : 1;
    ///< 1 - Always set. Indicates that a JEDEC assigned value is used.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x1"
    uint32_t REVISION : 4;
    ///< Revision. Set by the configuration inputs revision[3:0].
    ///< AccessType="RO" BitOffset="4" ResetValue="0xF"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr2_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_DEFAULT (0x000000ffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_WR_MASK (0x00000000U)


///< JEP106 identification code, bits[6:4]. Set by the configuration inputs
///< jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate
///< the designer of the component and not the implementer, except where
///< the two are the same.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_DES_1_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_DES_1_BF_WID ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_DES_1_BF_MSK (0x00000007)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_DES_1_BF_DEF (0x00000007)

///< 1 - Always set. Indicates that a JEDEC assigned value is used.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_JEDEC_BF_OFF ( 3)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_JEDEC_BF_WID ( 1)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_JEDEC_BF_MSK (0x00000008)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_JEDEC_BF_DEF (0x00000008)

///< Revision. Set by the configuration inputs revision[3:0].
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_REVISION_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_REVISION_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_REVISION_BF_MSK (0x000000F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_REVISION_BF_DEF (0x000000F0)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_PIDR3 register description at address offset 0xfec
  *
  * Register default value:        0x00000000
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/PIDR3
  * Peripheral Identification Register 3
  */

typedef union {
  struct {
    uint32_t CMOD : 4;
    ///< Customer Modified. Where the component is reusable IP, this value
    ///< indicates if the customer has modified the behavior of the component.
    ///< In most cases this field is 0x0.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t REVAND : 4;
    ///< This field indicates minor errata fixes specific to this design, for
    ///< example metal fixes after implementation. In most cases this field
    ///< is 0x0.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_pidr3_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_DEFAULT (0x00000000U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_WR_MASK (0x00000000U)


///< Customer Modified. Where the component is reusable IP, this value
///< indicates if the customer has modified the behavior of the component.
///< In most cases this field is 0x0.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_CMOD_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_CMOD_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_CMOD_BF_MSK (0x0000000F)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_CMOD_BF_DEF (0x00000000)

///< This field indicates minor errata fixes specific to this design, for
///< example metal fixes after implementation. In most cases this field
///< is 0x0.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_REVAND_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_REVAND_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_REVAND_BF_MSK (0x000000F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_REVAND_BF_DEF (0x00000000)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_CIDR0 register description at address offset 0xff0
  *
  * Register default value:        0x0000000D
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/CIDR0
  * Component Identification Register 0
  */

typedef union {
  struct {
    uint32_t PRMBL_0 : 8;
    ///< Preamble. Returns 0x0D.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xD"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_cidr0_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_DEFAULT (0x0000000dU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_WR_MASK (0x00000000U)


///< Preamble. Returns 0x0D.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_PRMBL_0_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_PRMBL_0_BF_WID ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_PRMBL_0_BF_MSK (0x000000FF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_PRMBL_0_BF_DEF (0x0000000D)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_CIDR1 register description at address offset 0xff4
  *
  * Register default value:        0x00000090
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/CIDR1
  * Component Identification Register 1
  */

typedef union {
  struct {
    uint32_t PRMBL_1 : 4;
    ///< Preamble. Returns 0x0.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t CLASS : 4;
    ///< Component class. Returns 0x9, indicating this is a CoreSight component.
    ///< AccessType="RO" BitOffset="4" ResetValue="0x9"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_cidr1_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_DEFAULT (0x00000090U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_WR_MASK (0x00000000U)


///< Preamble. Returns 0x0.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_PRMBL_1_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_PRMBL_1_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_PRMBL_1_BF_MSK (0x0000000F)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_PRMBL_1_BF_DEF (0x00000000)

///< Component class. Returns 0x9, indicating this is a CoreSight component.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_CLASS_BF_OFF ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_CLASS_BF_WID ( 4)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_CLASS_BF_MSK (0x000000F0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_CLASS_BF_DEF (0x00000090)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_CIDR2 register description at address offset 0xff8
  *
  * Register default value:        0x00000005
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/CIDR2
  * Component Identification Register 2
  */

typedef union {
  struct {
    uint32_t PRMBL_2 : 8;
    ///< Preamble. Returns 0x05.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x5"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_cidr2_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_DEFAULT (0x00000005U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_WR_MASK (0x00000000U)


///< Preamble. Returns 0x05.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_PRMBL_2_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_PRMBL_2_BF_WID ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_PRMBL_2_BF_MSK (0x000000FF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_PRMBL_2_BF_DEF (0x00000005)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_RES0_0_BF_DEF (0x00000000)


/** @brief CSS600_APBROM_HWC_JTAG_APB4_SLAVE_0_MM_ADDRESSBLOCK_0_CIDR3 register description at address offset 0xffc
  *
  * Register default value:        0x000000B1
  * Register full path in IP: css600_apbrom_hwc_jtag/APB4_Slave_0_MM/addressBlock_0/CIDR3
  * Component Identification Register 3
  */

typedef union {
  struct {
    uint32_t PRMBL_3 : 8;
    ///< Preamble. Returns 0xB1.
    ///< AccessType="RO" BitOffset="0" ResetValue="0xB1"
    uint32_t RES0_0 : 24;
    ///< Reserved bit or field with SBZP behavior
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} css600_apbrom_hwc_jtag_addressblock_0_cidr3_reg_t;

#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_DEFAULT (0x000000b1U)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_RD_MASK (0xffffffffU)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_WR_MASK (0x00000000U)


///< Preamble. Returns 0xB1.
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_PRMBL_3_BF_OFF ( 0)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_PRMBL_3_BF_WID ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_PRMBL_3_BF_MSK (0x000000FF)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_PRMBL_3_BF_DEF (0x000000B1)

///< Reserved bit or field with SBZP behavior
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_RES0_0_BF_OFF ( 8)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_RES0_0_BF_WID (24)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_RES0_0_BF_MSK (0xFFFFFF00)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_RES0_0_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

// Stepping: A0
//
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry0_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY0_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry1_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY1_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry2_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY2_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry3_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY3_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry4_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY4_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry5_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY5_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry6_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY6_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry7_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY7_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry8_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY8_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry9_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY9_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry10_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY10_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry11_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY11_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry12_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY12_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry13_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY13_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry14_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY14_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry15_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY15_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry16_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY16_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry17_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY17_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry18_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY18_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry19_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY19_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry20_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY20_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry21_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY21_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry22_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY22_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry23_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY23_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry24_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY24_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry25_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY25_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry26_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY26_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry27_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY27_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry28_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY28_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry29_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY29_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry30_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY30_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry31_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY31_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry32_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY32_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry33_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY33_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry34_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY34_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry35_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY35_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry36_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY36_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry37_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY37_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry38_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY38_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry39_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY39_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry40_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY40_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry41_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY41_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry42_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY42_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry43_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY43_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry44_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY44_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry45_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY45_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry46_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY46_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry47_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY47_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry48_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY48_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry49_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY49_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry50_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY50_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry51_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY51_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry52_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY52_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry53_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY53_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry54_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY54_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry55_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY55_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry56_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY56_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry57_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY57_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry58_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY58_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry59_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY59_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry60_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY60_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry61_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY61_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry62_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY62_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry63_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY63_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry64_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY64_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry65_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY65_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry66_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY66_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry67_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY67_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry68_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY68_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry69_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY69_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry70_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY70_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry71_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY71_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry72_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY72_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry73_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY73_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry74_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY74_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry75_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY75_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry76_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY76_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry77_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY77_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry78_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY78_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry79_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY79_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry80_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY80_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry81_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY81_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry82_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY82_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry83_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY83_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry84_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY84_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry85_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY85_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry86_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY86_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry87_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY87_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry88_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY88_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry89_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY89_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry90_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY90_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry91_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY91_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry92_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY92_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry93_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY93_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry94_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY94_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry95_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY95_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry96_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY96_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry97_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY97_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry98_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY98_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry99_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY99_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry100_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY100_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry101_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY101_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry102_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY102_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry103_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY103_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry104_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY104_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry105_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY105_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry106_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY106_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry107_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY107_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry108_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY108_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry109_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY109_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry110_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY110_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry111_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY111_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry112_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY112_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry113_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY113_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry114_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY114_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry115_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY115_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry116_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY116_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry117_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY117_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry118_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY118_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry119_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY119_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry120_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY120_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry121_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY121_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry122_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY122_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry123_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY123_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry124_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY124_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry125_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY125_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry126_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY126_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry127_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY127_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry128_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY128_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry129_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY129_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry130_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY130_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry131_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY131_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry132_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY132_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry133_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY133_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry134_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY134_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry135_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY135_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry136_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY136_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry137_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY137_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry138_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY138_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry139_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY139_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry140_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY140_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry141_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY141_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry142_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY142_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry143_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY143_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry144_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY144_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry145_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY145_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry146_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY146_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry147_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY147_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry148_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY148_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry149_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY149_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry150_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY150_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry151_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY151_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry152_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY152_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry153_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY153_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry154_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY154_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry155_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY155_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry156_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY156_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry157_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY157_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry158_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY158_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry159_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY159_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry160_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY160_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry161_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY161_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry162_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY162_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry163_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY163_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry164_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY164_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry165_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY165_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry166_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY166_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry167_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY167_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry168_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY168_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry169_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY169_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry170_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY170_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry171_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY171_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry172_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY172_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry173_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY173_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry174_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY174_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry175_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY175_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry176_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY176_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry177_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY177_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry178_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY178_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry179_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY179_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry180_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY180_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry181_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY181_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry182_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY182_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry183_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY183_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry184_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY184_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry185_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY185_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry186_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY186_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry187_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY187_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry188_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY188_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry189_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY189_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry190_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY190_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry191_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY191_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry192_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY192_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry193_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY193_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry194_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY194_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry195_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY195_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry196_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY196_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry197_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY197_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry198_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY198_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry199_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY199_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry200_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY200_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry201_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY201_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry202_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY202_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry203_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY203_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry204_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY204_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry205_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY205_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry206_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY206_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry207_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY207_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry208_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY208_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry209_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY209_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry210_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY210_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry211_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY211_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry212_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY212_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry213_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY213_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry214_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY214_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry215_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY215_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry216_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY216_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry217_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY217_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry218_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY218_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry219_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY219_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry220_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY220_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry221_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY221_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry222_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY222_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry223_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY223_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry224_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY224_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry225_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY225_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry226_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY226_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry227_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY227_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry228_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY228_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry229_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY229_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry230_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY230_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry231_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY231_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry232_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY232_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry233_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY233_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry234_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY234_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry235_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY235_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry236_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY236_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry237_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY237_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry238_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY238_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry239_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY239_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry240_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY240_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry241_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY241_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry242_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY242_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry243_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY243_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry244_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY244_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry245_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY245_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry246_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY246_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry247_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY247_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry248_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY248_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry249_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY249_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry250_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY250_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry251_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY251_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry252_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY252_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry253_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY253_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry254_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY254_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry255_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY255_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry256_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY256_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry257_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY257_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry258_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY258_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry259_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY259_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry260_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY260_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry261_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY261_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry262_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY262_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry263_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY263_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry264_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY264_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry265_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY265_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry266_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY266_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry267_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY267_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry268_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY268_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry269_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY269_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry270_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY270_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry271_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY271_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry272_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY272_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry273_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY273_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry274_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY274_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry275_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY275_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry276_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY276_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry277_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY277_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry278_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY278_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry279_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY279_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry280_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY280_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry281_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY281_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry282_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY282_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry283_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY283_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry284_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY284_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry285_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY285_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry286_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY286_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry287_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY287_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry288_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY288_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry289_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY289_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry290_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY290_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry291_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY291_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry292_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY292_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry293_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY293_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry294_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY294_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry295_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY295_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry296_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY296_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry297_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY297_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry298_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY298_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry299_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY299_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry300_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY300_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry301_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY301_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry302_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY302_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry303_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY303_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry304_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY304_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry305_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY305_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry306_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY306_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry307_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY307_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry308_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY308_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry309_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY309_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry310_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY310_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry311_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY311_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry312_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY312_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry313_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY313_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry314_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY314_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry315_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY315_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry316_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY316_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry317_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY317_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry318_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY318_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry319_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY319_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry320_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY320_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry321_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY321_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry322_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY322_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry323_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY323_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry324_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY324_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry325_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY325_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry326_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY326_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry327_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY327_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry328_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY328_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry329_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY329_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry330_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY330_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry331_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY331_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry332_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY332_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry333_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY333_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry334_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY334_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry335_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY335_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry336_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY336_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry337_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY337_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry338_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY338_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry339_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY339_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry340_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY340_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry341_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY341_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry342_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY342_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry343_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY343_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry344_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY344_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry345_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY345_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry346_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY346_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry347_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY347_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry348_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY348_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry349_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY349_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry350_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY350_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry351_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY351_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry352_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY352_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry353_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY353_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry354_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY354_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry355_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY355_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry356_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY356_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry357_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY357_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry358_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY358_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry359_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY359_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry360_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY360_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry361_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY361_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry362_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY362_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry363_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY363_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry364_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY364_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry365_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY365_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry366_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY366_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry367_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY367_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry368_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY368_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry369_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY369_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry370_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY370_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry371_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY371_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry372_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY372_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry373_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY373_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry374_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY374_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry375_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY375_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry376_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY376_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry377_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY377_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry378_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY378_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry379_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY379_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry380_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY380_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry381_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY381_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry382_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY382_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry383_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY383_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry384_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY384_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry385_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY385_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry386_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY386_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry387_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY387_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry388_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY388_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry389_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY389_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry390_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY390_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry391_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY391_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry392_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY392_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry393_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY393_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry394_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY394_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry395_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY395_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry396_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY396_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry397_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY397_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry398_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY398_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry399_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY399_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry400_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY400_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry401_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY401_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry402_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY402_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry403_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY403_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry404_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY404_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry405_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY405_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry406_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY406_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry407_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY407_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry408_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY408_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry409_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY409_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry410_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY410_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry411_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY411_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry412_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY412_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry413_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY413_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry414_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY414_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry415_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY415_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry416_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY416_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry417_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY417_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry418_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY418_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry419_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY419_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry420_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY420_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry421_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY421_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry422_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY422_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry423_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY423_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry424_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY424_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry425_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY425_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry426_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY426_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry427_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY427_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry428_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY428_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry429_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY429_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry430_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY430_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry431_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY431_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry432_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY432_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry433_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY433_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry434_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY434_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry435_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY435_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry436_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY436_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry437_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY437_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry438_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY438_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry439_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY439_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry440_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY440_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry441_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY441_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry442_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY442_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry443_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY443_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry444_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY444_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry445_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY445_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry446_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY446_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry447_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY447_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry448_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY448_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry449_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY449_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry450_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY450_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry451_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY451_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry452_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY452_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry453_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY453_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry454_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY454_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry455_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY455_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry456_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY456_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry457_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY457_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry458_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY458_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry459_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY459_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry460_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY460_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry461_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY461_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry462_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY462_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry463_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY463_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry464_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY464_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry465_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY465_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry466_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY466_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry467_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY467_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry468_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY468_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry469_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY469_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry470_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY470_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry471_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY471_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry472_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY472_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry473_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY473_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry474_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY474_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry475_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY475_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry476_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY476_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry477_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY477_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry478_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY478_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry479_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY479_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry480_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY480_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry481_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY481_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry482_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY482_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry483_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY483_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry484_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY484_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry485_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY485_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry486_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY486_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry487_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY487_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry488_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY488_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry489_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY489_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry490_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY490_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry491_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY491_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry492_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY492_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry493_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY493_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry494_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY494_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry495_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY495_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry496_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY496_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry497_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY497_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry498_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY498_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry499_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY499_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry500_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY500_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry501_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY501_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry502_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY502_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry503_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY503_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry504_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY504_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry505_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY505_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry506_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY506_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry507_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY507_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry508_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY508_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry509_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY509_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry510_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY510_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_REG ((css600_apbrom_hwc_jtag_addressblock_0_romentry511_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_ROMENTRY511_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_REG ((css600_apbrom_hwc_jtag_addressblock_0_authstatus_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_AUTHSTATUS_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_REG ((css600_apbrom_hwc_jtag_addressblock_0_devarch_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVARCH_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_REG ((css600_apbrom_hwc_jtag_addressblock_0_devid_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_DEVID_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr4_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR4_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr5_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR5_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr6_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR6_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr7_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR7_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr0_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR0_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr1_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR1_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr2_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR2_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_REG ((css600_apbrom_hwc_jtag_addressblock_0_pidr3_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_PIDR3_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_REG ((css600_apbrom_hwc_jtag_addressblock_0_cidr0_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR0_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_REG ((css600_apbrom_hwc_jtag_addressblock_0_cidr1_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR1_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_REG ((css600_apbrom_hwc_jtag_addressblock_0_cidr2_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR2_ADR)
#define CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_REG ((css600_apbrom_hwc_jtag_addressblock_0_cidr3_reg_t*) CSS600_APBROM_HWC_JTAG_ADDRESSBLOCK_0_CIDR3_ADR)

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
// Stepping: A0
//
typedef struct
{
    css600_apbrom_hwc_jtag_addressblock_0_romentry0_reg_t ADDRESSBLOCK_0_ROMENTRY0; /*< Address offset = 0x0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry1_reg_t ADDRESSBLOCK_0_ROMENTRY1; /*< Address offset = 0x4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry2_reg_t ADDRESSBLOCK_0_ROMENTRY2; /*< Address offset = 0x8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry3_reg_t ADDRESSBLOCK_0_ROMENTRY3; /*< Address offset = 0xc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry4_reg_t ADDRESSBLOCK_0_ROMENTRY4; /*< Address offset = 0x10 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry5_reg_t ADDRESSBLOCK_0_ROMENTRY5; /*< Address offset = 0x14 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry6_reg_t ADDRESSBLOCK_0_ROMENTRY6; /*< Address offset = 0x18 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry7_reg_t ADDRESSBLOCK_0_ROMENTRY7; /*< Address offset = 0x1c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry8_reg_t ADDRESSBLOCK_0_ROMENTRY8; /*< Address offset = 0x20 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry9_reg_t ADDRESSBLOCK_0_ROMENTRY9; /*< Address offset = 0x24 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry10_reg_t ADDRESSBLOCK_0_ROMENTRY10; /*< Address offset = 0x28 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry11_reg_t ADDRESSBLOCK_0_ROMENTRY11; /*< Address offset = 0x2c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry12_reg_t ADDRESSBLOCK_0_ROMENTRY12; /*< Address offset = 0x30 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry13_reg_t ADDRESSBLOCK_0_ROMENTRY13; /*< Address offset = 0x34 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry14_reg_t ADDRESSBLOCK_0_ROMENTRY14; /*< Address offset = 0x38 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry15_reg_t ADDRESSBLOCK_0_ROMENTRY15; /*< Address offset = 0x3c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry16_reg_t ADDRESSBLOCK_0_ROMENTRY16; /*< Address offset = 0x40 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry17_reg_t ADDRESSBLOCK_0_ROMENTRY17; /*< Address offset = 0x44 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry18_reg_t ADDRESSBLOCK_0_ROMENTRY18; /*< Address offset = 0x48 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry19_reg_t ADDRESSBLOCK_0_ROMENTRY19; /*< Address offset = 0x4c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry20_reg_t ADDRESSBLOCK_0_ROMENTRY20; /*< Address offset = 0x50 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry21_reg_t ADDRESSBLOCK_0_ROMENTRY21; /*< Address offset = 0x54 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry22_reg_t ADDRESSBLOCK_0_ROMENTRY22; /*< Address offset = 0x58 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry23_reg_t ADDRESSBLOCK_0_ROMENTRY23; /*< Address offset = 0x5c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry24_reg_t ADDRESSBLOCK_0_ROMENTRY24; /*< Address offset = 0x60 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry25_reg_t ADDRESSBLOCK_0_ROMENTRY25; /*< Address offset = 0x64 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry26_reg_t ADDRESSBLOCK_0_ROMENTRY26; /*< Address offset = 0x68 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry27_reg_t ADDRESSBLOCK_0_ROMENTRY27; /*< Address offset = 0x6c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry28_reg_t ADDRESSBLOCK_0_ROMENTRY28; /*< Address offset = 0x70 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry29_reg_t ADDRESSBLOCK_0_ROMENTRY29; /*< Address offset = 0x74 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry30_reg_t ADDRESSBLOCK_0_ROMENTRY30; /*< Address offset = 0x78 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry31_reg_t ADDRESSBLOCK_0_ROMENTRY31; /*< Address offset = 0x7c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry32_reg_t ADDRESSBLOCK_0_ROMENTRY32; /*< Address offset = 0x80 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry33_reg_t ADDRESSBLOCK_0_ROMENTRY33; /*< Address offset = 0x84 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry34_reg_t ADDRESSBLOCK_0_ROMENTRY34; /*< Address offset = 0x88 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry35_reg_t ADDRESSBLOCK_0_ROMENTRY35; /*< Address offset = 0x8c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry36_reg_t ADDRESSBLOCK_0_ROMENTRY36; /*< Address offset = 0x90 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry37_reg_t ADDRESSBLOCK_0_ROMENTRY37; /*< Address offset = 0x94 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry38_reg_t ADDRESSBLOCK_0_ROMENTRY38; /*< Address offset = 0x98 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry39_reg_t ADDRESSBLOCK_0_ROMENTRY39; /*< Address offset = 0x9c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry40_reg_t ADDRESSBLOCK_0_ROMENTRY40; /*< Address offset = 0xa0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry41_reg_t ADDRESSBLOCK_0_ROMENTRY41; /*< Address offset = 0xa4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry42_reg_t ADDRESSBLOCK_0_ROMENTRY42; /*< Address offset = 0xa8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry43_reg_t ADDRESSBLOCK_0_ROMENTRY43; /*< Address offset = 0xac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry44_reg_t ADDRESSBLOCK_0_ROMENTRY44; /*< Address offset = 0xb0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry45_reg_t ADDRESSBLOCK_0_ROMENTRY45; /*< Address offset = 0xb4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry46_reg_t ADDRESSBLOCK_0_ROMENTRY46; /*< Address offset = 0xb8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry47_reg_t ADDRESSBLOCK_0_ROMENTRY47; /*< Address offset = 0xbc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry48_reg_t ADDRESSBLOCK_0_ROMENTRY48; /*< Address offset = 0xc0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry49_reg_t ADDRESSBLOCK_0_ROMENTRY49; /*< Address offset = 0xc4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry50_reg_t ADDRESSBLOCK_0_ROMENTRY50; /*< Address offset = 0xc8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry51_reg_t ADDRESSBLOCK_0_ROMENTRY51; /*< Address offset = 0xcc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry52_reg_t ADDRESSBLOCK_0_ROMENTRY52; /*< Address offset = 0xd0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry53_reg_t ADDRESSBLOCK_0_ROMENTRY53; /*< Address offset = 0xd4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry54_reg_t ADDRESSBLOCK_0_ROMENTRY54; /*< Address offset = 0xd8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry55_reg_t ADDRESSBLOCK_0_ROMENTRY55; /*< Address offset = 0xdc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry56_reg_t ADDRESSBLOCK_0_ROMENTRY56; /*< Address offset = 0xe0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry57_reg_t ADDRESSBLOCK_0_ROMENTRY57; /*< Address offset = 0xe4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry58_reg_t ADDRESSBLOCK_0_ROMENTRY58; /*< Address offset = 0xe8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry59_reg_t ADDRESSBLOCK_0_ROMENTRY59; /*< Address offset = 0xec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry60_reg_t ADDRESSBLOCK_0_ROMENTRY60; /*< Address offset = 0xf0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry61_reg_t ADDRESSBLOCK_0_ROMENTRY61; /*< Address offset = 0xf4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry62_reg_t ADDRESSBLOCK_0_ROMENTRY62; /*< Address offset = 0xf8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry63_reg_t ADDRESSBLOCK_0_ROMENTRY63; /*< Address offset = 0xfc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry64_reg_t ADDRESSBLOCK_0_ROMENTRY64; /*< Address offset = 0x100 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry65_reg_t ADDRESSBLOCK_0_ROMENTRY65; /*< Address offset = 0x104 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry66_reg_t ADDRESSBLOCK_0_ROMENTRY66; /*< Address offset = 0x108 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry67_reg_t ADDRESSBLOCK_0_ROMENTRY67; /*< Address offset = 0x10c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry68_reg_t ADDRESSBLOCK_0_ROMENTRY68; /*< Address offset = 0x110 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry69_reg_t ADDRESSBLOCK_0_ROMENTRY69; /*< Address offset = 0x114 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry70_reg_t ADDRESSBLOCK_0_ROMENTRY70; /*< Address offset = 0x118 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry71_reg_t ADDRESSBLOCK_0_ROMENTRY71; /*< Address offset = 0x11c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry72_reg_t ADDRESSBLOCK_0_ROMENTRY72; /*< Address offset = 0x120 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry73_reg_t ADDRESSBLOCK_0_ROMENTRY73; /*< Address offset = 0x124 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry74_reg_t ADDRESSBLOCK_0_ROMENTRY74; /*< Address offset = 0x128 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry75_reg_t ADDRESSBLOCK_0_ROMENTRY75; /*< Address offset = 0x12c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry76_reg_t ADDRESSBLOCK_0_ROMENTRY76; /*< Address offset = 0x130 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry77_reg_t ADDRESSBLOCK_0_ROMENTRY77; /*< Address offset = 0x134 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry78_reg_t ADDRESSBLOCK_0_ROMENTRY78; /*< Address offset = 0x138 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry79_reg_t ADDRESSBLOCK_0_ROMENTRY79; /*< Address offset = 0x13c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry80_reg_t ADDRESSBLOCK_0_ROMENTRY80; /*< Address offset = 0x140 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry81_reg_t ADDRESSBLOCK_0_ROMENTRY81; /*< Address offset = 0x144 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry82_reg_t ADDRESSBLOCK_0_ROMENTRY82; /*< Address offset = 0x148 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry83_reg_t ADDRESSBLOCK_0_ROMENTRY83; /*< Address offset = 0x14c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry84_reg_t ADDRESSBLOCK_0_ROMENTRY84; /*< Address offset = 0x150 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry85_reg_t ADDRESSBLOCK_0_ROMENTRY85; /*< Address offset = 0x154 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry86_reg_t ADDRESSBLOCK_0_ROMENTRY86; /*< Address offset = 0x158 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry87_reg_t ADDRESSBLOCK_0_ROMENTRY87; /*< Address offset = 0x15c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry88_reg_t ADDRESSBLOCK_0_ROMENTRY88; /*< Address offset = 0x160 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry89_reg_t ADDRESSBLOCK_0_ROMENTRY89; /*< Address offset = 0x164 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry90_reg_t ADDRESSBLOCK_0_ROMENTRY90; /*< Address offset = 0x168 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry91_reg_t ADDRESSBLOCK_0_ROMENTRY91; /*< Address offset = 0x16c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry92_reg_t ADDRESSBLOCK_0_ROMENTRY92; /*< Address offset = 0x170 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry93_reg_t ADDRESSBLOCK_0_ROMENTRY93; /*< Address offset = 0x174 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry94_reg_t ADDRESSBLOCK_0_ROMENTRY94; /*< Address offset = 0x178 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry95_reg_t ADDRESSBLOCK_0_ROMENTRY95; /*< Address offset = 0x17c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry96_reg_t ADDRESSBLOCK_0_ROMENTRY96; /*< Address offset = 0x180 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry97_reg_t ADDRESSBLOCK_0_ROMENTRY97; /*< Address offset = 0x184 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry98_reg_t ADDRESSBLOCK_0_ROMENTRY98; /*< Address offset = 0x188 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry99_reg_t ADDRESSBLOCK_0_ROMENTRY99; /*< Address offset = 0x18c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry100_reg_t ADDRESSBLOCK_0_ROMENTRY100; /*< Address offset = 0x190 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry101_reg_t ADDRESSBLOCK_0_ROMENTRY101; /*< Address offset = 0x194 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry102_reg_t ADDRESSBLOCK_0_ROMENTRY102; /*< Address offset = 0x198 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry103_reg_t ADDRESSBLOCK_0_ROMENTRY103; /*< Address offset = 0x19c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry104_reg_t ADDRESSBLOCK_0_ROMENTRY104; /*< Address offset = 0x1a0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry105_reg_t ADDRESSBLOCK_0_ROMENTRY105; /*< Address offset = 0x1a4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry106_reg_t ADDRESSBLOCK_0_ROMENTRY106; /*< Address offset = 0x1a8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry107_reg_t ADDRESSBLOCK_0_ROMENTRY107; /*< Address offset = 0x1ac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry108_reg_t ADDRESSBLOCK_0_ROMENTRY108; /*< Address offset = 0x1b0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry109_reg_t ADDRESSBLOCK_0_ROMENTRY109; /*< Address offset = 0x1b4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry110_reg_t ADDRESSBLOCK_0_ROMENTRY110; /*< Address offset = 0x1b8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry111_reg_t ADDRESSBLOCK_0_ROMENTRY111; /*< Address offset = 0x1bc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry112_reg_t ADDRESSBLOCK_0_ROMENTRY112; /*< Address offset = 0x1c0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry113_reg_t ADDRESSBLOCK_0_ROMENTRY113; /*< Address offset = 0x1c4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry114_reg_t ADDRESSBLOCK_0_ROMENTRY114; /*< Address offset = 0x1c8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry115_reg_t ADDRESSBLOCK_0_ROMENTRY115; /*< Address offset = 0x1cc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry116_reg_t ADDRESSBLOCK_0_ROMENTRY116; /*< Address offset = 0x1d0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry117_reg_t ADDRESSBLOCK_0_ROMENTRY117; /*< Address offset = 0x1d4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry118_reg_t ADDRESSBLOCK_0_ROMENTRY118; /*< Address offset = 0x1d8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry119_reg_t ADDRESSBLOCK_0_ROMENTRY119; /*< Address offset = 0x1dc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry120_reg_t ADDRESSBLOCK_0_ROMENTRY120; /*< Address offset = 0x1e0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry121_reg_t ADDRESSBLOCK_0_ROMENTRY121; /*< Address offset = 0x1e4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry122_reg_t ADDRESSBLOCK_0_ROMENTRY122; /*< Address offset = 0x1e8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry123_reg_t ADDRESSBLOCK_0_ROMENTRY123; /*< Address offset = 0x1ec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry124_reg_t ADDRESSBLOCK_0_ROMENTRY124; /*< Address offset = 0x1f0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry125_reg_t ADDRESSBLOCK_0_ROMENTRY125; /*< Address offset = 0x1f4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry126_reg_t ADDRESSBLOCK_0_ROMENTRY126; /*< Address offset = 0x1f8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry127_reg_t ADDRESSBLOCK_0_ROMENTRY127; /*< Address offset = 0x1fc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry128_reg_t ADDRESSBLOCK_0_ROMENTRY128; /*< Address offset = 0x200 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry129_reg_t ADDRESSBLOCK_0_ROMENTRY129; /*< Address offset = 0x204 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry130_reg_t ADDRESSBLOCK_0_ROMENTRY130; /*< Address offset = 0x208 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry131_reg_t ADDRESSBLOCK_0_ROMENTRY131; /*< Address offset = 0x20c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry132_reg_t ADDRESSBLOCK_0_ROMENTRY132; /*< Address offset = 0x210 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry133_reg_t ADDRESSBLOCK_0_ROMENTRY133; /*< Address offset = 0x214 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry134_reg_t ADDRESSBLOCK_0_ROMENTRY134; /*< Address offset = 0x218 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry135_reg_t ADDRESSBLOCK_0_ROMENTRY135; /*< Address offset = 0x21c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry136_reg_t ADDRESSBLOCK_0_ROMENTRY136; /*< Address offset = 0x220 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry137_reg_t ADDRESSBLOCK_0_ROMENTRY137; /*< Address offset = 0x224 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry138_reg_t ADDRESSBLOCK_0_ROMENTRY138; /*< Address offset = 0x228 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry139_reg_t ADDRESSBLOCK_0_ROMENTRY139; /*< Address offset = 0x22c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry140_reg_t ADDRESSBLOCK_0_ROMENTRY140; /*< Address offset = 0x230 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry141_reg_t ADDRESSBLOCK_0_ROMENTRY141; /*< Address offset = 0x234 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry142_reg_t ADDRESSBLOCK_0_ROMENTRY142; /*< Address offset = 0x238 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry143_reg_t ADDRESSBLOCK_0_ROMENTRY143; /*< Address offset = 0x23c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry144_reg_t ADDRESSBLOCK_0_ROMENTRY144; /*< Address offset = 0x240 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry145_reg_t ADDRESSBLOCK_0_ROMENTRY145; /*< Address offset = 0x244 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry146_reg_t ADDRESSBLOCK_0_ROMENTRY146; /*< Address offset = 0x248 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry147_reg_t ADDRESSBLOCK_0_ROMENTRY147; /*< Address offset = 0x24c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry148_reg_t ADDRESSBLOCK_0_ROMENTRY148; /*< Address offset = 0x250 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry149_reg_t ADDRESSBLOCK_0_ROMENTRY149; /*< Address offset = 0x254 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry150_reg_t ADDRESSBLOCK_0_ROMENTRY150; /*< Address offset = 0x258 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry151_reg_t ADDRESSBLOCK_0_ROMENTRY151; /*< Address offset = 0x25c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry152_reg_t ADDRESSBLOCK_0_ROMENTRY152; /*< Address offset = 0x260 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry153_reg_t ADDRESSBLOCK_0_ROMENTRY153; /*< Address offset = 0x264 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry154_reg_t ADDRESSBLOCK_0_ROMENTRY154; /*< Address offset = 0x268 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry155_reg_t ADDRESSBLOCK_0_ROMENTRY155; /*< Address offset = 0x26c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry156_reg_t ADDRESSBLOCK_0_ROMENTRY156; /*< Address offset = 0x270 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry157_reg_t ADDRESSBLOCK_0_ROMENTRY157; /*< Address offset = 0x274 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry158_reg_t ADDRESSBLOCK_0_ROMENTRY158; /*< Address offset = 0x278 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry159_reg_t ADDRESSBLOCK_0_ROMENTRY159; /*< Address offset = 0x27c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry160_reg_t ADDRESSBLOCK_0_ROMENTRY160; /*< Address offset = 0x280 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry161_reg_t ADDRESSBLOCK_0_ROMENTRY161; /*< Address offset = 0x284 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry162_reg_t ADDRESSBLOCK_0_ROMENTRY162; /*< Address offset = 0x288 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry163_reg_t ADDRESSBLOCK_0_ROMENTRY163; /*< Address offset = 0x28c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry164_reg_t ADDRESSBLOCK_0_ROMENTRY164; /*< Address offset = 0x290 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry165_reg_t ADDRESSBLOCK_0_ROMENTRY165; /*< Address offset = 0x294 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry166_reg_t ADDRESSBLOCK_0_ROMENTRY166; /*< Address offset = 0x298 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry167_reg_t ADDRESSBLOCK_0_ROMENTRY167; /*< Address offset = 0x29c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry168_reg_t ADDRESSBLOCK_0_ROMENTRY168; /*< Address offset = 0x2a0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry169_reg_t ADDRESSBLOCK_0_ROMENTRY169; /*< Address offset = 0x2a4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry170_reg_t ADDRESSBLOCK_0_ROMENTRY170; /*< Address offset = 0x2a8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry171_reg_t ADDRESSBLOCK_0_ROMENTRY171; /*< Address offset = 0x2ac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry172_reg_t ADDRESSBLOCK_0_ROMENTRY172; /*< Address offset = 0x2b0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry173_reg_t ADDRESSBLOCK_0_ROMENTRY173; /*< Address offset = 0x2b4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry174_reg_t ADDRESSBLOCK_0_ROMENTRY174; /*< Address offset = 0x2b8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry175_reg_t ADDRESSBLOCK_0_ROMENTRY175; /*< Address offset = 0x2bc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry176_reg_t ADDRESSBLOCK_0_ROMENTRY176; /*< Address offset = 0x2c0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry177_reg_t ADDRESSBLOCK_0_ROMENTRY177; /*< Address offset = 0x2c4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry178_reg_t ADDRESSBLOCK_0_ROMENTRY178; /*< Address offset = 0x2c8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry179_reg_t ADDRESSBLOCK_0_ROMENTRY179; /*< Address offset = 0x2cc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry180_reg_t ADDRESSBLOCK_0_ROMENTRY180; /*< Address offset = 0x2d0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry181_reg_t ADDRESSBLOCK_0_ROMENTRY181; /*< Address offset = 0x2d4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry182_reg_t ADDRESSBLOCK_0_ROMENTRY182; /*< Address offset = 0x2d8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry183_reg_t ADDRESSBLOCK_0_ROMENTRY183; /*< Address offset = 0x2dc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry184_reg_t ADDRESSBLOCK_0_ROMENTRY184; /*< Address offset = 0x2e0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry185_reg_t ADDRESSBLOCK_0_ROMENTRY185; /*< Address offset = 0x2e4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry186_reg_t ADDRESSBLOCK_0_ROMENTRY186; /*< Address offset = 0x2e8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry187_reg_t ADDRESSBLOCK_0_ROMENTRY187; /*< Address offset = 0x2ec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry188_reg_t ADDRESSBLOCK_0_ROMENTRY188; /*< Address offset = 0x2f0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry189_reg_t ADDRESSBLOCK_0_ROMENTRY189; /*< Address offset = 0x2f4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry190_reg_t ADDRESSBLOCK_0_ROMENTRY190; /*< Address offset = 0x2f8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry191_reg_t ADDRESSBLOCK_0_ROMENTRY191; /*< Address offset = 0x2fc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry192_reg_t ADDRESSBLOCK_0_ROMENTRY192; /*< Address offset = 0x300 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry193_reg_t ADDRESSBLOCK_0_ROMENTRY193; /*< Address offset = 0x304 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry194_reg_t ADDRESSBLOCK_0_ROMENTRY194; /*< Address offset = 0x308 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry195_reg_t ADDRESSBLOCK_0_ROMENTRY195; /*< Address offset = 0x30c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry196_reg_t ADDRESSBLOCK_0_ROMENTRY196; /*< Address offset = 0x310 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry197_reg_t ADDRESSBLOCK_0_ROMENTRY197; /*< Address offset = 0x314 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry198_reg_t ADDRESSBLOCK_0_ROMENTRY198; /*< Address offset = 0x318 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry199_reg_t ADDRESSBLOCK_0_ROMENTRY199; /*< Address offset = 0x31c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry200_reg_t ADDRESSBLOCK_0_ROMENTRY200; /*< Address offset = 0x320 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry201_reg_t ADDRESSBLOCK_0_ROMENTRY201; /*< Address offset = 0x324 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry202_reg_t ADDRESSBLOCK_0_ROMENTRY202; /*< Address offset = 0x328 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry203_reg_t ADDRESSBLOCK_0_ROMENTRY203; /*< Address offset = 0x32c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry204_reg_t ADDRESSBLOCK_0_ROMENTRY204; /*< Address offset = 0x330 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry205_reg_t ADDRESSBLOCK_0_ROMENTRY205; /*< Address offset = 0x334 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry206_reg_t ADDRESSBLOCK_0_ROMENTRY206; /*< Address offset = 0x338 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry207_reg_t ADDRESSBLOCK_0_ROMENTRY207; /*< Address offset = 0x33c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry208_reg_t ADDRESSBLOCK_0_ROMENTRY208; /*< Address offset = 0x340 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry209_reg_t ADDRESSBLOCK_0_ROMENTRY209; /*< Address offset = 0x344 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry210_reg_t ADDRESSBLOCK_0_ROMENTRY210; /*< Address offset = 0x348 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry211_reg_t ADDRESSBLOCK_0_ROMENTRY211; /*< Address offset = 0x34c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry212_reg_t ADDRESSBLOCK_0_ROMENTRY212; /*< Address offset = 0x350 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry213_reg_t ADDRESSBLOCK_0_ROMENTRY213; /*< Address offset = 0x354 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry214_reg_t ADDRESSBLOCK_0_ROMENTRY214; /*< Address offset = 0x358 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry215_reg_t ADDRESSBLOCK_0_ROMENTRY215; /*< Address offset = 0x35c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry216_reg_t ADDRESSBLOCK_0_ROMENTRY216; /*< Address offset = 0x360 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry217_reg_t ADDRESSBLOCK_0_ROMENTRY217; /*< Address offset = 0x364 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry218_reg_t ADDRESSBLOCK_0_ROMENTRY218; /*< Address offset = 0x368 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry219_reg_t ADDRESSBLOCK_0_ROMENTRY219; /*< Address offset = 0x36c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry220_reg_t ADDRESSBLOCK_0_ROMENTRY220; /*< Address offset = 0x370 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry221_reg_t ADDRESSBLOCK_0_ROMENTRY221; /*< Address offset = 0x374 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry222_reg_t ADDRESSBLOCK_0_ROMENTRY222; /*< Address offset = 0x378 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry223_reg_t ADDRESSBLOCK_0_ROMENTRY223; /*< Address offset = 0x37c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry224_reg_t ADDRESSBLOCK_0_ROMENTRY224; /*< Address offset = 0x380 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry225_reg_t ADDRESSBLOCK_0_ROMENTRY225; /*< Address offset = 0x384 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry226_reg_t ADDRESSBLOCK_0_ROMENTRY226; /*< Address offset = 0x388 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry227_reg_t ADDRESSBLOCK_0_ROMENTRY227; /*< Address offset = 0x38c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry228_reg_t ADDRESSBLOCK_0_ROMENTRY228; /*< Address offset = 0x390 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry229_reg_t ADDRESSBLOCK_0_ROMENTRY229; /*< Address offset = 0x394 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry230_reg_t ADDRESSBLOCK_0_ROMENTRY230; /*< Address offset = 0x398 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry231_reg_t ADDRESSBLOCK_0_ROMENTRY231; /*< Address offset = 0x39c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry232_reg_t ADDRESSBLOCK_0_ROMENTRY232; /*< Address offset = 0x3a0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry233_reg_t ADDRESSBLOCK_0_ROMENTRY233; /*< Address offset = 0x3a4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry234_reg_t ADDRESSBLOCK_0_ROMENTRY234; /*< Address offset = 0x3a8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry235_reg_t ADDRESSBLOCK_0_ROMENTRY235; /*< Address offset = 0x3ac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry236_reg_t ADDRESSBLOCK_0_ROMENTRY236; /*< Address offset = 0x3b0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry237_reg_t ADDRESSBLOCK_0_ROMENTRY237; /*< Address offset = 0x3b4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry238_reg_t ADDRESSBLOCK_0_ROMENTRY238; /*< Address offset = 0x3b8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry239_reg_t ADDRESSBLOCK_0_ROMENTRY239; /*< Address offset = 0x3bc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry240_reg_t ADDRESSBLOCK_0_ROMENTRY240; /*< Address offset = 0x3c0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry241_reg_t ADDRESSBLOCK_0_ROMENTRY241; /*< Address offset = 0x3c4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry242_reg_t ADDRESSBLOCK_0_ROMENTRY242; /*< Address offset = 0x3c8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry243_reg_t ADDRESSBLOCK_0_ROMENTRY243; /*< Address offset = 0x3cc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry244_reg_t ADDRESSBLOCK_0_ROMENTRY244; /*< Address offset = 0x3d0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry245_reg_t ADDRESSBLOCK_0_ROMENTRY245; /*< Address offset = 0x3d4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry246_reg_t ADDRESSBLOCK_0_ROMENTRY246; /*< Address offset = 0x3d8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry247_reg_t ADDRESSBLOCK_0_ROMENTRY247; /*< Address offset = 0x3dc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry248_reg_t ADDRESSBLOCK_0_ROMENTRY248; /*< Address offset = 0x3e0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry249_reg_t ADDRESSBLOCK_0_ROMENTRY249; /*< Address offset = 0x3e4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry250_reg_t ADDRESSBLOCK_0_ROMENTRY250; /*< Address offset = 0x3e8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry251_reg_t ADDRESSBLOCK_0_ROMENTRY251; /*< Address offset = 0x3ec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry252_reg_t ADDRESSBLOCK_0_ROMENTRY252; /*< Address offset = 0x3f0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry253_reg_t ADDRESSBLOCK_0_ROMENTRY253; /*< Address offset = 0x3f4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry254_reg_t ADDRESSBLOCK_0_ROMENTRY254; /*< Address offset = 0x3f8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry255_reg_t ADDRESSBLOCK_0_ROMENTRY255; /*< Address offset = 0x3fc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry256_reg_t ADDRESSBLOCK_0_ROMENTRY256; /*< Address offset = 0x400 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry257_reg_t ADDRESSBLOCK_0_ROMENTRY257; /*< Address offset = 0x404 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry258_reg_t ADDRESSBLOCK_0_ROMENTRY258; /*< Address offset = 0x408 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry259_reg_t ADDRESSBLOCK_0_ROMENTRY259; /*< Address offset = 0x40c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry260_reg_t ADDRESSBLOCK_0_ROMENTRY260; /*< Address offset = 0x410 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry261_reg_t ADDRESSBLOCK_0_ROMENTRY261; /*< Address offset = 0x414 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry262_reg_t ADDRESSBLOCK_0_ROMENTRY262; /*< Address offset = 0x418 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry263_reg_t ADDRESSBLOCK_0_ROMENTRY263; /*< Address offset = 0x41c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry264_reg_t ADDRESSBLOCK_0_ROMENTRY264; /*< Address offset = 0x420 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry265_reg_t ADDRESSBLOCK_0_ROMENTRY265; /*< Address offset = 0x424 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry266_reg_t ADDRESSBLOCK_0_ROMENTRY266; /*< Address offset = 0x428 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry267_reg_t ADDRESSBLOCK_0_ROMENTRY267; /*< Address offset = 0x42c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry268_reg_t ADDRESSBLOCK_0_ROMENTRY268; /*< Address offset = 0x430 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry269_reg_t ADDRESSBLOCK_0_ROMENTRY269; /*< Address offset = 0x434 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry270_reg_t ADDRESSBLOCK_0_ROMENTRY270; /*< Address offset = 0x438 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry271_reg_t ADDRESSBLOCK_0_ROMENTRY271; /*< Address offset = 0x43c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry272_reg_t ADDRESSBLOCK_0_ROMENTRY272; /*< Address offset = 0x440 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry273_reg_t ADDRESSBLOCK_0_ROMENTRY273; /*< Address offset = 0x444 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry274_reg_t ADDRESSBLOCK_0_ROMENTRY274; /*< Address offset = 0x448 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry275_reg_t ADDRESSBLOCK_0_ROMENTRY275; /*< Address offset = 0x44c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry276_reg_t ADDRESSBLOCK_0_ROMENTRY276; /*< Address offset = 0x450 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry277_reg_t ADDRESSBLOCK_0_ROMENTRY277; /*< Address offset = 0x454 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry278_reg_t ADDRESSBLOCK_0_ROMENTRY278; /*< Address offset = 0x458 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry279_reg_t ADDRESSBLOCK_0_ROMENTRY279; /*< Address offset = 0x45c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry280_reg_t ADDRESSBLOCK_0_ROMENTRY280; /*< Address offset = 0x460 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry281_reg_t ADDRESSBLOCK_0_ROMENTRY281; /*< Address offset = 0x464 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry282_reg_t ADDRESSBLOCK_0_ROMENTRY282; /*< Address offset = 0x468 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry283_reg_t ADDRESSBLOCK_0_ROMENTRY283; /*< Address offset = 0x46c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry284_reg_t ADDRESSBLOCK_0_ROMENTRY284; /*< Address offset = 0x470 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry285_reg_t ADDRESSBLOCK_0_ROMENTRY285; /*< Address offset = 0x474 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry286_reg_t ADDRESSBLOCK_0_ROMENTRY286; /*< Address offset = 0x478 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry287_reg_t ADDRESSBLOCK_0_ROMENTRY287; /*< Address offset = 0x47c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry288_reg_t ADDRESSBLOCK_0_ROMENTRY288; /*< Address offset = 0x480 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry289_reg_t ADDRESSBLOCK_0_ROMENTRY289; /*< Address offset = 0x484 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry290_reg_t ADDRESSBLOCK_0_ROMENTRY290; /*< Address offset = 0x488 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry291_reg_t ADDRESSBLOCK_0_ROMENTRY291; /*< Address offset = 0x48c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry292_reg_t ADDRESSBLOCK_0_ROMENTRY292; /*< Address offset = 0x490 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry293_reg_t ADDRESSBLOCK_0_ROMENTRY293; /*< Address offset = 0x494 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry294_reg_t ADDRESSBLOCK_0_ROMENTRY294; /*< Address offset = 0x498 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry295_reg_t ADDRESSBLOCK_0_ROMENTRY295; /*< Address offset = 0x49c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry296_reg_t ADDRESSBLOCK_0_ROMENTRY296; /*< Address offset = 0x4a0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry297_reg_t ADDRESSBLOCK_0_ROMENTRY297; /*< Address offset = 0x4a4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry298_reg_t ADDRESSBLOCK_0_ROMENTRY298; /*< Address offset = 0x4a8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry299_reg_t ADDRESSBLOCK_0_ROMENTRY299; /*< Address offset = 0x4ac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry300_reg_t ADDRESSBLOCK_0_ROMENTRY300; /*< Address offset = 0x4b0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry301_reg_t ADDRESSBLOCK_0_ROMENTRY301; /*< Address offset = 0x4b4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry302_reg_t ADDRESSBLOCK_0_ROMENTRY302; /*< Address offset = 0x4b8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry303_reg_t ADDRESSBLOCK_0_ROMENTRY303; /*< Address offset = 0x4bc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry304_reg_t ADDRESSBLOCK_0_ROMENTRY304; /*< Address offset = 0x4c0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry305_reg_t ADDRESSBLOCK_0_ROMENTRY305; /*< Address offset = 0x4c4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry306_reg_t ADDRESSBLOCK_0_ROMENTRY306; /*< Address offset = 0x4c8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry307_reg_t ADDRESSBLOCK_0_ROMENTRY307; /*< Address offset = 0x4cc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry308_reg_t ADDRESSBLOCK_0_ROMENTRY308; /*< Address offset = 0x4d0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry309_reg_t ADDRESSBLOCK_0_ROMENTRY309; /*< Address offset = 0x4d4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry310_reg_t ADDRESSBLOCK_0_ROMENTRY310; /*< Address offset = 0x4d8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry311_reg_t ADDRESSBLOCK_0_ROMENTRY311; /*< Address offset = 0x4dc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry312_reg_t ADDRESSBLOCK_0_ROMENTRY312; /*< Address offset = 0x4e0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry313_reg_t ADDRESSBLOCK_0_ROMENTRY313; /*< Address offset = 0x4e4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry314_reg_t ADDRESSBLOCK_0_ROMENTRY314; /*< Address offset = 0x4e8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry315_reg_t ADDRESSBLOCK_0_ROMENTRY315; /*< Address offset = 0x4ec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry316_reg_t ADDRESSBLOCK_0_ROMENTRY316; /*< Address offset = 0x4f0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry317_reg_t ADDRESSBLOCK_0_ROMENTRY317; /*< Address offset = 0x4f4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry318_reg_t ADDRESSBLOCK_0_ROMENTRY318; /*< Address offset = 0x4f8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry319_reg_t ADDRESSBLOCK_0_ROMENTRY319; /*< Address offset = 0x4fc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry320_reg_t ADDRESSBLOCK_0_ROMENTRY320; /*< Address offset = 0x500 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry321_reg_t ADDRESSBLOCK_0_ROMENTRY321; /*< Address offset = 0x504 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry322_reg_t ADDRESSBLOCK_0_ROMENTRY322; /*< Address offset = 0x508 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry323_reg_t ADDRESSBLOCK_0_ROMENTRY323; /*< Address offset = 0x50c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry324_reg_t ADDRESSBLOCK_0_ROMENTRY324; /*< Address offset = 0x510 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry325_reg_t ADDRESSBLOCK_0_ROMENTRY325; /*< Address offset = 0x514 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry326_reg_t ADDRESSBLOCK_0_ROMENTRY326; /*< Address offset = 0x518 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry327_reg_t ADDRESSBLOCK_0_ROMENTRY327; /*< Address offset = 0x51c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry328_reg_t ADDRESSBLOCK_0_ROMENTRY328; /*< Address offset = 0x520 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry329_reg_t ADDRESSBLOCK_0_ROMENTRY329; /*< Address offset = 0x524 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry330_reg_t ADDRESSBLOCK_0_ROMENTRY330; /*< Address offset = 0x528 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry331_reg_t ADDRESSBLOCK_0_ROMENTRY331; /*< Address offset = 0x52c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry332_reg_t ADDRESSBLOCK_0_ROMENTRY332; /*< Address offset = 0x530 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry333_reg_t ADDRESSBLOCK_0_ROMENTRY333; /*< Address offset = 0x534 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry334_reg_t ADDRESSBLOCK_0_ROMENTRY334; /*< Address offset = 0x538 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry335_reg_t ADDRESSBLOCK_0_ROMENTRY335; /*< Address offset = 0x53c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry336_reg_t ADDRESSBLOCK_0_ROMENTRY336; /*< Address offset = 0x540 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry337_reg_t ADDRESSBLOCK_0_ROMENTRY337; /*< Address offset = 0x544 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry338_reg_t ADDRESSBLOCK_0_ROMENTRY338; /*< Address offset = 0x548 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry339_reg_t ADDRESSBLOCK_0_ROMENTRY339; /*< Address offset = 0x54c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry340_reg_t ADDRESSBLOCK_0_ROMENTRY340; /*< Address offset = 0x550 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry341_reg_t ADDRESSBLOCK_0_ROMENTRY341; /*< Address offset = 0x554 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry342_reg_t ADDRESSBLOCK_0_ROMENTRY342; /*< Address offset = 0x558 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry343_reg_t ADDRESSBLOCK_0_ROMENTRY343; /*< Address offset = 0x55c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry344_reg_t ADDRESSBLOCK_0_ROMENTRY344; /*< Address offset = 0x560 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry345_reg_t ADDRESSBLOCK_0_ROMENTRY345; /*< Address offset = 0x564 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry346_reg_t ADDRESSBLOCK_0_ROMENTRY346; /*< Address offset = 0x568 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry347_reg_t ADDRESSBLOCK_0_ROMENTRY347; /*< Address offset = 0x56c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry348_reg_t ADDRESSBLOCK_0_ROMENTRY348; /*< Address offset = 0x570 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry349_reg_t ADDRESSBLOCK_0_ROMENTRY349; /*< Address offset = 0x574 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry350_reg_t ADDRESSBLOCK_0_ROMENTRY350; /*< Address offset = 0x578 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry351_reg_t ADDRESSBLOCK_0_ROMENTRY351; /*< Address offset = 0x57c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry352_reg_t ADDRESSBLOCK_0_ROMENTRY352; /*< Address offset = 0x580 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry353_reg_t ADDRESSBLOCK_0_ROMENTRY353; /*< Address offset = 0x584 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry354_reg_t ADDRESSBLOCK_0_ROMENTRY354; /*< Address offset = 0x588 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry355_reg_t ADDRESSBLOCK_0_ROMENTRY355; /*< Address offset = 0x58c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry356_reg_t ADDRESSBLOCK_0_ROMENTRY356; /*< Address offset = 0x590 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry357_reg_t ADDRESSBLOCK_0_ROMENTRY357; /*< Address offset = 0x594 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry358_reg_t ADDRESSBLOCK_0_ROMENTRY358; /*< Address offset = 0x598 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry359_reg_t ADDRESSBLOCK_0_ROMENTRY359; /*< Address offset = 0x59c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry360_reg_t ADDRESSBLOCK_0_ROMENTRY360; /*< Address offset = 0x5a0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry361_reg_t ADDRESSBLOCK_0_ROMENTRY361; /*< Address offset = 0x5a4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry362_reg_t ADDRESSBLOCK_0_ROMENTRY362; /*< Address offset = 0x5a8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry363_reg_t ADDRESSBLOCK_0_ROMENTRY363; /*< Address offset = 0x5ac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry364_reg_t ADDRESSBLOCK_0_ROMENTRY364; /*< Address offset = 0x5b0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry365_reg_t ADDRESSBLOCK_0_ROMENTRY365; /*< Address offset = 0x5b4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry366_reg_t ADDRESSBLOCK_0_ROMENTRY366; /*< Address offset = 0x5b8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry367_reg_t ADDRESSBLOCK_0_ROMENTRY367; /*< Address offset = 0x5bc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry368_reg_t ADDRESSBLOCK_0_ROMENTRY368; /*< Address offset = 0x5c0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry369_reg_t ADDRESSBLOCK_0_ROMENTRY369; /*< Address offset = 0x5c4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry370_reg_t ADDRESSBLOCK_0_ROMENTRY370; /*< Address offset = 0x5c8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry371_reg_t ADDRESSBLOCK_0_ROMENTRY371; /*< Address offset = 0x5cc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry372_reg_t ADDRESSBLOCK_0_ROMENTRY372; /*< Address offset = 0x5d0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry373_reg_t ADDRESSBLOCK_0_ROMENTRY373; /*< Address offset = 0x5d4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry374_reg_t ADDRESSBLOCK_0_ROMENTRY374; /*< Address offset = 0x5d8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry375_reg_t ADDRESSBLOCK_0_ROMENTRY375; /*< Address offset = 0x5dc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry376_reg_t ADDRESSBLOCK_0_ROMENTRY376; /*< Address offset = 0x5e0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry377_reg_t ADDRESSBLOCK_0_ROMENTRY377; /*< Address offset = 0x5e4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry378_reg_t ADDRESSBLOCK_0_ROMENTRY378; /*< Address offset = 0x5e8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry379_reg_t ADDRESSBLOCK_0_ROMENTRY379; /*< Address offset = 0x5ec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry380_reg_t ADDRESSBLOCK_0_ROMENTRY380; /*< Address offset = 0x5f0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry381_reg_t ADDRESSBLOCK_0_ROMENTRY381; /*< Address offset = 0x5f4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry382_reg_t ADDRESSBLOCK_0_ROMENTRY382; /*< Address offset = 0x5f8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry383_reg_t ADDRESSBLOCK_0_ROMENTRY383; /*< Address offset = 0x5fc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry384_reg_t ADDRESSBLOCK_0_ROMENTRY384; /*< Address offset = 0x600 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry385_reg_t ADDRESSBLOCK_0_ROMENTRY385; /*< Address offset = 0x604 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry386_reg_t ADDRESSBLOCK_0_ROMENTRY386; /*< Address offset = 0x608 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry387_reg_t ADDRESSBLOCK_0_ROMENTRY387; /*< Address offset = 0x60c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry388_reg_t ADDRESSBLOCK_0_ROMENTRY388; /*< Address offset = 0x610 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry389_reg_t ADDRESSBLOCK_0_ROMENTRY389; /*< Address offset = 0x614 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry390_reg_t ADDRESSBLOCK_0_ROMENTRY390; /*< Address offset = 0x618 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry391_reg_t ADDRESSBLOCK_0_ROMENTRY391; /*< Address offset = 0x61c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry392_reg_t ADDRESSBLOCK_0_ROMENTRY392; /*< Address offset = 0x620 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry393_reg_t ADDRESSBLOCK_0_ROMENTRY393; /*< Address offset = 0x624 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry394_reg_t ADDRESSBLOCK_0_ROMENTRY394; /*< Address offset = 0x628 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry395_reg_t ADDRESSBLOCK_0_ROMENTRY395; /*< Address offset = 0x62c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry396_reg_t ADDRESSBLOCK_0_ROMENTRY396; /*< Address offset = 0x630 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry397_reg_t ADDRESSBLOCK_0_ROMENTRY397; /*< Address offset = 0x634 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry398_reg_t ADDRESSBLOCK_0_ROMENTRY398; /*< Address offset = 0x638 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry399_reg_t ADDRESSBLOCK_0_ROMENTRY399; /*< Address offset = 0x63c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry400_reg_t ADDRESSBLOCK_0_ROMENTRY400; /*< Address offset = 0x640 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry401_reg_t ADDRESSBLOCK_0_ROMENTRY401; /*< Address offset = 0x644 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry402_reg_t ADDRESSBLOCK_0_ROMENTRY402; /*< Address offset = 0x648 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry403_reg_t ADDRESSBLOCK_0_ROMENTRY403; /*< Address offset = 0x64c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry404_reg_t ADDRESSBLOCK_0_ROMENTRY404; /*< Address offset = 0x650 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry405_reg_t ADDRESSBLOCK_0_ROMENTRY405; /*< Address offset = 0x654 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry406_reg_t ADDRESSBLOCK_0_ROMENTRY406; /*< Address offset = 0x658 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry407_reg_t ADDRESSBLOCK_0_ROMENTRY407; /*< Address offset = 0x65c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry408_reg_t ADDRESSBLOCK_0_ROMENTRY408; /*< Address offset = 0x660 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry409_reg_t ADDRESSBLOCK_0_ROMENTRY409; /*< Address offset = 0x664 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry410_reg_t ADDRESSBLOCK_0_ROMENTRY410; /*< Address offset = 0x668 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry411_reg_t ADDRESSBLOCK_0_ROMENTRY411; /*< Address offset = 0x66c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry412_reg_t ADDRESSBLOCK_0_ROMENTRY412; /*< Address offset = 0x670 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry413_reg_t ADDRESSBLOCK_0_ROMENTRY413; /*< Address offset = 0x674 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry414_reg_t ADDRESSBLOCK_0_ROMENTRY414; /*< Address offset = 0x678 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry415_reg_t ADDRESSBLOCK_0_ROMENTRY415; /*< Address offset = 0x67c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry416_reg_t ADDRESSBLOCK_0_ROMENTRY416; /*< Address offset = 0x680 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry417_reg_t ADDRESSBLOCK_0_ROMENTRY417; /*< Address offset = 0x684 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry418_reg_t ADDRESSBLOCK_0_ROMENTRY418; /*< Address offset = 0x688 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry419_reg_t ADDRESSBLOCK_0_ROMENTRY419; /*< Address offset = 0x68c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry420_reg_t ADDRESSBLOCK_0_ROMENTRY420; /*< Address offset = 0x690 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry421_reg_t ADDRESSBLOCK_0_ROMENTRY421; /*< Address offset = 0x694 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry422_reg_t ADDRESSBLOCK_0_ROMENTRY422; /*< Address offset = 0x698 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry423_reg_t ADDRESSBLOCK_0_ROMENTRY423; /*< Address offset = 0x69c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry424_reg_t ADDRESSBLOCK_0_ROMENTRY424; /*< Address offset = 0x6a0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry425_reg_t ADDRESSBLOCK_0_ROMENTRY425; /*< Address offset = 0x6a4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry426_reg_t ADDRESSBLOCK_0_ROMENTRY426; /*< Address offset = 0x6a8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry427_reg_t ADDRESSBLOCK_0_ROMENTRY427; /*< Address offset = 0x6ac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry428_reg_t ADDRESSBLOCK_0_ROMENTRY428; /*< Address offset = 0x6b0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry429_reg_t ADDRESSBLOCK_0_ROMENTRY429; /*< Address offset = 0x6b4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry430_reg_t ADDRESSBLOCK_0_ROMENTRY430; /*< Address offset = 0x6b8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry431_reg_t ADDRESSBLOCK_0_ROMENTRY431; /*< Address offset = 0x6bc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry432_reg_t ADDRESSBLOCK_0_ROMENTRY432; /*< Address offset = 0x6c0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry433_reg_t ADDRESSBLOCK_0_ROMENTRY433; /*< Address offset = 0x6c4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry434_reg_t ADDRESSBLOCK_0_ROMENTRY434; /*< Address offset = 0x6c8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry435_reg_t ADDRESSBLOCK_0_ROMENTRY435; /*< Address offset = 0x6cc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry436_reg_t ADDRESSBLOCK_0_ROMENTRY436; /*< Address offset = 0x6d0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry437_reg_t ADDRESSBLOCK_0_ROMENTRY437; /*< Address offset = 0x6d4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry438_reg_t ADDRESSBLOCK_0_ROMENTRY438; /*< Address offset = 0x6d8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry439_reg_t ADDRESSBLOCK_0_ROMENTRY439; /*< Address offset = 0x6dc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry440_reg_t ADDRESSBLOCK_0_ROMENTRY440; /*< Address offset = 0x6e0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry441_reg_t ADDRESSBLOCK_0_ROMENTRY441; /*< Address offset = 0x6e4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry442_reg_t ADDRESSBLOCK_0_ROMENTRY442; /*< Address offset = 0x6e8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry443_reg_t ADDRESSBLOCK_0_ROMENTRY443; /*< Address offset = 0x6ec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry444_reg_t ADDRESSBLOCK_0_ROMENTRY444; /*< Address offset = 0x6f0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry445_reg_t ADDRESSBLOCK_0_ROMENTRY445; /*< Address offset = 0x6f4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry446_reg_t ADDRESSBLOCK_0_ROMENTRY446; /*< Address offset = 0x6f8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry447_reg_t ADDRESSBLOCK_0_ROMENTRY447; /*< Address offset = 0x6fc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry448_reg_t ADDRESSBLOCK_0_ROMENTRY448; /*< Address offset = 0x700 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry449_reg_t ADDRESSBLOCK_0_ROMENTRY449; /*< Address offset = 0x704 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry450_reg_t ADDRESSBLOCK_0_ROMENTRY450; /*< Address offset = 0x708 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry451_reg_t ADDRESSBLOCK_0_ROMENTRY451; /*< Address offset = 0x70c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry452_reg_t ADDRESSBLOCK_0_ROMENTRY452; /*< Address offset = 0x710 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry453_reg_t ADDRESSBLOCK_0_ROMENTRY453; /*< Address offset = 0x714 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry454_reg_t ADDRESSBLOCK_0_ROMENTRY454; /*< Address offset = 0x718 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry455_reg_t ADDRESSBLOCK_0_ROMENTRY455; /*< Address offset = 0x71c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry456_reg_t ADDRESSBLOCK_0_ROMENTRY456; /*< Address offset = 0x720 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry457_reg_t ADDRESSBLOCK_0_ROMENTRY457; /*< Address offset = 0x724 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry458_reg_t ADDRESSBLOCK_0_ROMENTRY458; /*< Address offset = 0x728 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry459_reg_t ADDRESSBLOCK_0_ROMENTRY459; /*< Address offset = 0x72c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry460_reg_t ADDRESSBLOCK_0_ROMENTRY460; /*< Address offset = 0x730 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry461_reg_t ADDRESSBLOCK_0_ROMENTRY461; /*< Address offset = 0x734 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry462_reg_t ADDRESSBLOCK_0_ROMENTRY462; /*< Address offset = 0x738 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry463_reg_t ADDRESSBLOCK_0_ROMENTRY463; /*< Address offset = 0x73c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry464_reg_t ADDRESSBLOCK_0_ROMENTRY464; /*< Address offset = 0x740 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry465_reg_t ADDRESSBLOCK_0_ROMENTRY465; /*< Address offset = 0x744 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry466_reg_t ADDRESSBLOCK_0_ROMENTRY466; /*< Address offset = 0x748 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry467_reg_t ADDRESSBLOCK_0_ROMENTRY467; /*< Address offset = 0x74c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry468_reg_t ADDRESSBLOCK_0_ROMENTRY468; /*< Address offset = 0x750 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry469_reg_t ADDRESSBLOCK_0_ROMENTRY469; /*< Address offset = 0x754 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry470_reg_t ADDRESSBLOCK_0_ROMENTRY470; /*< Address offset = 0x758 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry471_reg_t ADDRESSBLOCK_0_ROMENTRY471; /*< Address offset = 0x75c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry472_reg_t ADDRESSBLOCK_0_ROMENTRY472; /*< Address offset = 0x760 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry473_reg_t ADDRESSBLOCK_0_ROMENTRY473; /*< Address offset = 0x764 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry474_reg_t ADDRESSBLOCK_0_ROMENTRY474; /*< Address offset = 0x768 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry475_reg_t ADDRESSBLOCK_0_ROMENTRY475; /*< Address offset = 0x76c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry476_reg_t ADDRESSBLOCK_0_ROMENTRY476; /*< Address offset = 0x770 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry477_reg_t ADDRESSBLOCK_0_ROMENTRY477; /*< Address offset = 0x774 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry478_reg_t ADDRESSBLOCK_0_ROMENTRY478; /*< Address offset = 0x778 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry479_reg_t ADDRESSBLOCK_0_ROMENTRY479; /*< Address offset = 0x77c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry480_reg_t ADDRESSBLOCK_0_ROMENTRY480; /*< Address offset = 0x780 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry481_reg_t ADDRESSBLOCK_0_ROMENTRY481; /*< Address offset = 0x784 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry482_reg_t ADDRESSBLOCK_0_ROMENTRY482; /*< Address offset = 0x788 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry483_reg_t ADDRESSBLOCK_0_ROMENTRY483; /*< Address offset = 0x78c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry484_reg_t ADDRESSBLOCK_0_ROMENTRY484; /*< Address offset = 0x790 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry485_reg_t ADDRESSBLOCK_0_ROMENTRY485; /*< Address offset = 0x794 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry486_reg_t ADDRESSBLOCK_0_ROMENTRY486; /*< Address offset = 0x798 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry487_reg_t ADDRESSBLOCK_0_ROMENTRY487; /*< Address offset = 0x79c */
    css600_apbrom_hwc_jtag_addressblock_0_romentry488_reg_t ADDRESSBLOCK_0_ROMENTRY488; /*< Address offset = 0x7a0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry489_reg_t ADDRESSBLOCK_0_ROMENTRY489; /*< Address offset = 0x7a4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry490_reg_t ADDRESSBLOCK_0_ROMENTRY490; /*< Address offset = 0x7a8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry491_reg_t ADDRESSBLOCK_0_ROMENTRY491; /*< Address offset = 0x7ac */
    css600_apbrom_hwc_jtag_addressblock_0_romentry492_reg_t ADDRESSBLOCK_0_ROMENTRY492; /*< Address offset = 0x7b0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry493_reg_t ADDRESSBLOCK_0_ROMENTRY493; /*< Address offset = 0x7b4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry494_reg_t ADDRESSBLOCK_0_ROMENTRY494; /*< Address offset = 0x7b8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry495_reg_t ADDRESSBLOCK_0_ROMENTRY495; /*< Address offset = 0x7bc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry496_reg_t ADDRESSBLOCK_0_ROMENTRY496; /*< Address offset = 0x7c0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry497_reg_t ADDRESSBLOCK_0_ROMENTRY497; /*< Address offset = 0x7c4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry498_reg_t ADDRESSBLOCK_0_ROMENTRY498; /*< Address offset = 0x7c8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry499_reg_t ADDRESSBLOCK_0_ROMENTRY499; /*< Address offset = 0x7cc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry500_reg_t ADDRESSBLOCK_0_ROMENTRY500; /*< Address offset = 0x7d0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry501_reg_t ADDRESSBLOCK_0_ROMENTRY501; /*< Address offset = 0x7d4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry502_reg_t ADDRESSBLOCK_0_ROMENTRY502; /*< Address offset = 0x7d8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry503_reg_t ADDRESSBLOCK_0_ROMENTRY503; /*< Address offset = 0x7dc */
    css600_apbrom_hwc_jtag_addressblock_0_romentry504_reg_t ADDRESSBLOCK_0_ROMENTRY504; /*< Address offset = 0x7e0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry505_reg_t ADDRESSBLOCK_0_ROMENTRY505; /*< Address offset = 0x7e4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry506_reg_t ADDRESSBLOCK_0_ROMENTRY506; /*< Address offset = 0x7e8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry507_reg_t ADDRESSBLOCK_0_ROMENTRY507; /*< Address offset = 0x7ec */
    css600_apbrom_hwc_jtag_addressblock_0_romentry508_reg_t ADDRESSBLOCK_0_ROMENTRY508; /*< Address offset = 0x7f0 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry509_reg_t ADDRESSBLOCK_0_ROMENTRY509; /*< Address offset = 0x7f4 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry510_reg_t ADDRESSBLOCK_0_ROMENTRY510; /*< Address offset = 0x7f8 */
    css600_apbrom_hwc_jtag_addressblock_0_romentry511_reg_t ADDRESSBLOCK_0_ROMENTRY511; /*< Address offset = 0x7fc */
    const uint8_t        reservedArea0 [1976]; /*< Address offset = 0x800 */
    css600_apbrom_hwc_jtag_addressblock_0_authstatus_reg_t ADDRESSBLOCK_0_AUTHSTATUS; /*< Address offset = 0xfb8 */
    css600_apbrom_hwc_jtag_addressblock_0_devarch_reg_t ADDRESSBLOCK_0_DEVARCH; /*< Address offset = 0xfbc */
    const uint8_t        reservedArea1 [8];   /*< Address offset = 0xfc0 */
    css600_apbrom_hwc_jtag_addressblock_0_devid_reg_t ADDRESSBLOCK_0_DEVID; /*< Address offset = 0xfc8 */
    const uint8_t        reservedArea2 [4];   /*< Address offset = 0xfcc */
    css600_apbrom_hwc_jtag_addressblock_0_pidr4_reg_t ADDRESSBLOCK_0_PIDR4; /*< Address offset = 0xfd0 */
    css600_apbrom_hwc_jtag_addressblock_0_pidr5_reg_t ADDRESSBLOCK_0_PIDR5; /*< Address offset = 0xfd4 */
    css600_apbrom_hwc_jtag_addressblock_0_pidr6_reg_t ADDRESSBLOCK_0_PIDR6; /*< Address offset = 0xfd8 */
    css600_apbrom_hwc_jtag_addressblock_0_pidr7_reg_t ADDRESSBLOCK_0_PIDR7; /*< Address offset = 0xfdc */
    css600_apbrom_hwc_jtag_addressblock_0_pidr0_reg_t ADDRESSBLOCK_0_PIDR0; /*< Address offset = 0xfe0 */
    css600_apbrom_hwc_jtag_addressblock_0_pidr1_reg_t ADDRESSBLOCK_0_PIDR1; /*< Address offset = 0xfe4 */
    css600_apbrom_hwc_jtag_addressblock_0_pidr2_reg_t ADDRESSBLOCK_0_PIDR2; /*< Address offset = 0xfe8 */
    css600_apbrom_hwc_jtag_addressblock_0_pidr3_reg_t ADDRESSBLOCK_0_PIDR3; /*< Address offset = 0xfec */
    css600_apbrom_hwc_jtag_addressblock_0_cidr0_reg_t ADDRESSBLOCK_0_CIDR0; /*< Address offset = 0xff0 */
    css600_apbrom_hwc_jtag_addressblock_0_cidr1_reg_t ADDRESSBLOCK_0_CIDR1; /*< Address offset = 0xff4 */
    css600_apbrom_hwc_jtag_addressblock_0_cidr2_reg_t ADDRESSBLOCK_0_CIDR2; /*< Address offset = 0xff8 */
    css600_apbrom_hwc_jtag_addressblock_0_cidr3_reg_t ADDRESSBLOCK_0_CIDR3; /*< Address offset = 0xffc */
} css600_apbrom_hwc_jtag_t;     // size: 0x083c

// AddressSpace struct pointer
//
#define SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM ((css600_apbrom_hwc_jtag_t*) SYSCON_CS_SOC_APBROM_APB4_SLAVE_0_MM_BASE)

// ******************************************* /Address Space

#endif      // _CSS600_APBROM_HWC_JTAG_H_

