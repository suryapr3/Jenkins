#ifndef _DMOD_H_
#define _DMOD_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define FB_SYS0_DMOD_BASE     ( 0x0510c000 )
#define FB_SYS1_DMOD_BASE     ( 0x0511c000 )
#define TRX_SYS0_DMOD_BASE    ( 0x05278000 )
#define TRX_SYS1_DMOD_BASE    ( 0x05298000 )
#define TRX_SYS2_DMOD_BASE    ( 0x052b8000 )
#define TRX_SYS3_DMOD_BASE    ( 0x052d8000 )
#define TRX_SYS4_DMOD_BASE    ( 0x052f8000 )
#define TRX_SYS5_DMOD_BASE    ( 0x05318000 )
#define TRX_SYS6_DMOD_BASE    ( 0x05338000 )
#define TRX_SYS7_DMOD_BASE    ( 0x05358000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define DMOD_SCRATCH_OFFSET      ( 0x00000000U )
#define DMOD_CFG_OFFSET       ( 0x00000004U )
#define DMOD_EN_OFFSET       ( 0x00000008U )
#define DMOD_SAT_VAL_OFFSET      ( 0x0000000cU )
#define DMOD_APB_BRDG_STAT_OFFSET ( 0x00000060U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define DMOD_SCRATCH_ADR(_BASE)         (( ( _BASE ) + ( DMOD_SCRATCH_OFFSET ) ))
#define DMOD_CFG_ADR(_BASE)          (( ( _BASE ) + ( DMOD_CFG_OFFSET ) ))
#define DMOD_EN_ADR(_BASE)          (( ( _BASE ) + ( DMOD_EN_OFFSET ) ))
#define DMOD_SAT_VAL_ADR(_BASE)         (( ( _BASE ) + ( DMOD_SAT_VAL_OFFSET ) ))
#define DMOD_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( DMOD_APB_BRDG_STAT_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief DMOD_MAP_REG_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: dmod_map/reg/SCRATCH
  * DMOD scratchpad register.
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Do anything with this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} dmod_scratch_reg_t;

#define DMOD_SCRATCH_DEFAULT (0x00000000U)
#define DMOD_SCRATCH_RD_MASK (0xffffffffU)
#define DMOD_SCRATCH_WR_MASK (0xffffffffU)


///< Do anything with this field.
#define DMOD_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define DMOD_SCRATCH_SCRATCHPAD_BF_WID (32)
#define DMOD_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define DMOD_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief DMOD_MAP_REG_CONFIG register description at address offset 0x4
  *
  * Register default value:        0x00000000
  * Register full path in IP: dmod_map/reg/CONFIG
  * DMOD configuration register.
  */

typedef union {
  struct {
    uint32_t BYP_DMOD : 2;
    ///< When bit 0 of this field is set, the demodulation function of the
    ///< even data channel is bypassed. When bit 1 of this field is set, the
    ///< demodulation function of the odd data channel is bypassed. When operating
    ///< in bypass mode, the inputs of the demodulator drive the real outputs
    ///< (I) of the demodulator.  The quadrature components (Q) of the demodulator's
    ///< IQ samples are driven by 0s. Additionally, the SWG inputs are ignored
    ///< and no demodulation is performed.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CONJ : 2;
    ///< When bit i of this field is set, the Real and Imag samples of the
    ///< SWG input to the ith demodulator are conjugated. The conjugate function
    ///< operates on an IQ sample in the following manner: If an IQ sample
    ///< is represented as  a + ib (where ib is the quadrature component of
    ///< an IQ sample), then conjugation of the IQ sample results in the negation
    ///< of the Q portion of the IQ portion. As a result, the output  will
    ///< be  a - ib. Because the selection is done with multiplixers, if the
    ///< bit i of the field is cleared, then the output (which had become a-ib)
    ///< will change back to a+ib. When bit 0 of this field is set, the IQ
    ///< samples of the SWG input to the even demodulator of an odd/even pair
    ///< are conjugated. Otherwise, the SWG input is delivered unchanged. When
    ///< bit 1 of this field is set, the IQ samples of the SWG input to the
    ///< odd demodulator of an odd/even pair are conjugated. Otherwise, the
    ///< SWG input is delivered unchanged. In the event that the swap  and
    ///< conjugate functions are both enabled, please note that  the swap function
    ///< occurs first followed by the conjugation function. So, in this case,
    ///< if the the input was a+ib, then the swap function results in b+ia,
    ///< and then applying the conjugate function results in b-ia
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} dmod_cfg_reg_t;

#define DMOD_CFG_DEFAULT (0x00000000U)
#define DMOD_CFG_RD_MASK (0x0000000fU)
#define DMOD_CFG_WR_MASK (0x0000000fU)


///< When bit 0 of this field is set, the demodulation function of the
///< even data channel is bypassed. When bit 1 of this field is set, the
///< demodulation function of the odd data channel is bypassed. When operating
///< in bypass mode, the inputs of the demodulator drive the real outputs
///< (I) of the demodulator.  The quadrature components (Q) of the demodulator's
///< IQ samples are driven by 0s. Additionally, the SWG inputs are ignored
///< and no demodulation is performed.
#define DMOD_CFG_BYP_DMOD_BF_OFF ( 0)
#define DMOD_CFG_BYP_DMOD_BF_WID ( 2)
#define DMOD_CFG_BYP_DMOD_BF_MSK (0x00000003)
#define DMOD_CFG_BYP_DMOD_BF_DEF (0x00000000)

///< When bit i of this field is set, the Real and Imag samples of the
///< SWG input to the ith demodulator are conjugated. The conjugate function
///< operates on an IQ sample in the following manner: If an IQ sample
///< is represented as  a + ib (where ib is the quadrature component of
///< an IQ sample), then conjugation of the IQ sample results in the negation
///< of the Q portion of the IQ portion. As a result, the output  will
///< be  a - ib. Because the selection is done with multiplixers, if the
///< bit i of the field is cleared, then the output (which had become a-ib)
///< will change back to a+ib. When bit 0 of this field is set, the IQ
///< samples of the SWG input to the even demodulator of an odd/even pair
///< are conjugated. Otherwise, the SWG input is delivered unchanged. When
///< bit 1 of this field is set, the IQ samples of the SWG input to the
///< odd demodulator of an odd/even pair are conjugated. Otherwise, the
///< SWG input is delivered unchanged. In the event that the swap  and
///< conjugate functions are both enabled, please note that  the swap function
///< occurs first followed by the conjugation function. So, in this case,
///< if the the input was a+ib, then the swap function results in b+ia,
///< and then applying the conjugate function results in b-ia
#define DMOD_CFG_CONJ_BF_OFF ( 2)
#define DMOD_CFG_CONJ_BF_WID ( 2)
#define DMOD_CFG_CONJ_BF_MSK (0x0000000C)
#define DMOD_CFG_CONJ_BF_DEF (0x00000000)


/** @brief DMOD_MAP_REG_ENABLE register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: dmod_map/reg/ENABLE
  * DMOD enable register.
  */

typedef union {
  struct {
    uint32_t DMOD_EN_ANT_EVEN : 1;
    ///< When 0, the even channel in an odd/even demodulator pair is disabled.
    ///< When 1, the even channel in an odd/even demodulator pair is enabled.
    ///< Enabling of an antenna channel is independent of enabling of up to
    ///< 16 lanes of samples which is accomplished by the field DMOD_EN_PER_SAMPLE.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMOD_EN_ANT_ODD : 1;
    ///< When 0, the odd channel in an odd/even demodulator pair is disabled.
    ///< When 1, the odd channel in an odd/even demodulator pair is enabled.
    ///< Enabling of an antenna channel is independent of enabling of up to
    ///< 16 lanes of samples which is accomplished by the field DMOD_EN_PER_SAMPLE.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DMOD_EN_PER_SAMPLE : 16;
    ///< The Demodulator supports rates of N GSPS were N = (3,4,6,8,12, 16).
    ///< The N least signficant bits of this register must be set to 1. The
    ///< 16-N most signlficants bits must be set to 0.  Using these settings
    ///< ensure that the demodulators corresponding to the unused samples will
    ///< have their logic clock-gated, thus saving power.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
  } ;
  uint32_t value;
} dmod_en_reg_t;

#define DMOD_EN_DEFAULT (0x00000000U)
#define DMOD_EN_RD_MASK (0x0003ffffU)
#define DMOD_EN_WR_MASK (0x0003ffffU)


///< When 0, the even channel in an odd/even demodulator pair is disabled.
///< When 1, the even channel in an odd/even demodulator pair is enabled.
///< Enabling of an antenna channel is independent of enabling of up to
///< 16 lanes of samples which is accomplished by the field DMOD_EN_PER_SAMPLE.
#define DMOD_EN_DMOD_EN_ANT_EVEN_BF_OFF ( 0)
#define DMOD_EN_DMOD_EN_ANT_EVEN_BF_WID ( 1)
#define DMOD_EN_DMOD_EN_ANT_EVEN_BF_MSK (0x00000001)
#define DMOD_EN_DMOD_EN_ANT_EVEN_BF_DEF (0x00000000)

///< When 0, the odd channel in an odd/even demodulator pair is disabled.
///< When 1, the odd channel in an odd/even demodulator pair is enabled.
///< Enabling of an antenna channel is independent of enabling of up to
///< 16 lanes of samples which is accomplished by the field DMOD_EN_PER_SAMPLE.
#define DMOD_EN_DMOD_EN_ANT_ODD_BF_OFF ( 1)
#define DMOD_EN_DMOD_EN_ANT_ODD_BF_WID ( 1)
#define DMOD_EN_DMOD_EN_ANT_ODD_BF_MSK (0x00000002)
#define DMOD_EN_DMOD_EN_ANT_ODD_BF_DEF (0x00000000)

///< The Demodulator supports rates of N GSPS were N = (3,4,6,8,12, 16).
///< The N least signficant bits of this register must be set to 1. The
///< 16-N most signlficants bits must be set to 0.  Using these settings
///< ensure that the demodulators corresponding to the unused samples will
///< have their logic clock-gated, thus saving power.
#define DMOD_EN_DMOD_EN_PER_SAMPLE_BF_OFF ( 2)
#define DMOD_EN_DMOD_EN_PER_SAMPLE_BF_WID (16)
#define DMOD_EN_DMOD_EN_PER_SAMPLE_BF_MSK (0x0003FFFC)
#define DMOD_EN_DMOD_EN_PER_SAMPLE_BF_DEF (0x00000000)


/** @brief DMOD_MAP_REG_SAT_VAL register description at address offset 0xc
  *
  * Register default value:        0x00007FFF
  * Register full path in IP: dmod_map/reg/SAT_VAL
  * Saturation Value.
  */

typedef union {
  struct {
    uint32_t SAT_VAL : 15;
    ///< Saturation Value which allows the user to saturate the output of the
    ///< dc_offset addition function.       This assures the user that the
    ///< adding the DC offset does not cause the adjusted input to        dc_offset
    ///< addition to overflow. Typically, the DC offset would be set to the
    ///< unsigned max value of 15'7FFF.       However, without any limitation,
    ///< the DC offset can take on the full rate of 0 through 15'h7FFF.
    ///< Naturally, reducing the saturation value below 15'h7FFF may have an
    ///< impact of the achievable        range of the signal downstream.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7FFF"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} dmod_sat_val_reg_t;

#define DMOD_SAT_VAL_DEFAULT (0x00007fffU)
#define DMOD_SAT_VAL_RD_MASK (0x00007fffU)
#define DMOD_SAT_VAL_WR_MASK (0x00007fffU)


///< Saturation Value which allows the user to saturate the output of the
///< dc_offset addition function.       This assures the user that the
///< adding the DC offset does not cause the adjusted input to        dc_offset
///< addition to overflow. Typically, the DC offset would be set to the
///< unsigned max value of 15'7FFF.       However, without any limitation,
///< the DC offset can take on the full rate of 0 through 15'h7FFF.
///< Naturally, reducing the saturation value below 15'h7FFF may have an
///< impact of the achievable        range of the signal downstream.
#define DMOD_SAT_VAL_SAT_VAL_BF_OFF ( 0)
#define DMOD_SAT_VAL_SAT_VAL_BF_WID (15)
#define DMOD_SAT_VAL_SAT_VAL_BF_MSK (0x00007FFF)
#define DMOD_SAT_VAL_SAT_VAL_BF_DEF (0x00007FFF)


/** @brief DMOD_MAP_REG_APB_BRIDGE_STATUS register description at address offset 0x60
  *
  * Register default value:        0x00010000
  * Register full path in IP: dmod_map/reg/APB_BRIDGE_STATUS
  * DMOD APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number.
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set.
    ///< AccessType="RW/1S" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received.
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set.
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out.
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} dmod_apb_brdg_stat_reg_t;

#define DMOD_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define DMOD_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define DMOD_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request.
#define DMOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define DMOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define DMOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define DMOD_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number.
#define DMOD_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define DMOD_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define DMOD_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define DMOD_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set.
#define DMOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define DMOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define DMOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define DMOD_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received.
#define DMOD_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define DMOD_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define DMOD_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define DMOD_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set.
#define DMOD_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define DMOD_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define DMOD_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define DMOD_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out.
#define DMOD_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define DMOD_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define DMOD_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define DMOD_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define DMOD_SCRATCH_REG(_BASE) ((dmod_scratch_reg_t*) DMOD_SCRATCH_ADR(_BASE))
#define DMOD_CFG_REG(_BASE) ((dmod_cfg_reg_t*) DMOD_CFG_ADR(_BASE))
#define DMOD_EN_REG(_BASE) ((dmod_en_reg_t*) DMOD_EN_ADR(_BASE))
#define DMOD_SAT_VAL_REG(_BASE) ((dmod_sat_val_reg_t*) DMOD_SAT_VAL_ADR(_BASE))
#define DMOD_APB_BRDG_STAT_REG(_BASE) ((dmod_apb_brdg_stat_reg_t*) DMOD_APB_BRDG_STAT_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    dmod_scratch_reg_t SCRATCH;         /*< Address offset = 0x0 */
    dmod_cfg_reg_t CFG;          /*< Address offset = 0x4 */
    dmod_en_reg_t EN;          /*< Address offset = 0x8 */
    dmod_sat_val_reg_t SAT_VAL;         /*< Address offset = 0xc */
    const uint8_t        reservedArea0 [80];  /*< Address offset = 0x10 */
    dmod_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x60 */
} dmod_t;     // size: 0x0014

// AddressSpace struct pointer
//
#define FB_SYS0_DMOD     ((dmod_t*) FB_SYS0_DMOD_BASE)
#define FB_SYS1_DMOD     ((dmod_t*) FB_SYS1_DMOD_BASE)
#define TRX_SYS0_DMOD    ((dmod_t*) TRX_SYS0_DMOD_BASE)
#define TRX_SYS1_DMOD    ((dmod_t*) TRX_SYS1_DMOD_BASE)
#define TRX_SYS2_DMOD    ((dmod_t*) TRX_SYS2_DMOD_BASE)
#define TRX_SYS3_DMOD    ((dmod_t*) TRX_SYS3_DMOD_BASE)
#define TRX_SYS4_DMOD    ((dmod_t*) TRX_SYS4_DMOD_BASE)
#define TRX_SYS5_DMOD    ((dmod_t*) TRX_SYS5_DMOD_BASE)
#define TRX_SYS6_DMOD    ((dmod_t*) TRX_SYS6_DMOD_BASE)
#define TRX_SYS7_DMOD    ((dmod_t*) TRX_SYS7_DMOD_BASE)

// ******************************************* /Address Space

#endif      // _DMOD_H_

