#ifndef _CMFF_H_
#define _CMFF_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
//    Soc ver:
//        abc_soc-srvrgen4-0p6_emul-23ww51a
//
//
//    Tool Version:
//        23.38.4p2
//
//    Generation Date:
//        2024-01-02
//
// ******************************************************************************

// ******************************************* Base address macros

// Stepping: A0
//

#if (CPU_ANA) // from ADC view
#include "adc_addr_offset.h"
#define ANT0_CMFF_BASE        0x049f0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT0_OFFSET + WRP_ADC_DIGRF_OFFSET
#define ANT1_CMFF_BASE        0x04bf0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT1_OFFSET + WRP_ADC_DIGRF_OFFSET
#define ANT2_CMFF_BASE        0x04df0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT2_OFFSET + WRP_ADC_DIGRF_OFFSET
#define ANT3_CMFF_BASE        0x04ff0000 - WRP_ADC_DIGRF_BASE - WRP_ADC_ANT3_OFFSET + WRP_ADC_DIGRF_OFFSET
#else // from digRF view
#define ANT0_CMFF_BASE        0x049f0000
#define ANT1_CMFF_BASE        0x04bf0000
#define ANT2_CMFF_BASE        0x04df0000
#define ANT3_CMFF_BASE        0x04ff0000
#endif // CPU_ANA

// ******************************************* /Base address macros


// ******************************************* Register offset macros

// Stepping: A0
//
#define CMFF_SCRATCH_OFFSET      ( 0x00000000U )
#define CMFF_CONFIG_OFFSET       ( 0x00000004U )
#define CMFF_CONTROL_OFFSET      ( 0x00000008U )
#define CMFF_FIFO_STATUS_OFFSET  ( 0x0000000cU )
#define CMFF_APB_BRIDGE_STATUS_OFFSET ( 0x000003fcU )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
// Stepping: A0
//
#define CMFF_SCRATCH_ADR(_BASE)         (( ( _BASE ) + ( CMFF_SCRATCH_OFFSET ) ))
#define CMFF_CONFIG_ADR(_BASE)          (( ( _BASE ) + ( CMFF_CONFIG_OFFSET ) ))
#define CMFF_CONTROL_ADR(_BASE)         (( ( _BASE ) + ( CMFF_CONTROL_OFFSET ) ))
#define CMFF_FIFO_STATUS_ADR(_BASE)     (( ( _BASE ) + ( CMFF_FIFO_STATUS_OFFSET ) ))
#define CMFF_APB_BRIDGE_STATUS_ADR(_BASE) (( ( _BASE ) + ( CMFF_APB_BRIDGE_STATUS_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief CMFF_MAP_REG_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmff_map/reg/SCRATCH
  * CMFF Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCH : 32;
    ///< Scratch register for software to use.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} cmff_scratch_reg_t;

#define CMFF_SCRATCH_DEFAULT (0x00000000U)
#define CMFF_SCRATCH_RD_MASK (0xffffffffU)
#define CMFF_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch register for software to use.
#define CMFF_SCRATCH_BF_OFF ( 0)
#define CMFF_SCRATCH_BF_WID (32)
#define CMFF_SCRATCH_BF_MSK (0xFFFFFFFF)
#define CMFF_SCRATCH_BF_DEF (0x00000000)


/** @brief CMFF_MAP_REG_CONFIG register description at address offset 0x4
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmff_map/reg/CONFIG
  * CMFF Configuration Register
  */

typedef union {
  struct {
    uint32_t PATH : 3;
    ///< Selects one of Five Paths. Paths to select RX ADC[3:0] or FB ADC.
    ///< Values 0,1,2,3, selects Paths RX ADC0, DC1, ADC2 and ADC3.  Value
    ///< of 4 selects the FB ADCV path.  All other vaues default to path 0.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
    uint32_t SLICE : 5;
    ///< Selects one of seventeen data slices from the selected data path.
    ///< Valid Values 0 to 16. Any other value defaults to slice0.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} cmff_config_reg_t;

#define CMFF_CONFIG_DEFAULT (0x00000000U)
#define CMFF_CONFIG_RD_MASK (0x000001f7U)
#define CMFF_CONFIG_WR_MASK (0x000001f7U)


///< Selects one of Five Paths. Paths to select RX ADC[3:0] or FB ADC.
///< Values 0,1,2,3, selects Paths RX ADC0, DC1, ADC2 and ADC3.  Value
///< of 4 selects the FB ADCV path.  All other vaues default to path 0.
#define CMFF_CONFIG_PATH_BF_OFF ( 0)
#define CMFF_CONFIG_PATH_BF_WID ( 3)
#define CMFF_CONFIG_PATH_BF_MSK (0x00000007)
#define CMFF_CONFIG_PATH_BF_DEF (0x00000000)

///< Selects one of seventeen data slices from the selected data path.
///< Valid Values 0 to 16. Any other value defaults to slice0.
#define CMFF_CONFIG_SLICE_BF_OFF ( 4)
#define CMFF_CONFIG_SLICE_BF_WID ( 5)
#define CMFF_CONFIG_SLICE_BF_MSK (0x000001F0)
#define CMFF_CONFIG_SLICE_BF_DEF (0x00000000)


/** @brief CMFF_MAP_REG_CONTROL register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: cmff_map/reg/CONTROL
  * CMFF Configuration Register
  */

typedef union {
  struct {
    uint32_t EN_PUSH : 1;
    ///< Set to 1 to allow valid data to be pushed into the data clock crossing
    ///< FIFO.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t SOFT_RESET : 1;
    ///< Soft reset of CC_FIFO in the event of over/under flow condition.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} cmff_control_reg_t;

#define CMFF_CONTROL_DEFAULT (0x00000000U)
#define CMFF_CONTROL_RD_MASK (0x00000003U)
#define CMFF_CONTROL_WR_MASK (0x00000003U)


///< Set to 1 to allow valid data to be pushed into the data clock crossing
///< FIFO.
#define CMFF_CONTROL_EN_PUSH_BF_OFF ( 0)
#define CMFF_CONTROL_EN_PUSH_BF_WID ( 1)
#define CMFF_CONTROL_EN_PUSH_BF_MSK (0x00000001)
#define CMFF_CONTROL_EN_PUSH_BF_DEF (0x00000000)

///< Soft reset of CC_FIFO in the event of over/under flow condition.
#define CMFF_CONTROL_SOFT_RESET_BF_OFF ( 1)
#define CMFF_CONTROL_SOFT_RESET_BF_WID ( 1)
#define CMFF_CONTROL_SOFT_RESET_BF_MSK (0x00000002)
#define CMFF_CONTROL_SOFT_RESET_BF_DEF (0x00000000)


/** @brief CMFF_MAP_REG_FIFO_STATUS register description at address offset 0xc
  *
  * Register default value:        0x00000004
  * Register full path in IP: cmff_map/reg/FIFO_STATUS
  * CMFF Clock Crossing FIFO Status Register
  */

typedef union {
  struct {
    uint32_t UNDERFLOW_ERROR : 1;
    ///< Indicates CC-FIFO Inderflow_Error condition
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t OVERFLOW_ERROR : 1;
    ///< Indicates CC_FIFO Overflow_Error condition.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< Indicates CC_FIFO is Empty.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t FULL : 1;
    ///< Indicates CC_FIFO is Full.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t FF_DEPTH : 8;
    ///< Indicates CC_FIFO Depth
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} cmff_fifo_status_reg_t;

#define CMFF_FIFO_STATUS_DEFAULT (0x00000004U)
#define CMFF_FIFO_STATUS_RD_MASK (0x00000fffU)
#define CMFF_FIFO_STATUS_WR_MASK (0x00000000U)


///< Indicates CC-FIFO Inderflow_Error condition
#define CMFF_FIFO_STATUS_UNDERFLOW_ERROR_BF_OFF ( 0)
#define CMFF_FIFO_STATUS_UNDERFLOW_ERROR_BF_WID ( 1)
#define CMFF_FIFO_STATUS_UNDERFLOW_ERROR_BF_MSK (0x00000001)
#define CMFF_FIFO_STATUS_UNDERFLOW_ERROR_BF_DEF (0x00000000)

///< Indicates CC_FIFO Overflow_Error condition.
#define CMFF_FIFO_STATUS_OVERFLOW_ERROR_BF_OFF ( 1)
#define CMFF_FIFO_STATUS_OVERFLOW_ERROR_BF_WID ( 1)
#define CMFF_FIFO_STATUS_OVERFLOW_ERROR_BF_MSK (0x00000002)
#define CMFF_FIFO_STATUS_OVERFLOW_ERROR_BF_DEF (0x00000000)

///< Indicates CC_FIFO is Empty.
#define CMFF_FIFO_STATUS_EMPTY_BF_OFF ( 2)
#define CMFF_FIFO_STATUS_EMPTY_BF_WID ( 1)
#define CMFF_FIFO_STATUS_EMPTY_BF_MSK (0x00000004)
#define CMFF_FIFO_STATUS_EMPTY_BF_DEF (0x00000004)

///< Indicates CC_FIFO is Full.
#define CMFF_FIFO_STATUS_FULL_BF_OFF ( 3)
#define CMFF_FIFO_STATUS_FULL_BF_WID ( 1)
#define CMFF_FIFO_STATUS_FULL_BF_MSK (0x00000008)
#define CMFF_FIFO_STATUS_FULL_BF_DEF (0x00000000)

///< Indicates CC_FIFO Depth
#define CMFF_FIFO_STATUS_FF_DEPTH_BF_OFF ( 4)
#define CMFF_FIFO_STATUS_FF_DEPTH_BF_WID ( 8)
#define CMFF_FIFO_STATUS_FF_DEPTH_BF_MSK (0x00000FF0)
#define CMFF_FIFO_STATUS_FF_DEPTH_BF_DEF (0x00000000)


/** @brief CMFF_MAP_REG_APB_BRIDGE_STATUS register description at address offset 0x3fc
  *
  * Register default value:        0x00010000
  * Register full path in IP: cmff_map/reg/APB_BRIDGE_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW/L" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW/1S/V/L" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} cmff_apb_bridge_status_reg_t;

#define CMFF_APB_BRIDGE_STATUS_DEFAULT (0x00010000U)
#define CMFF_APB_BRIDGE_STATUS_RD_MASK (0xffffffffU)
#define CMFF_APB_BRIDGE_STATUS_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_VALUE_BF_OFF ( 0)
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_VALUE_BF_WID (20)
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_VALUE_BF_MSK (0x000FFFFF)
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_VALUE_BF_DEF (0x00010000)

///< Module Revision Number
#define CMFF_APB_BRIDGE_STATUS_REVISION_BF_OFF (20)
#define CMFF_APB_BRIDGE_STATUS_REVISION_BF_WID ( 8)
#define CMFF_APB_BRIDGE_STATUS_REVISION_BF_MSK (0x0FF00000)
#define CMFF_APB_BRIDGE_STATUS_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define CMFF_APB_BRIDGE_STATUS_SW_LOCK_CTRL_BF_OFF (28)
#define CMFF_APB_BRIDGE_STATUS_SW_LOCK_CTRL_BF_WID ( 1)
#define CMFF_APB_BRIDGE_STATUS_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define CMFF_APB_BRIDGE_STATUS_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define CMFF_APB_BRIDGE_STATUS_UNSOL_ACK_BF_OFF (29)
#define CMFF_APB_BRIDGE_STATUS_UNSOL_ACK_BF_WID ( 1)
#define CMFF_APB_BRIDGE_STATUS_UNSOL_ACK_BF_MSK (0x20000000)
#define CMFF_APB_BRIDGE_STATUS_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define CMFF_APB_BRIDGE_STATUS_ACK_ERROR_BF_OFF (30)
#define CMFF_APB_BRIDGE_STATUS_ACK_ERROR_BF_WID ( 1)
#define CMFF_APB_BRIDGE_STATUS_ACK_ERROR_BF_MSK (0x40000000)
#define CMFF_APB_BRIDGE_STATUS_ACK_ERROR_BF_DEF (0x00000000)

///< An APB request has timed out
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_BF_OFF (31)
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_BF_WID ( 1)
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_BF_MSK (0x80000000)
#define CMFF_APB_BRIDGE_STATUS_TIMEOUT_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

// Stepping: A0
//
#define CMFF_SCRATCH_REG(_BASE) ((cmff_scratch_reg_t*) CMFF_SCRATCH_ADR(_BASE))
#define CMFF_CONFIG_REG(_BASE) ((cmff_config_reg_t*) CMFF_CONFIG_ADR(_BASE))
#define CMFF_CONTROL_REG(_BASE) ((cmff_control_reg_t*) CMFF_CONTROL_ADR(_BASE))
#define CMFF_FIFO_STATUS_REG(_BASE) ((cmff_fifo_status_reg_t*) CMFF_FIFO_STATUS_ADR(_BASE))
#define CMFF_APB_BRIDGE_STATUS_REG(_BASE) ((cmff_apb_bridge_status_reg_t*) CMFF_APB_BRIDGE_STATUS_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
// Stepping: A0
//
typedef struct
{
    cmff_scratch_reg_t SCRATCH;         /*< Address offset = 0x0 */
    cmff_config_reg_t CONFIG;          /*< Address offset = 0x4 */
    cmff_control_reg_t CONTROL;         /*< Address offset = 0x8 */
    cmff_fifo_status_reg_t FIFO_STATUS;     /*< Address offset = 0xc */
    const uint8_t        reservedArea0 [1004]; /*< Address offset = 0x10 */
    cmff_apb_bridge_status_reg_t APB_BRIDGE_STATUS; /*< Address offset = 0x3fc */
} cmff_t;     // size: 0x0014

// AddressSpace struct pointer
//
#define ANT0_CMFF ((cmff_t*) ANT0_CMFF_BASE)
#define ANT1_CMFF ((cmff_t*) ANT1_CMFF_BASE)
#define ANT2_CMFF ((cmff_t*) ANT2_CMFF_BASE)
#define ANT3_CMFF ((cmff_t*) ANT3_CMFF_BASE)

// ******************************************* /Address Space

#endif      // _CMFF_H_

