#ifndef _JESD_TX_CHAR_CLK_CSR_H_
#define _JESD_TX_CHAR_CLK_CSR_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define DLNK_JESD0_TX_CHAR_CLK_CSR_BASE  ( 0x0670a000 )
#define DLNK_JESD1_TX_CHAR_CLK_CSR_BASE  ( 0x06f0a000 )
#define DLNK_JESD2_TX_CHAR_CLK_CSR_BASE  ( 0x0770a000 )
#define DLNK_JESD3_TX_CHAR_CLK_CSR_BASE  ( 0x07f0a000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define JESD_TX_CHAR_CLK_CSR_SCRATCH_OFFSET ( 0x00000000U )
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_OFFSET ( 0x00000004U )
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_OFFSET ( 0x00000010U )
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_OFFSET ( 0x00000014U )
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_OFFSET ( 0x00000018U )
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_OFFSET ( 0x0000001cU )
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_OFFSET ( 0x00000020U )
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_OFFSET ( 0x00000024U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define JESD_TX_CHAR_CLK_CSR_SCRATCH_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_SCRATCH_OFFSET ) ))
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_OFFSET ) ))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_OFFSET ) ))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_OFFSET ) ))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_OFFSET ) ))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_OFFSET ) ))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_OFFSET ) ))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_ADR(_BASE) (( ( _BASE ) + ( JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/SCRATCH
  * Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Scratch pad
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_scratch_reg_t;

#define JESD_TX_CHAR_CLK_CSR_SCRATCH_DEFAULT (0x00000000U)
#define JESD_TX_CHAR_CLK_CSR_SCRATCH_RD_MASK (0xffffffffU)
#define JESD_TX_CHAR_CLK_CSR_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch pad
#define JESD_TX_CHAR_CLK_CSR_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_SCRATCH_SCRATCHPAD_BF_WID (32)
#define JESD_TX_CHAR_CLK_CSR_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define JESD_TX_CHAR_CLK_CSR_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_APB_BRIDGE_STATUS register description at address offset 0x4
  *
  * Register default value:        0x00010000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/APB_BRIDGE_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW/1S" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_apb_brdg_stat_reg_t;

#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/TX_CHAR_CLK_IMM_ERR_STS
  * Status register for Fatal errors detected in TX character clock domain
  */

typedef union {
  struct {
    uint32_t IMM_ERR_STS : 8;
    ///< Status register for Fatal errors detected in TX character clock domain
    ///< which needs to set alarms/interrupts immediately.            The register
    ///< value is sticky once set and only cleared upon writing to corresponding
    ///< error clear register.             This register is set if the corresponding
    ///< erro is detected irrespective of the value of the error generation
    ///< enable.            The mapping of individual bits is shown below.
    ///< [1:0]   - TX Lane 0 error Status.                [0]  - TX Gearbox
    ///< Full Error.               [1]  - TX Gearbox Empty Error.        [3:2]
    ///< - TX Lane 1 error Status. Error bit mapping same as Lane 0.
    ///< [5:4]  - TX Lane 2 error Status. Error bit mapping same as Lane 0.
    ///< [7:8]  - TX Lane 3 error Status. Error bit mapping same as Lane 0.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_tx_char_clk_imm_err_sts_reg_t;

#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_DEFAULT (0x00000000U)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_RD_MASK (0x000000ffU)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_WR_MASK (0x00000000U)


///< Status register for Fatal errors detected in TX character clock domain
///< which needs to set alarms/interrupts immediately.            The register
///< value is sticky once set and only cleared upon writing to corresponding
///< error clear register.             This register is set if the corresponding
///< erro is detected irrespective of the value of the error generation
///< enable.            The mapping of individual bits is shown below.
///< [1:0]   - TX Lane 0 error Status.                [0]  - TX Gearbox
///< Full Error.               [1]  - TX Gearbox Empty Error.        [3:2]
///< - TX Lane 1 error Status. Error bit mapping same as Lane 0.
///< [5:4]  - TX Lane 2 error Status. Error bit mapping same as Lane 0.
///< [7:8]  - TX Lane 3 error Status. Error bit mapping same as Lane 0.
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_IMM_ERR_STS_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_IMM_ERR_STS_BF_WID ( 8)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_IMM_ERR_STS_BF_MSK (0x000000FF)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_IMM_ERR_STS_BF_DEF (0x00000000)


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN register description at address offset 0x14
  *
  * Register default value:        0x00000000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/TX_CHAR_CLK_IMM_INTR_HIGH_EN
  * High Priority Enable register for TX Interrupts for Fatal errors detected in TX character clock domain
  */

typedef union {
  struct {
    uint32_t IMM_INTR_HIGH_EN : 8;
    ///< This register contains corresponding high priority Interrupt enable
    ///< bits for all the Interrupt conditions detected in TX character clock
    ///< immediate errors Status register.             Each bit of this register
    ///< enable High priority Interrupt for corresponding error in the status
    ///< register.             The mapping of bits is same as TX character
    ///< clock immediate errors Status register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_tx_char_clk_imm_intr_high_en_reg_t;

#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_DEFAULT (0x00000000U)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_RD_MASK (0x000000ffU)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_WR_MASK (0x000000ffU)


///< This register contains corresponding high priority Interrupt enable
///< bits for all the Interrupt conditions detected in TX character clock
///< immediate errors Status register.             Each bit of this register
///< enable High priority Interrupt for corresponding error in the status
///< register.             The mapping of bits is same as TX character
///< clock immediate errors Status register.
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_IMM_INTR_HIGH_EN_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_IMM_INTR_HIGH_EN_BF_WID ( 8)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_IMM_INTR_HIGH_EN_BF_MSK (0x000000FF)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_IMM_INTR_HIGH_EN_BF_DEF (0x00000000)


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/TX_CHAR_CLK_IMM_INTR_LOW_EN
  * Low Priority Enable register for TX Interrupts for Fatal errors detected in TX character clock domain
  */

typedef union {
  struct {
    uint32_t IMM_INTR_LOW_EN : 8;
    ///< This register contains corresponding Low priority Interrupt enable
    ///< bits for all the Interrupt conditions detected in TX character clock
    ///< immediate errors Status register.             Each bit of this register
    ///< enable Low priority Interrupt for corresponding error in the status
    ///< register.             The mapping of bits is same as TX character
    ///< clock immediate errors Status register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_tx_char_clk_imm_intr_low_en_reg_t;

#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_DEFAULT (0x00000000U)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_RD_MASK (0x000000ffU)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_WR_MASK (0x000000ffU)


///< This register contains corresponding Low priority Interrupt enable
///< bits for all the Interrupt conditions detected in TX character clock
///< immediate errors Status register.             Each bit of this register
///< enable Low priority Interrupt for corresponding error in the status
///< register.             The mapping of bits is same as TX character
///< clock immediate errors Status register.
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_IMM_INTR_LOW_EN_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_IMM_INTR_LOW_EN_BF_WID ( 8)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_IMM_INTR_LOW_EN_BF_MSK (0x000000FF)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_IMM_INTR_LOW_EN_BF_DEF (0x00000000)


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN register description at address offset 0x1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/TX_CHAR_CLK_IMM_ALM_EN
  * Enable register for TX Alarms for Fatal errors detected in TX character clock domain
  */

typedef union {
  struct {
    uint32_t IMM_ALM_EN : 8;
    ///< This register contains corresponding enable bits for all the error
    ///< conditions detected in TX character clock immediate error Status register.
    ///< Each bit of this register enable alarm for corresponding error in
    ///< the status register.             The mapping of bits is same as TX
    ///< character clock immediate error Status register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_tx_char_clk_imm_alm_en_reg_t;

#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_DEFAULT (0x00000000U)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_RD_MASK (0x000000ffU)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_WR_MASK (0x000000ffU)


///< This register contains corresponding enable bits for all the error
///< conditions detected in TX character clock immediate error Status register.
///< Each bit of this register enable alarm for corresponding error in
///< the status register.             The mapping of bits is same as TX
///< character clock immediate error Status register.
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_IMM_ALM_EN_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_IMM_ALM_EN_BF_WID ( 8)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_IMM_ALM_EN_BF_MSK (0x000000FF)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_IMM_ALM_EN_BF_DEF (0x00000000)


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/TX_CHAR_CLK_IMM_ERR_CLR
  * Clear register for Fatal errors detected in TX character clock domain
  */

typedef union {
  struct {
    uint32_t IMM_ERR_CLR : 8;
    ///< This register contains clear bits for all the error conditions detected
    ///< in TX character clock immediate error Status register.
    ///< Each bit of this register when written clears the corresponding bit
    ///< in the error status status register.            The clear operation
    ///< is done for only one cycle and subsequent error bits can set the status
    ///< registers.             The mapping of bits is same as TX character
    ///< clock immediate error Status register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_tx_char_clk_imm_err_clr_reg_t;

#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_DEFAULT (0x00000000U)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_RD_MASK (0x000000ffU)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_WR_MASK (0x000000ffU)


///< This register contains clear bits for all the error conditions detected
///< in TX character clock immediate error Status register.
///< Each bit of this register when written clears the corresponding bit
///< in the error status status register.            The clear operation
///< is done for only one cycle and subsequent error bits can set the status
///< registers.             The mapping of bits is same as TX character
///< clock immediate error Status register.
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_IMM_ERR_CLR_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_IMM_ERR_CLR_BF_WID ( 8)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_IMM_ERR_CLR_BF_MSK (0x000000FF)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_IMM_ERR_CLR_BF_DEF (0x00000000)


/** @brief JESDABC_TX_CHAR_CLK_CSR_MEM_JESDABC_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: jesdabc_tx_char_clk_csr_MEM/jesdabc_tx_char_clk_csr/TX_CHAR_CLK_IMM_ERR_FRC
  * Force register for Fatal errors detected in TX character clock domain
  */

typedef union {
  struct {
    uint32_t IMM_ERR_FRC : 8;
    ///< This register contains forcr bits for all the error conditions detected
    ///< in TX character clock immediate error Status register.
    ///< Each bit of this register when written force the corresponding bit
    ///< in the error status register to 1 irrespective of the error condition
    ///< (active value of the error) until written back to 0.
    ///< The mapping of bits is same as TX character clock immediate error
    ///< Status register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} jesd_tx_char_clk_csr_tx_char_clk_imm_err_frc_reg_t;

#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_DEFAULT (0x00000000U)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_RD_MASK (0x000000ffU)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_WR_MASK (0x000000ffU)


///< This register contains forcr bits for all the error conditions detected
///< in TX character clock immediate error Status register.
///< Each bit of this register when written force the corresponding bit
///< in the error status register to 1 irrespective of the error condition
///< (active value of the error) until written back to 0.
///< The mapping of bits is same as TX character clock immediate error
///< Status register.
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_IMM_ERR_FRC_BF_OFF ( 0)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_IMM_ERR_FRC_BF_WID ( 8)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_IMM_ERR_FRC_BF_MSK (0x000000FF)
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_IMM_ERR_FRC_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define JESD_TX_CHAR_CLK_CSR_SCRATCH_REG(_BASE) ((jesd_tx_char_clk_csr_scratch_reg_t*) JESD_TX_CHAR_CLK_CSR_SCRATCH_ADR(_BASE))
#define JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_REG(_BASE) ((jesd_tx_char_clk_csr_apb_brdg_stat_reg_t*) JESD_TX_CHAR_CLK_CSR_APB_BRDG_STAT_ADR(_BASE))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_REG(_BASE) ((jesd_tx_char_clk_csr_tx_char_clk_imm_err_sts_reg_t*) JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_STS_ADR(_BASE))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_REG(_BASE) ((jesd_tx_char_clk_csr_tx_char_clk_imm_intr_high_en_reg_t*) JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_HIGH_EN_ADR(_BASE))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_REG(_BASE) ((jesd_tx_char_clk_csr_tx_char_clk_imm_intr_low_en_reg_t*) JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_INTR_LOW_EN_ADR(_BASE))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_REG(_BASE) ((jesd_tx_char_clk_csr_tx_char_clk_imm_alm_en_reg_t*) JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ALM_EN_ADR(_BASE))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_REG(_BASE) ((jesd_tx_char_clk_csr_tx_char_clk_imm_err_clr_reg_t*) JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_CLR_ADR(_BASE))
#define JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_REG(_BASE) ((jesd_tx_char_clk_csr_tx_char_clk_imm_err_frc_reg_t*) JESD_TX_CHAR_CLK_CSR_TX_CHAR_CLK_IMM_ERR_FRC_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    jesd_tx_char_clk_csr_scratch_reg_t SCRATCH; /*< Address offset = 0x0 */
    jesd_tx_char_clk_csr_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x4 */
    const uint8_t        reservedArea0 [8];   /*< Address offset = 0x8 */
    jesd_tx_char_clk_csr_tx_char_clk_imm_err_sts_reg_t TX_CHAR_CLK_IMM_ERR_STS; /*< Address offset = 0x10 */
    jesd_tx_char_clk_csr_tx_char_clk_imm_intr_high_en_reg_t TX_CHAR_CLK_IMM_INTR_HIGH_EN; /*< Address offset = 0x14 */
    jesd_tx_char_clk_csr_tx_char_clk_imm_intr_low_en_reg_t TX_CHAR_CLK_IMM_INTR_LOW_EN; /*< Address offset = 0x18 */
    jesd_tx_char_clk_csr_tx_char_clk_imm_alm_en_reg_t TX_CHAR_CLK_IMM_ALM_EN; /*< Address offset = 0x1c */
    jesd_tx_char_clk_csr_tx_char_clk_imm_err_clr_reg_t TX_CHAR_CLK_IMM_ERR_CLR; /*< Address offset = 0x20 */
    jesd_tx_char_clk_csr_tx_char_clk_imm_err_frc_reg_t TX_CHAR_CLK_IMM_ERR_FRC; /*< Address offset = 0x24 */
} jesd_tx_char_clk_csr_t;     // size: 0x0020

// AddressSpace struct pointer
//
#define DLNK_JESD0_TX_CHAR_CLK_CSR  ((jesd_tx_char_clk_csr_t*) DLNK_JESD0_TX_CHAR_CLK_CSR_BASE)
#define DLNK_JESD1_TX_CHAR_CLK_CSR  ((jesd_tx_char_clk_csr_t*) DLNK_JESD1_TX_CHAR_CLK_CSR_BASE)
#define DLNK_JESD2_TX_CHAR_CLK_CSR  ((jesd_tx_char_clk_csr_t*) DLNK_JESD2_TX_CHAR_CLK_CSR_BASE)
#define DLNK_JESD3_TX_CHAR_CLK_CSR  ((jesd_tx_char_clk_csr_t*) DLNK_JESD3_TX_CHAR_CLK_CSR_BASE)

// ******************************************* /Address Space

#endif      // _JESD_TX_CHAR_CLK_CSR_H_

