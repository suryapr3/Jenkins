#ifndef _VHA_ANT_H_
#define _VHA_ANT_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define VHA0_ANT0_BASE        ( 0x03c03000 )
#define VHA0_ANT1_BASE        ( 0x03c13000 )
#define VHA1_ANT0_BASE        ( 0x03c23000 )
#define VHA1_ANT1_BASE        ( 0x03c33000 )
#define VHA2_ANT0_BASE        ( 0x03c43000 )
#define VHA2_ANT1_BASE        ( 0x03c53000 )
#define VHA3_ANT0_BASE        ( 0x03c63000 )
#define VHA3_ANT1_BASE        ( 0x03c73000 )
#define VHA4_ANT0_BASE        ( 0x03c83000 )
#define VHA4_ANT1_BASE        ( 0x03c93000 )
#define VHA5_ANT0_BASE        ( 0x03ca3000 )
#define VHA5_ANT1_BASE        ( 0x03cb3000 )
#define VHA6_ANT0_BASE        ( 0x03cc3000 )
#define VHA6_ANT1_BASE        ( 0x03cd3000 )
#define VHA7_ANT0_BASE        ( 0x03ce3000 )
#define VHA7_ANT1_BASE        ( 0x03cf3000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define VHA_ANT_SCRATCH_OFFSET ( 0x00000000U )
#define VHA_ANT_CFG_OFFSET ( 0x00000004U )
#define VHA_ANT_DL_CFG_OFFSET ( 0x00000008U )
#define VHA_ANT_TX_ALARM_EN_OFFSET ( 0x0000000cU )
#define VHA_ANT_DL_IF_CFG0_OFFSET ( 0x00000010U )
#define VHA_ANT_DL_IF_CFG1_OFFSET ( 0x00000014U )
#define VHA_ANT_DL_OF_CFG0_OFFSET ( 0x00000018U )
#define VHA_ANT_DL_OF_CFG1_OFFSET ( 0x0000001cU )
#define VHA_ANT_DL_IF_ECC_CTRL0_OFFSET ( 0x00000020U )
#define VHA_ANT_DL_IF_ECC_CTRL1_OFFSET ( 0x00000024U )
#define VHA_ANT_ARB_CFG_OFFSET ( 0x00000028U )
#define VHA_ANT_UL_CFG_OFFSET ( 0x0000002cU )
#define VHA_ANT_UL_IF_CFG_OFFSET ( 0x00000030U )
#define VHA_ANT_UL_IF_ECC_CTRL_OFFSET ( 0x00000034U )
#define VHA_ANT_UL_OF_CFG0_OFFSET ( 0x00000038U )
#define VHA_ANT_UL_OF_CFG1_OFFSET ( 0x0000003cU )
#define VHA_ANT_INT_STAT_OFFSET ( 0x00000040U )
#define VHA_ANT_INT_HIGH_EN_OFFSET ( 0x00000044U )
#define VHA_ANT_INT_LOW_EN_OFFSET ( 0x00000048U )
#define VHA_ANT_INT_CLR_OFFSET ( 0x0000004cU )
#define VHA_ANT_INT_FORCE_OFFSET ( 0x00000050U )
#define VHA_ANT_APB_BRDG_STAT_OFFSET ( 0x00000054U )
#define VHA_ANT_DL_IF_STAT0_OFFSET ( 0x00000060U )
#define VHA_ANT_DL_IF_STAT1_OFFSET ( 0x00000064U )
#define VHA_ANT_DL_CC_IF_STAT0_OFFSET ( 0x00000068U )
#define VHA_ANT_DL_CC_IF_STAT1_OFFSET ( 0x0000006cU )
#define VHA_ANT_DL_IF_ECC_STAT_OFFSET ( 0x00000070U )
#define VHA_ANT_DL_IF_ECC_INFO0_OFFSET ( 0x00000078U )
#define VHA_ANT_DL_IF_ECC_INFO1_OFFSET ( 0x0000007cU )
#define VHA_ANT_DL_OF_STAT0_OFFSET ( 0x00000080U )
#define VHA_ANT_DL_OF_STAT1_OFFSET ( 0x00000084U )
#define VHA_ANT_UL_IF_STAT_OFFSET ( 0x00000088U )
#define VHA_ANT_UL_CC_IF_STAT_OFFSET ( 0x0000008cU )
#define VHA_ANT_UL_IF_ECC_STAT_OFFSET ( 0x00000090U )
#define VHA_ANT_UL_IF_ECC_INFO_OFFSET ( 0x00000094U )
#define VHA_ANT_UL_OF_STAT0_OFFSET ( 0x00000098U )
#define VHA_ANT_UL_OF_STAT1_OFFSET ( 0x0000009cU )
#define VHA_ANT_DL_ARB_CNT0_OFFSET ( 0x000000a0U )
#define VHA_ANT_DL_ARB_CNT1_OFFSET ( 0x000000a4U )
#define VHA_ANT_UL_ARB_CNT0_OFFSET ( 0x000000a8U )
#define VHA_ANT_UL_ARB_CNT1_OFFSET ( 0x000000acU )
#define VHA_ANT_ARB_STAT_OFFSET ( 0x000000b0U )
#define VHA_ANT_SMON_R0_OFFSET ( 0x000000c0U )
#define VHA_ANT_SMON_R1_OFFSET ( 0x000000c4U )
#define VHA_ANT_SMON_R2_OFFSET ( 0x000000c8U )
#define VHA_ANT_SMON_R3_OFFSET ( 0x000000ccU )
#define VHA_ANT_SMON_R4_OFFSET ( 0x000000d0U )
#define VHA_ANT_SMON_R5_OFFSET ( 0x000000d4U )
#define VHA_ANT_SMON_R6_OFFSET ( 0x000000d8U )
#define VHA_ANT_SMON_R7_OFFSET ( 0x000000dcU )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define VHA_ANT_SCRATCH_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SCRATCH_OFFSET ) ))
#define VHA_ANT_CFG_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_CFG_OFFSET ) ))
#define VHA_ANT_DL_CFG_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_CFG_OFFSET ) ))
#define VHA_ANT_TX_ALARM_EN_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_TX_ALARM_EN_OFFSET ) ))
#define VHA_ANT_DL_IF_CFG0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_CFG0_OFFSET ) ))
#define VHA_ANT_DL_IF_CFG1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_CFG1_OFFSET ) ))
#define VHA_ANT_DL_OF_CFG0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_OF_CFG0_OFFSET ) ))
#define VHA_ANT_DL_OF_CFG1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_OF_CFG1_OFFSET ) ))
#define VHA_ANT_DL_IF_ECC_CTRL0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_ECC_CTRL0_OFFSET ) ))
#define VHA_ANT_DL_IF_ECC_CTRL1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_ECC_CTRL1_OFFSET ) ))
#define VHA_ANT_ARB_CFG_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_ARB_CFG_OFFSET ) ))
#define VHA_ANT_UL_CFG_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_CFG_OFFSET ) ))
#define VHA_ANT_UL_IF_CFG_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_IF_CFG_OFFSET ) ))
#define VHA_ANT_UL_IF_ECC_CTRL_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_IF_ECC_CTRL_OFFSET ) ))
#define VHA_ANT_UL_OF_CFG0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_OF_CFG0_OFFSET ) ))
#define VHA_ANT_UL_OF_CFG1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_OF_CFG1_OFFSET ) ))
#define VHA_ANT_INT_STAT_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_INT_STAT_OFFSET ) ))
#define VHA_ANT_INT_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_INT_HIGH_EN_OFFSET ) ))
#define VHA_ANT_INT_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_INT_LOW_EN_OFFSET ) ))
#define VHA_ANT_INT_CLR_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_INT_CLR_OFFSET ) ))
#define VHA_ANT_INT_FORCE_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_INT_FORCE_OFFSET ) ))
#define VHA_ANT_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_APB_BRDG_STAT_OFFSET ) ))
#define VHA_ANT_DL_IF_STAT0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_STAT0_OFFSET ) ))
#define VHA_ANT_DL_IF_STAT1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_STAT1_OFFSET ) ))
#define VHA_ANT_DL_CC_IF_STAT0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_CC_IF_STAT0_OFFSET ) ))
#define VHA_ANT_DL_CC_IF_STAT1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_CC_IF_STAT1_OFFSET ) ))
#define VHA_ANT_DL_IF_ECC_STAT_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_ECC_STAT_OFFSET ) ))
#define VHA_ANT_DL_IF_ECC_INFO0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_ECC_INFO0_OFFSET ) ))
#define VHA_ANT_DL_IF_ECC_INFO1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_IF_ECC_INFO1_OFFSET ) ))
#define VHA_ANT_DL_OF_STAT0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_OF_STAT0_OFFSET ) ))
#define VHA_ANT_DL_OF_STAT1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_OF_STAT1_OFFSET ) ))
#define VHA_ANT_UL_IF_STAT_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_IF_STAT_OFFSET ) ))
#define VHA_ANT_UL_CC_IF_STAT_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_CC_IF_STAT_OFFSET ) ))
#define VHA_ANT_UL_IF_ECC_STAT_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_IF_ECC_STAT_OFFSET ) ))
#define VHA_ANT_UL_IF_ECC_INFO_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_IF_ECC_INFO_OFFSET ) ))
#define VHA_ANT_UL_OF_STAT0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_OF_STAT0_OFFSET ) ))
#define VHA_ANT_UL_OF_STAT1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_OF_STAT1_OFFSET ) ))
#define VHA_ANT_DL_ARB_CNT0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_ARB_CNT0_OFFSET ) ))
#define VHA_ANT_DL_ARB_CNT1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_DL_ARB_CNT1_OFFSET ) ))
#define VHA_ANT_UL_ARB_CNT0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_ARB_CNT0_OFFSET ) ))
#define VHA_ANT_UL_ARB_CNT1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_UL_ARB_CNT1_OFFSET ) ))
#define VHA_ANT_ARB_STAT_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_ARB_STAT_OFFSET ) ))
#define VHA_ANT_SMON_R0_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R0_OFFSET ) ))
#define VHA_ANT_SMON_R1_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R1_OFFSET ) ))
#define VHA_ANT_SMON_R2_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R2_OFFSET ) ))
#define VHA_ANT_SMON_R3_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R3_OFFSET ) ))
#define VHA_ANT_SMON_R4_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R4_OFFSET ) ))
#define VHA_ANT_SMON_R5_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R5_OFFSET ) ))
#define VHA_ANT_SMON_R6_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R6_OFFSET ) ))
#define VHA_ANT_SMON_R7_ADR(_BASE) (( ( _BASE ) + ( VHA_ANT_SMON_R7_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_SCRATCH
  * VHA Antenna Scratchpad Register
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Do anything with this field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_scratch_reg_t;

#define VHA_ANT_SCRATCH_DEFAULT (0x00000000U)
#define VHA_ANT_SCRATCH_RD_MASK (0xffffffffU)
#define VHA_ANT_SCRATCH_WR_MASK (0xffffffffU)


///< Do anything with this field.
#define VHA_ANT_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define VHA_ANT_SCRATCH_SCRATCHPAD_BF_WID (32)
#define VHA_ANT_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_CFG register description at address offset 0x4
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_CFG
  * VHA Antenna Config
  */

typedef union {
  struct {
    uint32_t BURST_SIZE : 2;
    ///< This is one less than the size of the burst that is to be sent to
    ///< HBI_NSIP. It controls the SOP and EOP signals sent to the HBI_NSIP,
    ///< but also determines the  units  of the N1/N2 counts of the Split Destination
    ///< feature of the output fifos. Both Uplink and Downlink must use the
    ///< same setting, so there is only one per Antenna.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_cfg_reg_t;

#define VHA_ANT_CFG_DEFAULT (0x00000000U)
#define VHA_ANT_CFG_RD_MASK (0x00000003U)
#define VHA_ANT_CFG_WR_MASK (0x00000003U)


///< This is one less than the size of the burst that is to be sent to
///< HBI_NSIP. It controls the SOP and EOP signals sent to the HBI_NSIP,
///< but also determines the  units  of the N1/N2 counts of the Split Destination
///< feature of the output fifos. Both Uplink and Downlink must use the
///< same setting, so there is only one per Antenna.
#define VHA_ANT_CFG_BURST_SIZE_BF_OFF ( 0)
#define VHA_ANT_CFG_BURST_SIZE_BF_WID ( 2)
#define VHA_ANT_CFG_BURST_SIZE_BF_MSK (0x00000003)
#define VHA_ANT_CFG_BURST_SIZE_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_CFG register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_CFG
  * VHA Antenna Downlink Config
  */

typedef union {
  struct {
    uint32_t IN_RATE0 : 3;
    ///< This is the sample rate of the data present in the downlink band 0
    ///< iinput FIFO. This must be set correctly so that the VHA circuitry
    ///< extracts data for the respective band correctly. If the VHA_DUC is
    ///< being used, this must be programmed to match its input rate.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t IN_RATE1 : 3;
    ///< This is the sample rate of the data present in the downlink band 1
    ///< iinput FIFO. This must be set correctly so that the VHA circuitry
    ///< extracts data for the respective band correctly. If the VHA_DUC is
    ///< being used, this must be programmed to match its input rate.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t MOD_BYPASS : 2;
    ///< Set to 1 to bypass the VHA MOD path for the the respective band.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t OUT_RATE0 : 3;
    ///< This is the sample rate out of bank 0 of vha_duc. Note that if vha_mod
    ///< is being used, this cannot be any less than VHA_RATE_1.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t OUT_RATE1 : 3;
    ///< This is the sample rate out of bank 1 of vha_duc.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t DL_OF_ENABLE : 2;
    ///< Set to 1 to enable the output FIFO for the respective downlink band
    ///< of this antenna. Note that for single band operation where the data
    ///< is to be sent to two locations (Dual Cast), both of these must be
    ///< enabled.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_cfg_reg_t;

#define VHA_ANT_DL_CFG_DEFAULT (0x00000000U)
#define VHA_ANT_DL_CFG_RD_MASK (0x0000ffffU)
#define VHA_ANT_DL_CFG_WR_MASK (0x0000ffffU)


///< This is the sample rate of the data present in the downlink band 0
///< iinput FIFO. This must be set correctly so that the VHA circuitry
///< extracts data for the respective band correctly. If the VHA_DUC is
///< being used, this must be programmed to match its input rate.
#define VHA_ANT_DL_CFG_IN_RATE0_BF_OFF ( 0)
#define VHA_ANT_DL_CFG_IN_RATE0_BF_WID ( 3)
#define VHA_ANT_DL_CFG_IN_RATE0_BF_MSK (0x00000007)
#define VHA_ANT_DL_CFG_IN_RATE0_BF_DEF (0x00000000)

///< This is the sample rate of the data present in the downlink band 1
///< iinput FIFO. This must be set correctly so that the VHA circuitry
///< extracts data for the respective band correctly. If the VHA_DUC is
///< being used, this must be programmed to match its input rate.
#define VHA_ANT_DL_CFG_IN_RATE1_BF_OFF ( 3)
#define VHA_ANT_DL_CFG_IN_RATE1_BF_WID ( 3)
#define VHA_ANT_DL_CFG_IN_RATE1_BF_MSK (0x00000038)
#define VHA_ANT_DL_CFG_IN_RATE1_BF_DEF (0x00000000)

///< Set to 1 to bypass the VHA MOD path for the the respective band.
#define VHA_ANT_DL_CFG_MOD_BYP_BF_OFF ( 6)
#define VHA_ANT_DL_CFG_MOD_BYP_BF_WID ( 2)
#define VHA_ANT_DL_CFG_MOD_BYP_BF_MSK (0x000000C0)
#define VHA_ANT_DL_CFG_MOD_BYP_BF_DEF (0x00000000)

///< This is the sample rate out of bank 0 of vha_duc. Note that if vha_mod
///< is being used, this cannot be any less than VHA_RATE_1.
#define VHA_ANT_DL_CFG_OUT_RATE0_BF_OFF ( 8)
#define VHA_ANT_DL_CFG_OUT_RATE0_BF_WID ( 3)
#define VHA_ANT_DL_CFG_OUT_RATE0_BF_MSK (0x00000700)
#define VHA_ANT_DL_CFG_OUT_RATE0_BF_DEF (0x00000000)

///< This is the sample rate out of bank 1 of vha_duc.
#define VHA_ANT_DL_CFG_OUT_RATE1_BF_OFF (11)
#define VHA_ANT_DL_CFG_OUT_RATE1_BF_WID ( 3)
#define VHA_ANT_DL_CFG_OUT_RATE1_BF_MSK (0x00003800)
#define VHA_ANT_DL_CFG_OUT_RATE1_BF_DEF (0x00000000)

///< Set to 1 to enable the output FIFO for the respective downlink band
///< of this antenna. Note that for single band operation where the data
///< is to be sent to two locations (Dual Cast), both of these must be
///< enabled.
#define VHA_ANT_DL_CFG_OF_EN_BF_OFF (14)
#define VHA_ANT_DL_CFG_OF_EN_BF_WID ( 2)
#define VHA_ANT_DL_CFG_OF_EN_BF_MSK (0x0000C000)
#define VHA_ANT_DL_CFG_OF_EN_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_TX_ALARM_EN register description at address offset 0xc
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_TX_ALARM_EN
  * VHA Antenna TX Alarm Pin Config
  */

typedef union {
  struct {
    uint32_t UL_IF_ERROR : 1;
    ///< Enable the Uplink Input FIFO error interrupt to propagate to the tx
    ///< alarm pin.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DL_IF_ERROR : 2;
    ///< Enable the respective Downlink Input FIFO error interrupt to propagate
    ///< to the tx alarm pin.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE : 2;
    ///< Enable the respective Downlink Input FIFO single bit error interrupt
    ///< to propagate to the tx alarm pin.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DL_IF_ECC_DBE : 2;
    ///< Enable the respective Downlink Input FIFO double bit error interrupt
    ///< to propagate to the tx alarm pin.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE_CNT_OVFL : 2;
    ///< Enable the respective Downlink Input FIFO ECC SBE counter overflow
    ///< error interrupt to propagate to the tx alarm pin.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE : 1;
    ///< Enable the Uplink Input FIFO single bit error interrupt to propagate
    ///< to the tx alarm pin.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t UL_IF_ECC_DBE : 1;
    ///< Enable the Uplink Input FIFO double bit error interrupt to propagate
    ///< to the tx alarm pin.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE_CNT_OVFL : 1;
    ///< Enable the Uplink Input FIFO ECC SBE counter overflow error interrupt
    ///< to propagate to the tx alarm pin.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t UL_OF_ERROR : 2;
    ///< Enable the respective Uplink Output FIFO error interrupt to propagate
    ///< to the tx alarm pin.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DL_OF_ERROR : 2;
    ///< Enable the respective Downlink Output FIFO error interrupt to propagate
    ///< to the tx alarm pin.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t NSIP_HBI_ERROR : 1;
    ///< Enable the High Priority Interrupt pin of the nsip_hbi to propagate
    ///< to the tx alarm pin.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_tx_alarm_en_reg_t;

#define VHA_ANT_TX_ALARM_EN_DEFAULT (0x00000000U)
#define VHA_ANT_TX_ALARM_EN_RD_MASK (0x0001ffffU)
#define VHA_ANT_TX_ALARM_EN_WR_MASK (0x0001ffffU)


///< Enable the Uplink Input FIFO error interrupt to propagate to the tx
///< alarm pin.
#define VHA_ANT_TX_ALARM_EN_UL_IF_ERR_BF_OFF ( 0)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ERR_BF_WID ( 1)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ERR_BF_MSK (0x00000001)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO error interrupt to propagate
///< to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_DL_IF_ERR_BF_OFF ( 1)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ERR_BF_WID ( 2)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ERR_BF_MSK (0x00000006)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO single bit error interrupt
///< to propagate to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_BF_OFF ( 3)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_BF_WID ( 2)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_BF_MSK (0x00000018)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO double bit error interrupt
///< to propagate to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_DBE_BF_OFF ( 5)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_DBE_BF_WID ( 2)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_DBE_BF_MSK (0x00000060)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO ECC SBE counter overflow
///< error interrupt to propagate to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_OFF ( 7)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 2)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000180)
#define VHA_ANT_TX_ALARM_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO single bit error interrupt to propagate
///< to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_BF_OFF ( 9)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_BF_WID ( 1)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_BF_MSK (0x00000200)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO double bit error interrupt to propagate
///< to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_DBE_BF_OFF (10)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_DBE_BF_WID ( 1)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_DBE_BF_MSK (0x00000400)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO ECC SBE counter overflow error interrupt
///< to propagate to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_OFF (11)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000800)
#define VHA_ANT_TX_ALARM_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Enable the respective Uplink Output FIFO error interrupt to propagate
///< to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_UL_OF_ERR_BF_OFF (12)
#define VHA_ANT_TX_ALARM_EN_UL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_TX_ALARM_EN_UL_OF_ERR_BF_MSK (0x00003000)
#define VHA_ANT_TX_ALARM_EN_UL_OF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Output FIFO error interrupt to propagate
///< to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_DL_OF_ERR_BF_OFF (14)
#define VHA_ANT_TX_ALARM_EN_DL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_TX_ALARM_EN_DL_OF_ERR_BF_MSK (0x0000C000)
#define VHA_ANT_TX_ALARM_EN_DL_OF_ERR_BF_DEF (0x00000000)

///< Enable the High Priority Interrupt pin of the nsip_hbi to propagate
///< to the tx alarm pin.
#define VHA_ANT_TX_ALARM_EN_NSIP_HBI_ERR_BF_OFF (16)
#define VHA_ANT_TX_ALARM_EN_NSIP_HBI_ERR_BF_WID ( 1)
#define VHA_ANT_TX_ALARM_EN_NSIP_HBI_ERR_BF_MSK (0x00010000)
#define VHA_ANT_TX_ALARM_EN_NSIP_HBI_ERR_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_IF_CFG[2] register description at address offset 0x10
  *
  * Register default value:        0x00000400
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_IF_CFG
  * VHA Antenna Downlink Input FIFO Config
  */

typedef union {
  struct {
    uint32_t IF_WM : 8;
    ///< This is the target fill level, in words (each word, or flit, is 16
    ///< 16i,16q samples) at which the VHA can start draining the downlink
    ///< input fifo. Before this FIFO starts to fill, the VHA waits for the
    ///< associated clock-crossing FIFO to fill to its programmed watermark.
    ///< Also, a programmable set of these will determine when the reads start
    ///< to enable syncing the bands and/or antennas in each VHA instance.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CC_IF_WM : 3;
    ///< This is the target fill level, in words (each word, or flit, is 16
    ///< 16i,16q samples), to which the VHA fills the clock crossing FIFO.
    ///< This is programmable so that, in low bandwidth use cases, the VHA
    ///< will not wait to fill this whole fifo because that would add too much
    ///< latency.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x4"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_if_cfg_reg_t;

#define VHA_ANT_DL_IF_CFG_DEFAULT (0x00000400U)
#define VHA_ANT_DL_IF_CFG_RD_MASK (0x000007ffU)
#define VHA_ANT_DL_IF_CFG_WR_MASK (0x000007ffU)


///< This is the target fill level, in words (each word, or flit, is 16
///< 16i,16q samples) at which the VHA can start draining the downlink
///< input fifo. Before this FIFO starts to fill, the VHA waits for the
///< associated clock-crossing FIFO to fill to its programmed watermark.
///< Also, a programmable set of these will determine when the reads start
///< to enable syncing the bands and/or antennas in each VHA instance.
#define VHA_ANT_DL_IF_CFG_WM_BF_OFF ( 0)
#define VHA_ANT_DL_IF_CFG_WM_BF_WID ( 8)
#define VHA_ANT_DL_IF_CFG_WM_BF_MSK (0x000000FF)
#define VHA_ANT_DL_IF_CFG_WM_BF_DEF (0x00000000)

///< This is the target fill level, in words (each word, or flit, is 16
///< 16i,16q samples), to which the VHA fills the clock crossing FIFO.
///< This is programmable so that, in low bandwidth use cases, the VHA
///< will not wait to fill this whole fifo because that would add too much
///< latency.
#define VHA_ANT_DL_IF_CFG_CC_WM_BF_OFF ( 8)
#define VHA_ANT_DL_IF_CFG_CC_WM_BF_WID ( 3)
#define VHA_ANT_DL_IF_CFG_CC_WM_BF_MSK (0x00000700)
#define VHA_ANT_DL_IF_CFG_CC_WM_BF_DEF (0x00000400)
#define VHA_ANT_DL_IF_CFG_ARR_SZ0 (2)
#define VHA_ANT_DL_IF_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_OF_CFG[2] register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_OF_CFG
  * VHA Antenna Downlink Output FIFO Config
  */

typedef union {
  struct {
    uint32_t DS_N1 : 8;
    ///< When Destination Split is enabled, this is one less than the number
    ///< of bursts the circuitry will send to the first ID assigned to the
    ///< repective FIFO.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DS_N2 : 8;
    ///< When Destination Split is enabled, this one less than is the number
    ///< of bursts the circuitry will send to the second ID assigned to the
    ///< repective FIFO.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DS_ENABLE : 1;
    ///< When this is set to 1, the output FIFO circuitry will send N1+1 bursts
    ///< to the first ID, and N2+1 bursts to the second ID.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_of_cfg_reg_t;

#define VHA_ANT_DL_OF_CFG_DEFAULT (0x00000000U)
#define VHA_ANT_DL_OF_CFG_RD_MASK (0x0001ffffU)
#define VHA_ANT_DL_OF_CFG_WR_MASK (0x0001ffffU)


///< When Destination Split is enabled, this is one less than the number
///< of bursts the circuitry will send to the first ID assigned to the
///< repective FIFO.
#define VHA_ANT_DL_OF_CFG_DS_N1_BF_OFF ( 0)
#define VHA_ANT_DL_OF_CFG_DS_N1_BF_WID ( 8)
#define VHA_ANT_DL_OF_CFG_DS_N1_BF_MSK (0x000000FF)
#define VHA_ANT_DL_OF_CFG_DS_N1_BF_DEF (0x00000000)

///< When Destination Split is enabled, this one less than is the number
///< of bursts the circuitry will send to the second ID assigned to the
///< repective FIFO.
#define VHA_ANT_DL_OF_CFG_DS_N2_BF_OFF ( 8)
#define VHA_ANT_DL_OF_CFG_DS_N2_BF_WID ( 8)
#define VHA_ANT_DL_OF_CFG_DS_N2_BF_MSK (0x0000FF00)
#define VHA_ANT_DL_OF_CFG_DS_N2_BF_DEF (0x00000000)

///< When this is set to 1, the output FIFO circuitry will send N1+1 bursts
///< to the first ID, and N2+1 bursts to the second ID.
#define VHA_ANT_DL_OF_CFG_DS_EN_BF_OFF (16)
#define VHA_ANT_DL_OF_CFG_DS_EN_BF_WID ( 1)
#define VHA_ANT_DL_OF_CFG_DS_EN_BF_MSK (0x00010000)
#define VHA_ANT_DL_OF_CFG_DS_EN_BF_DEF (0x00000000)
#define VHA_ANT_DL_OF_CFG_ARR_SZ0 (2)
#define VHA_ANT_DL_OF_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_IF_ECC_CTRL[2] register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_IF_ECC_CTRL
  * Downlink Input FIFO Memory ECC Control
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< ECC Force Error Type. This bit indicates the type of forced ECC error
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< ECC Force Error. When set to 1, one ECC error is inserted, as determined
    ///< by ECC_FORCE_TYPE. It's automatically cleared when the expected ECC
    ///< error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
    ///< and ECC_ERR_SYNDROME of the correponding memory. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
    ///< of the corresponding memory. This bit retains the last written value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< ECC Check and Correction Disable. When set, this bit disables ECC
    ///< checking and correction for the corresponding memory. It's used for
    ///< debug and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< ECC Generation Disable. When set, this bit disables ECC generation
    ///< for the corresponding memory. It's used for debug and testing purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_if_ecc_ctrl_reg_t;

#define VHA_ANT_DL_IF_ECC_CTRL_DEFAULT (0x00000000U)
#define VHA_ANT_DL_IF_ECC_CTRL_RD_MASK (0x0000003fU)
#define VHA_ANT_DL_IF_ECC_CTRL_WR_MASK (0x0000003fU)


///< ECC Force Error Type. This bit indicates the type of forced ECC error
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_TYPE_BF_OFF ( 0)
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_TYPE_BF_WID ( 1)
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_TYPE_BF_MSK (0x00000001)
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_TYPE_BF_DEF (0x00000000)

///< ECC Force Error. When set to 1, one ECC error is inserted, as determined
///< by ECC_FORCE_TYPE. It's automatically cleared when the expected ECC
///< error is seen by hardware.
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_ERR_BF_OFF ( 1)
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_ERR_BF_WID ( 1)
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_ERR_BF_MSK (0x00000002)
#define VHA_ANT_DL_IF_ECC_CTRL_FORCE_ERR_BF_DEF (0x00000000)

///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
///< and ECC_ERR_SYNDROME of the correponding memory. This bit retains
///< the last written value.
#define VHA_ANT_DL_IF_ECC_CTRL_ERR_CLR_BF_OFF ( 2)
#define VHA_ANT_DL_IF_ECC_CTRL_ERR_CLR_BF_WID ( 1)
#define VHA_ANT_DL_IF_ECC_CTRL_ERR_CLR_BF_MSK (0x00000004)
#define VHA_ANT_DL_IF_ECC_CTRL_ERR_CLR_BF_DEF (0x00000000)

///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
///< of the corresponding memory. This bit retains the last written value.
#define VHA_ANT_DL_IF_ECC_CTRL_CNT_CLR_BF_OFF ( 3)
#define VHA_ANT_DL_IF_ECC_CTRL_CNT_CLR_BF_WID ( 1)
#define VHA_ANT_DL_IF_ECC_CTRL_CNT_CLR_BF_MSK (0x00000008)
#define VHA_ANT_DL_IF_ECC_CTRL_CNT_CLR_BF_DEF (0x00000000)

///< ECC Check and Correction Disable. When set, this bit disables ECC
///< checking and correction for the corresponding memory. It's used for
///< debug and testing purpose.
#define VHA_ANT_DL_IF_ECC_CTRL_CHK_DIS_BF_OFF ( 4)
#define VHA_ANT_DL_IF_ECC_CTRL_CHK_DIS_BF_WID ( 1)
#define VHA_ANT_DL_IF_ECC_CTRL_CHK_DIS_BF_MSK (0x00000010)
#define VHA_ANT_DL_IF_ECC_CTRL_CHK_DIS_BF_DEF (0x00000000)

///< ECC Generation Disable. When set, this bit disables ECC generation
///< for the corresponding memory. It's used for debug and testing purpose.
#define VHA_ANT_DL_IF_ECC_CTRL_GEN_DIS_BF_OFF ( 5)
#define VHA_ANT_DL_IF_ECC_CTRL_GEN_DIS_BF_WID ( 1)
#define VHA_ANT_DL_IF_ECC_CTRL_GEN_DIS_BF_MSK (0x00000020)
#define VHA_ANT_DL_IF_ECC_CTRL_GEN_DIS_BF_DEF (0x00000000)
#define VHA_ANT_DL_IF_ECC_CTRL_ARR_SZ0 (2)
#define VHA_ANT_DL_IF_ECC_CTRL_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_ARB_CFG register description at address offset 0x28
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_ARB_CFG
  * VHA Antenna Output FIFO Arbitration Config
  */

typedef union {
  struct {
    uint32_t MODE : 1;
    ///< Selects the mode of the output FIFO arbiter
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_arb_cfg_reg_t;

#define VHA_ANT_ARB_CFG_DEFAULT (0x00000000U)
#define VHA_ANT_ARB_CFG_RD_MASK (0x00000001U)
#define VHA_ANT_ARB_CFG_WR_MASK (0x00000001U)


///< Selects the mode of the output FIFO arbiter
#define VHA_ANT_ARB_CFG_MODE_BF_OFF ( 0)
#define VHA_ANT_ARB_CFG_MODE_BF_WID ( 1)
#define VHA_ANT_ARB_CFG_MODE_BF_MSK (0x00000001)
#define VHA_ANT_ARB_CFG_MODE_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_CFG register description at address offset 0x2c
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_CFG
  * VHA Antenna Uplink Config
  */

typedef union {
  struct {
    uint32_t IN_RATE : 3;
    ///< This is the sample rate of the data present in the uplink iinput FIFO.
    ///< If the dmod is being used, the lowest legal value is VHA_RATE_1. If
    ///< the dmod is bypassed, however, this can take on any legal rate because
    ///< it then represents the rate being applied to the vha_ddc.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DMOD_BYPASS : 1;
    ///< Set to 1 to bypass the VHA DMOD path for uplink. In this mode, there
    ///< is a single band being processed by only one of the vha_ddc instances.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t OUT_RATE : 3;
    ///< This is the sample rate of the data at the output of the vha_ddc.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t UL_OF_ENABLE : 2;
    ///< Set to 1 to enable the output FIFO for the respective uplink band
    ///< of this antenna.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_cfg_reg_t;

#define VHA_ANT_UL_CFG_DEFAULT (0x00000000U)
#define VHA_ANT_UL_CFG_RD_MASK (0x0000037fU)
#define VHA_ANT_UL_CFG_WR_MASK (0x0000037fU)


///< This is the sample rate of the data present in the uplink iinput FIFO.
///< If the dmod is being used, the lowest legal value is VHA_RATE_1. If
///< the dmod is bypassed, however, this can take on any legal rate because
///< it then represents the rate being applied to the vha_ddc.
#define VHA_ANT_UL_CFG_IN_RATE_BF_OFF ( 0)
#define VHA_ANT_UL_CFG_IN_RATE_BF_WID ( 3)
#define VHA_ANT_UL_CFG_IN_RATE_BF_MSK (0x00000007)
#define VHA_ANT_UL_CFG_IN_RATE_BF_DEF (0x00000000)

///< Set to 1 to bypass the VHA DMOD path for uplink. In this mode, there
///< is a single band being processed by only one of the vha_ddc instances.
#define VHA_ANT_UL_CFG_DMOD_BYP_BF_OFF ( 3)
#define VHA_ANT_UL_CFG_DMOD_BYP_BF_WID ( 1)
#define VHA_ANT_UL_CFG_DMOD_BYP_BF_MSK (0x00000008)
#define VHA_ANT_UL_CFG_DMOD_BYP_BF_DEF (0x00000000)

///< This is the sample rate of the data at the output of the vha_ddc.
#define VHA_ANT_UL_CFG_OUT_RATE_BF_OFF ( 4)
#define VHA_ANT_UL_CFG_OUT_RATE_BF_WID ( 3)
#define VHA_ANT_UL_CFG_OUT_RATE_BF_MSK (0x00000070)
#define VHA_ANT_UL_CFG_OUT_RATE_BF_DEF (0x00000000)

///< Set to 1 to enable the output FIFO for the respective uplink band
///< of this antenna.
#define VHA_ANT_UL_CFG_OF_EN_BF_OFF ( 8)
#define VHA_ANT_UL_CFG_OF_EN_BF_WID ( 2)
#define VHA_ANT_UL_CFG_OF_EN_BF_MSK (0x00000300)
#define VHA_ANT_UL_CFG_OF_EN_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_IF_CFG register description at address offset 0x30
  *
  * Register default value:        0x00000800
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_IF_CFG
  * VHA Antenna Uplink Input FIFO Config
  */

typedef union {
  struct {
    uint32_t IF_WM : 9;
    ///< This is the fill level, in words (each word, or flit, is 16 16i,16q
    ///< samples) at which the output can start draining the uplink input fifo.
    ///< Before this FIFO starts to fill, the VHA waits for the associated
    ///< clock-crossing FIFO to fill to its programmed watermark. A programmable
    ///< set of these will determine when the reads start to enable syncing
    ///< the bands and/or antennas in each VHA instance.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CC_IF_WM : 3;
    ///< This is the fill level, in words (each word, or flit, is 16 16i,16q
    ///< samples) to which the VHA fills the clock crossing FIFO. This is programmable
    ///< so that, in low bandwidth use cases, the VHA will not wait to fill
    ///< this whole fifo because that would add too much latency.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x4"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_if_cfg_reg_t;

#define VHA_ANT_UL_IF_CFG_DEFAULT (0x00000800U)
#define VHA_ANT_UL_IF_CFG_RD_MASK (0x00000fffU)
#define VHA_ANT_UL_IF_CFG_WR_MASK (0x00000fffU)


///< This is the fill level, in words (each word, or flit, is 16 16i,16q
///< samples) at which the output can start draining the uplink input fifo.
///< Before this FIFO starts to fill, the VHA waits for the associated
///< clock-crossing FIFO to fill to its programmed watermark. A programmable
///< set of these will determine when the reads start to enable syncing
///< the bands and/or antennas in each VHA instance.
#define VHA_ANT_UL_IF_CFG_WM_BF_OFF ( 0)
#define VHA_ANT_UL_IF_CFG_WM_BF_WID ( 9)
#define VHA_ANT_UL_IF_CFG_WM_BF_MSK (0x000001FF)
#define VHA_ANT_UL_IF_CFG_WM_BF_DEF (0x00000000)

///< This is the fill level, in words (each word, or flit, is 16 16i,16q
///< samples) to which the VHA fills the clock crossing FIFO. This is programmable
///< so that, in low bandwidth use cases, the VHA will not wait to fill
///< this whole fifo because that would add too much latency.
#define VHA_ANT_UL_IF_CFG_CC_WM_BF_OFF ( 9)
#define VHA_ANT_UL_IF_CFG_CC_WM_BF_WID ( 3)
#define VHA_ANT_UL_IF_CFG_CC_WM_BF_MSK (0x00000E00)
#define VHA_ANT_UL_IF_CFG_CC_WM_BF_DEF (0x00000800)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_IF_ECC_CTRL register description at address offset 0x34
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_IF_ECC_CTRL
  * Uplink Input FIFO Memory ECC Control
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< ECC Force Error Type. This bit indicates the type of forced ECC error
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< ECC Force Error. When set to 1, one ECC error is inserted, as determined
    ///< by ECC_FORCE_TYPE. It's automatically cleared when the expected ECC
    ///< error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
    ///< and ECC_ERR_SYNDROME of the correponding memory. This bit retains
    ///< the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
    ///< of the corresponding memory. This bit retains the last written value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< ECC Check and Correction Disable. When set, this bit disables ECC
    ///< checking and correction for the corresponding memory. It's used for
    ///< debug and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< ECC Generation Disable. When set, this bit disables ECC generation
    ///< for the corresponding memory. It's used for debug and testing purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_if_ecc_ctrl_reg_t;

#define VHA_ANT_UL_IF_ECC_CTRL_DEFAULT (0x00000000U)
#define VHA_ANT_UL_IF_ECC_CTRL_RD_MASK (0x0000003fU)
#define VHA_ANT_UL_IF_ECC_CTRL_WR_MASK (0x0000003fU)


///< ECC Force Error Type. This bit indicates the type of forced ECC error
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_TYPE_BF_OFF ( 0)
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_TYPE_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_TYPE_BF_MSK (0x00000001)
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_TYPE_BF_DEF (0x00000000)

///< ECC Force Error. When set to 1, one ECC error is inserted, as determined
///< by ECC_FORCE_TYPE. It's automatically cleared when the expected ECC
///< error is seen by hardware.
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_ERR_BF_OFF ( 1)
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_ERR_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_ERR_BF_MSK (0x00000002)
#define VHA_ANT_UL_IF_ECC_CTRL_FORCE_ERR_BF_DEF (0x00000000)

///< ECC Error Clear. Writing this bit to 1 clears ECC_SBE, ECC_DBE, ECC_ERR_ADDR
///< and ECC_ERR_SYNDROME of the correponding memory. This bit retains
///< the last written value.
#define VHA_ANT_UL_IF_ECC_CTRL_ERR_CLR_BF_OFF ( 2)
#define VHA_ANT_UL_IF_ECC_CTRL_ERR_CLR_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_CTRL_ERR_CLR_BF_MSK (0x00000004)
#define VHA_ANT_UL_IF_ECC_CTRL_ERR_CLR_BF_DEF (0x00000000)

///< ECC Count Clear. Writing this bit to 1 clears ECC_SBE_COUNT and ECC_SBE_CNT_OVFL
///< of the corresponding memory. This bit retains the last written value.
#define VHA_ANT_UL_IF_ECC_CTRL_CNT_CLR_BF_OFF ( 3)
#define VHA_ANT_UL_IF_ECC_CTRL_CNT_CLR_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_CTRL_CNT_CLR_BF_MSK (0x00000008)
#define VHA_ANT_UL_IF_ECC_CTRL_CNT_CLR_BF_DEF (0x00000000)

///< ECC Check and Correction Disable. When set, this bit disables ECC
///< checking and correction for the corresponding memory. It's used for
///< debug and testing purpose.
#define VHA_ANT_UL_IF_ECC_CTRL_CHK_DIS_BF_OFF ( 4)
#define VHA_ANT_UL_IF_ECC_CTRL_CHK_DIS_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_CTRL_CHK_DIS_BF_MSK (0x00000010)
#define VHA_ANT_UL_IF_ECC_CTRL_CHK_DIS_BF_DEF (0x00000000)

///< ECC Generation Disable. When set, this bit disables ECC generation
///< for the corresponding memory. It's used for debug and testing purpose.
#define VHA_ANT_UL_IF_ECC_CTRL_GEN_DIS_BF_OFF ( 5)
#define VHA_ANT_UL_IF_ECC_CTRL_GEN_DIS_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_CTRL_GEN_DIS_BF_MSK (0x00000020)
#define VHA_ANT_UL_IF_ECC_CTRL_GEN_DIS_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_OF_CFG[2] register description at address offset 0x38
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_OF_CFG
  * VHA Antenna Uplink Output FIFO Config
  */

typedef union {
  struct {
    uint32_t DS_N1 : 8;
    ///< When Destination Split is enabled, this is one less than the number
    ///< of bursts the circuitry will send to the first ID assigned to the
    ///< repective FIFO.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DS_N2 : 8;
    ///< When Destination Split is enabled, this one less than is the number
    ///< of bursts the circuitry will send to the second ID assigned to the
    ///< repective FIFO.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DS_ENABLE : 1;
    ///< When this is set to 1, the output FIFO circuitry will send N1+1 bursts
    ///< to the first ID, and N2+1 bursts to the second ID.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_of_cfg_reg_t;

#define VHA_ANT_UL_OF_CFG_DEFAULT (0x00000000U)
#define VHA_ANT_UL_OF_CFG_RD_MASK (0x0001ffffU)
#define VHA_ANT_UL_OF_CFG_WR_MASK (0x0001ffffU)


///< When Destination Split is enabled, this is one less than the number
///< of bursts the circuitry will send to the first ID assigned to the
///< repective FIFO.
#define VHA_ANT_UL_OF_CFG_DS_N1_BF_OFF ( 0)
#define VHA_ANT_UL_OF_CFG_DS_N1_BF_WID ( 8)
#define VHA_ANT_UL_OF_CFG_DS_N1_BF_MSK (0x000000FF)
#define VHA_ANT_UL_OF_CFG_DS_N1_BF_DEF (0x00000000)

///< When Destination Split is enabled, this one less than is the number
///< of bursts the circuitry will send to the second ID assigned to the
///< repective FIFO.
#define VHA_ANT_UL_OF_CFG_DS_N2_BF_OFF ( 8)
#define VHA_ANT_UL_OF_CFG_DS_N2_BF_WID ( 8)
#define VHA_ANT_UL_OF_CFG_DS_N2_BF_MSK (0x0000FF00)
#define VHA_ANT_UL_OF_CFG_DS_N2_BF_DEF (0x00000000)

///< When this is set to 1, the output FIFO circuitry will send N1+1 bursts
///< to the first ID, and N2+1 bursts to the second ID.
#define VHA_ANT_UL_OF_CFG_DS_EN_BF_OFF (16)
#define VHA_ANT_UL_OF_CFG_DS_EN_BF_WID ( 1)
#define VHA_ANT_UL_OF_CFG_DS_EN_BF_MSK (0x00010000)
#define VHA_ANT_UL_OF_CFG_DS_EN_BF_DEF (0x00000000)
#define VHA_ANT_UL_OF_CFG_ARR_SZ0 (2)
#define VHA_ANT_UL_OF_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_INT_STATUS register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_INT_STATUS
  * VHA Antenna Interrupt Status
  */

typedef union {
  struct {
    uint32_t UL_IF_ERROR : 1;
    ///< The Uplink Input FIFO has had an error event. This can be either the
    ///< main FIFO or the clock crossing FIFO. Check appropriate status registers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DL_IF_ERROR : 2;
    ///< The respective Downlink Input FIFO has had an error event. This can
    ///< be either the main FIFO or the clock crossing FIFO. Check appropriate
    ///< status registers.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE : 2;
    ///< The respective Downlink Input FIFO has had a single bit ECC error.
    ///< Check appropriate status register.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t DL_IF_ECC_DBE : 2;
    ///< The respective Downlink Input FIFO has had a double (or greater) bit
    ///< ECC error. Check appropriate status register.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE_CNT_OVFL : 2;
    ///< The respective Downlink Input FIFO SBE counter has overflown. Check
    ///< appropriate status register.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE : 1;
    ///< The Uplink Input FIFO has had a single bit ECC error. Check appropriate
    ///< status register.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t UL_IF_ECC_DBE : 1;
    ///< The Uplink Input FIFO has had a double (or greater) bit ECC error.
    ///< Check appropriate status register.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE_CNT_OVFL : 1;
    ///< The Uplink Input FIFO SBE counter has overflown. Check appropriate
    ///< status register.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t UL_OF_ERROR : 2;
    ///< The respective Uplink Output FIFO has had an error event. Check appropriate
    ///< status register.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t DL_OF_ERROR : 2;
    ///< The respective Downlink Output FIFO has had an error event. Check
    ///< appropriate status register.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t SMON : 1;
    ///< The SMON has had an event. Check SMON registers.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_int_stat_reg_t;

#define VHA_ANT_INT_STAT_DEFAULT (0x00000000U)
#define VHA_ANT_INT_STAT_RD_MASK (0x0001ffffU)
#define VHA_ANT_INT_STAT_WR_MASK (0x00000000U)


///< The Uplink Input FIFO has had an error event. This can be either the
///< main FIFO or the clock crossing FIFO. Check appropriate status registers.
#define VHA_ANT_INT_STAT_UL_IF_ERR_BF_OFF ( 0)
#define VHA_ANT_INT_STAT_UL_IF_ERR_BF_WID ( 1)
#define VHA_ANT_INT_STAT_UL_IF_ERR_BF_MSK (0x00000001)
#define VHA_ANT_INT_STAT_UL_IF_ERR_BF_DEF (0x00000000)

///< The respective Downlink Input FIFO has had an error event. This can
///< be either the main FIFO or the clock crossing FIFO. Check appropriate
///< status registers.
#define VHA_ANT_INT_STAT_DL_IF_ERR_BF_OFF ( 1)
#define VHA_ANT_INT_STAT_DL_IF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_STAT_DL_IF_ERR_BF_MSK (0x00000006)
#define VHA_ANT_INT_STAT_DL_IF_ERR_BF_DEF (0x00000000)

///< The respective Downlink Input FIFO has had a single bit ECC error.
///< Check appropriate status register.
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_BF_OFF ( 3)
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_BF_WID ( 2)
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_BF_MSK (0x00000018)
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_BF_DEF (0x00000000)

///< The respective Downlink Input FIFO has had a double (or greater) bit
///< ECC error. Check appropriate status register.
#define VHA_ANT_INT_STAT_DL_IF_ECC_DBE_BF_OFF ( 5)
#define VHA_ANT_INT_STAT_DL_IF_ECC_DBE_BF_WID ( 2)
#define VHA_ANT_INT_STAT_DL_IF_ECC_DBE_BF_MSK (0x00000060)
#define VHA_ANT_INT_STAT_DL_IF_ECC_DBE_BF_DEF (0x00000000)

///< The respective Downlink Input FIFO SBE counter has overflown. Check
///< appropriate status register.
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_CNT_OVFL_BF_OFF ( 7)
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 2)
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000180)
#define VHA_ANT_INT_STAT_DL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< The Uplink Input FIFO has had a single bit ECC error. Check appropriate
///< status register.
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_BF_OFF ( 9)
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_BF_WID ( 1)
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_BF_MSK (0x00000200)
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_BF_DEF (0x00000000)

///< The Uplink Input FIFO has had a double (or greater) bit ECC error.
///< Check appropriate status register.
#define VHA_ANT_INT_STAT_UL_IF_ECC_DBE_BF_OFF (10)
#define VHA_ANT_INT_STAT_UL_IF_ECC_DBE_BF_WID ( 1)
#define VHA_ANT_INT_STAT_UL_IF_ECC_DBE_BF_MSK (0x00000400)
#define VHA_ANT_INT_STAT_UL_IF_ECC_DBE_BF_DEF (0x00000000)

///< The Uplink Input FIFO SBE counter has overflown. Check appropriate
///< status register.
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_CNT_OVFL_BF_OFF (11)
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000800)
#define VHA_ANT_INT_STAT_UL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< The respective Uplink Output FIFO has had an error event. Check appropriate
///< status register.
#define VHA_ANT_INT_STAT_UL_OF_ERR_BF_OFF (12)
#define VHA_ANT_INT_STAT_UL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_STAT_UL_OF_ERR_BF_MSK (0x00003000)
#define VHA_ANT_INT_STAT_UL_OF_ERR_BF_DEF (0x00000000)

///< The respective Downlink Output FIFO has had an error event. Check
///< appropriate status register.
#define VHA_ANT_INT_STAT_DL_OF_ERR_BF_OFF (14)
#define VHA_ANT_INT_STAT_DL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_STAT_DL_OF_ERR_BF_MSK (0x0000C000)
#define VHA_ANT_INT_STAT_DL_OF_ERR_BF_DEF (0x00000000)

///< The SMON has had an event. Check SMON registers.
#define VHA_ANT_INT_STAT_SMON_BF_OFF (16)
#define VHA_ANT_INT_STAT_SMON_BF_WID ( 1)
#define VHA_ANT_INT_STAT_SMON_BF_MSK (0x00010000)
#define VHA_ANT_INT_STAT_SMON_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_INT_HIGH_EN register description at address offset 0x44
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_INT_HIGH_EN
  * VHA Antenna Interrupt High Enable
  */

typedef union {
  struct {
    uint32_t UL_IF_ERROR : 1;
    ///< Enable the Uplink Input FIFO error interrupt to propagate to the specified
    ///< pin.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DL_IF_ERROR : 2;
    ///< Enable the respective Downlink Input FIFO error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE : 2;
    ///< Enable the respective Downlink Input FIFO single bit error interrupt
    ///< to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DL_IF_ECC_DBE : 2;
    ///< Enable the respective Downlink Input FIFO double bit error interrupt
    ///< to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE_CNT_OVFL : 2;
    ///< Enable the respective Downlink Input FIFO ECC SBE counter overflow
    ///< error interrupt to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE : 1;
    ///< Enable the Uplink Input FIFO single bit error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t UL_IF_ECC_DBE : 1;
    ///< Enable the Uplink Input FIFO double bit error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE_CNT_OVFL : 1;
    ///< Enable the Uplink Input FIFO ECC SBE counter overflow error interrupt
    ///< to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t UL_OF_ERROR : 2;
    ///< Enable the respective Uplink Output FIFO error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DL_OF_ERROR : 2;
    ///< Enable the respective Downlink Output FIFO error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SMON : 1;
    ///< Enable the SMON interrupt to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_int_high_en_reg_t;

#define VHA_ANT_INT_HIGH_EN_DEFAULT (0x00000000U)
#define VHA_ANT_INT_HIGH_EN_RD_MASK (0x0001ffffU)
#define VHA_ANT_INT_HIGH_EN_WR_MASK (0x0001ffffU)


///< Enable the Uplink Input FIFO error interrupt to propagate to the specified
///< pin.
#define VHA_ANT_INT_HIGH_EN_UL_IF_ERR_BF_OFF ( 0)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ERR_BF_WID ( 1)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ERR_BF_MSK (0x00000001)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_HIGH_EN_DL_IF_ERR_BF_OFF ( 1)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ERR_BF_MSK (0x00000006)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO single bit error interrupt
///< to propagate to the specified pin.
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_BF_OFF ( 3)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_BF_WID ( 2)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_BF_MSK (0x00000018)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO double bit error interrupt
///< to propagate to the specified pin.
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_DBE_BF_OFF ( 5)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_DBE_BF_WID ( 2)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_DBE_BF_MSK (0x00000060)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO ECC SBE counter overflow
///< error interrupt to propagate to the specified pin.
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_OFF ( 7)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 2)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000180)
#define VHA_ANT_INT_HIGH_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO single bit error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_BF_OFF ( 9)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_BF_WID ( 1)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_BF_MSK (0x00000200)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO double bit error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_DBE_BF_OFF (10)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_DBE_BF_WID ( 1)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_DBE_BF_MSK (0x00000400)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO ECC SBE counter overflow error interrupt
///< to propagate to the specified pin.
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_OFF (11)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000800)
#define VHA_ANT_INT_HIGH_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Enable the respective Uplink Output FIFO error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_HIGH_EN_UL_OF_ERR_BF_OFF (12)
#define VHA_ANT_INT_HIGH_EN_UL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_HIGH_EN_UL_OF_ERR_BF_MSK (0x00003000)
#define VHA_ANT_INT_HIGH_EN_UL_OF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Output FIFO error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_HIGH_EN_DL_OF_ERR_BF_OFF (14)
#define VHA_ANT_INT_HIGH_EN_DL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_HIGH_EN_DL_OF_ERR_BF_MSK (0x0000C000)
#define VHA_ANT_INT_HIGH_EN_DL_OF_ERR_BF_DEF (0x00000000)

///< Enable the SMON interrupt to propagate to the specified pin.
#define VHA_ANT_INT_HIGH_EN_SMON_BF_OFF (16)
#define VHA_ANT_INT_HIGH_EN_SMON_BF_WID ( 1)
#define VHA_ANT_INT_HIGH_EN_SMON_BF_MSK (0x00010000)
#define VHA_ANT_INT_HIGH_EN_SMON_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_INT_LOW_EN register description at address offset 0x48
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_INT_LOW_EN
  * VHA Antenna Interrupt Low Enable
  */

typedef union {
  struct {
    uint32_t UL_IF_ERROR : 1;
    ///< Enable the Uplink Input FIFO error interrupt to propagate to the specified
    ///< pin.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DL_IF_ERROR : 2;
    ///< Enable the respective Downlink Input FIFO error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE : 2;
    ///< Enable the respective Downlink Input FIFO single bit error interrupt
    ///< to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DL_IF_ECC_DBE : 2;
    ///< Enable the respective Downlink Input FIFO double bit error interrupt
    ///< to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE_CNT_OVFL : 2;
    ///< Enable the respective Downlink Input FIFO ECC SBE counter overflow
    ///< error interrupt to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE : 1;
    ///< Enable the Uplink Input FIFO single bit error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t UL_IF_ECC_DBE : 1;
    ///< Enable the Uplink Input FIFO double bit error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE_CNT_OVFL : 1;
    ///< Enable the Uplink Input FIFO ECC SBE counter overflow error interrupt
    ///< to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t UL_OF_ERROR : 2;
    ///< Enable the respective Uplink Output FIFO error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DL_OF_ERROR : 2;
    ///< Enable the respective Downlink Output FIFO error interrupt to propagate
    ///< to the specified pin.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SMON : 1;
    ///< Enable the SMON interrupt to propagate to the specified pin.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_int_low_en_reg_t;

#define VHA_ANT_INT_LOW_EN_DEFAULT (0x00000000U)
#define VHA_ANT_INT_LOW_EN_RD_MASK (0x0001ffffU)
#define VHA_ANT_INT_LOW_EN_WR_MASK (0x0001ffffU)


///< Enable the Uplink Input FIFO error interrupt to propagate to the specified
///< pin.
#define VHA_ANT_INT_LOW_EN_UL_IF_ERR_BF_OFF ( 0)
#define VHA_ANT_INT_LOW_EN_UL_IF_ERR_BF_WID ( 1)
#define VHA_ANT_INT_LOW_EN_UL_IF_ERR_BF_MSK (0x00000001)
#define VHA_ANT_INT_LOW_EN_UL_IF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_LOW_EN_DL_IF_ERR_BF_OFF ( 1)
#define VHA_ANT_INT_LOW_EN_DL_IF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_LOW_EN_DL_IF_ERR_BF_MSK (0x00000006)
#define VHA_ANT_INT_LOW_EN_DL_IF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO single bit error interrupt
///< to propagate to the specified pin.
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_BF_OFF ( 3)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_BF_WID ( 2)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_BF_MSK (0x00000018)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO double bit error interrupt
///< to propagate to the specified pin.
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_DBE_BF_OFF ( 5)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_DBE_BF_WID ( 2)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_DBE_BF_MSK (0x00000060)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Enable the respective Downlink Input FIFO ECC SBE counter overflow
///< error interrupt to propagate to the specified pin.
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_OFF ( 7)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 2)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000180)
#define VHA_ANT_INT_LOW_EN_DL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO single bit error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_BF_OFF ( 9)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_BF_WID ( 1)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_BF_MSK (0x00000200)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO double bit error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_DBE_BF_OFF (10)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_DBE_BF_WID ( 1)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_DBE_BF_MSK (0x00000400)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Enable the Uplink Input FIFO ECC SBE counter overflow error interrupt
///< to propagate to the specified pin.
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_OFF (11)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000800)
#define VHA_ANT_INT_LOW_EN_UL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Enable the respective Uplink Output FIFO error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_LOW_EN_UL_OF_ERR_BF_OFF (12)
#define VHA_ANT_INT_LOW_EN_UL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_LOW_EN_UL_OF_ERR_BF_MSK (0x00003000)
#define VHA_ANT_INT_LOW_EN_UL_OF_ERR_BF_DEF (0x00000000)

///< Enable the respective Downlink Output FIFO error interrupt to propagate
///< to the specified pin.
#define VHA_ANT_INT_LOW_EN_DL_OF_ERR_BF_OFF (14)
#define VHA_ANT_INT_LOW_EN_DL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_LOW_EN_DL_OF_ERR_BF_MSK (0x0000C000)
#define VHA_ANT_INT_LOW_EN_DL_OF_ERR_BF_DEF (0x00000000)

///< Enable the SMON interrupt to propagate to the specified pin.
#define VHA_ANT_INT_LOW_EN_SMON_BF_OFF (16)
#define VHA_ANT_INT_LOW_EN_SMON_BF_WID ( 1)
#define VHA_ANT_INT_LOW_EN_SMON_BF_MSK (0x00010000)
#define VHA_ANT_INT_LOW_EN_SMON_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_INT_CLEAR register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_INT_CLEAR
  * VHA Antenna Interrupt Clear
  */

typedef union {
  struct {
    uint32_t UL_IF_ERROR : 1;
    ///< Write a 1 to clear the Uplink Input FIFO error interrupt. The value
    ///< can be read back, but there is no need to clear the bit before writing
    ///< again.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DL_IF_ERROR : 2;
    ///< Write a 1 to clear the respective Downlink Input FIFO error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE : 2;
    ///< Write a 1 to clear the respective Downlink Input FIFO single bit error
    ///< interrupt. The value can be read back, but there is no need to clear
    ///< the bit before writing again.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DL_IF_ECC_DBE : 2;
    ///< Write a 1 to clear the respective Downlink Input FIFO double bit error
    ///< interrupt. The value can be read back, but there is no need to clear
    ///< the bit before writing again.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE_CNT_OVFL : 2;
    ///< Write a 1 to clear the respective Downlink Input FIFO ECC SBE counter
    ///< overflow interrupt. The value can be read back, but there is no need
    ///< to clear the bit before writing again.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE : 1;
    ///< Write a 1 to clear the Uplink Input FIFO single bit error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t UL_IF_ECC_DBE : 1;
    ///< Write a 1 to clear the Uplink Input FIFO double bit error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE_CNT_OVFL : 1;
    ///< Write a 1 to clear the Uplink Input FIFO ECC SBE counter overflow
    ///< interrupt. The value can be read back, but there is no need to clear
    ///< the bit before writing again.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t UL_OF_ERROR : 2;
    ///< Write a 1 to clear the respective Uplink Output FIFO error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DL_OF_ERROR : 2;
    ///< Write a 1 to clear the respective Downlink Output FIFO error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SMON : 1;
    ///< Write a 1 to clear the SMON interrupt. The value can be read back,
    ///< but there is no need to clear the bit before writing again.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_int_clr_reg_t;

#define VHA_ANT_INT_CLR_DEFAULT (0x00000000U)
#define VHA_ANT_INT_CLR_RD_MASK (0x0001ffffU)
#define VHA_ANT_INT_CLR_WR_MASK (0x0001ffffU)


///< Write a 1 to clear the Uplink Input FIFO error interrupt. The value
///< can be read back, but there is no need to clear the bit before writing
///< again.
#define VHA_ANT_INT_CLR_UL_IF_ERR_BF_OFF ( 0)
#define VHA_ANT_INT_CLR_UL_IF_ERR_BF_WID ( 1)
#define VHA_ANT_INT_CLR_UL_IF_ERR_BF_MSK (0x00000001)
#define VHA_ANT_INT_CLR_UL_IF_ERR_BF_DEF (0x00000000)

///< Write a 1 to clear the respective Downlink Input FIFO error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_CLR_DL_IF_ERR_BF_OFF ( 1)
#define VHA_ANT_INT_CLR_DL_IF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_CLR_DL_IF_ERR_BF_MSK (0x00000006)
#define VHA_ANT_INT_CLR_DL_IF_ERR_BF_DEF (0x00000000)

///< Write a 1 to clear the respective Downlink Input FIFO single bit error
///< interrupt. The value can be read back, but there is no need to clear
///< the bit before writing again.
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_BF_OFF ( 3)
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_BF_WID ( 2)
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_BF_MSK (0x00000018)
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Write a 1 to clear the respective Downlink Input FIFO double bit error
///< interrupt. The value can be read back, but there is no need to clear
///< the bit before writing again.
#define VHA_ANT_INT_CLR_DL_IF_ECC_DBE_BF_OFF ( 5)
#define VHA_ANT_INT_CLR_DL_IF_ECC_DBE_BF_WID ( 2)
#define VHA_ANT_INT_CLR_DL_IF_ECC_DBE_BF_MSK (0x00000060)
#define VHA_ANT_INT_CLR_DL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Write a 1 to clear the respective Downlink Input FIFO ECC SBE counter
///< overflow interrupt. The value can be read back, but there is no need
///< to clear the bit before writing again.
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_CNT_OVFL_BF_OFF ( 7)
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 2)
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000180)
#define VHA_ANT_INT_CLR_DL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Write a 1 to clear the Uplink Input FIFO single bit error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_BF_OFF ( 9)
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_BF_WID ( 1)
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_BF_MSK (0x00000200)
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Write a 1 to clear the Uplink Input FIFO double bit error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_CLR_UL_IF_ECC_DBE_BF_OFF (10)
#define VHA_ANT_INT_CLR_UL_IF_ECC_DBE_BF_WID ( 1)
#define VHA_ANT_INT_CLR_UL_IF_ECC_DBE_BF_MSK (0x00000400)
#define VHA_ANT_INT_CLR_UL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Write a 1 to clear the Uplink Input FIFO ECC SBE counter overflow
///< interrupt. The value can be read back, but there is no need to clear
///< the bit before writing again.
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_CNT_OVFL_BF_OFF (11)
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000800)
#define VHA_ANT_INT_CLR_UL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Write a 1 to clear the respective Uplink Output FIFO error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_CLR_UL_OF_ERR_BF_OFF (12)
#define VHA_ANT_INT_CLR_UL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_CLR_UL_OF_ERR_BF_MSK (0x00003000)
#define VHA_ANT_INT_CLR_UL_OF_ERR_BF_DEF (0x00000000)

///< Write a 1 to clear the respective Downlink Output FIFO error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_CLR_DL_OF_ERR_BF_OFF (14)
#define VHA_ANT_INT_CLR_DL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_CLR_DL_OF_ERR_BF_MSK (0x0000C000)
#define VHA_ANT_INT_CLR_DL_OF_ERR_BF_DEF (0x00000000)

///< Write a 1 to clear the SMON interrupt. The value can be read back,
///< but there is no need to clear the bit before writing again.
#define VHA_ANT_INT_CLR_SMON_BF_OFF (16)
#define VHA_ANT_INT_CLR_SMON_BF_WID ( 1)
#define VHA_ANT_INT_CLR_SMON_BF_MSK (0x00010000)
#define VHA_ANT_INT_CLR_SMON_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_INT_FORCE register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_INT_FORCE
  * VHA Antenna Interrupt Force
  */

typedef union {
  struct {
    uint32_t UL_IF_ERROR : 1;
    ///< Write a 1 to force high the Uplink Input FIFO error interrupt. The
    ///< value can be read back, but there is no need to clear the bit before
    ///< writing again.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DL_IF_ERROR : 2;
    ///< Write a 1 to force high the respective Downlink Input FIFO error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE : 2;
    ///< Write a 1 to force high the respective Downlink Input FIFO single
    ///< bit error interrupt. The value can be read back, but there is no need
    ///< to clear the bit before writing again.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DL_IF_ECC_DBE : 2;
    ///< Write a 1 to force high the respective Downlink Input FIFO double
    ///< bit error interrupt. The value can be read back, but there is no need
    ///< to clear the bit before writing again.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DL_IF_ECC_SBE_CNT_OVFL : 2;
    ///< Write a 1 to force the respective Downlink Input FIFO ECC SBE counter
    ///< overflow interrupt. The value can be read back, but there is no need
    ///< to clear the bit before writing again.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE : 1;
    ///< Write a 1 to force high the Uplink Input FIFO single bit error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t UL_IF_ECC_DBE : 1;
    ///< Write a 1 to force high the Uplink Input FIFO double bit error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t UL_IF_ECC_SBE_CNT_OVFL : 1;
    ///< Write a 1 to force the Uplink Input FIFO ECC SBE counter overflow
    ///< interrupt. The value can be read back, but there is no need to clear
    ///< the bit before writing again.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t UL_OF_ERROR : 2;
    ///< Write a 1 to force high the respective Uplink Output FIFO error interrupt.
    ///< The value can be read back, but there is no need to clear the bit
    ///< before writing again.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DL_OF_ERROR : 2;
    ///< Write a 1 to force high the respective Downlink Output FIFO error
    ///< interrupt. The value can be read back, but there is no need to clear
    ///< the bit before writing again.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SMON : 1;
    ///< Write a 1 to force high the SMON interrupt. The value can be read
    ///< back, but there is no need to clear the bit before writing again.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_int_force_reg_t;

#define VHA_ANT_INT_FORCE_DEFAULT (0x00000000U)
#define VHA_ANT_INT_FORCE_RD_MASK (0x0001ffffU)
#define VHA_ANT_INT_FORCE_WR_MASK (0x0001ffffU)


///< Write a 1 to force high the Uplink Input FIFO error interrupt. The
///< value can be read back, but there is no need to clear the bit before
///< writing again.
#define VHA_ANT_INT_FORCE_UL_IF_ERR_BF_OFF ( 0)
#define VHA_ANT_INT_FORCE_UL_IF_ERR_BF_WID ( 1)
#define VHA_ANT_INT_FORCE_UL_IF_ERR_BF_MSK (0x00000001)
#define VHA_ANT_INT_FORCE_UL_IF_ERR_BF_DEF (0x00000000)

///< Write a 1 to force high the respective Downlink Input FIFO error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_FORCE_DL_IF_ERR_BF_OFF ( 1)
#define VHA_ANT_INT_FORCE_DL_IF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_FORCE_DL_IF_ERR_BF_MSK (0x00000006)
#define VHA_ANT_INT_FORCE_DL_IF_ERR_BF_DEF (0x00000000)

///< Write a 1 to force high the respective Downlink Input FIFO single
///< bit error interrupt. The value can be read back, but there is no need
///< to clear the bit before writing again.
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_BF_OFF ( 3)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_BF_WID ( 2)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_BF_MSK (0x00000018)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Write a 1 to force high the respective Downlink Input FIFO double
///< bit error interrupt. The value can be read back, but there is no need
///< to clear the bit before writing again.
#define VHA_ANT_INT_FORCE_DL_IF_ECC_DBE_BF_OFF ( 5)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_DBE_BF_WID ( 2)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_DBE_BF_MSK (0x00000060)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Write a 1 to force the respective Downlink Input FIFO ECC SBE counter
///< overflow interrupt. The value can be read back, but there is no need
///< to clear the bit before writing again.
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_CNT_OVFL_BF_OFF ( 7)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 2)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000180)
#define VHA_ANT_INT_FORCE_DL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Write a 1 to force high the Uplink Input FIFO single bit error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_BF_OFF ( 9)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_BF_WID ( 1)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_BF_MSK (0x00000200)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_BF_DEF (0x00000000)

///< Write a 1 to force high the Uplink Input FIFO double bit error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_FORCE_UL_IF_ECC_DBE_BF_OFF (10)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_DBE_BF_WID ( 1)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_DBE_BF_MSK (0x00000400)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_DBE_BF_DEF (0x00000000)

///< Write a 1 to force the Uplink Input FIFO ECC SBE counter overflow
///< interrupt. The value can be read back, but there is no need to clear
///< the bit before writing again.
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_CNT_OVFL_BF_OFF (11)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_CNT_OVFL_BF_MSK (0x00000800)
#define VHA_ANT_INT_FORCE_UL_IF_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Write a 1 to force high the respective Uplink Output FIFO error interrupt.
///< The value can be read back, but there is no need to clear the bit
///< before writing again.
#define VHA_ANT_INT_FORCE_UL_OF_ERR_BF_OFF (12)
#define VHA_ANT_INT_FORCE_UL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_FORCE_UL_OF_ERR_BF_MSK (0x00003000)
#define VHA_ANT_INT_FORCE_UL_OF_ERR_BF_DEF (0x00000000)

///< Write a 1 to force high the respective Downlink Output FIFO error
///< interrupt. The value can be read back, but there is no need to clear
///< the bit before writing again.
#define VHA_ANT_INT_FORCE_DL_OF_ERR_BF_OFF (14)
#define VHA_ANT_INT_FORCE_DL_OF_ERR_BF_WID ( 2)
#define VHA_ANT_INT_FORCE_DL_OF_ERR_BF_MSK (0x0000C000)
#define VHA_ANT_INT_FORCE_DL_OF_ERR_BF_DEF (0x00000000)

///< Write a 1 to force high the SMON interrupt. The value can be read
///< back, but there is no need to clear the bit before writing again.
#define VHA_ANT_INT_FORCE_SMON_BF_OFF (16)
#define VHA_ANT_INT_FORCE_SMON_BF_WID ( 1)
#define VHA_ANT_INT_FORCE_SMON_BF_MSK (0x00010000)
#define VHA_ANT_INT_FORCE_SMON_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_APB_BRIDGE_STATUS register description at address offset 0x54
  *
  * Register default value:        0x00010000
  * Register full path in IP: vha_ant_reg_map/reg/APB_BRIDGE_STATUS
  * VHA APB Bridge Status
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW/L" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW/1S/V/L" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_apb_brdg_stat_reg_t;

#define VHA_ANT_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define VHA_ANT_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define VHA_ANT_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define VHA_ANT_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define VHA_ANT_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define VHA_ANT_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define VHA_ANT_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define VHA_ANT_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define VHA_ANT_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define VHA_ANT_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define VHA_ANT_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define VHA_ANT_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define VHA_ANT_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define VHA_ANT_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define VHA_ANT_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define VHA_ANT_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define VHA_ANT_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define VHA_ANT_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define VHA_ANT_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define VHA_ANT_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_IF_STAT[2] register description at address offset 0x60
  *
  * Register default value:        0x0000000C
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_IF_STAT
  * VHA Antenna Downlink Input FIFO Status
  */

typedef union {
  struct {
    uint32_t UFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t OFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t AEMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t AFULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 8;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_if_stat_reg_t;

#define VHA_ANT_DL_IF_STAT_DEFAULT (0x0000000cU)
#define VHA_ANT_DL_IF_STAT_RD_MASK (0x00003fffU)
#define VHA_ANT_DL_IF_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define VHA_ANT_DL_IF_STAT_UFLOW_BF_OFF ( 0)
#define VHA_ANT_DL_IF_STAT_UFLOW_BF_WID ( 1)
#define VHA_ANT_DL_IF_STAT_UFLOW_BF_MSK (0x00000001)
#define VHA_ANT_DL_IF_STAT_UFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define VHA_ANT_DL_IF_STAT_OFLOW_BF_OFF ( 1)
#define VHA_ANT_DL_IF_STAT_OFLOW_BF_WID ( 1)
#define VHA_ANT_DL_IF_STAT_OFLOW_BF_MSK (0x00000002)
#define VHA_ANT_DL_IF_STAT_OFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define VHA_ANT_DL_IF_STAT_EMPTY_BF_OFF ( 2)
#define VHA_ANT_DL_IF_STAT_EMPTY_BF_WID ( 1)
#define VHA_ANT_DL_IF_STAT_EMPTY_BF_MSK (0x00000004)
#define VHA_ANT_DL_IF_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define VHA_ANT_DL_IF_STAT_AEMPTY_BF_OFF ( 3)
#define VHA_ANT_DL_IF_STAT_AEMPTY_BF_WID ( 1)
#define VHA_ANT_DL_IF_STAT_AEMPTY_BF_MSK (0x00000008)
#define VHA_ANT_DL_IF_STAT_AEMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define VHA_ANT_DL_IF_STAT_AFULL_BF_OFF ( 4)
#define VHA_ANT_DL_IF_STAT_AFULL_BF_WID ( 1)
#define VHA_ANT_DL_IF_STAT_AFULL_BF_MSK (0x00000010)
#define VHA_ANT_DL_IF_STAT_AFULL_BF_DEF (0x00000000)

///< FIFO Full
#define VHA_ANT_DL_IF_STAT_FULL_BF_OFF ( 5)
#define VHA_ANT_DL_IF_STAT_FULL_BF_WID ( 1)
#define VHA_ANT_DL_IF_STAT_FULL_BF_MSK (0x00000020)
#define VHA_ANT_DL_IF_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define VHA_ANT_DL_IF_STAT_DEPTH_BF_OFF ( 6)
#define VHA_ANT_DL_IF_STAT_DEPTH_BF_WID ( 8)
#define VHA_ANT_DL_IF_STAT_DEPTH_BF_MSK (0x00003FC0)
#define VHA_ANT_DL_IF_STAT_DEPTH_BF_DEF (0x00000000)
#define VHA_ANT_DL_IF_STAT_ARR_SZ0 (2)
#define VHA_ANT_DL_IF_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_CC_IF_STAT[2] register description at address offset 0x68
  *
  * Register default value:        0x0000000C
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_CC_IF_STAT
  * VHA Antenna Downlink Input Clock Crossing FIFO Status
  */

typedef union {
  struct {
    uint32_t UFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t OFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t AEMPTY : 1;
    ///< FIFO Almost Empty - Active when at or below 1/2 of the programmed
    ///< watermark
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t AFULL : 1;
    ///< FIFO Almost Full - Active when at or above the programmed watermark
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 3;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_cc_if_stat_reg_t;

#define VHA_ANT_DL_CC_IF_STAT_DEFAULT (0x0000000cU)
#define VHA_ANT_DL_CC_IF_STAT_RD_MASK (0x000001ffU)
#define VHA_ANT_DL_CC_IF_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define VHA_ANT_DL_CC_IF_STAT_UFLOW_BF_OFF ( 0)
#define VHA_ANT_DL_CC_IF_STAT_UFLOW_BF_WID ( 1)
#define VHA_ANT_DL_CC_IF_STAT_UFLOW_BF_MSK (0x00000001)
#define VHA_ANT_DL_CC_IF_STAT_UFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define VHA_ANT_DL_CC_IF_STAT_OFLOW_BF_OFF ( 1)
#define VHA_ANT_DL_CC_IF_STAT_OFLOW_BF_WID ( 1)
#define VHA_ANT_DL_CC_IF_STAT_OFLOW_BF_MSK (0x00000002)
#define VHA_ANT_DL_CC_IF_STAT_OFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define VHA_ANT_DL_CC_IF_STAT_EMPTY_BF_OFF ( 2)
#define VHA_ANT_DL_CC_IF_STAT_EMPTY_BF_WID ( 1)
#define VHA_ANT_DL_CC_IF_STAT_EMPTY_BF_MSK (0x00000004)
#define VHA_ANT_DL_CC_IF_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty - Active when at or below 1/2 of the programmed
///< watermark
#define VHA_ANT_DL_CC_IF_STAT_AEMPTY_BF_OFF ( 3)
#define VHA_ANT_DL_CC_IF_STAT_AEMPTY_BF_WID ( 1)
#define VHA_ANT_DL_CC_IF_STAT_AEMPTY_BF_MSK (0x00000008)
#define VHA_ANT_DL_CC_IF_STAT_AEMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full - Active when at or above the programmed watermark
#define VHA_ANT_DL_CC_IF_STAT_AFULL_BF_OFF ( 4)
#define VHA_ANT_DL_CC_IF_STAT_AFULL_BF_WID ( 1)
#define VHA_ANT_DL_CC_IF_STAT_AFULL_BF_MSK (0x00000010)
#define VHA_ANT_DL_CC_IF_STAT_AFULL_BF_DEF (0x00000000)

///< FIFO Full
#define VHA_ANT_DL_CC_IF_STAT_FULL_BF_OFF ( 5)
#define VHA_ANT_DL_CC_IF_STAT_FULL_BF_WID ( 1)
#define VHA_ANT_DL_CC_IF_STAT_FULL_BF_MSK (0x00000020)
#define VHA_ANT_DL_CC_IF_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define VHA_ANT_DL_CC_IF_STAT_DEPTH_BF_OFF ( 6)
#define VHA_ANT_DL_CC_IF_STAT_DEPTH_BF_WID ( 3)
#define VHA_ANT_DL_CC_IF_STAT_DEPTH_BF_MSK (0x000001C0)
#define VHA_ANT_DL_CC_IF_STAT_DEPTH_BF_DEF (0x00000000)
#define VHA_ANT_DL_CC_IF_STAT_ARR_SZ0 (2)
#define VHA_ANT_DL_CC_IF_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_IF_ECC_STAT register description at address offset 0x70
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_IF_ECC_STAT
  * VHA Antenna Downlink Input FIFO Memory ECC Error Status
  */

typedef union {
  struct {
    uint32_t SBE : 2;
    ///< ECC Single Bit Error. Each bit corresponds to the respective DL_IF_FIFO
    ///< memory, and when high, indicates an ECC single bit error was detected.
    ///< It can be cleared by ECC_ERR_CLR bit in corresponding VHA_ANT_DL_IF_ECC_CTRL
    ///< register. Note that if a DBE has been detected, this bit will not
    ///< be set until after that error is cleared.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 2;
    ///< ECC Double/Multi Bit Error. Each bit corresponds to the respective
    ///< DL_IF_FIFO memory, and when high, indicates an ECC double/multi bit
    ///< error was detected. It can be cleared by ECC_ERR_CLR bit in corresponding
    ///< VHA_ANT_DL_IF_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 2;
    ///< ECC SBE Count Overflow. Each bit corresponds to the respective DL_IF_FIFO
    ///< memory, and when high, indicates the ECC_SBE_COUNT[3:0] is overflowed.
    ///< It can be cleared by ECC_CNT_CLR bit in corresponding VHA_ANT_DL_IF_ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_if_ecc_stat_reg_t;

#define VHA_ANT_DL_IF_ECC_STAT_DEFAULT (0x00000000U)
#define VHA_ANT_DL_IF_ECC_STAT_RD_MASK (0x0000003fU)
#define VHA_ANT_DL_IF_ECC_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. Each bit corresponds to the respective DL_IF_FIFO
///< memory, and when high, indicates an ECC single bit error was detected.
///< It can be cleared by ECC_ERR_CLR bit in corresponding VHA_ANT_DL_IF_ECC_CTRL
///< register. Note that if a DBE has been detected, this bit will not
///< be set until after that error is cleared.
#define VHA_ANT_DL_IF_ECC_STAT_SBE_BF_OFF ( 0)
#define VHA_ANT_DL_IF_ECC_STAT_SBE_BF_WID ( 2)
#define VHA_ANT_DL_IF_ECC_STAT_SBE_BF_MSK (0x00000003)
#define VHA_ANT_DL_IF_ECC_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. Each bit corresponds to the respective
///< DL_IF_FIFO memory, and when high, indicates an ECC double/multi bit
///< error was detected. It can be cleared by ECC_ERR_CLR bit in corresponding
///< VHA_ANT_DL_IF_ECC_CTRL register.
#define VHA_ANT_DL_IF_ECC_STAT_DBE_BF_OFF ( 2)
#define VHA_ANT_DL_IF_ECC_STAT_DBE_BF_WID ( 2)
#define VHA_ANT_DL_IF_ECC_STAT_DBE_BF_MSK (0x0000000C)
#define VHA_ANT_DL_IF_ECC_STAT_DBE_BF_DEF (0x00000000)

///< ECC SBE Count Overflow. Each bit corresponds to the respective DL_IF_FIFO
///< memory, and when high, indicates the ECC_SBE_COUNT[3:0] is overflowed.
///< It can be cleared by ECC_CNT_CLR bit in corresponding VHA_ANT_DL_IF_ECC_CTRL
///< register.
#define VHA_ANT_DL_IF_ECC_STAT_SBE_CNT_OVFL_BF_OFF ( 4)
#define VHA_ANT_DL_IF_ECC_STAT_SBE_CNT_OVFL_BF_WID ( 2)
#define VHA_ANT_DL_IF_ECC_STAT_SBE_CNT_OVFL_BF_MSK (0x00000030)
#define VHA_ANT_DL_IF_ECC_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_IF_ECC_INFO[2] register description at address offset 0x78
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_IF_ECC_INFO
  * VHA Antenna Downlink Input FIFO Memory ECC Error Info
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 8;
    ///< ECC Error Address. This is the captured memory address of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE address. It can be cleared by ECC_ERR_CLR bit in the corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ERR_SYNDROME : 11;
    ///< ECC Error Syndrome. This is the captured ECC syndrome of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE syndrome. It can be cleared by ECC_ERR_CLR bit in the corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t SBE_COUNT : 4;
    ///< ECC SBE Count. This is the value of the SBE counter, which doesn't
    ///< roll over and can be cleared by ECC_CNT_CLR bit in the corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_if_ecc_info_reg_t;

#define VHA_ANT_DL_IF_ECC_INFO_DEFAULT (0x00000000U)
#define VHA_ANT_DL_IF_ECC_INFO_RD_MASK (0x007fffffU)
#define VHA_ANT_DL_IF_ECC_INFO_WR_MASK (0x00000000U)


///< ECC Error Address. This is the captured memory address of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE address. It can be cleared by ECC_ERR_CLR bit in the corresponding
///< ECC_CTRL register.
#define VHA_ANT_DL_IF_ECC_INFO_ERR_ADDR_BF_OFF ( 0)
#define VHA_ANT_DL_IF_ECC_INFO_ERR_ADDR_BF_WID ( 8)
#define VHA_ANT_DL_IF_ECC_INFO_ERR_ADDR_BF_MSK (0x000000FF)
#define VHA_ANT_DL_IF_ECC_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< ECC Error Syndrome. This is the captured ECC syndrome of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE syndrome. It can be cleared by ECC_ERR_CLR bit in the corresponding
///< ECC_CTRL register.
#define VHA_ANT_DL_IF_ECC_INFO_ERR_SYNDROME_BF_OFF ( 8)
#define VHA_ANT_DL_IF_ECC_INFO_ERR_SYNDROME_BF_WID (11)
#define VHA_ANT_DL_IF_ECC_INFO_ERR_SYNDROME_BF_MSK (0x0007FF00)
#define VHA_ANT_DL_IF_ECC_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< ECC SBE Count. This is the value of the SBE counter, which doesn't
///< roll over and can be cleared by ECC_CNT_CLR bit in the corresponding
///< ECC_CTRL register.
#define VHA_ANT_DL_IF_ECC_INFO_SBE_CNT_BF_OFF (19)
#define VHA_ANT_DL_IF_ECC_INFO_SBE_CNT_BF_WID ( 4)
#define VHA_ANT_DL_IF_ECC_INFO_SBE_CNT_BF_MSK (0x00780000)
#define VHA_ANT_DL_IF_ECC_INFO_SBE_CNT_BF_DEF (0x00000000)
#define VHA_ANT_DL_IF_ECC_INFO_ARR_SZ0 (2)
#define VHA_ANT_DL_IF_ECC_INFO_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_OF_STAT[2] register description at address offset 0x80
  *
  * Register default value:        0x0000000C
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_OF_STAT
  * VHA Antenna Downlink Output FIFO Status
  */

typedef union {
  struct {
    uint32_t UFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t OFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t AEMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t AFULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 5;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_dl_of_stat_reg_t;

#define VHA_ANT_DL_OF_STAT_DEFAULT (0x0000000cU)
#define VHA_ANT_DL_OF_STAT_RD_MASK (0x000007ffU)
#define VHA_ANT_DL_OF_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define VHA_ANT_DL_OF_STAT_UFLOW_BF_OFF ( 0)
#define VHA_ANT_DL_OF_STAT_UFLOW_BF_WID ( 1)
#define VHA_ANT_DL_OF_STAT_UFLOW_BF_MSK (0x00000001)
#define VHA_ANT_DL_OF_STAT_UFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define VHA_ANT_DL_OF_STAT_OFLOW_BF_OFF ( 1)
#define VHA_ANT_DL_OF_STAT_OFLOW_BF_WID ( 1)
#define VHA_ANT_DL_OF_STAT_OFLOW_BF_MSK (0x00000002)
#define VHA_ANT_DL_OF_STAT_OFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define VHA_ANT_DL_OF_STAT_EMPTY_BF_OFF ( 2)
#define VHA_ANT_DL_OF_STAT_EMPTY_BF_WID ( 1)
#define VHA_ANT_DL_OF_STAT_EMPTY_BF_MSK (0x00000004)
#define VHA_ANT_DL_OF_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define VHA_ANT_DL_OF_STAT_AEMPTY_BF_OFF ( 3)
#define VHA_ANT_DL_OF_STAT_AEMPTY_BF_WID ( 1)
#define VHA_ANT_DL_OF_STAT_AEMPTY_BF_MSK (0x00000008)
#define VHA_ANT_DL_OF_STAT_AEMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define VHA_ANT_DL_OF_STAT_AFULL_BF_OFF ( 4)
#define VHA_ANT_DL_OF_STAT_AFULL_BF_WID ( 1)
#define VHA_ANT_DL_OF_STAT_AFULL_BF_MSK (0x00000010)
#define VHA_ANT_DL_OF_STAT_AFULL_BF_DEF (0x00000000)

///< FIFO Full
#define VHA_ANT_DL_OF_STAT_FULL_BF_OFF ( 5)
#define VHA_ANT_DL_OF_STAT_FULL_BF_WID ( 1)
#define VHA_ANT_DL_OF_STAT_FULL_BF_MSK (0x00000020)
#define VHA_ANT_DL_OF_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define VHA_ANT_DL_OF_STAT_DEPTH_BF_OFF ( 6)
#define VHA_ANT_DL_OF_STAT_DEPTH_BF_WID ( 5)
#define VHA_ANT_DL_OF_STAT_DEPTH_BF_MSK (0x000007C0)
#define VHA_ANT_DL_OF_STAT_DEPTH_BF_DEF (0x00000000)
#define VHA_ANT_DL_OF_STAT_ARR_SZ0 (2)
#define VHA_ANT_DL_OF_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_IF_STAT register description at address offset 0x88
  *
  * Register default value:        0x0000000C
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_IF_STAT
  * VHA Antenna Uplink Input FIFO Status
  */

typedef union {
  struct {
    uint32_t UFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t OFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t AEMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t AFULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 9;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_if_stat_reg_t;

#define VHA_ANT_UL_IF_STAT_DEFAULT (0x0000000cU)
#define VHA_ANT_UL_IF_STAT_RD_MASK (0x00007fffU)
#define VHA_ANT_UL_IF_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define VHA_ANT_UL_IF_STAT_UFLOW_BF_OFF ( 0)
#define VHA_ANT_UL_IF_STAT_UFLOW_BF_WID ( 1)
#define VHA_ANT_UL_IF_STAT_UFLOW_BF_MSK (0x00000001)
#define VHA_ANT_UL_IF_STAT_UFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define VHA_ANT_UL_IF_STAT_OFLOW_BF_OFF ( 1)
#define VHA_ANT_UL_IF_STAT_OFLOW_BF_WID ( 1)
#define VHA_ANT_UL_IF_STAT_OFLOW_BF_MSK (0x00000002)
#define VHA_ANT_UL_IF_STAT_OFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define VHA_ANT_UL_IF_STAT_EMPTY_BF_OFF ( 2)
#define VHA_ANT_UL_IF_STAT_EMPTY_BF_WID ( 1)
#define VHA_ANT_UL_IF_STAT_EMPTY_BF_MSK (0x00000004)
#define VHA_ANT_UL_IF_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define VHA_ANT_UL_IF_STAT_AEMPTY_BF_OFF ( 3)
#define VHA_ANT_UL_IF_STAT_AEMPTY_BF_WID ( 1)
#define VHA_ANT_UL_IF_STAT_AEMPTY_BF_MSK (0x00000008)
#define VHA_ANT_UL_IF_STAT_AEMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define VHA_ANT_UL_IF_STAT_AFULL_BF_OFF ( 4)
#define VHA_ANT_UL_IF_STAT_AFULL_BF_WID ( 1)
#define VHA_ANT_UL_IF_STAT_AFULL_BF_MSK (0x00000010)
#define VHA_ANT_UL_IF_STAT_AFULL_BF_DEF (0x00000000)

///< FIFO Full
#define VHA_ANT_UL_IF_STAT_FULL_BF_OFF ( 5)
#define VHA_ANT_UL_IF_STAT_FULL_BF_WID ( 1)
#define VHA_ANT_UL_IF_STAT_FULL_BF_MSK (0x00000020)
#define VHA_ANT_UL_IF_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define VHA_ANT_UL_IF_STAT_DEPTH_BF_OFF ( 6)
#define VHA_ANT_UL_IF_STAT_DEPTH_BF_WID ( 9)
#define VHA_ANT_UL_IF_STAT_DEPTH_BF_MSK (0x00007FC0)
#define VHA_ANT_UL_IF_STAT_DEPTH_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_CC_IF_STAT register description at address offset 0x8c
  *
  * Register default value:        0x0000000C
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_CC_IF_STAT
  * VHA Antenna Uplink Clock Crossing Input FIFO Status
  */

typedef union {
  struct {
    uint32_t UFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t OFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t AEMPTY : 1;
    ///< FIFO Almost Empty - Active when at or below 1/2 of the programmed
    ///< watermark
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t AFULL : 1;
    ///< FIFO Almost Full - Active when at or above the programmed watermark
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 3;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 23;
    ///< Reserved
    ///< AccessType="RO" BitOffset="9" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_cc_if_stat_reg_t;

#define VHA_ANT_UL_CC_IF_STAT_DEFAULT (0x0000000cU)
#define VHA_ANT_UL_CC_IF_STAT_RD_MASK (0x000001ffU)
#define VHA_ANT_UL_CC_IF_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define VHA_ANT_UL_CC_IF_STAT_UFLOW_BF_OFF ( 0)
#define VHA_ANT_UL_CC_IF_STAT_UFLOW_BF_WID ( 1)
#define VHA_ANT_UL_CC_IF_STAT_UFLOW_BF_MSK (0x00000001)
#define VHA_ANT_UL_CC_IF_STAT_UFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define VHA_ANT_UL_CC_IF_STAT_OFLOW_BF_OFF ( 1)
#define VHA_ANT_UL_CC_IF_STAT_OFLOW_BF_WID ( 1)
#define VHA_ANT_UL_CC_IF_STAT_OFLOW_BF_MSK (0x00000002)
#define VHA_ANT_UL_CC_IF_STAT_OFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define VHA_ANT_UL_CC_IF_STAT_EMPTY_BF_OFF ( 2)
#define VHA_ANT_UL_CC_IF_STAT_EMPTY_BF_WID ( 1)
#define VHA_ANT_UL_CC_IF_STAT_EMPTY_BF_MSK (0x00000004)
#define VHA_ANT_UL_CC_IF_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty - Active when at or below 1/2 of the programmed
///< watermark
#define VHA_ANT_UL_CC_IF_STAT_AEMPTY_BF_OFF ( 3)
#define VHA_ANT_UL_CC_IF_STAT_AEMPTY_BF_WID ( 1)
#define VHA_ANT_UL_CC_IF_STAT_AEMPTY_BF_MSK (0x00000008)
#define VHA_ANT_UL_CC_IF_STAT_AEMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full - Active when at or above the programmed watermark
#define VHA_ANT_UL_CC_IF_STAT_AFULL_BF_OFF ( 4)
#define VHA_ANT_UL_CC_IF_STAT_AFULL_BF_WID ( 1)
#define VHA_ANT_UL_CC_IF_STAT_AFULL_BF_MSK (0x00000010)
#define VHA_ANT_UL_CC_IF_STAT_AFULL_BF_DEF (0x00000000)

///< FIFO Full
#define VHA_ANT_UL_CC_IF_STAT_FULL_BF_OFF ( 5)
#define VHA_ANT_UL_CC_IF_STAT_FULL_BF_WID ( 1)
#define VHA_ANT_UL_CC_IF_STAT_FULL_BF_MSK (0x00000020)
#define VHA_ANT_UL_CC_IF_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define VHA_ANT_UL_CC_IF_STAT_DEPTH_BF_OFF ( 6)
#define VHA_ANT_UL_CC_IF_STAT_DEPTH_BF_WID ( 3)
#define VHA_ANT_UL_CC_IF_STAT_DEPTH_BF_MSK (0x000001C0)
#define VHA_ANT_UL_CC_IF_STAT_DEPTH_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_IF_ECC_STAT register description at address offset 0x90
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_IF_ECC_STAT
  * VHA Antenna Uplink Input FIFO Memory ECC Error Status
  */

typedef union {
  struct {
    uint32_t SBE : 1;
    ///< ECC Single Bit Error. When high, indicates an ECC single bit error
    ///< was detected in the UL memory, and can be cleared by ECC_ERR_CLR bit
    ///< in corresponding VHA_ANT_UL_IF_ECC_CTRL register. Note that if a DBE
    ///< has been detected, this bit will not be set until after that error
    ///< is cleared.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 1;
    ///< ECC Double/Multi Bit Error. When high, indicates an ECC double/multi
    ///< bit error was detected in the UL memory, and can be cleared by ECC_ERR_CLR
    ///< bit in corresponding VHA_ANT_UL_IF_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 1;
    ///< ECC SBE Count Overflow. When high, indicates the ECC_SBE_COUNT[3:0]
    ///< for the UL memory has overflowed. It can be cleared by ECC_CNT_CLR
    ///< bit in corresponding VHA_ANT_UL_IF_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_if_ecc_stat_reg_t;

#define VHA_ANT_UL_IF_ECC_STAT_DEFAULT (0x00000000U)
#define VHA_ANT_UL_IF_ECC_STAT_RD_MASK (0x00000007U)
#define VHA_ANT_UL_IF_ECC_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. When high, indicates an ECC single bit error
///< was detected in the UL memory, and can be cleared by ECC_ERR_CLR bit
///< in corresponding VHA_ANT_UL_IF_ECC_CTRL register. Note that if a DBE
///< has been detected, this bit will not be set until after that error
///< is cleared.
#define VHA_ANT_UL_IF_ECC_STAT_SBE_BF_OFF ( 0)
#define VHA_ANT_UL_IF_ECC_STAT_SBE_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_STAT_SBE_BF_MSK (0x00000001)
#define VHA_ANT_UL_IF_ECC_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. When high, indicates an ECC double/multi
///< bit error was detected in the UL memory, and can be cleared by ECC_ERR_CLR
///< bit in corresponding VHA_ANT_UL_IF_ECC_CTRL register.
#define VHA_ANT_UL_IF_ECC_STAT_DBE_BF_OFF ( 1)
#define VHA_ANT_UL_IF_ECC_STAT_DBE_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_STAT_DBE_BF_MSK (0x00000002)
#define VHA_ANT_UL_IF_ECC_STAT_DBE_BF_DEF (0x00000000)

///< ECC SBE Count Overflow. When high, indicates the ECC_SBE_COUNT[3:0]
///< for the UL memory has overflowed. It can be cleared by ECC_CNT_CLR
///< bit in corresponding VHA_ANT_UL_IF_ECC_CTRL register.
#define VHA_ANT_UL_IF_ECC_STAT_SBE_CNT_OVFL_BF_OFF ( 2)
#define VHA_ANT_UL_IF_ECC_STAT_SBE_CNT_OVFL_BF_WID ( 1)
#define VHA_ANT_UL_IF_ECC_STAT_SBE_CNT_OVFL_BF_MSK (0x00000004)
#define VHA_ANT_UL_IF_ECC_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_IF_ECC_INFO register description at address offset 0x94
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_IF_ECC_INFO
  * VHA Antenna Uplink Input FIFO Memory ECC Error Info
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 9;
    ///< ECC Error Address. This is the captured memory address of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE address. It can be cleared by ECC_ERR_CLR bit in the corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t ERR_SYNDROME : 11;
    ///< ECC Error Syndrome. This is the captured ECC syndrome of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE syndrome. It can be cleared by ECC_ERR_CLR bit in the corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t SBE_COUNT : 4;
    ///< ECC SBE Count. This is the value of the SBE counter, which doesn't
    ///< roll over and can be cleared by ECC_CNT_CLR bit in the corresponding
    ///< ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_if_ecc_info_reg_t;

#define VHA_ANT_UL_IF_ECC_INFO_DEFAULT (0x00000000U)
#define VHA_ANT_UL_IF_ECC_INFO_RD_MASK (0x00ffffffU)
#define VHA_ANT_UL_IF_ECC_INFO_WR_MASK (0x00000000U)


///< ECC Error Address. This is the captured memory address of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE address. It can be cleared by ECC_ERR_CLR bit in the corresponding
///< ECC_CTRL register.
#define VHA_ANT_UL_IF_ECC_INFO_ERR_ADDR_BF_OFF ( 0)
#define VHA_ANT_UL_IF_ECC_INFO_ERR_ADDR_BF_WID ( 9)
#define VHA_ANT_UL_IF_ECC_INFO_ERR_ADDR_BF_MSK (0x000001FF)
#define VHA_ANT_UL_IF_ECC_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< ECC Error Syndrome. This is the captured ECC syndrome of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE syndrome. It can be cleared by ECC_ERR_CLR bit in the corresponding
///< ECC_CTRL register.
#define VHA_ANT_UL_IF_ECC_INFO_ERR_SYNDROME_BF_OFF ( 9)
#define VHA_ANT_UL_IF_ECC_INFO_ERR_SYNDROME_BF_WID (11)
#define VHA_ANT_UL_IF_ECC_INFO_ERR_SYNDROME_BF_MSK (0x000FFE00)
#define VHA_ANT_UL_IF_ECC_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< ECC SBE Count. This is the value of the SBE counter, which doesn't
///< roll over and can be cleared by ECC_CNT_CLR bit in the corresponding
///< ECC_CTRL register.
#define VHA_ANT_UL_IF_ECC_INFO_SBE_CNT_BF_OFF (20)
#define VHA_ANT_UL_IF_ECC_INFO_SBE_CNT_BF_WID ( 4)
#define VHA_ANT_UL_IF_ECC_INFO_SBE_CNT_BF_MSK (0x00F00000)
#define VHA_ANT_UL_IF_ECC_INFO_SBE_CNT_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_OF_STAT[2] register description at address offset 0x98
  *
  * Register default value:        0x0000000C
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_OF_STAT
  * VHA Antenna Uplink Output FIFO Status
  */

typedef union {
  struct {
    uint32_t UFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t OFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t AEMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t AFULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 5;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_ul_of_stat_reg_t;

#define VHA_ANT_UL_OF_STAT_DEFAULT (0x0000000cU)
#define VHA_ANT_UL_OF_STAT_RD_MASK (0x000007ffU)
#define VHA_ANT_UL_OF_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define VHA_ANT_UL_OF_STAT_UFLOW_BF_OFF ( 0)
#define VHA_ANT_UL_OF_STAT_UFLOW_BF_WID ( 1)
#define VHA_ANT_UL_OF_STAT_UFLOW_BF_MSK (0x00000001)
#define VHA_ANT_UL_OF_STAT_UFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define VHA_ANT_UL_OF_STAT_OFLOW_BF_OFF ( 1)
#define VHA_ANT_UL_OF_STAT_OFLOW_BF_WID ( 1)
#define VHA_ANT_UL_OF_STAT_OFLOW_BF_MSK (0x00000002)
#define VHA_ANT_UL_OF_STAT_OFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define VHA_ANT_UL_OF_STAT_EMPTY_BF_OFF ( 2)
#define VHA_ANT_UL_OF_STAT_EMPTY_BF_WID ( 1)
#define VHA_ANT_UL_OF_STAT_EMPTY_BF_MSK (0x00000004)
#define VHA_ANT_UL_OF_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define VHA_ANT_UL_OF_STAT_AEMPTY_BF_OFF ( 3)
#define VHA_ANT_UL_OF_STAT_AEMPTY_BF_WID ( 1)
#define VHA_ANT_UL_OF_STAT_AEMPTY_BF_MSK (0x00000008)
#define VHA_ANT_UL_OF_STAT_AEMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define VHA_ANT_UL_OF_STAT_AFULL_BF_OFF ( 4)
#define VHA_ANT_UL_OF_STAT_AFULL_BF_WID ( 1)
#define VHA_ANT_UL_OF_STAT_AFULL_BF_MSK (0x00000010)
#define VHA_ANT_UL_OF_STAT_AFULL_BF_DEF (0x00000000)

///< FIFO Full
#define VHA_ANT_UL_OF_STAT_FULL_BF_OFF ( 5)
#define VHA_ANT_UL_OF_STAT_FULL_BF_WID ( 1)
#define VHA_ANT_UL_OF_STAT_FULL_BF_MSK (0x00000020)
#define VHA_ANT_UL_OF_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define VHA_ANT_UL_OF_STAT_DEPTH_BF_OFF ( 6)
#define VHA_ANT_UL_OF_STAT_DEPTH_BF_WID ( 5)
#define VHA_ANT_UL_OF_STAT_DEPTH_BF_MSK (0x000007C0)
#define VHA_ANT_UL_OF_STAT_DEPTH_BF_DEF (0x00000000)
#define VHA_ANT_UL_OF_STAT_ARR_SZ0 (2)
#define VHA_ANT_UL_OF_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_DL_ARB_CNT[2] register description at address offset 0xa0
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_DL_ARB_CNT
  * VHA Antenna Downlink Arbitration Count
  */

typedef union {
  struct {
    uint32_t CNT : 32;
    ///< This shows the most recent winner of the arbitration. Note that this
    ///< will be changing frequently in operation, as it is only a single snapshot.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_dl_arb_cnt_reg_t;

#define VHA_ANT_DL_ARB_CNT_DEFAULT (0x00000000U)
#define VHA_ANT_DL_ARB_CNT_RD_MASK (0xffffffffU)
#define VHA_ANT_DL_ARB_CNT_WR_MASK (0x00000000U)


///< This shows the most recent winner of the arbitration. Note that this
///< will be changing frequently in operation, as it is only a single snapshot.
#define VHA_ANT_DL_ARB_CNT_BF_OFF ( 0)
#define VHA_ANT_DL_ARB_CNT_BF_WID (32)
#define VHA_ANT_DL_ARB_CNT_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_DL_ARB_CNT_BF_DEF (0x00000000)
#define VHA_ANT_DL_ARB_CNT_ARR_SZ0 (2)
#define VHA_ANT_DL_ARB_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_UL_ARB_CNT[2] register description at address offset 0xa8
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_UL_ARB_CNT
  * VHA Antenna Uplink Arbitration Count
  */

typedef union {
  struct {
    uint32_t CNT : 32;
    ///< This shows the most recent winner of the arbitration. Note that this
    ///< will be changing frequently in operation, as it is only a single snapshot.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_ul_arb_cnt_reg_t;

#define VHA_ANT_UL_ARB_CNT_DEFAULT (0x00000000U)
#define VHA_ANT_UL_ARB_CNT_RD_MASK (0xffffffffU)
#define VHA_ANT_UL_ARB_CNT_WR_MASK (0x00000000U)


///< This shows the most recent winner of the arbitration. Note that this
///< will be changing frequently in operation, as it is only a single snapshot.
#define VHA_ANT_UL_ARB_CNT_BF_OFF ( 0)
#define VHA_ANT_UL_ARB_CNT_BF_WID (32)
#define VHA_ANT_UL_ARB_CNT_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_UL_ARB_CNT_BF_DEF (0x00000000)
#define VHA_ANT_UL_ARB_CNT_ARR_SZ0 (2)
#define VHA_ANT_UL_ARB_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief VHA_ANT_REG_MAP_REG_VHA_ANT_ARB_STAT register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/VHA_ANT_ARB_STAT
  * VHA Antenna Arbiter Status
  */

typedef union {
  struct {
    uint32_t WINNER : 2;
    ///< This shows the most recent winner of the arbitration. Note that this
    ///< will be changing frequently in operation, as it is only a single snapshot.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} vha_ant_arb_stat_reg_t;

#define VHA_ANT_ARB_STAT_DEFAULT (0x00000000U)
#define VHA_ANT_ARB_STAT_RD_MASK (0x00000003U)
#define VHA_ANT_ARB_STAT_WR_MASK (0x00000000U)


///< This shows the most recent winner of the arbitration. Note that this
///< will be changing frequently in operation, as it is only a single snapshot.
#define VHA_ANT_ARB_STAT_WINNER_BF_OFF ( 0)
#define VHA_ANT_ARB_STAT_WINNER_BF_WID ( 2)
#define VHA_ANT_ARB_STAT_WINNER_BF_MSK (0x00000003)
#define VHA_ANT_ARB_STAT_WINNER_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R0 register description at address offset 0xc0
  *
  * Register default value:        0x40000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r0
  * AW_smon CONTROL0 register
  */

typedef union {
  struct {
    uint32_t SMON_ENABLE : 1;
    ///< enable the SMON counters
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t RSVD0 : 3;
    ///< reserved
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SMON0_FUNCTION : 3;
    ///< SMON0 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SMON0_FUNCTION_COMPARE : 1;
    ///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t SMON1_FUNCTION : 3;
    ///< SMON1 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t SMON1_FUNCTION_COMPARE : 1;
    ///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t SMON_MODE : 4;
    ///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
    ///< independantly as their function is configured.       4'h1 = Average
    ///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
    ///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
    ///< values. For multiple stop for a single start, accumulate  start_to_stop1,
    ///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
    ///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
    ///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
    ///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
    ///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
    ///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
    ///< the first start_to_stop1 if there are multiple stop for each start.
    ///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
    ///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
    ///< stop for each start.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t STOPCOUNTEROVFL : 1;
    ///< configure to stop on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INTCOUNTEROVFL : 1;
    ///< configure to interupt on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t STATCOUNTER0OVFL : 1;
    ///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
    ///< AccessType="RW/V" BitOffset="18" ResetValue="0x0"
    uint32_t STATCOUNTER1OVFL : 1;
    ///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
    ///< AccessType="RW/V" BitOffset="19" ResetValue="0x0"
    uint32_t STOPTIMEROVFL : 1;
    ///< configure to stop on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t INTTIMEROVFL : 1;
    ///< configure to interrupt on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t STATTIMEROVFL : 1;
    ///< status of timer overflow. A value of '1' signifies timer overflow,
    ///< or timer>maxvalue.
    ///< AccessType="RW/V" BitOffset="22" ResetValue="0x0"
    uint32_t RSVD1 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t TIMER_PRESCALE : 5;
    ///< timer prescale    5'h00 = mode00, increment timer every      1 clock
    ///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
    ///< increment timer every      4 clocks    5'h03 = mode03, increment timer
    ///< every      8 clocks    5'h04 = mode04, increment timer every     16
    ///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
    ///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
    ///< timer every    128 clocks    5'h08 = mode08, increment timer every
    ///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
    ///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
    ///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
    ///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
    ///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
    ///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
    ///< timer every  65536 clocks    5'h11 = mode17, increment timer every
    ///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
    ///< 5'h13 = mode19, increment timer every 524288 clocks
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t RSVD2 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t VERSION : 2;
    ///< version
    ///< AccessType="RO" BitOffset="30" ResetValue="0x1"
  } ;
  uint32_t value;
} vha_ant_smon_r0_reg_t;

#define VHA_ANT_SMON_R0_DEFAULT (0x40000000U)
#define VHA_ANT_SMON_R0_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R0_WR_MASK (0x3fffffffU)


///< enable the SMON counters
#define VHA_ANT_SMON_R0_EN_BF_OFF ( 0)
#define VHA_ANT_SMON_R0_EN_BF_WID ( 1)
#define VHA_ANT_SMON_R0_EN_BF_MSK (0x00000001)
#define VHA_ANT_SMON_R0_EN_BF_DEF (0x00000000)

///< reserved
#define VHA_ANT_SMON_R0_RSVD0_BF_OFF ( 1)
#define VHA_ANT_SMON_R0_RSVD0_BF_WID ( 3)
#define VHA_ANT_SMON_R0_RSVD0_BF_MSK (0x0000000E)
#define VHA_ANT_SMON_R0_RSVD0_BF_DEF (0x00000000)

///< SMON0 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_BF_OFF ( 4)
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_BF_WID ( 3)
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_BF_MSK (0x00000070)
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_BF_DEF (0x00000000)

///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_CMP_BF_OFF ( 7)
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_CMP_BF_WID ( 1)
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_CMP_BF_MSK (0x00000080)
#define VHA_ANT_SMON_R0_SMON0_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON1 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_BF_OFF ( 8)
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_BF_WID ( 3)
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_BF_MSK (0x00000700)
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_BF_DEF (0x00000000)

///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_CMP_BF_OFF (11)
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_CMP_BF_WID ( 1)
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_CMP_BF_MSK (0x00000800)
#define VHA_ANT_SMON_R0_SMON1_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
///< independantly as their function is configured.       4'h1 = Average
///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
///< values. For multiple stop for a single start, accumulate  start_to_stop1,
///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
///< the first start_to_stop1 if there are multiple stop for each start.
///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
///< stop for each start.
#define VHA_ANT_SMON_R0_MODE_BF_OFF (12)
#define VHA_ANT_SMON_R0_MODE_BF_WID ( 4)
#define VHA_ANT_SMON_R0_MODE_BF_MSK (0x0000F000)
#define VHA_ANT_SMON_R0_MODE_BF_DEF (0x00000000)

///< configure to stop on counter0 or counter1 overflow
#define VHA_ANT_SMON_R0_STOPCNTEROVFL_BF_OFF (16)
#define VHA_ANT_SMON_R0_STOPCNTEROVFL_BF_WID ( 1)
#define VHA_ANT_SMON_R0_STOPCNTEROVFL_BF_MSK (0x00010000)
#define VHA_ANT_SMON_R0_STOPCNTEROVFL_BF_DEF (0x00000000)

///< configure to interupt on counter0 or counter1 overflow
#define VHA_ANT_SMON_R0_INTCNTEROVFL_BF_OFF (17)
#define VHA_ANT_SMON_R0_INTCNTEROVFL_BF_WID ( 1)
#define VHA_ANT_SMON_R0_INTCNTEROVFL_BF_MSK (0x00020000)
#define VHA_ANT_SMON_R0_INTCNTEROVFL_BF_DEF (0x00000000)

///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
#define VHA_ANT_SMON_R0_STATCNTER0OVFL_BF_OFF (18)
#define VHA_ANT_SMON_R0_STATCNTER0OVFL_BF_WID ( 1)
#define VHA_ANT_SMON_R0_STATCNTER0OVFL_BF_MSK (0x00040000)
#define VHA_ANT_SMON_R0_STATCNTER0OVFL_BF_DEF (0x00000000)

///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
#define VHA_ANT_SMON_R0_STATCNTER1OVFL_BF_OFF (19)
#define VHA_ANT_SMON_R0_STATCNTER1OVFL_BF_WID ( 1)
#define VHA_ANT_SMON_R0_STATCNTER1OVFL_BF_MSK (0x00080000)
#define VHA_ANT_SMON_R0_STATCNTER1OVFL_BF_DEF (0x00000000)

///< configure to stop on timer overflow or timer>maxvalue
#define VHA_ANT_SMON_R0_STOPTIMEROVFL_BF_OFF (20)
#define VHA_ANT_SMON_R0_STOPTIMEROVFL_BF_WID ( 1)
#define VHA_ANT_SMON_R0_STOPTIMEROVFL_BF_MSK (0x00100000)
#define VHA_ANT_SMON_R0_STOPTIMEROVFL_BF_DEF (0x00000000)

///< configure to interrupt on timer overflow or timer>maxvalue
#define VHA_ANT_SMON_R0_INTTIMEROVFL_BF_OFF (21)
#define VHA_ANT_SMON_R0_INTTIMEROVFL_BF_WID ( 1)
#define VHA_ANT_SMON_R0_INTTIMEROVFL_BF_MSK (0x00200000)
#define VHA_ANT_SMON_R0_INTTIMEROVFL_BF_DEF (0x00000000)

///< status of timer overflow. A value of '1' signifies timer overflow,
///< or timer>maxvalue.
#define VHA_ANT_SMON_R0_STATTIMEROVFL_BF_OFF (22)
#define VHA_ANT_SMON_R0_STATTIMEROVFL_BF_WID ( 1)
#define VHA_ANT_SMON_R0_STATTIMEROVFL_BF_MSK (0x00400000)
#define VHA_ANT_SMON_R0_STATTIMEROVFL_BF_DEF (0x00000000)

///< reserved
#define VHA_ANT_SMON_R0_RSVD1_BF_OFF (23)
#define VHA_ANT_SMON_R0_RSVD1_BF_WID ( 1)
#define VHA_ANT_SMON_R0_RSVD1_BF_MSK (0x00800000)
#define VHA_ANT_SMON_R0_RSVD1_BF_DEF (0x00000000)

///< timer prescale    5'h00 = mode00, increment timer every      1 clock
///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
///< increment timer every      4 clocks    5'h03 = mode03, increment timer
///< every      8 clocks    5'h04 = mode04, increment timer every     16
///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
///< timer every    128 clocks    5'h08 = mode08, increment timer every
///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
///< timer every  65536 clocks    5'h11 = mode17, increment timer every
///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
///< 5'h13 = mode19, increment timer every 524288 clocks
#define VHA_ANT_SMON_R0_TIMER_PRESCALE_BF_OFF (24)
#define VHA_ANT_SMON_R0_TIMER_PRESCALE_BF_WID ( 5)
#define VHA_ANT_SMON_R0_TIMER_PRESCALE_BF_MSK (0x1F000000)
#define VHA_ANT_SMON_R0_TIMER_PRESCALE_BF_DEF (0x00000000)

///< reserved
#define VHA_ANT_SMON_R0_RSVD2_BF_OFF (29)
#define VHA_ANT_SMON_R0_RSVD2_BF_WID ( 1)
#define VHA_ANT_SMON_R0_RSVD2_BF_MSK (0x20000000)
#define VHA_ANT_SMON_R0_RSVD2_BF_DEF (0x00000000)

///< version
#define VHA_ANT_SMON_R0_VER_BF_OFF (30)
#define VHA_ANT_SMON_R0_VER_BF_WID ( 2)
#define VHA_ANT_SMON_R0_VER_BF_MSK (0xC0000000)
#define VHA_ANT_SMON_R0_VER_BF_DEF (0x40000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R1 register description at address offset 0xc4
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r1
  * AW_smon CONTROL1 register
  */

typedef union {
  struct {
    uint32_t MODE0 : 8;
    ///< select input signal for SMON0 engine. <br/> 23 modes supported:<br/>
    ///< 0: reg core write, Comparison= offset, Value= wdata<br/>   1: reg
    ///< core read, Comparison= offset, Value= rdata<br/>   2: ul_if_push,
    ///< Comparison= nsip_pop_data.index, nsip_empty, ul_if_full, Value= nsip_pop_data.data[31:0]<br/>
    ///< 3: dl_if_push[0], Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0],
    ///< Value= nsip_pop_data.data[31:0]<br/>   4: dl_if_push[1], Comparison=
    ///< nsip_pop_data.index, nsip_empty, dl_if_full[1], Value= nsip_pop_data.data[31:0]<br/>
    ///< 5: i_ul_enable, Comparison= nsip_pop_data.index, nsip_empty, ul_if_full,
    ///< Value= ~ul_if_depth<br/>   6: i_ul_enable, Comparison= nsip_pop_data.index,
    ///< nsip_empty, ul_if_full, Value= ul_if_depth<br/>   7: i_dl_enable[0],
    ///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0], Value=
    ///< ~dl_if_depth[0]<br/>   8: i_dl_enable[0], Comparison= nsip_pop_data.index,
    ///< nsip_empty, dl_if_full[0], Value= dl_if_depth[0]<br/>   9: i_dl_enable[1],
    ///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[1], Value=
    ///< ~dl_if_depth[1]<br/>  10: i_dl_enable[1], Comparison= nsip_pop_data.index,
    ///< nsip_empty, dl_if_full[1], Value= dl_if_depth[1]<br/>  11: ul_of_cfg[0].enable,
    ///< Comparison= nsip_afull, nsip_afull_all, Value= ~ul_of_depth[0]<br/>
    ///< 12: ul_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
    ///< ul_of_depth[0]<br/>  13: ul_of_cfg[1].enable, Comparison= nsip_afull,
    ///< nsip_afull_all, Value= ~ul_of_depth[1]<br/>         14: ul_of_cfg[1].enable,
    ///< Comparison= nsip_afull, nsip_afull_all, Value= ul_of_depth[1]<br/>
    ///< 15: dl_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
    ///< ~dl_of_depth[0]<br/>         16: dl_of_cfg[0].enable, Comparison=
    ///< nsip_afull, nsip_afull_all, Value= dl_of_depth[0]<br/>  17: dl_of_cfg[1].enable,
    ///< Comparison= nsip_afull, nsip_afull_all, Value= ~dl_of_depth[1]<br/>
    ///< 18: dl_of_cfg[1].enable, Comparison= nsip_afull, nsip_afull_all, Value=
    ///< dl_of_depth[1]<br/>         19: ul_of_valid[0], Comparison= ul_of_ack[0],nsip_afull,
    ///< nsip_afull_all, Value= 0<br/>  20: ul_of_valid[1], Comparison= ul_of_ack[1],nsip_afull,
    ///< nsip_afull_all, Value= 0<br/>         21: dl_of_valid[0], Comparison=
    ///< dl_of_ack[0],nsip_afull, nsip_afull_all, Value= 0<br/>  22: dl_of_valid[1],
    ///< Comparison= dl_of_ack[1],nsip_afull, nsip_afull_all, Value= 0
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MODE1 : 8;
    ///< select input signal for SMON1 engine. <br/> 23 modes supported:<br/>
    ///< 0: reg core write, Comparison= offset, Value= wdata<br/>   1: reg
    ///< core read, Comparison= offset, Value= rdata<br/>   2: ul_if_push,
    ///< Comparison= nsip_pop_data.index, nsip_empty, ul_if_full, Value= nsip_pop_data.data[31:0]<br/>
    ///< 3: dl_if_push[0], Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0],
    ///< Value= nsip_pop_data.data[31:0]<br/>   4: dl_if_push[1], Comparison=
    ///< nsip_pop_data.index, nsip_empty, dl_if_full[1], Value= nsip_pop_data.data[31:0]<br/>
    ///< 5: i_ul_enable, Comparison= nsip_pop_data.index, nsip_empty, ul_if_full,
    ///< Value= ~ul_if_depth<br/>   6: i_ul_enable, Comparison= nsip_pop_data.index,
    ///< nsip_empty, ul_if_full, Value= ul_if_depth<br/>   7: i_dl_enable[0],
    ///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0], Value=
    ///< ~dl_if_depth[0]<br/>   8: i_dl_enable[0], Comparison= nsip_pop_data.index,
    ///< nsip_empty, dl_if_full[0], Value= dl_if_depth[0]<br/>   9: i_dl_enable[1],
    ///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[1], Value=
    ///< ~dl_if_depth[1]<br/>  10: i_dl_enable[1], Comparison= nsip_pop_data.index,
    ///< nsip_empty, dl_if_full[1], Value= dl_if_depth[1]<br/>  11: ul_of_cfg[0].enable,
    ///< Comparison= nsip_afull, nsip_afull_all, Value= ~ul_of_depth[0]<br/>
    ///< 12: ul_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
    ///< ul_of_depth[0]<br/>  13: ul_of_cfg[1].enable, Comparison= nsip_afull,
    ///< nsip_afull_all, Value= ~ul_of_depth[1]<br/>         14: ul_of_cfg[1].enable,
    ///< Comparison= nsip_afull, nsip_afull_all, Value= ul_of_depth[1]<br/>
    ///< 15: dl_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
    ///< ~dl_of_depth[0]<br/>         16: dl_of_cfg[0].enable, Comparison=
    ///< nsip_afull, nsip_afull_all, Value= dl_of_depth[0]<br/>  17: dl_of_cfg[1].enable,
    ///< Comparison= nsip_afull, nsip_afull_all, Value= ~dl_of_depth[1]<br/>
    ///< 18: dl_of_cfg[1].enable, Comparison= nsip_afull, nsip_afull_all, Value=
    ///< dl_of_depth[1]<br/>         19: ul_of_valid[0], Comparison= ul_of_ack[0],nsip_afull,
    ///< nsip_afull_all, Value= 0<br/>  20: ul_of_valid[1], Comparison= ul_of_ack[1],nsip_afull,
    ///< nsip_afull_all, Value= 0<br/>         21: dl_of_valid[0], Comparison=
    ///< dl_of_ack[0],nsip_afull, nsip_afull_all, Value= 0<br/>  22: dl_of_valid[1],
    ///< Comparison= dl_of_ack[1],nsip_afull, nsip_afull_all, Value= 0
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t RSVD : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_smon_r1_reg_t;

#define VHA_ANT_SMON_R1_DEFAULT (0x00000000U)
#define VHA_ANT_SMON_R1_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R1_WR_MASK (0xffffffffU)


///< select input signal for SMON0 engine. <br/> 23 modes supported:<br/>
///< 0: reg core write, Comparison= offset, Value= wdata<br/>   1: reg
///< core read, Comparison= offset, Value= rdata<br/>   2: ul_if_push,
///< Comparison= nsip_pop_data.index, nsip_empty, ul_if_full, Value= nsip_pop_data.data[31:0]<br/>
///< 3: dl_if_push[0], Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0],
///< Value= nsip_pop_data.data[31:0]<br/>   4: dl_if_push[1], Comparison=
///< nsip_pop_data.index, nsip_empty, dl_if_full[1], Value= nsip_pop_data.data[31:0]<br/>
///< 5: i_ul_enable, Comparison= nsip_pop_data.index, nsip_empty, ul_if_full,
///< Value= ~ul_if_depth<br/>   6: i_ul_enable, Comparison= nsip_pop_data.index,
///< nsip_empty, ul_if_full, Value= ul_if_depth<br/>   7: i_dl_enable[0],
///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0], Value=
///< ~dl_if_depth[0]<br/>   8: i_dl_enable[0], Comparison= nsip_pop_data.index,
///< nsip_empty, dl_if_full[0], Value= dl_if_depth[0]<br/>   9: i_dl_enable[1],
///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[1], Value=
///< ~dl_if_depth[1]<br/>  10: i_dl_enable[1], Comparison= nsip_pop_data.index,
///< nsip_empty, dl_if_full[1], Value= dl_if_depth[1]<br/>  11: ul_of_cfg[0].enable,
///< Comparison= nsip_afull, nsip_afull_all, Value= ~ul_of_depth[0]<br/>
///< 12: ul_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
///< ul_of_depth[0]<br/>  13: ul_of_cfg[1].enable, Comparison= nsip_afull,
///< nsip_afull_all, Value= ~ul_of_depth[1]<br/>         14: ul_of_cfg[1].enable,
///< Comparison= nsip_afull, nsip_afull_all, Value= ul_of_depth[1]<br/>
///< 15: dl_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
///< ~dl_of_depth[0]<br/>         16: dl_of_cfg[0].enable, Comparison=
///< nsip_afull, nsip_afull_all, Value= dl_of_depth[0]<br/>  17: dl_of_cfg[1].enable,
///< Comparison= nsip_afull, nsip_afull_all, Value= ~dl_of_depth[1]<br/>
///< 18: dl_of_cfg[1].enable, Comparison= nsip_afull, nsip_afull_all, Value=
///< dl_of_depth[1]<br/>         19: ul_of_valid[0], Comparison= ul_of_ack[0],nsip_afull,
///< nsip_afull_all, Value= 0<br/>  20: ul_of_valid[1], Comparison= ul_of_ack[1],nsip_afull,
///< nsip_afull_all, Value= 0<br/>         21: dl_of_valid[0], Comparison=
///< dl_of_ack[0],nsip_afull, nsip_afull_all, Value= 0<br/>  22: dl_of_valid[1],
///< Comparison= dl_of_ack[1],nsip_afull, nsip_afull_all, Value= 0
#define VHA_ANT_SMON_R1_MODE0_BF_OFF ( 0)
#define VHA_ANT_SMON_R1_MODE0_BF_WID ( 8)
#define VHA_ANT_SMON_R1_MODE0_BF_MSK (0x000000FF)
#define VHA_ANT_SMON_R1_MODE0_BF_DEF (0x00000000)

///< select input signal for SMON1 engine. <br/> 23 modes supported:<br/>
///< 0: reg core write, Comparison= offset, Value= wdata<br/>   1: reg
///< core read, Comparison= offset, Value= rdata<br/>   2: ul_if_push,
///< Comparison= nsip_pop_data.index, nsip_empty, ul_if_full, Value= nsip_pop_data.data[31:0]<br/>
///< 3: dl_if_push[0], Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0],
///< Value= nsip_pop_data.data[31:0]<br/>   4: dl_if_push[1], Comparison=
///< nsip_pop_data.index, nsip_empty, dl_if_full[1], Value= nsip_pop_data.data[31:0]<br/>
///< 5: i_ul_enable, Comparison= nsip_pop_data.index, nsip_empty, ul_if_full,
///< Value= ~ul_if_depth<br/>   6: i_ul_enable, Comparison= nsip_pop_data.index,
///< nsip_empty, ul_if_full, Value= ul_if_depth<br/>   7: i_dl_enable[0],
///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[0], Value=
///< ~dl_if_depth[0]<br/>   8: i_dl_enable[0], Comparison= nsip_pop_data.index,
///< nsip_empty, dl_if_full[0], Value= dl_if_depth[0]<br/>   9: i_dl_enable[1],
///< Comparison= nsip_pop_data.index, nsip_empty, dl_if_full[1], Value=
///< ~dl_if_depth[1]<br/>  10: i_dl_enable[1], Comparison= nsip_pop_data.index,
///< nsip_empty, dl_if_full[1], Value= dl_if_depth[1]<br/>  11: ul_of_cfg[0].enable,
///< Comparison= nsip_afull, nsip_afull_all, Value= ~ul_of_depth[0]<br/>
///< 12: ul_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
///< ul_of_depth[0]<br/>  13: ul_of_cfg[1].enable, Comparison= nsip_afull,
///< nsip_afull_all, Value= ~ul_of_depth[1]<br/>         14: ul_of_cfg[1].enable,
///< Comparison= nsip_afull, nsip_afull_all, Value= ul_of_depth[1]<br/>
///< 15: dl_of_cfg[0].enable, Comparison= nsip_afull, nsip_afull_all, Value=
///< ~dl_of_depth[0]<br/>         16: dl_of_cfg[0].enable, Comparison=
///< nsip_afull, nsip_afull_all, Value= dl_of_depth[0]<br/>  17: dl_of_cfg[1].enable,
///< Comparison= nsip_afull, nsip_afull_all, Value= ~dl_of_depth[1]<br/>
///< 18: dl_of_cfg[1].enable, Comparison= nsip_afull, nsip_afull_all, Value=
///< dl_of_depth[1]<br/>         19: ul_of_valid[0], Comparison= ul_of_ack[0],nsip_afull,
///< nsip_afull_all, Value= 0<br/>  20: ul_of_valid[1], Comparison= ul_of_ack[1],nsip_afull,
///< nsip_afull_all, Value= 0<br/>         21: dl_of_valid[0], Comparison=
///< dl_of_ack[0],nsip_afull, nsip_afull_all, Value= 0<br/>  22: dl_of_valid[1],
///< Comparison= dl_of_ack[1],nsip_afull, nsip_afull_all, Value= 0
#define VHA_ANT_SMON_R1_MODE1_BF_OFF ( 8)
#define VHA_ANT_SMON_R1_MODE1_BF_WID ( 8)
#define VHA_ANT_SMON_R1_MODE1_BF_MSK (0x0000FF00)
#define VHA_ANT_SMON_R1_MODE1_BF_DEF (0x00000000)

///< reserved
#define VHA_ANT_SMON_R1_RSVD_BF_OFF (16)
#define VHA_ANT_SMON_R1_RSVD_BF_WID (16)
#define VHA_ANT_SMON_R1_RSVD_BF_MSK (0xFFFF0000)
#define VHA_ANT_SMON_R1_RSVD_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R2 register description at address offset 0xc8
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r2
  * AW_smon SMON0_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE0 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_smon_r2_reg_t;

#define VHA_ANT_SMON_R2_DEFAULT (0x00000000U)
#define VHA_ANT_SMON_R2_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R2_WR_MASK (0xffffffffU)


///< Comparison value.
#define VHA_ANT_SMON_R2_CMP0_BF_OFF ( 0)
#define VHA_ANT_SMON_R2_CMP0_BF_WID (32)
#define VHA_ANT_SMON_R2_CMP0_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_SMON_R2_CMP0_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R3 register description at address offset 0xcc
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r3
  * AW_smon SMON1_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE1 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_smon_r3_reg_t;

#define VHA_ANT_SMON_R3_DEFAULT (0x00000000U)
#define VHA_ANT_SMON_R3_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R3_WR_MASK (0xffffffffU)


///< Comparison value.
#define VHA_ANT_SMON_R3_CMP1_BF_OFF ( 0)
#define VHA_ANT_SMON_R3_CMP1_BF_WID (32)
#define VHA_ANT_SMON_R3_CMP1_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_SMON_R3_CMP1_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R4 register description at address offset 0xd0
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r4
  * AW_smon SMON0_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER0 : 32;
    ///< counter0
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_smon_r4_reg_t;

#define VHA_ANT_SMON_R4_DEFAULT (0x00000000U)
#define VHA_ANT_SMON_R4_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R4_WR_MASK (0xffffffffU)


///< counter0
#define VHA_ANT_SMON_R4_CNTER0_BF_OFF ( 0)
#define VHA_ANT_SMON_R4_CNTER0_BF_WID (32)
#define VHA_ANT_SMON_R4_CNTER0_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_SMON_R4_CNTER0_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R5 register description at address offset 0xd4
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r5
  * AW_smon SMON1_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER1 : 32;
    ///< counter1
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_smon_r5_reg_t;

#define VHA_ANT_SMON_R5_DEFAULT (0x00000000U)
#define VHA_ANT_SMON_R5_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R5_WR_MASK (0xffffffffU)


///< counter1
#define VHA_ANT_SMON_R5_CNTER1_BF_OFF ( 0)
#define VHA_ANT_SMON_R5_CNTER1_BF_WID (32)
#define VHA_ANT_SMON_R5_CNTER1_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_SMON_R5_CNTER1_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R6 register description at address offset 0xd8
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r6
  * AW_smon TIMER register
  */

typedef union {
  struct {
    uint32_t TIMER : 32;
    ///< timer
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_smon_r6_reg_t;

#define VHA_ANT_SMON_R6_DEFAULT (0x00000000U)
#define VHA_ANT_SMON_R6_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R6_WR_MASK (0xffffffffU)


///< timer
#define VHA_ANT_SMON_R6_TIMER_BF_OFF ( 0)
#define VHA_ANT_SMON_R6_TIMER_BF_WID (32)
#define VHA_ANT_SMON_R6_TIMER_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_SMON_R6_TIMER_BF_DEF (0x00000000)


/** @brief VHA_ANT_REG_MAP_REG_SMON_MAP_SMON_R7 register description at address offset 0xdc
  *
  * Register default value:        0x00000000
  * Register full path in IP: vha_ant_reg_map/reg/SMON_MAP/SMON_r7
  * AW_smon TIMERMAXVAL register
  */

typedef union {
  struct {
    uint32_t MAXVALUE : 32;
    ///< maxvalue
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} vha_ant_smon_r7_reg_t;

#define VHA_ANT_SMON_R7_DEFAULT (0x00000000U)
#define VHA_ANT_SMON_R7_RD_MASK (0xffffffffU)
#define VHA_ANT_SMON_R7_WR_MASK (0xffffffffU)


///< maxvalue
#define VHA_ANT_SMON_R7_MAXVAL_BF_OFF ( 0)
#define VHA_ANT_SMON_R7_MAXVAL_BF_WID (32)
#define VHA_ANT_SMON_R7_MAXVAL_BF_MSK (0xFFFFFFFF)
#define VHA_ANT_SMON_R7_MAXVAL_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define VHA_ANT_SCRATCH_REG(_BASE) ((vha_ant_scratch_reg_t*) VHA_ANT_SCRATCH_ADR(_BASE))
#define VHA_ANT_CFG_REG(_BASE) ((vha_ant_cfg_reg_t*) VHA_ANT_CFG_ADR(_BASE))
#define VHA_ANT_DL_CFG_REG(_BASE) ((vha_ant_dl_cfg_reg_t*) VHA_ANT_DL_CFG_ADR(_BASE))
#define VHA_ANT_TX_ALARM_EN_REG(_BASE) ((vha_ant_tx_alarm_en_reg_t*) VHA_ANT_TX_ALARM_EN_ADR(_BASE))
#define VHA_ANT_DL_IF_CFG0_REG(_BASE) ((vha_ant_dl_if_cfg_reg_t*) VHA_ANT_DL_IF_CFG0_ADR(_BASE))
#define VHA_ANT_DL_IF_CFG1_REG(_BASE) ((vha_ant_dl_if_cfg_reg_t*) VHA_ANT_DL_IF_CFG1_ADR(_BASE))
#define VHA_ANT_DL_OF_CFG0_REG(_BASE) ((vha_ant_dl_of_cfg_reg_t*) VHA_ANT_DL_OF_CFG0_ADR(_BASE))
#define VHA_ANT_DL_OF_CFG1_REG(_BASE) ((vha_ant_dl_of_cfg_reg_t*) VHA_ANT_DL_OF_CFG1_ADR(_BASE))
#define VHA_ANT_DL_IF_ECC_CTRL0_REG(_BASE) ((vha_ant_dl_if_ecc_ctrl_reg_t*) VHA_ANT_DL_IF_ECC_CTRL0_ADR(_BASE))
#define VHA_ANT_DL_IF_ECC_CTRL1_REG(_BASE) ((vha_ant_dl_if_ecc_ctrl_reg_t*) VHA_ANT_DL_IF_ECC_CTRL1_ADR(_BASE))
#define VHA_ANT_ARB_CFG_REG(_BASE) ((vha_ant_arb_cfg_reg_t*) VHA_ANT_ARB_CFG_ADR(_BASE))
#define VHA_ANT_UL_CFG_REG(_BASE) ((vha_ant_ul_cfg_reg_t*) VHA_ANT_UL_CFG_ADR(_BASE))
#define VHA_ANT_UL_IF_CFG_REG(_BASE) ((vha_ant_ul_if_cfg_reg_t*) VHA_ANT_UL_IF_CFG_ADR(_BASE))
#define VHA_ANT_UL_IF_ECC_CTRL_REG(_BASE) ((vha_ant_ul_if_ecc_ctrl_reg_t*) VHA_ANT_UL_IF_ECC_CTRL_ADR(_BASE))
#define VHA_ANT_UL_OF_CFG0_REG(_BASE) ((vha_ant_ul_of_cfg_reg_t*) VHA_ANT_UL_OF_CFG0_ADR(_BASE))
#define VHA_ANT_UL_OF_CFG1_REG(_BASE) ((vha_ant_ul_of_cfg_reg_t*) VHA_ANT_UL_OF_CFG1_ADR(_BASE))
#define VHA_ANT_INT_STAT_REG(_BASE) ((vha_ant_int_stat_reg_t*) VHA_ANT_INT_STAT_ADR(_BASE))
#define VHA_ANT_INT_HIGH_EN_REG(_BASE) ((vha_ant_int_high_en_reg_t*) VHA_ANT_INT_HIGH_EN_ADR(_BASE))
#define VHA_ANT_INT_LOW_EN_REG(_BASE) ((vha_ant_int_low_en_reg_t*) VHA_ANT_INT_LOW_EN_ADR(_BASE))
#define VHA_ANT_INT_CLR_REG(_BASE) ((vha_ant_int_clr_reg_t*) VHA_ANT_INT_CLR_ADR(_BASE))
#define VHA_ANT_INT_FORCE_REG(_BASE) ((vha_ant_int_force_reg_t*) VHA_ANT_INT_FORCE_ADR(_BASE))
#define VHA_ANT_APB_BRDG_STAT_REG(_BASE) ((vha_ant_apb_brdg_stat_reg_t*) VHA_ANT_APB_BRDG_STAT_ADR(_BASE))
#define VHA_ANT_DL_IF_STAT0_REG(_BASE) ((vha_ant_dl_if_stat_reg_t*) VHA_ANT_DL_IF_STAT0_ADR(_BASE))
#define VHA_ANT_DL_IF_STAT1_REG(_BASE) ((vha_ant_dl_if_stat_reg_t*) VHA_ANT_DL_IF_STAT1_ADR(_BASE))
#define VHA_ANT_DL_CC_IF_STAT0_REG(_BASE) ((vha_ant_dl_cc_if_stat_reg_t*) VHA_ANT_DL_CC_IF_STAT0_ADR(_BASE))
#define VHA_ANT_DL_CC_IF_STAT1_REG(_BASE) ((vha_ant_dl_cc_if_stat_reg_t*) VHA_ANT_DL_CC_IF_STAT1_ADR(_BASE))
#define VHA_ANT_DL_IF_ECC_STAT_REG(_BASE) ((vha_ant_dl_if_ecc_stat_reg_t*) VHA_ANT_DL_IF_ECC_STAT_ADR(_BASE))
#define VHA_ANT_DL_IF_ECC_INFO0_REG(_BASE) ((vha_ant_dl_if_ecc_info_reg_t*) VHA_ANT_DL_IF_ECC_INFO0_ADR(_BASE))
#define VHA_ANT_DL_IF_ECC_INFO1_REG(_BASE) ((vha_ant_dl_if_ecc_info_reg_t*) VHA_ANT_DL_IF_ECC_INFO1_ADR(_BASE))
#define VHA_ANT_DL_OF_STAT0_REG(_BASE) ((vha_ant_dl_of_stat_reg_t*) VHA_ANT_DL_OF_STAT0_ADR(_BASE))
#define VHA_ANT_DL_OF_STAT1_REG(_BASE) ((vha_ant_dl_of_stat_reg_t*) VHA_ANT_DL_OF_STAT1_ADR(_BASE))
#define VHA_ANT_UL_IF_STAT_REG(_BASE) ((vha_ant_ul_if_stat_reg_t*) VHA_ANT_UL_IF_STAT_ADR(_BASE))
#define VHA_ANT_UL_CC_IF_STAT_REG(_BASE) ((vha_ant_ul_cc_if_stat_reg_t*) VHA_ANT_UL_CC_IF_STAT_ADR(_BASE))
#define VHA_ANT_UL_IF_ECC_STAT_REG(_BASE) ((vha_ant_ul_if_ecc_stat_reg_t*) VHA_ANT_UL_IF_ECC_STAT_ADR(_BASE))
#define VHA_ANT_UL_IF_ECC_INFO_REG(_BASE) ((vha_ant_ul_if_ecc_info_reg_t*) VHA_ANT_UL_IF_ECC_INFO_ADR(_BASE))
#define VHA_ANT_UL_OF_STAT0_REG(_BASE) ((vha_ant_ul_of_stat_reg_t*) VHA_ANT_UL_OF_STAT0_ADR(_BASE))
#define VHA_ANT_UL_OF_STAT1_REG(_BASE) ((vha_ant_ul_of_stat_reg_t*) VHA_ANT_UL_OF_STAT1_ADR(_BASE))
#define VHA_ANT_DL_ARB_CNT0_REG(_BASE) ((vha_ant_dl_arb_cnt_reg_t*) VHA_ANT_DL_ARB_CNT0_ADR(_BASE))
#define VHA_ANT_DL_ARB_CNT1_REG(_BASE) ((vha_ant_dl_arb_cnt_reg_t*) VHA_ANT_DL_ARB_CNT1_ADR(_BASE))
#define VHA_ANT_UL_ARB_CNT0_REG(_BASE) ((vha_ant_ul_arb_cnt_reg_t*) VHA_ANT_UL_ARB_CNT0_ADR(_BASE))
#define VHA_ANT_UL_ARB_CNT1_REG(_BASE) ((vha_ant_ul_arb_cnt_reg_t*) VHA_ANT_UL_ARB_CNT1_ADR(_BASE))
#define VHA_ANT_ARB_STAT_REG(_BASE) ((vha_ant_arb_stat_reg_t*) VHA_ANT_ARB_STAT_ADR(_BASE))
#define VHA_ANT_SMON_R0_REG(_BASE) ((vha_ant_smon_r0_reg_t*) VHA_ANT_SMON_R0_ADR(_BASE))
#define VHA_ANT_SMON_R1_REG(_BASE) ((vha_ant_smon_r1_reg_t*) VHA_ANT_SMON_R1_ADR(_BASE))
#define VHA_ANT_SMON_R2_REG(_BASE) ((vha_ant_smon_r2_reg_t*) VHA_ANT_SMON_R2_ADR(_BASE))
#define VHA_ANT_SMON_R3_REG(_BASE) ((vha_ant_smon_r3_reg_t*) VHA_ANT_SMON_R3_ADR(_BASE))
#define VHA_ANT_SMON_R4_REG(_BASE) ((vha_ant_smon_r4_reg_t*) VHA_ANT_SMON_R4_ADR(_BASE))
#define VHA_ANT_SMON_R5_REG(_BASE) ((vha_ant_smon_r5_reg_t*) VHA_ANT_SMON_R5_ADR(_BASE))
#define VHA_ANT_SMON_R6_REG(_BASE) ((vha_ant_smon_r6_reg_t*) VHA_ANT_SMON_R6_ADR(_BASE))
#define VHA_ANT_SMON_R7_REG(_BASE) ((vha_ant_smon_r7_reg_t*) VHA_ANT_SMON_R7_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    vha_ant_scratch_reg_t VHA_ANT_SCRATCH; /*< Address offset = 0x0 */
    vha_ant_cfg_reg_t VHA_ANT_CFG;     /*< Address offset = 0x4 */
    vha_ant_dl_cfg_reg_t VHA_ANT_DL_CFG;  /*< Address offset = 0x8 */
    vha_ant_tx_alarm_en_reg_t VHA_ANT_TX_ALARM_EN; /*< Address offset = 0xc */
    vha_ant_dl_if_cfg_reg_t VHA_ANT_DL_IF_CFG[2]; /*< Address offset = 0x10 */
    vha_ant_dl_of_cfg_reg_t VHA_ANT_DL_OF_CFG[2]; /*< Address offset = 0x18 */
    vha_ant_dl_if_ecc_ctrl_reg_t VHA_ANT_DL_IF_ECC_CTRL[2]; /*< Address offset = 0x20 */
    vha_ant_arb_cfg_reg_t VHA_ANT_ARB_CFG; /*< Address offset = 0x28 */
    vha_ant_ul_cfg_reg_t VHA_ANT_UL_CFG;  /*< Address offset = 0x2c */
    vha_ant_ul_if_cfg_reg_t VHA_ANT_UL_IF_CFG; /*< Address offset = 0x30 */
    vha_ant_ul_if_ecc_ctrl_reg_t VHA_ANT_UL_IF_ECC_CTRL; /*< Address offset = 0x34 */
    vha_ant_ul_of_cfg_reg_t VHA_ANT_UL_OF_CFG[2]; /*< Address offset = 0x38 */
    vha_ant_int_stat_reg_t VHA_ANT_INT_STAT; /*< Address offset = 0x40 */
    vha_ant_int_high_en_reg_t VHA_ANT_INT_HIGH_EN; /*< Address offset = 0x44 */
    vha_ant_int_low_en_reg_t VHA_ANT_INT_LOW_EN; /*< Address offset = 0x48 */
    vha_ant_int_clr_reg_t VHA_ANT_INT_CLR; /*< Address offset = 0x4c */
    vha_ant_int_force_reg_t VHA_ANT_INT_FORCE; /*< Address offset = 0x50 */
    vha_ant_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x54 */
    const uint8_t        reservedArea0 [8];   /*< Address offset = 0x58 */
    vha_ant_dl_if_stat_reg_t VHA_ANT_DL_IF_STAT[2]; /*< Address offset = 0x60 */
    vha_ant_dl_cc_if_stat_reg_t VHA_ANT_DL_CC_IF_STAT[2]; /*< Address offset = 0x68 */
    vha_ant_dl_if_ecc_stat_reg_t VHA_ANT_DL_IF_ECC_STAT; /*< Address offset = 0x70 */
    const uint8_t        reservedArea1 [4];   /*< Address offset = 0x74 */
    vha_ant_dl_if_ecc_info_reg_t VHA_ANT_DL_IF_ECC_INFO[2]; /*< Address offset = 0x78 */
    vha_ant_dl_of_stat_reg_t VHA_ANT_DL_OF_STAT[2]; /*< Address offset = 0x80 */
    vha_ant_ul_if_stat_reg_t VHA_ANT_UL_IF_STAT; /*< Address offset = 0x88 */
    vha_ant_ul_cc_if_stat_reg_t VHA_ANT_UL_CC_IF_STAT; /*< Address offset = 0x8c */
    vha_ant_ul_if_ecc_stat_reg_t VHA_ANT_UL_IF_ECC_STAT; /*< Address offset = 0x90 */
    vha_ant_ul_if_ecc_info_reg_t VHA_ANT_UL_IF_ECC_INFO; /*< Address offset = 0x94 */
    vha_ant_ul_of_stat_reg_t VHA_ANT_UL_OF_STAT[2]; /*< Address offset = 0x98 */
    vha_ant_dl_arb_cnt_reg_t VHA_ANT_DL_ARB_CNT[2]; /*< Address offset = 0xa0 */
    vha_ant_ul_arb_cnt_reg_t VHA_ANT_UL_ARB_CNT[2]; /*< Address offset = 0xa8 */
    vha_ant_arb_stat_reg_t VHA_ANT_ARB_STAT; /*< Address offset = 0xb0 */
    const uint8_t        reservedArea2 [12];  /*< Address offset = 0xb4 */
    vha_ant_smon_r0_reg_t SMON_R0; /*< Address offset = 0xc0 */
    vha_ant_smon_r1_reg_t SMON_R1; /*< Address offset = 0xc4 */
    vha_ant_smon_r2_reg_t SMON_R2; /*< Address offset = 0xc8 */
    vha_ant_smon_r3_reg_t SMON_R3; /*< Address offset = 0xcc */
    vha_ant_smon_r4_reg_t SMON_R4; /*< Address offset = 0xd0 */
    vha_ant_smon_r5_reg_t SMON_R5; /*< Address offset = 0xd4 */
    vha_ant_smon_r6_reg_t SMON_R6; /*< Address offset = 0xd8 */
    vha_ant_smon_r7_reg_t SMON_R7; /*< Address offset = 0xdc */
} vha_ant_t;     // size: 0x009c

// AddressSpace struct pointer
//
#define VHA0_ANT0        ((vha_ant_t*) VHA0_ANT0_BASE)
#define VHA0_ANT1        ((vha_ant_t*) VHA0_ANT1_BASE)
#define VHA1_ANT0        ((vha_ant_t*) VHA1_ANT0_BASE)
#define VHA1_ANT1        ((vha_ant_t*) VHA1_ANT1_BASE)
#define VHA2_ANT0        ((vha_ant_t*) VHA2_ANT0_BASE)
#define VHA2_ANT1        ((vha_ant_t*) VHA2_ANT1_BASE)
#define VHA3_ANT0        ((vha_ant_t*) VHA3_ANT0_BASE)
#define VHA3_ANT1        ((vha_ant_t*) VHA3_ANT1_BASE)
#define VHA4_ANT0        ((vha_ant_t*) VHA4_ANT0_BASE)
#define VHA4_ANT1        ((vha_ant_t*) VHA4_ANT1_BASE)
#define VHA5_ANT0        ((vha_ant_t*) VHA5_ANT0_BASE)
#define VHA5_ANT1        ((vha_ant_t*) VHA5_ANT1_BASE)
#define VHA6_ANT0        ((vha_ant_t*) VHA6_ANT0_BASE)
#define VHA6_ANT1        ((vha_ant_t*) VHA6_ANT1_BASE)
#define VHA7_ANT0        ((vha_ant_t*) VHA7_ANT0_BASE)
#define VHA7_ANT1        ((vha_ant_t*) VHA7_ANT1_BASE)

// ******************************************* /Address Space

#endif      // _VHA_ANT_H_

