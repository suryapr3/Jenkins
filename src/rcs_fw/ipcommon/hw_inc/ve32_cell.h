#ifndef _VE32_CELL_H_
#define _VE32_CELL_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define VEXABC0_SC_VE32_CELL_BASE   ( 0x02800000 )
#define VEXABC1_SC_VE32_CELL_BASE   ( 0x02840000 )
#define VEXABC2_SC_VE32_CELL_BASE   ( 0x02880000 )
#define VEXABC3_SC_VE32_CELL_BASE   ( 0x028c0000 )
#define VEXABC4_SC_VE32_CELL_BASE   ( 0x02900000 )
#define VEXABC5_SC_VE32_CELL_BASE   ( 0x02940000 )
#define VEXABC6_SC_VE32_CELL_BASE   ( 0x02980000 )
#define VEXABC7_SC_VE32_CELL_BASE   ( 0x029c0000 )
#define VEXABC8_SC_VE32_CELL_BASE   ( 0x02a00000 )
#define VEXABC9_SC_VE32_CELL_BASE   ( 0x02a40000 )
#define VEXABC10_SC_VE32_CELL_BASE  ( 0x02a80000 )
#define VEXABC11_SC_VE32_CELL_BASE  ( 0x02ac0000 )
#define VEXABC12_SC_VE32_CELL_BASE  ( 0x02b00000 )
#define VEXABC13_SC_VE32_CELL_BASE  ( 0x02b40000 )
#define VEXABC14_SC_VE32_CELL_BASE  ( 0x02b80000 )
#define VEXABC15_SC_VE32_CELL_BASE  ( 0x02bc0000 )
#define VEXABC16_SC_VE32_CELL_BASE  ( 0x02c00000 )
#define VEXABC17_SC_VE32_CELL_BASE  ( 0x02c40000 )
#define VEXABC18_SC_VE32_CELL_BASE  ( 0x02c80000 )
#define VEXABC19_SC_VE32_CELL_BASE  ( 0x02cc0000 )
#define VEXABC20_SC_VE32_CELL_BASE  ( 0x02d00000 )
#define VEXABC21_SC_VE32_CELL_BASE  ( 0x02d40000 )
#define VEXABC22_SC_VE32_CELL_BASE  ( 0x02d80000 )
#define VEXABC23_SC_VE32_CELL_BASE  ( 0x02dc0000 )
#define VEXABC24_SC_VE32_CELL_BASE  ( 0x02e00000 )
#define VEXABC25_SC_VE32_CELL_BASE  ( 0x02e40000 )
#define VEXABC26_SC_VE32_CELL_BASE  ( 0x02e80000 )
#define VEXABC27_SC_VE32_CELL_BASE  ( 0x02ec0000 )
#define VEXABC28_SC_VE32_CELL_BASE  ( 0x02f00000 )
#define VEXABC29_SC_VE32_CELL_BASE  ( 0x02f40000 )
#define VEXABC30_SC_VE32_CELL_BASE  ( 0x02f80000 )
#define VEXABC31_SC_VE32_CELL_BASE  ( 0x02fc0000 )
#define VEXABC32_SC_VE32_CELL_BASE  ( 0x03000000 )
#define VEXABC33_SC_VE32_CELL_BASE  ( 0x03040000 )
#define VEXABC34_SC_VE32_CELL_BASE  ( 0x03080000 )
#define VEXABC35_SC_VE32_CELL_BASE  ( 0x030c0000 )
#define VEXABC36_SC_VE32_CELL_BASE  ( 0x03100000 )
#define VEXABC37_SC_VE32_CELL_BASE  ( 0x03140000 )
#define VEXABC38_SC_VE32_CELL_BASE  ( 0x03180000 )
#define VEXABC39_SC_VE32_CELL_BASE  ( 0x031c0000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define VE32_CELL_CTRL_OFFSET ( 0x00000000U )
#define VE32_CELL_START_ADDR_OFFSET ( 0x00000004U )
#define VE32_CELL_STAT_OFFSET ( 0x00000008U )
#define VE32_CELL_ID_OFFSET ( 0x0000000cU )
#define VE32_CELL_CNT_EXE_LSBS_OFFSET ( 0x00000010U )
#define VE32_CELL_CNT_EXE_MSBS_OFFSET ( 0x00000014U )
#define VE32_CELL_CNT_SLP_LSBS_OFFSET ( 0x00000018U )
#define VE32_CELL_CNT_SLP_MSBS_OFFSET ( 0x0000001cU )
#define VE32_CELL_CNT_CLK_LSBS_OFFSET ( 0x00000020U )
#define VE32_CELL_CNT_CLK_MSBS_OFFSET ( 0x00000024U )
#define VE32_CELL_ECC_IRQ_SBE_OFFSET ( 0x00000028U )
#define VE32_CELL_ECC_IRQ_DBE_OFFSET ( 0x0000002cU )
#define VE32_CELL_ECC_IRQCLR_SBE_OFFSET ( 0x00000030U )
#define VE32_CELL_ECC_IRQCLR_DBE_OFFSET ( 0x00000034U )
#define VE32_CELL_SEQUENCER_IRQ_STTR_OFFSET ( 0x00000038U )
#define VE32_CELL_IRQPRIO_STTR_IDLE_OFFSET ( 0x00000044U )
#define VE32_CELL_IRQPRIO_STTR_SLEEP_OFFSET ( 0x00000048U )
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_OFFSET ( 0x0000004cU )
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_OFFSET ( 0x00000050U )
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_OFFSET ( 0x00000054U )
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_OFFSET ( 0x00000080U )
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_OFFSET ( 0x00000084U )
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_OFFSET ( 0x00000088U )
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_OFFSET ( 0x0000008cU )
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_OFFSET ( 0x00000090U )
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_OFFSET ( 0x00000094U )
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_OFFSET ( 0x00000098U )
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_OFFSET ( 0x0000009cU )
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_OFFSET ( 0x000000a0U )
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_OFFSET ( 0x000000a4U )
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_OFFSET ( 0x000000a8U )
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_OFFSET ( 0x000000acU )
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_OFFSET ( 0x000000b0U )
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_OFFSET ( 0x000000b4U )
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_OFFSET ( 0x000000b8U )
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_OFFSET ( 0x000000bcU )
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_OFFSET ( 0x000000c0U )
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_OFFSET ( 0x000000c4U )
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_OFFSET ( 0x000000c8U )
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_OFFSET ( 0x000000ccU )
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_OFFSET ( 0x000000d0U )
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_OFFSET ( 0x000000d4U )
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_OFFSET ( 0x000000d8U )
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_OFFSET ( 0x000000dcU )
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_OFFSET ( 0x000000e0U )
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_OFFSET ( 0x000000e4U )
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_OFFSET ( 0x000000e8U )
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_OFFSET ( 0x000000ecU )
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_OFFSET ( 0x000000f0U )
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_OFFSET ( 0x000000fcU )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define VE32_CELL_CTRL_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_CTRL_OFFSET ) ))
#define VE32_CELL_START_ADDR_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_START_ADDR_OFFSET ) ))
#define VE32_CELL_STAT_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_STAT_OFFSET ) ))
#define VE32_CELL_ID_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_ID_OFFSET ) ))
#define VE32_CELL_CNT_EXE_LSBS_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_CNT_EXE_LSBS_OFFSET ) ))
#define VE32_CELL_CNT_EXE_MSBS_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_CNT_EXE_MSBS_OFFSET ) ))
#define VE32_CELL_CNT_SLP_LSBS_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_CNT_SLP_LSBS_OFFSET ) ))
#define VE32_CELL_CNT_SLP_MSBS_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_CNT_SLP_MSBS_OFFSET ) ))
#define VE32_CELL_CNT_CLK_LSBS_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_CNT_CLK_LSBS_OFFSET ) ))
#define VE32_CELL_CNT_CLK_MSBS_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_CNT_CLK_MSBS_OFFSET ) ))
#define VE32_CELL_ECC_IRQ_SBE_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_ECC_IRQ_SBE_OFFSET ) ))
#define VE32_CELL_ECC_IRQ_DBE_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_ECC_IRQ_DBE_OFFSET ) ))
#define VE32_CELL_ECC_IRQCLR_SBE_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_ECC_IRQCLR_SBE_OFFSET ) ))
#define VE32_CELL_ECC_IRQCLR_DBE_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_ECC_IRQCLR_DBE_OFFSET ) ))
#define VE32_CELL_SEQUENCER_IRQ_STTR_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_SEQUENCER_IRQ_STTR_OFFSET ) ))
#define VE32_CELL_IRQPRIO_STTR_IDLE_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_IRQPRIO_STTR_IDLE_OFFSET ) ))
#define VE32_CELL_IRQPRIO_STTR_SLEEP_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_IRQPRIO_STTR_SLEEP_OFFSET ) ))
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_IRQPRIO_STTR_FALSE_START_OFFSET ) ))
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_SDFGATE_IRQ_RIDC_OOB_OFFSET ) ))
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_OFFSET ) ))
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_BP_DMEM_ARB_DMEM_REQ_OFFSET ) ))
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_OFFSET ) ))
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_OFFSET ) ))
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_CTRL_BP_CFG_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_OFFSET ) ))
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_CTRL_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_OFFSET ) ))
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_OFFSET ) ))
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_OFFSET ) ))
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_OFFSET ) ))
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_OFFSET ) ))
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_ADR(_BASE) (( ( _BASE ) + ( VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_CONTROL register description at address offset 0x0
  *
  * Register default value:        0x00000020
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/control
  * control_reg register.
  */

typedef union {
  struct {
    uint32_t NA_0_0 : 1;
    ///< Reserved/unused.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t START : 1;
    ///< Start control flag. Starts or continues program execution (high).
    ///< The cell automatically resets the bit to low. After accessing this
    ///< control flag the status flags are updated within two cycles.
    ///< AccessType="WO" BitOffset="1" ResetValue="0x0"
    uint32_t IRQCLR_FALSE_START : 1;
    ///< Interrupt clear control flag for false start attempts, i.e. starting
    ///< the cell while it is not in IDLE or SLEEP state. When asserted, clears
    ///< an interrupt request (IRQ) sent by the cell in response to a false
    ///< start. The cell automatically resets this flag to '0' after one clock
    ///< cycle.
    ///< AccessType="WO" BitOffset="2" ResetValue="0x0"
    uint32_t RUN : 1;
    ///< Run control flag. Enables program execution (high) or stalls the cell
    ///< (low) disabling it from continuing program execution. After accessing
    ///< this control flag the status flags are updated within two cycles.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t NA_4_4 : 1;
    ///< Reserved/unused.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t NA_5_5 : 1;
    ///< Reserved/unused.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x1"
    uint32_t NA_6_6 : 1;
    ///< Reserved/unused.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t NA_7_7 : 1;
    ///< Reserved/unused.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t IRQCLR_IDLE : 1;
    ///< Interrupt clear control flag for sequencer state transitions into
    ///< IDLE state. When asserted, clears an interrupt request (IRQ) sent
    ///< by the cell in response to a sequencer state transition to the IDLE
    ///< state. The cell automatically resets this flag to '0' after one clock
    ///< cycle.
    ///< AccessType="WO" BitOffset="8" ResetValue="0x0"
    uint32_t IRQCLR_SLEEP : 1;
    ///< Interrupt clear control flag for sequencer state transitions into
    ///< SLEEP state. When asserted, clears an interrupt request (IRQ) sent
    ///< by the cell in response to a sequencer state transition to the SLEEP
    ///< state. The cell automatically resets this flag to '0' after one clock
    ///< cycle.
    ///< AccessType="WO" BitOffset="9" ResetValue="0x0"
    uint32_t IRQMSK_IDLE : 1;
    ///< Idle IRQ mask flag. Enables (high) or disables (low) IRQ generation
    ///< when the cell enters the IDLE state.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t IRQMSK_SLEEP : 1;
    ///< Sleeping IRQ mask flag. Enables (high) or disables (low) IRQ generation
    ///< when the cell enters the SLEEP state.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t IRQMSK_FALSE_START : 1;
    ///< FALSE_START IRQ mask flag. Enables (high) or disables (low) IRQ generation
    ///< for attempts to start the cell while it is not in IDLE or SLEEP state.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t COUNT_START : 1;
    ///< Counter Start control flag. When high, all internal counters will
    ///< start updating their values according to their counting behavior.
    ///< The cell automatically resets this flag to low after one clock cycle.
    ///< Note, that count snapshot registers will only be updated to reflect
    ///< their internal values when the Counter Snapshot control flag is asserted.
    ///< AccessType="WO" BitOffset="13" ResetValue="0x0"
    uint32_t COUNT_STOP : 1;
    ///< Counter Stop control flag. When high, all internal counters will stop
    ///< updating their values. The cell automatically resets this flag to
    ///< low after one clock cycle.
    ///< AccessType="WO" BitOffset="14" ResetValue="0x0"
    uint32_t COUNT_CLR : 1;
    ///< Counter Clear control flag. When high, all internal counters will
    ///< be set to zero. The cell automatically resets this flag to low after
    ///< one clock cycle. Note, that count snapshot registers will only be
    ///< updated to reflect their internal values when the Counter Snapshot
    ///< control flag is asserted.
    ///< AccessType="WO" BitOffset="15" ResetValue="0x0"
    uint32_t COUNT_SNAP : 1;
    ///< Counter Snapshot control flag. When high, all internal counters current
    ///< values will be copied into their corresponding count snapshot registers,
    ///< to enable reading out consistent values. The cell automatically resets
    ///< this flag to low after one clock cycle.
    ///< AccessType="WO" BitOffset="16" ResetValue="0x0"
    uint32_t NA_31_17 : 15;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_ctrl_reg_t;

#define VE32_CELL_CTRL_DEFAULT (0x00000020U)
#define VE32_CELL_CTRL_RD_MASK (0xfffe1cf9U)
#define VE32_CELL_CTRL_WR_MASK (0x0001ff1fU)


///< Reserved/unused.
#define VE32_CELL_CTRL_NA_0_BF_OFF ( 0)
#define VE32_CELL_CTRL_NA_0_BF_WID ( 1)
#define VE32_CELL_CTRL_NA_0_BF_MSK (0x00000001)
#define VE32_CELL_CTRL_NA_0_BF_DEF (0x00000000)

///< Start control flag. Starts or continues program execution (high).
///< The cell automatically resets the bit to low. After accessing this
///< control flag the status flags are updated within two cycles.
#define VE32_CELL_CTRL_START_BF_OFF ( 1)
#define VE32_CELL_CTRL_START_BF_WID ( 1)
#define VE32_CELL_CTRL_START_BF_MSK (0x00000002)
#define VE32_CELL_CTRL_START_BF_DEF (0x00000000)

///< Interrupt clear control flag for false start attempts, i.e. starting
///< the cell while it is not in IDLE or SLEEP state. When asserted, clears
///< an interrupt request (IRQ) sent by the cell in response to a false
///< start. The cell automatically resets this flag to '0' after one clock
///< cycle.
#define VE32_CELL_CTRL_IRQCLR_FALSE_START_BF_OFF ( 2)
#define VE32_CELL_CTRL_IRQCLR_FALSE_START_BF_WID ( 1)
#define VE32_CELL_CTRL_IRQCLR_FALSE_START_BF_MSK (0x00000004)
#define VE32_CELL_CTRL_IRQCLR_FALSE_START_BF_DEF (0x00000000)

///< Run control flag. Enables program execution (high) or stalls the cell
///< (low) disabling it from continuing program execution. After accessing
///< this control flag the status flags are updated within two cycles.
#define VE32_CELL_CTRL_RUN_BF_OFF ( 3)
#define VE32_CELL_CTRL_RUN_BF_WID ( 1)
#define VE32_CELL_CTRL_RUN_BF_MSK (0x00000008)
#define VE32_CELL_CTRL_RUN_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_CTRL_NA_4_BF_OFF ( 4)
#define VE32_CELL_CTRL_NA_4_BF_WID ( 1)
#define VE32_CELL_CTRL_NA_4_BF_MSK (0x00000010)
#define VE32_CELL_CTRL_NA_4_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_CTRL_NA_5_BF_OFF ( 5)
#define VE32_CELL_CTRL_NA_5_BF_WID ( 1)
#define VE32_CELL_CTRL_NA_5_BF_MSK (0x00000020)
#define VE32_CELL_CTRL_NA_5_BF_DEF (0x00000020)

///< Reserved/unused.
#define VE32_CELL_CTRL_NA_6_BF_OFF ( 6)
#define VE32_CELL_CTRL_NA_6_BF_WID ( 1)
#define VE32_CELL_CTRL_NA_6_BF_MSK (0x00000040)
#define VE32_CELL_CTRL_NA_6_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_CTRL_NA_7_BF_OFF ( 7)
#define VE32_CELL_CTRL_NA_7_BF_WID ( 1)
#define VE32_CELL_CTRL_NA_7_BF_MSK (0x00000080)
#define VE32_CELL_CTRL_NA_7_BF_DEF (0x00000000)

///< Interrupt clear control flag for sequencer state transitions into
///< IDLE state. When asserted, clears an interrupt request (IRQ) sent
///< by the cell in response to a sequencer state transition to the IDLE
///< state. The cell automatically resets this flag to '0' after one clock
///< cycle.
#define VE32_CELL_CTRL_IRQCLR_IDLE_BF_OFF ( 8)
#define VE32_CELL_CTRL_IRQCLR_IDLE_BF_WID ( 1)
#define VE32_CELL_CTRL_IRQCLR_IDLE_BF_MSK (0x00000100)
#define VE32_CELL_CTRL_IRQCLR_IDLE_BF_DEF (0x00000000)

///< Interrupt clear control flag for sequencer state transitions into
///< SLEEP state. When asserted, clears an interrupt request (IRQ) sent
///< by the cell in response to a sequencer state transition to the SLEEP
///< state. The cell automatically resets this flag to '0' after one clock
///< cycle.
#define VE32_CELL_CTRL_IRQCLR_SLEEP_BF_OFF ( 9)
#define VE32_CELL_CTRL_IRQCLR_SLEEP_BF_WID ( 1)
#define VE32_CELL_CTRL_IRQCLR_SLEEP_BF_MSK (0x00000200)
#define VE32_CELL_CTRL_IRQCLR_SLEEP_BF_DEF (0x00000000)

///< Idle IRQ mask flag. Enables (high) or disables (low) IRQ generation
///< when the cell enters the IDLE state.
#define VE32_CELL_CTRL_IRQMSK_IDLE_BF_OFF (10)
#define VE32_CELL_CTRL_IRQMSK_IDLE_BF_WID ( 1)
#define VE32_CELL_CTRL_IRQMSK_IDLE_BF_MSK (0x00000400)
#define VE32_CELL_CTRL_IRQMSK_IDLE_BF_DEF (0x00000000)

///< Sleeping IRQ mask flag. Enables (high) or disables (low) IRQ generation
///< when the cell enters the SLEEP state.
#define VE32_CELL_CTRL_IRQMSK_SLEEP_BF_OFF (11)
#define VE32_CELL_CTRL_IRQMSK_SLEEP_BF_WID ( 1)
#define VE32_CELL_CTRL_IRQMSK_SLEEP_BF_MSK (0x00000800)
#define VE32_CELL_CTRL_IRQMSK_SLEEP_BF_DEF (0x00000000)

///< FALSE_START IRQ mask flag. Enables (high) or disables (low) IRQ generation
///< for attempts to start the cell while it is not in IDLE or SLEEP state.
#define VE32_CELL_CTRL_IRQMSK_FALSE_START_BF_OFF (12)
#define VE32_CELL_CTRL_IRQMSK_FALSE_START_BF_WID ( 1)
#define VE32_CELL_CTRL_IRQMSK_FALSE_START_BF_MSK (0x00001000)
#define VE32_CELL_CTRL_IRQMSK_FALSE_START_BF_DEF (0x00000000)

///< Counter Start control flag. When high, all internal counters will
///< start updating their values according to their counting behavior.
///< The cell automatically resets this flag to low after one clock cycle.
///< Note, that count snapshot registers will only be updated to reflect
///< their internal values when the Counter Snapshot control flag is asserted.
#define VE32_CELL_CTRL_CNT_START_BF_OFF (13)
#define VE32_CELL_CTRL_CNT_START_BF_WID ( 1)
#define VE32_CELL_CTRL_CNT_START_BF_MSK (0x00002000)
#define VE32_CELL_CTRL_CNT_START_BF_DEF (0x00000000)

///< Counter Stop control flag. When high, all internal counters will stop
///< updating their values. The cell automatically resets this flag to
///< low after one clock cycle.
#define VE32_CELL_CTRL_CNT_STOP_BF_OFF (14)
#define VE32_CELL_CTRL_CNT_STOP_BF_WID ( 1)
#define VE32_CELL_CTRL_CNT_STOP_BF_MSK (0x00004000)
#define VE32_CELL_CTRL_CNT_STOP_BF_DEF (0x00000000)

///< Counter Clear control flag. When high, all internal counters will
///< be set to zero. The cell automatically resets this flag to low after
///< one clock cycle. Note, that count snapshot registers will only be
///< updated to reflect their internal values when the Counter Snapshot
///< control flag is asserted.
#define VE32_CELL_CTRL_CNT_CLR_BF_OFF (15)
#define VE32_CELL_CTRL_CNT_CLR_BF_WID ( 1)
#define VE32_CELL_CTRL_CNT_CLR_BF_MSK (0x00008000)
#define VE32_CELL_CTRL_CNT_CLR_BF_DEF (0x00000000)

///< Counter Snapshot control flag. When high, all internal counters current
///< values will be copied into their corresponding count snapshot registers,
///< to enable reading out consistent values. The cell automatically resets
///< this flag to low after one clock cycle.
#define VE32_CELL_CTRL_CNT_SNAP_BF_OFF (16)
#define VE32_CELL_CTRL_CNT_SNAP_BF_WID ( 1)
#define VE32_CELL_CTRL_CNT_SNAP_BF_MSK (0x00010000)
#define VE32_CELL_CTRL_CNT_SNAP_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_CTRL_NA_31_17_BF_OFF (17)
#define VE32_CELL_CTRL_NA_31_17_BF_WID (15)
#define VE32_CELL_CTRL_NA_31_17_BF_MSK (0xFFFE0000)
#define VE32_CELL_CTRL_NA_31_17_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_START_ADDR register description at address offset 0x4
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/start_addr
  * start_addr_reg register.
  */

typedef union {
  struct {
    uint32_t START_ADDR : 22;
    ///< Program Start Address.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_22 : 10;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="22" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_start_addr_reg_t;

#define VE32_CELL_START_ADDR_DEFAULT (0x00000000U)
#define VE32_CELL_START_ADDR_RD_MASK (0xffffffffU)
#define VE32_CELL_START_ADDR_WR_MASK (0x003fffffU)


///< Program Start Address.
#define VE32_CELL_START_ADDR_START_ADDR_BF_OFF ( 0)
#define VE32_CELL_START_ADDR_START_ADDR_BF_WID (22)
#define VE32_CELL_START_ADDR_START_ADDR_BF_MSK (0x003FFFFF)
#define VE32_CELL_START_ADDR_START_ADDR_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_START_ADDR_NA_31_22_BF_OFF (22)
#define VE32_CELL_START_ADDR_NA_31_22_BF_WID (10)
#define VE32_CELL_START_ADDR_NA_31_22_BF_MSK (0xFFC00000)
#define VE32_CELL_START_ADDR_NA_31_22_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_STATUS register description at address offset 0x8
  *
  * Register default value:        0x00000001
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/status
  * status_reg register.
  */

typedef union {
  struct {
    uint32_t IDLING : 1;
    ///< Idling 'core execution state machine' status flag. The cell is in
    ///< IDLE state. This state is entered after a hard reset or when the idle()
    ///< operation has been executed. To (re)start execution from the Program
    ///< Start Address in register 1, the Start control flag must be set high.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x1"
    uint32_t STARTING : 1;
    ///< Starting 'core execution state machine' status flag. The cell is transitioning
    ///< from IDLE state to EXECUTE state through the START state. This state
    ///< is entered when the core is stalled during this transition, e.g. when
    ///< waiting for the instruction cache to fetch instructions. When the
    ///< stall is lifted, the cell will automatically transition to EXECUTE
    ///< state.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EXECUTING : 1;
    ///< Executing 'core execution state machine' status flag. The cell is
    ///< actively executing instructions.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t STALLING : 1;
    ///< Stalling 'core execution state machine' status flag. The cell is inactive,
    ///< i.e. stalled during the execution of instructions.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t SLEEPING : 1;
    ///< Sleeping 'core execution state machine' status flag. The cell is in
    ///< SLEEP state. Program execution is halted in this state. This state
    ///< is entered when the sleep() operation has been executed. To resume
    ///< execution and exit SLEEP state, the Start control flag must be set
    ///< high.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t BREAKING : 1;
    ///< Breaking 'core execution state machine' status flag. The cell is in
    ///< BREAK state. Program execution is halted in this state. This state
    ///< is entered when the external debug controller asserts an external
    ///< dbg_stop input of the cell due to a break-, watch- or cross-point.
    ///< To resume execution and exit BREAK state, the debug controller must
    ///< assert the external dbg_start input of the cell.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t FAILING : 1;
    ///< Core execution is failing due to the occurrence of an unrecoverable
    ///< error. Possible root cause : Core is halted due to the detection of
    ///< a double-bit error (DBE) in one of the ECC enabled memories, that
    ///< has CORE_HALT_EN set. Note that this state is not a dedicated core
    ///< execution state machine status flag. To resolve the problem, the core
    ///< needs to be reset and re-initialized. This bit is only cleared upon
    ///< reset.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t NA_31_7 : 25;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_stat_reg_t;

#define VE32_CELL_STAT_DEFAULT (0x00000001U)
#define VE32_CELL_STAT_RD_MASK (0xffffffffU)
#define VE32_CELL_STAT_WR_MASK (0x00000000U)


///< Idling 'core execution state machine' status flag. The cell is in
///< IDLE state. This state is entered after a hard reset or when the idle()
///< operation has been executed. To (re)start execution from the Program
///< Start Address in register 1, the Start control flag must be set high.
#define VE32_CELL_STAT_IDLING_BF_OFF ( 0)
#define VE32_CELL_STAT_IDLING_BF_WID ( 1)
#define VE32_CELL_STAT_IDLING_BF_MSK (0x00000001)
#define VE32_CELL_STAT_IDLING_BF_DEF (0x00000001)

///< Starting 'core execution state machine' status flag. The cell is transitioning
///< from IDLE state to EXECUTE state through the START state. This state
///< is entered when the core is stalled during this transition, e.g. when
///< waiting for the instruction cache to fetch instructions. When the
///< stall is lifted, the cell will automatically transition to EXECUTE
///< state.
#define VE32_CELL_STAT_STARTING_BF_OFF ( 1)
#define VE32_CELL_STAT_STARTING_BF_WID ( 1)
#define VE32_CELL_STAT_STARTING_BF_MSK (0x00000002)
#define VE32_CELL_STAT_STARTING_BF_DEF (0x00000000)

///< Executing 'core execution state machine' status flag. The cell is
///< actively executing instructions.
#define VE32_CELL_STAT_EXECUTING_BF_OFF ( 2)
#define VE32_CELL_STAT_EXECUTING_BF_WID ( 1)
#define VE32_CELL_STAT_EXECUTING_BF_MSK (0x00000004)
#define VE32_CELL_STAT_EXECUTING_BF_DEF (0x00000000)

///< Stalling 'core execution state machine' status flag. The cell is inactive,
///< i.e. stalled during the execution of instructions.
#define VE32_CELL_STAT_STALLING_BF_OFF ( 3)
#define VE32_CELL_STAT_STALLING_BF_WID ( 1)
#define VE32_CELL_STAT_STALLING_BF_MSK (0x00000008)
#define VE32_CELL_STAT_STALLING_BF_DEF (0x00000000)

///< Sleeping 'core execution state machine' status flag. The cell is in
///< SLEEP state. Program execution is halted in this state. This state
///< is entered when the sleep() operation has been executed. To resume
///< execution and exit SLEEP state, the Start control flag must be set
///< high.
#define VE32_CELL_STAT_SLEEPING_BF_OFF ( 4)
#define VE32_CELL_STAT_SLEEPING_BF_WID ( 1)
#define VE32_CELL_STAT_SLEEPING_BF_MSK (0x00000010)
#define VE32_CELL_STAT_SLEEPING_BF_DEF (0x00000000)

///< Breaking 'core execution state machine' status flag. The cell is in
///< BREAK state. Program execution is halted in this state. This state
///< is entered when the external debug controller asserts an external
///< dbg_stop input of the cell due to a break-, watch- or cross-point.
///< To resume execution and exit BREAK state, the debug controller must
///< assert the external dbg_start input of the cell.
#define VE32_CELL_STAT_BREAKING_BF_OFF ( 5)
#define VE32_CELL_STAT_BREAKING_BF_WID ( 1)
#define VE32_CELL_STAT_BREAKING_BF_MSK (0x00000020)
#define VE32_CELL_STAT_BREAKING_BF_DEF (0x00000000)

///< Core execution is failing due to the occurrence of an unrecoverable
///< error. Possible root cause : Core is halted due to the detection of
///< a double-bit error (DBE) in one of the ECC enabled memories, that
///< has CORE_HALT_EN set. Note that this state is not a dedicated core
///< execution state machine status flag. To resolve the problem, the core
///< needs to be reset and re-initialized. This bit is only cleared upon
///< reset.
#define VE32_CELL_STAT_FAILING_BF_OFF ( 6)
#define VE32_CELL_STAT_FAILING_BF_WID ( 1)
#define VE32_CELL_STAT_FAILING_BF_MSK (0x00000040)
#define VE32_CELL_STAT_FAILING_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_STAT_NA_31_7_BF_OFF ( 7)
#define VE32_CELL_STAT_NA_31_7_BF_WID (25)
#define VE32_CELL_STAT_NA_31_7_BF_MSK (0xFFFFFF80)
#define VE32_CELL_STAT_NA_31_7_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_CELL_ID register description at address offset 0xc
  *
  * Register default value:        0x00009E4F
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/cell_id
  * cell_id_reg register.
  */

typedef union {
  struct {
    uint32_t CELL_ID : 32;
    ///< It contains a unique cell identifier for this processor.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x9E4F"
  } ;
  uint32_t value;
} ve32_cell_id_reg_t;

#define VE32_CELL_ID_DEFAULT (0x00009e4fU)
#define VE32_CELL_ID_RD_MASK (0xffffffffU)
#define VE32_CELL_ID_WR_MASK (0x00000000U)


///< It contains a unique cell identifier for this processor.
#define VE32_CELL_ID_CELL_ID_BF_OFF ( 0)
#define VE32_CELL_ID_CELL_ID_BF_WID (32)
#define VE32_CELL_ID_CELL_ID_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_ID_CELL_ID_BF_DEF (0x00009E4F)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_COUNT_EXE_LSBS register description at address offset 0x10
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/count_exe_lsbs
  * count_exe_lsbs_reg register.
  */

typedef union {
  struct {
    uint32_t COUNT : 32;
    ///< Execution cycle count bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_cnt_exe_lsbs_reg_t;

#define VE32_CELL_CNT_EXE_LSBS_DEFAULT (0x00000000U)
#define VE32_CELL_CNT_EXE_LSBS_RD_MASK (0xffffffffU)
#define VE32_CELL_CNT_EXE_LSBS_WR_MASK (0x00000000U)


///< Execution cycle count bits.
#define VE32_CELL_CNT_EXE_LSBS_CNT_BF_OFF ( 0)
#define VE32_CELL_CNT_EXE_LSBS_CNT_BF_WID (32)
#define VE32_CELL_CNT_EXE_LSBS_CNT_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_CNT_EXE_LSBS_CNT_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_COUNT_EXE_MSBS register description at address offset 0x14
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/count_exe_msbs
  * count_exe_msbs_reg register.
  */

typedef union {
  struct {
    uint32_t COUNT : 32;
    ///< Execution cycle count bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_cnt_exe_msbs_reg_t;

#define VE32_CELL_CNT_EXE_MSBS_DEFAULT (0x00000000U)
#define VE32_CELL_CNT_EXE_MSBS_RD_MASK (0xffffffffU)
#define VE32_CELL_CNT_EXE_MSBS_WR_MASK (0x00000000U)


///< Execution cycle count bits.
#define VE32_CELL_CNT_EXE_MSBS_CNT_BF_OFF ( 0)
#define VE32_CELL_CNT_EXE_MSBS_CNT_BF_WID (32)
#define VE32_CELL_CNT_EXE_MSBS_CNT_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_CNT_EXE_MSBS_CNT_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_COUNT_SLP_LSBS register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/count_slp_lsbs
  * count_slp_lsbs_reg register.
  */

typedef union {
  struct {
    uint32_t COUNT : 32;
    ///< Sleep cycle count bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_cnt_slp_lsbs_reg_t;

#define VE32_CELL_CNT_SLP_LSBS_DEFAULT (0x00000000U)
#define VE32_CELL_CNT_SLP_LSBS_RD_MASK (0xffffffffU)
#define VE32_CELL_CNT_SLP_LSBS_WR_MASK (0x00000000U)


///< Sleep cycle count bits.
#define VE32_CELL_CNT_SLP_LSBS_CNT_BF_OFF ( 0)
#define VE32_CELL_CNT_SLP_LSBS_CNT_BF_WID (32)
#define VE32_CELL_CNT_SLP_LSBS_CNT_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_CNT_SLP_LSBS_CNT_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_COUNT_SLP_MSBS register description at address offset 0x1c
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/count_slp_msbs
  * count_slp_msbs_reg register.
  */

typedef union {
  struct {
    uint32_t COUNT : 32;
    ///< Sleep cycle count bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_cnt_slp_msbs_reg_t;

#define VE32_CELL_CNT_SLP_MSBS_DEFAULT (0x00000000U)
#define VE32_CELL_CNT_SLP_MSBS_RD_MASK (0xffffffffU)
#define VE32_CELL_CNT_SLP_MSBS_WR_MASK (0x00000000U)


///< Sleep cycle count bits.
#define VE32_CELL_CNT_SLP_MSBS_CNT_BF_OFF ( 0)
#define VE32_CELL_CNT_SLP_MSBS_CNT_BF_WID (32)
#define VE32_CELL_CNT_SLP_MSBS_CNT_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_CNT_SLP_MSBS_CNT_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_COUNT_CLK_LSBS register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/count_clk_lsbs
  * count_clk_lsbs_reg register.
  */

typedef union {
  struct {
    uint32_t COUNT : 32;
    ///< Clock cycle count bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_cnt_clk_lsbs_reg_t;

#define VE32_CELL_CNT_CLK_LSBS_DEFAULT (0x00000000U)
#define VE32_CELL_CNT_CLK_LSBS_RD_MASK (0xffffffffU)
#define VE32_CELL_CNT_CLK_LSBS_WR_MASK (0x00000000U)


///< Clock cycle count bits.
#define VE32_CELL_CNT_CLK_LSBS_CNT_BF_OFF ( 0)
#define VE32_CELL_CNT_CLK_LSBS_CNT_BF_WID (32)
#define VE32_CELL_CNT_CLK_LSBS_CNT_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_CNT_CLK_LSBS_CNT_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_COUNT_CLK_MSBS register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/count_clk_msbs
  * count_clk_msbs_reg register.
  */

typedef union {
  struct {
    uint32_t COUNT : 32;
    ///< Clock cycle count bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_cnt_clk_msbs_reg_t;

#define VE32_CELL_CNT_CLK_MSBS_DEFAULT (0x00000000U)
#define VE32_CELL_CNT_CLK_MSBS_RD_MASK (0xffffffffU)
#define VE32_CELL_CNT_CLK_MSBS_WR_MASK (0x00000000U)


///< Clock cycle count bits.
#define VE32_CELL_CNT_CLK_MSBS_CNT_BF_OFF ( 0)
#define VE32_CELL_CNT_CLK_MSBS_CNT_BF_WID (32)
#define VE32_CELL_CNT_CLK_MSBS_CNT_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_CNT_CLK_MSBS_CNT_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_ECC_IRQ_SBE register description at address offset 0x28
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/ecc_irq_sbe
  * ecc_irq_sbe_reg register.
  */

typedef union {
  struct {
    uint32_t IRQ_SBE : 3;
    ///< ECC single bit error interrupt request bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_3 : 29;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_ecc_irq_sbe_reg_t;

#define VE32_CELL_ECC_IRQ_SBE_DEFAULT (0x00000000U)
#define VE32_CELL_ECC_IRQ_SBE_RD_MASK (0xffffffffU)
#define VE32_CELL_ECC_IRQ_SBE_WR_MASK (0x00000000U)


///< ECC single bit error interrupt request bits.
#define VE32_CELL_ECC_IRQ_SBE_IRQ_SBE_BF_OFF ( 0)
#define VE32_CELL_ECC_IRQ_SBE_IRQ_SBE_BF_WID ( 3)
#define VE32_CELL_ECC_IRQ_SBE_IRQ_SBE_BF_MSK (0x00000007)
#define VE32_CELL_ECC_IRQ_SBE_IRQ_SBE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_ECC_IRQ_SBE_NA_31_3_BF_OFF ( 3)
#define VE32_CELL_ECC_IRQ_SBE_NA_31_3_BF_WID (29)
#define VE32_CELL_ECC_IRQ_SBE_NA_31_3_BF_MSK (0xFFFFFFF8)
#define VE32_CELL_ECC_IRQ_SBE_NA_31_3_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_ECC_IRQ_DBE register description at address offset 0x2c
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/ecc_irq_dbe
  * ecc_irq_dbe_reg register.
  */

typedef union {
  struct {
    uint32_t IRQ_DBE : 3;
    ///< ECC double bit error interrupt request bits.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_3 : 29;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_ecc_irq_dbe_reg_t;

#define VE32_CELL_ECC_IRQ_DBE_DEFAULT (0x00000000U)
#define VE32_CELL_ECC_IRQ_DBE_RD_MASK (0xffffffffU)
#define VE32_CELL_ECC_IRQ_DBE_WR_MASK (0x00000000U)


///< ECC double bit error interrupt request bits.
#define VE32_CELL_ECC_IRQ_DBE_IRQ_DBE_BF_OFF ( 0)
#define VE32_CELL_ECC_IRQ_DBE_IRQ_DBE_BF_WID ( 3)
#define VE32_CELL_ECC_IRQ_DBE_IRQ_DBE_BF_MSK (0x00000007)
#define VE32_CELL_ECC_IRQ_DBE_IRQ_DBE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_ECC_IRQ_DBE_NA_31_3_BF_OFF ( 3)
#define VE32_CELL_ECC_IRQ_DBE_NA_31_3_BF_WID (29)
#define VE32_CELL_ECC_IRQ_DBE_NA_31_3_BF_MSK (0xFFFFFFF8)
#define VE32_CELL_ECC_IRQ_DBE_NA_31_3_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_ECC_IRQCLR_SBE register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/ecc_irqclr_sbe
  * ecc_irqclr_sbe_reg register.
  */

typedef union {
  struct {
    uint32_t IRQCLR_SBE : 3;
    ///< ECC single bit error interrupt request clear bits.
    ///< AccessType="WO" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_3 : 29;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_ecc_irqclr_sbe_reg_t;

#define VE32_CELL_ECC_IRQCLR_SBE_DEFAULT (0x00000000U)
#define VE32_CELL_ECC_IRQCLR_SBE_RD_MASK (0xfffffff8U)
#define VE32_CELL_ECC_IRQCLR_SBE_WR_MASK (0x00000007U)


///< ECC single bit error interrupt request clear bits.
#define VE32_CELL_ECC_IRQCLR_SBE_IRQCLR_SBE_BF_OFF ( 0)
#define VE32_CELL_ECC_IRQCLR_SBE_IRQCLR_SBE_BF_WID ( 3)
#define VE32_CELL_ECC_IRQCLR_SBE_IRQCLR_SBE_BF_MSK (0x00000007)
#define VE32_CELL_ECC_IRQCLR_SBE_IRQCLR_SBE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_ECC_IRQCLR_SBE_NA_31_3_BF_OFF ( 3)
#define VE32_CELL_ECC_IRQCLR_SBE_NA_31_3_BF_WID (29)
#define VE32_CELL_ECC_IRQCLR_SBE_NA_31_3_BF_MSK (0xFFFFFFF8)
#define VE32_CELL_ECC_IRQCLR_SBE_NA_31_3_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_ECC_IRQCLR_DBE register description at address offset 0x34
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/ecc_irqclr_dbe
  * ecc_irqclr_dbe_reg register.
  */

typedef union {
  struct {
    uint32_t IRQCLR_DBE : 3;
    ///< ECC double bit error interrupt request clear bits.
    ///< AccessType="WO" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_3 : 29;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_ecc_irqclr_dbe_reg_t;

#define VE32_CELL_ECC_IRQCLR_DBE_DEFAULT (0x00000000U)
#define VE32_CELL_ECC_IRQCLR_DBE_RD_MASK (0xfffffff8U)
#define VE32_CELL_ECC_IRQCLR_DBE_WR_MASK (0x00000007U)


///< ECC double bit error interrupt request clear bits.
#define VE32_CELL_ECC_IRQCLR_DBE_IRQCLR_DBE_BF_OFF ( 0)
#define VE32_CELL_ECC_IRQCLR_DBE_IRQCLR_DBE_BF_WID ( 3)
#define VE32_CELL_ECC_IRQCLR_DBE_IRQCLR_DBE_BF_MSK (0x00000007)
#define VE32_CELL_ECC_IRQCLR_DBE_IRQCLR_DBE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_ECC_IRQCLR_DBE_NA_31_3_BF_OFF ( 3)
#define VE32_CELL_ECC_IRQCLR_DBE_NA_31_3_BF_WID (29)
#define VE32_CELL_ECC_IRQCLR_DBE_NA_31_3_BF_MSK (0xFFFFFFF8)
#define VE32_CELL_ECC_IRQCLR_DBE_NA_31_3_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_SEQUENCER_IRQ_STTR register description at address offset 0x38
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/sequencer_irq_sttr
  * sequencer_irq_sttr_reg register.
  */

typedef union {
  struct {
    uint32_t IRQ_IDLE : 1;
    ///< Sequencer Idle state transition interrupt request bit. Indicates a
    ///< pending interrupt request triggered by the transition of the Cell's
    ///< sequencer into the IDLE state.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t IRQ_SLEEP : 1;
    ///< Sequencer Sleep state transition interrupt request bit. Indicates
    ///< a pending interrupt request triggered by the transition of the Cell's
    ///< sequencer into the SLEEP state.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t IRQ_FALSE_START : 1;
    ///< Sequencer False Start State Transition Interrupt Request register.
    ///< Indicates a pending interrupt request triggered by the attempted start
    ///< of the cell, while the Cell's sequencer is not in the IDLE or SLEEP
    ///< state.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t NA_31_3 : 29;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_sequencer_irq_sttr_reg_t;

#define VE32_CELL_SEQUENCER_IRQ_STTR_DEFAULT (0x00000000U)
#define VE32_CELL_SEQUENCER_IRQ_STTR_RD_MASK (0xffffffffU)
#define VE32_CELL_SEQUENCER_IRQ_STTR_WR_MASK (0x00000000U)


///< Sequencer Idle state transition interrupt request bit. Indicates a
///< pending interrupt request triggered by the transition of the Cell's
///< sequencer into the IDLE state.
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_IDLE_BF_OFF ( 0)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_IDLE_BF_WID ( 1)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_IDLE_BF_MSK (0x00000001)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_IDLE_BF_DEF (0x00000000)

///< Sequencer Sleep state transition interrupt request bit. Indicates
///< a pending interrupt request triggered by the transition of the Cell's
///< sequencer into the SLEEP state.
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_SLEEP_BF_OFF ( 1)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_SLEEP_BF_WID ( 1)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_SLEEP_BF_MSK (0x00000002)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_SLEEP_BF_DEF (0x00000000)

///< Sequencer False Start State Transition Interrupt Request register.
///< Indicates a pending interrupt request triggered by the attempted start
///< of the cell, while the Cell's sequencer is not in the IDLE or SLEEP
///< state.
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_FALSE_START_BF_OFF ( 2)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_FALSE_START_BF_WID ( 1)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_FALSE_START_BF_MSK (0x00000004)
#define VE32_CELL_SEQUENCER_IRQ_STTR_IRQ_FALSE_START_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_SEQUENCER_IRQ_STTR_NA_31_3_BF_OFF ( 3)
#define VE32_CELL_SEQUENCER_IRQ_STTR_NA_31_3_BF_WID (29)
#define VE32_CELL_SEQUENCER_IRQ_STTR_NA_31_3_BF_MSK (0xFFFFFFF8)
#define VE32_CELL_SEQUENCER_IRQ_STTR_NA_31_3_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_IRQPRIO_STTR_IDLE register description at address offset 0x44
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/irqprio_sttr_idle
  * irqprio_sttr_idle_reg register.
  */

typedef union {
  struct {
    uint32_t IRQPRIO_STTR_IDLE : 1;
    ///< Sequencer Idle state transition interrupt priority. Sets priority
    ///< of interrupt requests generated for sequencer state transitions into
    ///< the IDLE state, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_IDLE
    ///< register. See section 2.3 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_irqprio_sttr_idle_reg_t;

#define VE32_CELL_IRQPRIO_STTR_IDLE_DEFAULT (0x00000000U)
#define VE32_CELL_IRQPRIO_STTR_IDLE_RD_MASK (0xffffffffU)
#define VE32_CELL_IRQPRIO_STTR_IDLE_WR_MASK (0x00000001U)


///< Sequencer Idle state transition interrupt priority. Sets priority
///< of interrupt requests generated for sequencer state transitions into
///< the IDLE state, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_IDLE
///< register. See section 2.3 for further details.
#define VE32_CELL_IRQPRIO_STTR_IDLE_IRQPRIO_STTR_IDLE_BF_OFF ( 0)
#define VE32_CELL_IRQPRIO_STTR_IDLE_IRQPRIO_STTR_IDLE_BF_WID ( 1)
#define VE32_CELL_IRQPRIO_STTR_IDLE_IRQPRIO_STTR_IDLE_BF_MSK (0x00000001)
#define VE32_CELL_IRQPRIO_STTR_IDLE_IRQPRIO_STTR_IDLE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_IRQPRIO_STTR_IDLE_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_IRQPRIO_STTR_IDLE_NA_31_1_BF_WID (31)
#define VE32_CELL_IRQPRIO_STTR_IDLE_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_IRQPRIO_STTR_IDLE_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_IRQPRIO_STTR_SLEEP register description at address offset 0x48
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/irqprio_sttr_sleep
  * irqprio_sttr_sleep_reg register.
  */

typedef union {
  struct {
    uint32_t IRQPRIO_STTR_SLEEP : 1;
    ///< Sequencer Sleep state transition interrupt priority. Sets priority
    ///< of interrupt requests generated for sequencer state transitions into
    ///< the SLEEP state, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_SLEEP
    ///< register. See section 2.3 for further details
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_irqprio_sttr_sleep_reg_t;

#define VE32_CELL_IRQPRIO_STTR_SLEEP_DEFAULT (0x00000000U)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_RD_MASK (0xffffffffU)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_WR_MASK (0x00000001U)


///< Sequencer Sleep state transition interrupt priority. Sets priority
///< of interrupt requests generated for sequencer state transitions into
///< the SLEEP state, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_SLEEP
///< register. See section 2.3 for further details
#define VE32_CELL_IRQPRIO_STTR_SLEEP_IRQPRIO_STTR_SLEEP_BF_OFF ( 0)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_IRQPRIO_STTR_SLEEP_BF_WID ( 1)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_IRQPRIO_STTR_SLEEP_BF_MSK (0x00000001)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_IRQPRIO_STTR_SLEEP_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_IRQPRIO_STTR_SLEEP_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_NA_31_1_BF_WID (31)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_IRQPRIO_STTR_SLEEP_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_IRQPRIO_STTR_FALSE_START register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/irqprio_sttr_false_start
  * irqprio_sttr_false_start_reg register.
  */

typedef union {
  struct {
    uint32_t IRQPRIO_STTR_FALSE_START : 1;
    ///< Sequencer False Start State Transition Interrupt Priority. Sets priority
    ///< of interrupt requests generated for attempted starting of the cell,
    ///< while it is not in the IDLE or SLEEP state, where 0 indicates lowest
    ///< priority, and 2^Q-1 indicates highest priority. Write access to this
    ///< register will modify the register contents only if the corresponding
    ///< interrupt is masked in the IRQMSK_FALSE_START register. See section
    ///< 2.4.4 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_irqprio_sttr_false_start_reg_t;

#define VE32_CELL_IRQPRIO_STTR_FALSE_START_DEFAULT (0x00000000U)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_RD_MASK (0xffffffffU)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_WR_MASK (0x00000001U)


///< Sequencer False Start State Transition Interrupt Priority. Sets priority
///< of interrupt requests generated for attempted starting of the cell,
///< while it is not in the IDLE or SLEEP state, where 0 indicates lowest
///< priority, and 2^Q-1 indicates highest priority. Write access to this
///< register will modify the register contents only if the corresponding
///< interrupt is masked in the IRQMSK_FALSE_START register. See section
///< 2.4.4 for further details.
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_IRQPRIO_STTR_FALSE_START_BF_OFF ( 0)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_IRQPRIO_STTR_FALSE_START_BF_WID ( 1)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_IRQPRIO_STTR_FALSE_START_BF_MSK (0x00000001)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_IRQPRIO_STTR_FALSE_START_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_NA_31_1_BF_WID (31)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_SDFGATE_IRQ_RIDC_OOB register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/sdfgate_irq_ridc_oob
  * sdfgate_irq_ridc_oob_reg register.
  */

typedef union {
  struct {
    uint32_t SDFGATE_IRQ_RIDC_OOB : 1;
    ///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Request register.
    ///< Each bit L_sdf in this register indicates that the SDF-Gate contained
    ///< in logical memory L_sdf  has triggered an out-of-bounds interrupt
    ///< request. Bit L_sdf in this register is cleared upon writing a '1'
    ///< in the IRQCLR_RIDC_OOB register at the corresponding bit position
    ///< l.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_sdfgate_irq_ridc_oob_reg_t;

#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_DEFAULT (0x00000000U)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_RD_MASK (0xffffffffU)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_WR_MASK (0x00000000U)


///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Request register.
///< Each bit L_sdf in this register indicates that the SDF-Gate contained
///< in logical memory L_sdf  has triggered an out-of-bounds interrupt
///< request. Bit L_sdf in this register is cleared upon writing a '1'
///< in the IRQCLR_RIDC_OOB register at the corresponding bit position
///< l.
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_SDFGATE_IRQ_RIDC_OOB_BF_OFF ( 0)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_SDFGATE_IRQ_RIDC_OOB_BF_WID ( 1)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_SDFGATE_IRQ_RIDC_OOB_BF_MSK (0x00000001)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_SDFGATE_IRQ_RIDC_OOB_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_NA_31_1_BF_WID (31)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_SDFGATE_IRQCLR_RIDC_OOB register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/sdfgate_irqclr_ridc_oob
  * sdfgate_irqclr_ridc_oob_reg register.
  */

typedef union {
  struct {
    uint32_t SDFGATE_IRQCLR_RIDC_OOB : 1;
    ///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Request Clear register.
    ///< Each bit L_sdf  in this register enables the clearing of the corresponding
    ///< pending interrupt request for the SDF-Gate contained in logical memory
    ///< L_sdf recorded at bit position L_sdf in the IRQ_RIDC_OOB register.
    ///< By concurrently setting multiple bits in this register, multiple interrupt
    ///< requests can be cleared simultaneously. Flags set to '1' in this register
    ///< in a given clock cycle are automatically reset to '0', one clock cycle
    ///< later.
    ///< AccessType="WO" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_sdfgate_irqclr_ridc_oob_reg_t;

#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_DEFAULT (0x00000000U)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_RD_MASK (0xfffffffeU)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_WR_MASK (0x00000001U)


///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Request Clear register.
///< Each bit L_sdf  in this register enables the clearing of the corresponding
///< pending interrupt request for the SDF-Gate contained in logical memory
///< L_sdf recorded at bit position L_sdf in the IRQ_RIDC_OOB register.
///< By concurrently setting multiple bits in this register, multiple interrupt
///< requests can be cleared simultaneously. Flags set to '1' in this register
///< in a given clock cycle are automatically reset to '0', one clock cycle
///< later.
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_SDFGATE_IRQCLR_RIDC_OOB_BF_OFF ( 0)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_SDFGATE_IRQCLR_RIDC_OOB_BF_WID ( 1)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_SDFGATE_IRQCLR_RIDC_OOB_BF_MSK (0x00000001)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_SDFGATE_IRQCLR_RIDC_OOB_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_NA_31_1_BF_WID (31)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_BP_DMEM_ARB_DMEM_REQ register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/bp_dmem_Arb_dmem_req
  * bp_dmem_Arb_dmem_req_reg register.
  */

typedef union {
  struct {
    uint32_t MODE : 2;
    ///< Arbitration mode for bp_dmem_Arb_dmem_req. Possible values are 0x0:
    ///< Round-robin arbitration wherein core and target alternate in priority
    ///< on each access grant, irrespective of the number of parallel load/stores
    ///< the core may issue to the arbiter on each cycle. Thus, both core and
    ///< target get a guaranteed 50% bandwidth in this case. 0x1: Round-robin
    ///< arbitration wherein individual core load/store units and target rotate
    ///< in priority on each access grant. Thus, with L defined as the number
    ///< of load/store units connected to the arbiter, the core gets a guaranteed
    ///< 100*L/(1+L)% bandwidth, while the target only gets a guaranteed 100/(1+L)%
    ///< bandwidth in this case. 0x2: Fixed priority arbitration wherein the
    ///< core gets a 100% guaranteed bandwidth, while the target has no bandwidth
    ///< guarantees, only getting access when the core is not requesting access
    ///< to the arbiter. 0x3: Fixed priority arbitration wherein the target
    ///< gets a 100% guaranteed bandwidth, while the core has no bandwidth
    ///< guarantees, only getting access when the target is not requesting
    ///< access to the arbiter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_2 : 30;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_bp_dmem_arb_dmem_req_reg_t;

#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_DEFAULT (0x00000000U)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_RD_MASK (0xffffffffU)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_WR_MASK (0x00000003U)


///< Arbitration mode for bp_dmem_Arb_dmem_req. Possible values are 0x0:
///< Round-robin arbitration wherein core and target alternate in priority
///< on each access grant, irrespective of the number of parallel load/stores
///< the core may issue to the arbiter on each cycle. Thus, both core and
///< target get a guaranteed 50% bandwidth in this case. 0x1: Round-robin
///< arbitration wherein individual core load/store units and target rotate
///< in priority on each access grant. Thus, with L defined as the number
///< of load/store units connected to the arbiter, the core gets a guaranteed
///< 100*L/(1+L)% bandwidth, while the target only gets a guaranteed 100/(1+L)%
///< bandwidth in this case. 0x2: Fixed priority arbitration wherein the
///< core gets a 100% guaranteed bandwidth, while the target has no bandwidth
///< guarantees, only getting access when the core is not requesting access
///< to the arbiter. 0x3: Fixed priority arbitration wherein the target
///< gets a 100% guaranteed bandwidth, while the core has no bandwidth
///< guarantees, only getting access when the target is not requesting
///< access to the arbiter.
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_MODE_BF_OFF ( 0)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_MODE_BF_WID ( 2)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_MODE_BF_MSK (0x00000003)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_MODE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_NA_31_2_BF_OFF ( 2)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_NA_31_2_BF_WID (30)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_NA_31_2_BF_MSK (0xFFFFFFFC)
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_NA_31_2_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_SIMD0_VMEM_ARB_VMEM_WP register description at address offset 0x84
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/simd0_vmem_Arb_vmem_wp
  * simd0_vmem_Arb_vmem_wp_reg register.
  */

typedef union {
  struct {
    uint32_t MODE : 2;
    ///< Arbitration mode for simd0_vmem_Arb_vmem_wp. Possible values are 0x0:
    ///< Round-robin arbitration wherein core and target alternate in priority
    ///< on each access grant, irrespective of the number of parallel load/stores
    ///< the core may issue to the arbiter on each cycle. Thus, both core and
    ///< target get a guaranteed 50% bandwidth in this case. 0x1: Round-robin
    ///< arbitration wherein individual core load/store units and target rotate
    ///< in priority on each access grant. Thus, with L defined as the number
    ///< of load/store units connected to the arbiter, the core gets a guaranteed
    ///< 100*L/(1+L)% bandwidth, while the target only gets a guaranteed 100/(1+L)%
    ///< bandwidth in this case. 0x2: Fixed priority arbitration wherein the
    ///< core gets a 100% guaranteed bandwidth, while the target has no bandwidth
    ///< guarantees, only getting access when the core is not requesting access
    ///< to the arbiter. 0x3: Fixed priority arbitration wherein the target
    ///< gets a 100% guaranteed bandwidth, while the core has no bandwidth
    ///< guarantees, only getting access when the target is not requesting
    ///< access to the arbiter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_2 : 30;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_simd0_vmem_arb_vmem_wp_reg_t;

#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_DEFAULT (0x00000000U)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_RD_MASK (0xffffffffU)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_WR_MASK (0x00000003U)


///< Arbitration mode for simd0_vmem_Arb_vmem_wp. Possible values are 0x0:
///< Round-robin arbitration wherein core and target alternate in priority
///< on each access grant, irrespective of the number of parallel load/stores
///< the core may issue to the arbiter on each cycle. Thus, both core and
///< target get a guaranteed 50% bandwidth in this case. 0x1: Round-robin
///< arbitration wherein individual core load/store units and target rotate
///< in priority on each access grant. Thus, with L defined as the number
///< of load/store units connected to the arbiter, the core gets a guaranteed
///< 100*L/(1+L)% bandwidth, while the target only gets a guaranteed 100/(1+L)%
///< bandwidth in this case. 0x2: Fixed priority arbitration wherein the
///< core gets a 100% guaranteed bandwidth, while the target has no bandwidth
///< guarantees, only getting access when the core is not requesting access
///< to the arbiter. 0x3: Fixed priority arbitration wherein the target
///< gets a 100% guaranteed bandwidth, while the core has no bandwidth
///< guarantees, only getting access when the target is not requesting
///< access to the arbiter.
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_MODE_BF_OFF ( 0)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_MODE_BF_WID ( 2)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_MODE_BF_MSK (0x00000003)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_MODE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_NA_31_2_BF_OFF ( 2)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_NA_31_2_BF_WID (30)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_NA_31_2_BF_MSK (0xFFFFFFFC)
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_NA_31_2_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_SIMD0_LUTMEM_ARB_LUTMEM_WP register description at address offset 0x88
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/simd0_lutmem_Arb_lutmem_wp
  * simd0_lutmem_Arb_lutmem_wp_reg register.
  */

typedef union {
  struct {
    uint32_t MODE : 2;
    ///< Arbitration mode for simd0_lutmem_Arb_lutmem_wp. Possible values are
    ///< 0x0: Round-robin arbitration wherein core and target alternate in
    ///< priority on each access grant, irrespective of the number of parallel
    ///< load/stores the core may issue to the arbiter on each cycle. Thus,
    ///< both core and target get a guaranteed 50% bandwidth in this case.
    ///< 0x1: Round-robin arbitration wherein individual core load/store units
    ///< and target rotate in priority on each access grant. Thus, with L defined
    ///< as the number of load/store units connected to the arbiter, the core
    ///< gets a guaranteed 100*L/(1+L)% bandwidth, while the target only gets
    ///< a guaranteed 100/(1+L)% bandwidth in this case. 0x2: Fixed priority
    ///< arbitration wherein the core gets a 100% guaranteed bandwidth, while
    ///< the target has no bandwidth guarantees, only getting access when the
    ///< core is not requesting access to the arbiter. 0x3: Fixed priority
    ///< arbitration wherein the target gets a 100% guaranteed bandwidth, while
    ///< the core has no bandwidth guarantees, only getting access when the
    ///< target is not requesting access to the arbiter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_2 : 30;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_simd0_lutmem_arb_lutmem_wp_reg_t;

#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_DEFAULT (0x00000000U)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_RD_MASK (0xffffffffU)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_WR_MASK (0x00000003U)


///< Arbitration mode for simd0_lutmem_Arb_lutmem_wp. Possible values are
///< 0x0: Round-robin arbitration wherein core and target alternate in
///< priority on each access grant, irrespective of the number of parallel
///< load/stores the core may issue to the arbiter on each cycle. Thus,
///< both core and target get a guaranteed 50% bandwidth in this case.
///< 0x1: Round-robin arbitration wherein individual core load/store units
///< and target rotate in priority on each access grant. Thus, with L defined
///< as the number of load/store units connected to the arbiter, the core
///< gets a guaranteed 100*L/(1+L)% bandwidth, while the target only gets
///< a guaranteed 100/(1+L)% bandwidth in this case. 0x2: Fixed priority
///< arbitration wherein the core gets a 100% guaranteed bandwidth, while
///< the target has no bandwidth guarantees, only getting access when the
///< core is not requesting access to the arbiter. 0x3: Fixed priority
///< arbitration wherein the target gets a 100% guaranteed bandwidth, while
///< the core has no bandwidth guarantees, only getting access when the
///< target is not requesting access to the arbiter.
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_MODE_BF_OFF ( 0)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_MODE_BF_WID ( 2)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_MODE_BF_MSK (0x00000003)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_MODE_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_NA_31_2_BF_OFF ( 2)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_NA_31_2_BF_WID (30)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_NA_31_2_BF_MSK (0xFFFFFFFC)
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_NA_31_2_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_CONTROL_BP_CONFIG register description at address offset 0x8c
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_control_bp_config
  * lm_ecc_control_bp_config_reg register.
  */

typedef union {
  struct {
    uint32_t ECC_EN : 1;
    ///< ECC Enable flag for ECC-supporting Logical Memory (LM) 0. When true,
    ///< enable ECC correction,  and generate single- and double-bit error
    ///< flags for this LM. When false all SBE and DBE errors are ignored,
    ///< and no correction of read data is performed. When this bit is false
    ///< also no interrupts are generated nor is the core halted on errors
    ///< detected by this LM.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t REFRESH_EN : 1;
    ///< ECC Refresh Enable flag for ECC-supporting Logical Memory (LM) 0.
    ///< This control bit is only available when the user property 'HasECCRefresh'
    ///< is set. When true, on a single-bit error write-back the corrected
    ///< data into the failing address location in this LM. When false, single-bit
    ///< errors are not corrected, only reported.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t IRQMSK_SBE : 1;
    ///< ECC Single Bit Error Interrupt Request Mask flag for ECC-supporting
    ///< Logical Memory (LM) 0. When true, enable interrupt request signalling
    ///< for single-bit ECC errors in this LM, on the interrupt request output
    ///< interface of the Cell. When false, disable interrupt request signalling.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t IRQMSK_DBE : 1;
    ///< ECC Double Bit Error Interrupt Request Mask flag for ECC-supporting
    ///< Logical Memory (LM) 0. When true, enable interrupt request signalling
    ///< for double-bit ECC errors in this LM, on the interrupt request output
    ///< interface of the Cell. When false, disable interrupt request signalling.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CORE_HALT_EN : 1;
    ///< ECC Core Halt Enable flag for ECC-supporting Logical Memory (LM) 0.
    ///< When true, in case this LM detects a double-bit error the program
    ///< fetch will be stopped, and the core will stall execution immediately.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ECC_COUNT_EN : 1;
    ///< ECC Error Counter Enable flag for ECC-supporting Logical Memory (LM)
    ///< 0. When true and ECC_EN for this LM is set to true as well, enable
    ///< ECC error counting in registers LM_ECC_SBE_CNT and LM_ECC_DBE_CNT
    ///< for this LM.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t NA_31_6 : 26;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_ctrl_bp_cfg_reg_t;

#define VE32_CELL_LM_ECC_CTRL_BP_CFG_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_WR_MASK (0x0000003fU)


///< ECC Enable flag for ECC-supporting Logical Memory (LM) 0. When true,
///< enable ECC correction,  and generate single- and double-bit error
///< flags for this LM. When false all SBE and DBE errors are ignored,
///< and no correction of read data is performed. When this bit is false
///< also no interrupts are generated nor is the core halted on errors
///< detected by this LM.
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_EN_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_EN_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_EN_BF_DEF (0x00000000)

///< ECC Refresh Enable flag for ECC-supporting Logical Memory (LM) 0.
///< This control bit is only available when the user property 'HasECCRefresh'
///< is set. When true, on a single-bit error write-back the corrected
///< data into the failing address location in this LM. When false, single-bit
///< errors are not corrected, only reported.
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_REFRESH_EN_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_REFRESH_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_REFRESH_EN_BF_MSK (0x00000002)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_REFRESH_EN_BF_DEF (0x00000000)

///< ECC Single Bit Error Interrupt Request Mask flag for ECC-supporting
///< Logical Memory (LM) 0. When true, enable interrupt request signalling
///< for single-bit ECC errors in this LM, on the interrupt request output
///< interface of the Cell. When false, disable interrupt request signalling.
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_SBE_BF_OFF ( 2)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_SBE_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_SBE_BF_MSK (0x00000004)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_SBE_BF_DEF (0x00000000)

///< ECC Double Bit Error Interrupt Request Mask flag for ECC-supporting
///< Logical Memory (LM) 0. When true, enable interrupt request signalling
///< for double-bit ECC errors in this LM, on the interrupt request output
///< interface of the Cell. When false, disable interrupt request signalling.
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_DBE_BF_OFF ( 3)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_DBE_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_DBE_BF_MSK (0x00000008)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_IRQMSK_DBE_BF_DEF (0x00000000)

///< ECC Core Halt Enable flag for ECC-supporting Logical Memory (LM) 0.
///< When true, in case this LM detects a double-bit error the program
///< fetch will be stopped, and the core will stall execution immediately.
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_CORE_HALT_EN_BF_OFF ( 4)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_CORE_HALT_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_CORE_HALT_EN_BF_MSK (0x00000010)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_CORE_HALT_EN_BF_DEF (0x00000000)

///< ECC Error Counter Enable flag for ECC-supporting Logical Memory (LM)
///< 0. When true and ECC_EN for this LM is set to true as well, enable
///< ECC error counting in registers LM_ECC_SBE_CNT and LM_ECC_DBE_CNT
///< for this LM.
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_CNT_EN_BF_OFF ( 5)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_CNT_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_CNT_EN_BF_MSK (0x00000020)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_ECC_CNT_EN_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_NA_31_6_BF_OFF ( 6)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_NA_31_6_BF_WID (26)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_NA_31_6_BF_MSK (0xFFFFFFC0)
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_NA_31_6_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_IRQPRIO_BP_CONFIG register description at address offset 0x90
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_irqprio_bp_config
  * lm_ecc_sbe_irqprio_bp_config_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_IRQPRIO : 1;
    ///< ECC Single Bit Error (SBE) Interrupt Priority for ECC-supporting Logical
    ///< Memory (LM) 0. Sets priority of Single Bit ECC Error (SBE) interrupts
    ///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_SBE
    ///< register. See section 2.3 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_irqprio_bp_cfg_reg_t;

#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_WR_MASK (0x00000001U)


///< ECC Single Bit Error (SBE) Interrupt Priority for ECC-supporting Logical
///< Memory (LM) 0. Sets priority of Single Bit ECC Error (SBE) interrupts
///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_SBE
///< register. See section 2.3 for further details.
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_SBE_IRQPRIO_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_SBE_IRQPRIO_BF_WID ( 1)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_SBE_IRQPRIO_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_SBE_IRQPRIO_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_IRQPRIO_BP_CONFIG register description at address offset 0x94
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_irqprio_bp_config
  * lm_ecc_dbe_irqprio_bp_config_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_IRQPRIO : 1;
    ///< ECC Double Bit Error (DBE) Interrupt Priority for ECC-supporting Logical
    ///< Memory (LM) 0. Sets priority of Double Bit ECC Error (DBE) interrupts
    ///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_DBE
    ///< register. See section 2.3 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_irqprio_bp_cfg_reg_t;

#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_WR_MASK (0x00000001U)


///< ECC Double Bit Error (DBE) Interrupt Priority for ECC-supporting Logical
///< Memory (LM) 0. Sets priority of Double Bit ECC Error (DBE) interrupts
///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_DBE
///< register. See section 2.3 for further details.
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_DBE_IRQPRIO_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_DBE_IRQPRIO_BF_WID ( 1)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_DBE_IRQPRIO_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_DBE_IRQPRIO_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_BAD_ADDR_BP_CONFIG register description at address offset 0x98
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_bad_addr_bp_config
  * lm_ecc_sbe_bad_addr_bp_config_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_BAD_ADDR : 16;
    ///< Single Bit ECC Error Bad Address for ECC-supporting Logical Memory
    ///< (LM) 0. Records the Logical Memory address for which a single-bit
    ///< error is detected and a corresponding ECC interrupt request is generated.
    ///< Following the reading of an active interrupt request flag for the
    ///< LM in the IRQ_SBE register, the value in this register is frozen and
    ///< represents the  address of the most recent SBE error that occurred
    ///< before the interrupt request flag was read. The register is unfrozen
    ///< and updated again following the clearing of the interrupt request
    ///< by writing the corresponding flag in the IRQCLR_SBE register. See
    ///< section 2.4.2 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_16 : 16;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_bad_addr_bp_cfg_reg_t;

#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_WR_MASK (0x00000000U)


///< Single Bit ECC Error Bad Address for ECC-supporting Logical Memory
///< (LM) 0. Records the Logical Memory address for which a single-bit
///< error is detected and a corresponding ECC interrupt request is generated.
///< Following the reading of an active interrupt request flag for the
///< LM in the IRQ_SBE register, the value in this register is frozen and
///< represents the  address of the most recent SBE error that occurred
///< before the interrupt request flag was read. The register is unfrozen
///< and updated again following the clearing of the interrupt request
///< by writing the corresponding flag in the IRQCLR_SBE register. See
///< section 2.4.2 for further details.
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_SBE_BAD_ADDR_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_SBE_BAD_ADDR_BF_WID (16)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_SBE_BAD_ADDR_BF_MSK (0x0000FFFF)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_SBE_BAD_ADDR_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_NA_31_16_BF_OFF (16)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_NA_31_16_BF_WID (16)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_NA_31_16_BF_MSK (0xFFFF0000)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_NA_31_16_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_BAD_ADDR_BP_CONFIG register description at address offset 0x9c
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_bad_addr_bp_config
  * lm_ecc_dbe_bad_addr_bp_config_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_BAD_ADDR : 16;
    ///< Double Bit ECC Error Bad Address for ECC-supporting Logical Memory
    ///< (LM) 0. Records the Logical Memory address for which a double-bit
    ///< error is detected and a corresponding ECC interrupt request is generated.
    ///< Following the reading of an active interrupt request flag for the
    ///< LM in the IRQ_DBE register, the value in this register is frozen and
    ///< represents the  address of the most recent DBE error that occurred
    ///< before the interrupt request flag was read. The register is unfrozen
    ///< and updated again following the clearing of the interrupt request
    ///< by writing the corresponding flag in the IRQCLR_DBE register. See
    ///< section 2.4.2 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_16 : 16;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_bad_addr_bp_cfg_reg_t;

#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_WR_MASK (0x00000000U)


///< Double Bit ECC Error Bad Address for ECC-supporting Logical Memory
///< (LM) 0. Records the Logical Memory address for which a double-bit
///< error is detected and a corresponding ECC interrupt request is generated.
///< Following the reading of an active interrupt request flag for the
///< LM in the IRQ_DBE register, the value in this register is frozen and
///< represents the  address of the most recent DBE error that occurred
///< before the interrupt request flag was read. The register is unfrozen
///< and updated again following the clearing of the interrupt request
///< by writing the corresponding flag in the IRQCLR_DBE register. See
///< section 2.4.2 for further details.
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_DBE_BAD_ADDR_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_DBE_BAD_ADDR_BF_WID (16)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_DBE_BAD_ADDR_BF_MSK (0x0000FFFF)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_DBE_BAD_ADDR_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_NA_31_16_BF_OFF (16)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_NA_31_16_BF_WID (16)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_NA_31_16_BF_MSK (0xFFFF0000)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_NA_31_16_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_COUNT_BP_CONFIG register description at address offset 0xa0
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_count_bp_config
  * lm_ecc_sbe_count_bp_config_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_COUNT : 8;
    ///< Single Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
    ///< 0. Records the number of single-bit errors detected for this LM, since
    ///< the last time this counter was read. Thus, on each read to this register,
    ///< the counter is reset. On overflow this counter saturates to value
    ///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
    ///< register for this LM is asserted. See section 2.4.1 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_8 : 24;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_cnt_bp_cfg_reg_t;

#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_WR_MASK (0x00000000U)


///< Single Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
///< 0. Records the number of single-bit errors detected for this LM, since
///< the last time this counter was read. Thus, on each read to this register,
///< the counter is reset. On overflow this counter saturates to value
///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
///< register for this LM is asserted. See section 2.4.1 for further details.
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_SBE_CNT_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_SBE_CNT_BF_WID ( 8)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_SBE_CNT_BF_MSK (0x000000FF)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_SBE_CNT_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_NA_31_8_BF_OFF ( 8)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_NA_31_8_BF_WID (24)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_NA_31_8_BF_MSK (0xFFFFFF00)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_NA_31_8_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_COUNT_BP_CONFIG register description at address offset 0xa4
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_count_bp_config
  * lm_ecc_dbe_count_bp_config_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_COUNT : 8;
    ///< Double Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
    ///< 0. Records the number of double-bit errors detected for this LM, since
    ///< the last time this counter was read. Thus, on each read to this register,
    ///< the counter is reset. On overflow this counter saturates to value
    ///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
    ///< register for this LM is asserted. See section 2.4.1 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_8 : 24;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_cnt_bp_cfg_reg_t;

#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_WR_MASK (0x00000000U)


///< Double Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
///< 0. Records the number of double-bit errors detected for this LM, since
///< the last time this counter was read. Thus, on each read to this register,
///< the counter is reset. On overflow this counter saturates to value
///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
///< register for this LM is asserted. See section 2.4.1 for further details.
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_DBE_CNT_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_DBE_CNT_BF_WID ( 8)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_DBE_CNT_BF_MSK (0x000000FF)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_DBE_CNT_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_NA_31_8_BF_OFF ( 8)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_NA_31_8_BF_WID (24)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_NA_31_8_BF_MSK (0xFFFFFF00)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_NA_31_8_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_CONTROL_BP_DMEM register description at address offset 0xa8
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_control_bp_dmem
  * lm_ecc_control_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t ECC_EN : 1;
    ///< ECC Enable flag for ECC-supporting Logical Memory (LM) 0. When true,
    ///< enable ECC correction,  and generate single- and double-bit error
    ///< flags for this LM. When false all SBE and DBE errors are ignored,
    ///< and no correction of read data is performed. When this bit is false
    ///< also no interrupts are generated nor is the core halted on errors
    ///< detected by this LM.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t REFRESH_EN : 1;
    ///< ECC Refresh Enable flag for ECC-supporting Logical Memory (LM) 0.
    ///< This control bit is only available when the user property 'HasECCRefresh'
    ///< is set. When true, on a single-bit error write-back the corrected
    ///< data into the failing address location in this LM. When false, single-bit
    ///< errors are not corrected, only reported.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t IRQMSK_SBE : 1;
    ///< ECC Single Bit Error Interrupt Request Mask flag for ECC-supporting
    ///< Logical Memory (LM) 0. When true, enable interrupt request signalling
    ///< for single-bit ECC errors in this LM, on the interrupt request output
    ///< interface of the Cell. When false, disable interrupt request signalling.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t IRQMSK_DBE : 1;
    ///< ECC Double Bit Error Interrupt Request Mask flag for ECC-supporting
    ///< Logical Memory (LM) 0. When true, enable interrupt request signalling
    ///< for double-bit ECC errors in this LM, on the interrupt request output
    ///< interface of the Cell. When false, disable interrupt request signalling.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CORE_HALT_EN : 1;
    ///< ECC Core Halt Enable flag for ECC-supporting Logical Memory (LM) 0.
    ///< When true, in case this LM detects a double-bit error the program
    ///< fetch will be stopped, and the core will stall execution immediately.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ECC_COUNT_EN : 1;
    ///< ECC Error Counter Enable flag for ECC-supporting Logical Memory (LM)
    ///< 0. When true and ECC_EN for this LM is set to true as well, enable
    ///< ECC error counting in registers LM_ECC_SBE_CNT and LM_ECC_DBE_CNT
    ///< for this LM.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t NA_31_6 : 26;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_ctrl_bp_dmem_reg_t;

#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_WR_MASK (0x0000003fU)


///< ECC Enable flag for ECC-supporting Logical Memory (LM) 0. When true,
///< enable ECC correction,  and generate single- and double-bit error
///< flags for this LM. When false all SBE and DBE errors are ignored,
///< and no correction of read data is performed. When this bit is false
///< also no interrupts are generated nor is the core halted on errors
///< detected by this LM.
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_EN_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_EN_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_EN_BF_DEF (0x00000000)

///< ECC Refresh Enable flag for ECC-supporting Logical Memory (LM) 0.
///< This control bit is only available when the user property 'HasECCRefresh'
///< is set. When true, on a single-bit error write-back the corrected
///< data into the failing address location in this LM. When false, single-bit
///< errors are not corrected, only reported.
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_REFRESH_EN_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_REFRESH_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_REFRESH_EN_BF_MSK (0x00000002)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_REFRESH_EN_BF_DEF (0x00000000)

///< ECC Single Bit Error Interrupt Request Mask flag for ECC-supporting
///< Logical Memory (LM) 0. When true, enable interrupt request signalling
///< for single-bit ECC errors in this LM, on the interrupt request output
///< interface of the Cell. When false, disable interrupt request signalling.
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_SBE_BF_OFF ( 2)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_SBE_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_SBE_BF_MSK (0x00000004)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_SBE_BF_DEF (0x00000000)

///< ECC Double Bit Error Interrupt Request Mask flag for ECC-supporting
///< Logical Memory (LM) 0. When true, enable interrupt request signalling
///< for double-bit ECC errors in this LM, on the interrupt request output
///< interface of the Cell. When false, disable interrupt request signalling.
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_DBE_BF_OFF ( 3)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_DBE_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_DBE_BF_MSK (0x00000008)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_IRQMSK_DBE_BF_DEF (0x00000000)

///< ECC Core Halt Enable flag for ECC-supporting Logical Memory (LM) 0.
///< When true, in case this LM detects a double-bit error the program
///< fetch will be stopped, and the core will stall execution immediately.
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_CORE_HALT_EN_BF_OFF ( 4)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_CORE_HALT_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_CORE_HALT_EN_BF_MSK (0x00000010)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_CORE_HALT_EN_BF_DEF (0x00000000)

///< ECC Error Counter Enable flag for ECC-supporting Logical Memory (LM)
///< 0. When true and ECC_EN for this LM is set to true as well, enable
///< ECC error counting in registers LM_ECC_SBE_CNT and LM_ECC_DBE_CNT
///< for this LM.
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_CNT_EN_BF_OFF ( 5)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_CNT_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_CNT_EN_BF_MSK (0x00000020)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_ECC_CNT_EN_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_NA_31_6_BF_OFF ( 6)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_NA_31_6_BF_WID (26)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_NA_31_6_BF_MSK (0xFFFFFFC0)
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_NA_31_6_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_IRQPRIO_BP_DMEM register description at address offset 0xac
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_irqprio_bp_dmem
  * lm_ecc_sbe_irqprio_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_IRQPRIO : 1;
    ///< ECC Single Bit Error (SBE) Interrupt Priority for ECC-supporting Logical
    ///< Memory (LM) 0. Sets priority of Single Bit ECC Error (SBE) interrupts
    ///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_SBE
    ///< register. See section 2.3 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_irqprio_bp_dmem_reg_t;

#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_WR_MASK (0x00000001U)


///< ECC Single Bit Error (SBE) Interrupt Priority for ECC-supporting Logical
///< Memory (LM) 0. Sets priority of Single Bit ECC Error (SBE) interrupts
///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_SBE
///< register. See section 2.3 for further details.
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_SBE_IRQPRIO_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_SBE_IRQPRIO_BF_WID ( 1)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_SBE_IRQPRIO_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_SBE_IRQPRIO_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_IRQPRIO_BP_DMEM register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_irqprio_bp_dmem
  * lm_ecc_dbe_irqprio_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_IRQPRIO : 1;
    ///< ECC Double Bit Error (DBE) Interrupt Priority for ECC-supporting Logical
    ///< Memory (LM) 0. Sets priority of Double Bit ECC Error (DBE) interrupts
    ///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_DBE
    ///< register. See section 2.3 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_irqprio_bp_dmem_reg_t;

#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_WR_MASK (0x00000001U)


///< ECC Double Bit Error (DBE) Interrupt Priority for ECC-supporting Logical
///< Memory (LM) 0. Sets priority of Double Bit ECC Error (DBE) interrupts
///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_DBE
///< register. See section 2.3 for further details.
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_DBE_IRQPRIO_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_DBE_IRQPRIO_BF_WID ( 1)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_DBE_IRQPRIO_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_DBE_IRQPRIO_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_BAD_ADDR_BP_DMEM register description at address offset 0xb4
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_bad_addr_bp_dmem
  * lm_ecc_sbe_bad_addr_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_BAD_ADDR : 14;
    ///< Single Bit ECC Error Bad Address for ECC-supporting Logical Memory
    ///< (LM) 0. Records the Logical Memory address for which a single-bit
    ///< error is detected and a corresponding ECC interrupt request is generated.
    ///< Following the reading of an active interrupt request flag for the
    ///< LM in the IRQ_SBE register, the value in this register is frozen and
    ///< represents the  address of the most recent SBE error that occurred
    ///< before the interrupt request flag was read. The register is unfrozen
    ///< and updated again following the clearing of the interrupt request
    ///< by writing the corresponding flag in the IRQCLR_SBE register. See
    ///< section 2.4.2 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_14 : 18;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="14" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_bad_addr_bp_dmem_reg_t;

#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_WR_MASK (0x00000000U)


///< Single Bit ECC Error Bad Address for ECC-supporting Logical Memory
///< (LM) 0. Records the Logical Memory address for which a single-bit
///< error is detected and a corresponding ECC interrupt request is generated.
///< Following the reading of an active interrupt request flag for the
///< LM in the IRQ_SBE register, the value in this register is frozen and
///< represents the  address of the most recent SBE error that occurred
///< before the interrupt request flag was read. The register is unfrozen
///< and updated again following the clearing of the interrupt request
///< by writing the corresponding flag in the IRQCLR_SBE register. See
///< section 2.4.2 for further details.
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_SBE_BAD_ADDR_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_SBE_BAD_ADDR_BF_WID (14)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_SBE_BAD_ADDR_BF_MSK (0x00003FFF)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_SBE_BAD_ADDR_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_OFF (14)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_WID (18)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_MSK (0xFFFFC000)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_BAD_ADDR_BP_DMEM register description at address offset 0xb8
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_bad_addr_bp_dmem
  * lm_ecc_dbe_bad_addr_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_BAD_ADDR : 14;
    ///< Double Bit ECC Error Bad Address for ECC-supporting Logical Memory
    ///< (LM) 0. Records the Logical Memory address for which a double-bit
    ///< error is detected and a corresponding ECC interrupt request is generated.
    ///< Following the reading of an active interrupt request flag for the
    ///< LM in the IRQ_DBE register, the value in this register is frozen and
    ///< represents the  address of the most recent DBE error that occurred
    ///< before the interrupt request flag was read. The register is unfrozen
    ///< and updated again following the clearing of the interrupt request
    ///< by writing the corresponding flag in the IRQCLR_DBE register. See
    ///< section 2.4.2 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_14 : 18;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="14" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_bad_addr_bp_dmem_reg_t;

#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_WR_MASK (0x00000000U)


///< Double Bit ECC Error Bad Address for ECC-supporting Logical Memory
///< (LM) 0. Records the Logical Memory address for which a double-bit
///< error is detected and a corresponding ECC interrupt request is generated.
///< Following the reading of an active interrupt request flag for the
///< LM in the IRQ_DBE register, the value in this register is frozen and
///< represents the  address of the most recent DBE error that occurred
///< before the interrupt request flag was read. The register is unfrozen
///< and updated again following the clearing of the interrupt request
///< by writing the corresponding flag in the IRQCLR_DBE register. See
///< section 2.4.2 for further details.
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_DBE_BAD_ADDR_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_DBE_BAD_ADDR_BF_WID (14)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_DBE_BAD_ADDR_BF_MSK (0x00003FFF)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_DBE_BAD_ADDR_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_OFF (14)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_WID (18)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_MSK (0xFFFFC000)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_NA_31_14_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_COUNT_BP_DMEM register description at address offset 0xbc
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_count_bp_dmem
  * lm_ecc_sbe_count_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_COUNT : 8;
    ///< Single Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
    ///< 0. Records the number of single-bit errors detected for this LM, since
    ///< the last time this counter was read. Thus, on each read to this register,
    ///< the counter is reset. On overflow this counter saturates to value
    ///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
    ///< register for this LM is asserted. See section 2.4.1 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_8 : 24;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_cnt_bp_dmem_reg_t;

#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_WR_MASK (0x00000000U)


///< Single Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
///< 0. Records the number of single-bit errors detected for this LM, since
///< the last time this counter was read. Thus, on each read to this register,
///< the counter is reset. On overflow this counter saturates to value
///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
///< register for this LM is asserted. See section 2.4.1 for further details.
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_SBE_CNT_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_SBE_CNT_BF_WID ( 8)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_SBE_CNT_BF_MSK (0x000000FF)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_SBE_CNT_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_NA_31_8_BF_OFF ( 8)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_NA_31_8_BF_WID (24)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_NA_31_8_BF_MSK (0xFFFFFF00)
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_NA_31_8_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_COUNT_BP_DMEM register description at address offset 0xc0
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_count_bp_dmem
  * lm_ecc_dbe_count_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_COUNT : 8;
    ///< Double Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
    ///< 0. Records the number of double-bit errors detected for this LM, since
    ///< the last time this counter was read. Thus, on each read to this register,
    ///< the counter is reset. On overflow this counter saturates to value
    ///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
    ///< register for this LM is asserted. See section 2.4.1 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_8 : 24;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_cnt_bp_dmem_reg_t;

#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_WR_MASK (0x00000000U)


///< Double Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
///< 0. Records the number of double-bit errors detected for this LM, since
///< the last time this counter was read. Thus, on each read to this register,
///< the counter is reset. On overflow this counter saturates to value
///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
///< register for this LM is asserted. See section 2.4.1 for further details.
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_DBE_CNT_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_DBE_CNT_BF_WID ( 8)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_DBE_CNT_BF_MSK (0x000000FF)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_DBE_CNT_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_NA_31_8_BF_OFF ( 8)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_NA_31_8_BF_WID (24)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_NA_31_8_BF_MSK (0xFFFFFF00)
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_NA_31_8_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_CONTROL_SIMD0_VMEM register description at address offset 0xc4
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_control_simd0_vmem
  * lm_ecc_control_simd0_vmem_reg register.
  */

typedef union {
  struct {
    uint32_t ECC_EN : 1;
    ///< ECC Enable flag for ECC-supporting Logical Memory (LM) 0. When true,
    ///< enable ECC correction,  and generate single- and double-bit error
    ///< flags for this LM. When false all SBE and DBE errors are ignored,
    ///< and no correction of read data is performed. When this bit is false
    ///< also no interrupts are generated nor is the core halted on errors
    ///< detected by this LM.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t REFRESH_EN : 1;
    ///< ECC Refresh Enable flag for ECC-supporting Logical Memory (LM) 0.
    ///< This control bit is only available when the user property 'HasECCRefresh'
    ///< is set. When true, on a single-bit error write-back the corrected
    ///< data into the failing address location in this LM. When false, single-bit
    ///< errors are not corrected, only reported.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t IRQMSK_SBE : 1;
    ///< ECC Single Bit Error Interrupt Request Mask flag for ECC-supporting
    ///< Logical Memory (LM) 0. When true, enable interrupt request signalling
    ///< for single-bit ECC errors in this LM, on the interrupt request output
    ///< interface of the Cell. When false, disable interrupt request signalling.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t IRQMSK_DBE : 1;
    ///< ECC Double Bit Error Interrupt Request Mask flag for ECC-supporting
    ///< Logical Memory (LM) 0. When true, enable interrupt request signalling
    ///< for double-bit ECC errors in this LM, on the interrupt request output
    ///< interface of the Cell. When false, disable interrupt request signalling.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CORE_HALT_EN : 1;
    ///< ECC Core Halt Enable flag for ECC-supporting Logical Memory (LM) 0.
    ///< When true, in case this LM detects a double-bit error the program
    ///< fetch will be stopped, and the core will stall execution immediately.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t ECC_COUNT_EN : 1;
    ///< ECC Error Counter Enable flag for ECC-supporting Logical Memory (LM)
    ///< 0. When true and ECC_EN for this LM is set to true as well, enable
    ///< ECC error counting in registers LM_ECC_SBE_CNT and LM_ECC_DBE_CNT
    ///< for this LM.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t NA_31_6 : 26;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_ctrl_simd0_vmem_reg_t;

#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_WR_MASK (0x0000003fU)


///< ECC Enable flag for ECC-supporting Logical Memory (LM) 0. When true,
///< enable ECC correction,  and generate single- and double-bit error
///< flags for this LM. When false all SBE and DBE errors are ignored,
///< and no correction of read data is performed. When this bit is false
///< also no interrupts are generated nor is the core halted on errors
///< detected by this LM.
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_EN_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_EN_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_EN_BF_DEF (0x00000000)

///< ECC Refresh Enable flag for ECC-supporting Logical Memory (LM) 0.
///< This control bit is only available when the user property 'HasECCRefresh'
///< is set. When true, on a single-bit error write-back the corrected
///< data into the failing address location in this LM. When false, single-bit
///< errors are not corrected, only reported.
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_REFRESH_EN_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_REFRESH_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_REFRESH_EN_BF_MSK (0x00000002)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_REFRESH_EN_BF_DEF (0x00000000)

///< ECC Single Bit Error Interrupt Request Mask flag for ECC-supporting
///< Logical Memory (LM) 0. When true, enable interrupt request signalling
///< for single-bit ECC errors in this LM, on the interrupt request output
///< interface of the Cell. When false, disable interrupt request signalling.
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_SBE_BF_OFF ( 2)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_SBE_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_SBE_BF_MSK (0x00000004)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_SBE_BF_DEF (0x00000000)

///< ECC Double Bit Error Interrupt Request Mask flag for ECC-supporting
///< Logical Memory (LM) 0. When true, enable interrupt request signalling
///< for double-bit ECC errors in this LM, on the interrupt request output
///< interface of the Cell. When false, disable interrupt request signalling.
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_DBE_BF_OFF ( 3)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_DBE_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_DBE_BF_MSK (0x00000008)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_IRQMSK_DBE_BF_DEF (0x00000000)

///< ECC Core Halt Enable flag for ECC-supporting Logical Memory (LM) 0.
///< When true, in case this LM detects a double-bit error the program
///< fetch will be stopped, and the core will stall execution immediately.
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_CORE_HALT_EN_BF_OFF ( 4)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_CORE_HALT_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_CORE_HALT_EN_BF_MSK (0x00000010)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_CORE_HALT_EN_BF_DEF (0x00000000)

///< ECC Error Counter Enable flag for ECC-supporting Logical Memory (LM)
///< 0. When true and ECC_EN for this LM is set to true as well, enable
///< ECC error counting in registers LM_ECC_SBE_CNT and LM_ECC_DBE_CNT
///< for this LM.
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_CNT_EN_BF_OFF ( 5)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_CNT_EN_BF_WID ( 1)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_CNT_EN_BF_MSK (0x00000020)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ECC_CNT_EN_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_NA_31_6_BF_OFF ( 6)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_NA_31_6_BF_WID (26)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_NA_31_6_BF_MSK (0xFFFFFFC0)
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_NA_31_6_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM register description at address offset 0xc8
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_irqprio_simd0_vmem
  * lm_ecc_sbe_irqprio_simd0_vmem_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_IRQPRIO : 1;
    ///< ECC Single Bit Error (SBE) Interrupt Priority for ECC-supporting Logical
    ///< Memory (LM) 0. Sets priority of Single Bit ECC Error (SBE) interrupts
    ///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_SBE
    ///< register. See section 2.3 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_irqprio_simd0_vmem_reg_t;

#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_WR_MASK (0x00000001U)


///< ECC Single Bit Error (SBE) Interrupt Priority for ECC-supporting Logical
///< Memory (LM) 0. Sets priority of Single Bit ECC Error (SBE) interrupts
///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_SBE
///< register. See section 2.3 for further details.
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_SBE_IRQPRIO_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_SBE_IRQPRIO_BF_WID ( 1)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_SBE_IRQPRIO_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_SBE_IRQPRIO_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM register description at address offset 0xcc
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_irqprio_simd0_vmem
  * lm_ecc_dbe_irqprio_simd0_vmem_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_IRQPRIO : 1;
    ///< ECC Double Bit Error (DBE) Interrupt Priority for ECC-supporting Logical
    ///< Memory (LM) 0. Sets priority of Double Bit ECC Error (DBE) interrupts
    ///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
    ///< highest priority. Write access to this register will modify the register
    ///< contents only if the corresponding interrupt is masked in the IRQMSK_DBE
    ///< register. See section 2.3 for further details.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_irqprio_simd0_vmem_reg_t;

#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_WR_MASK (0x00000001U)


///< ECC Double Bit Error (DBE) Interrupt Priority for ECC-supporting Logical
///< Memory (LM) 0. Sets priority of Double Bit ECC Error (DBE) interrupts
///< for this LM, where 0 indicates lowest priority, and 2^Q-1 indicates
///< highest priority. Write access to this register will modify the register
///< contents only if the corresponding interrupt is masked in the IRQMSK_DBE
///< register. See section 2.3 for further details.
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_DBE_IRQPRIO_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_DBE_IRQPRIO_BF_WID ( 1)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_DBE_IRQPRIO_BF_MSK (0x00000001)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_DBE_IRQPRIO_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM register description at address offset 0xd0
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_bad_addr_simd0_vmem
  * lm_ecc_sbe_bad_addr_simd0_vmem_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_BAD_ADDR : 16;
    ///< Single Bit ECC Error Bad Address for ECC-supporting Logical Memory
    ///< (LM) 0. Records the Logical Memory address for which a single-bit
    ///< error is detected and a corresponding ECC interrupt request is generated.
    ///< Following the reading of an active interrupt request flag for the
    ///< LM in the IRQ_SBE register, the value in this register is frozen and
    ///< represents the  address of the most recent SBE error that occurred
    ///< before the interrupt request flag was read. The register is unfrozen
    ///< and updated again following the clearing of the interrupt request
    ///< by writing the corresponding flag in the IRQCLR_SBE register. See
    ///< section 2.4.2 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_16 : 16;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_bad_addr_simd0_vmem_reg_t;

#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_WR_MASK (0x00000000U)


///< Single Bit ECC Error Bad Address for ECC-supporting Logical Memory
///< (LM) 0. Records the Logical Memory address for which a single-bit
///< error is detected and a corresponding ECC interrupt request is generated.
///< Following the reading of an active interrupt request flag for the
///< LM in the IRQ_SBE register, the value in this register is frozen and
///< represents the  address of the most recent SBE error that occurred
///< before the interrupt request flag was read. The register is unfrozen
///< and updated again following the clearing of the interrupt request
///< by writing the corresponding flag in the IRQCLR_SBE register. See
///< section 2.4.2 for further details.
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_SBE_BAD_ADDR_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_SBE_BAD_ADDR_BF_WID (16)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_SBE_BAD_ADDR_BF_MSK (0x0000FFFF)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_SBE_BAD_ADDR_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_OFF (16)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_WID (16)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_MSK (0xFFFF0000)
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM register description at address offset 0xd4
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_bad_addr_simd0_vmem
  * lm_ecc_dbe_bad_addr_simd0_vmem_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_BAD_ADDR : 16;
    ///< Double Bit ECC Error Bad Address for ECC-supporting Logical Memory
    ///< (LM) 0. Records the Logical Memory address for which a double-bit
    ///< error is detected and a corresponding ECC interrupt request is generated.
    ///< Following the reading of an active interrupt request flag for the
    ///< LM in the IRQ_DBE register, the value in this register is frozen and
    ///< represents the  address of the most recent DBE error that occurred
    ///< before the interrupt request flag was read. The register is unfrozen
    ///< and updated again following the clearing of the interrupt request
    ///< by writing the corresponding flag in the IRQCLR_DBE register. See
    ///< section 2.4.2 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_16 : 16;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_bad_addr_simd0_vmem_reg_t;

#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_WR_MASK (0x00000000U)


///< Double Bit ECC Error Bad Address for ECC-supporting Logical Memory
///< (LM) 0. Records the Logical Memory address for which a double-bit
///< error is detected and a corresponding ECC interrupt request is generated.
///< Following the reading of an active interrupt request flag for the
///< LM in the IRQ_DBE register, the value in this register is frozen and
///< represents the  address of the most recent DBE error that occurred
///< before the interrupt request flag was read. The register is unfrozen
///< and updated again following the clearing of the interrupt request
///< by writing the corresponding flag in the IRQCLR_DBE register. See
///< section 2.4.2 for further details.
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_DBE_BAD_ADDR_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_DBE_BAD_ADDR_BF_WID (16)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_DBE_BAD_ADDR_BF_MSK (0x0000FFFF)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_DBE_BAD_ADDR_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_OFF (16)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_WID (16)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_MSK (0xFFFF0000)
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_NA_31_16_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_SBE_COUNT_SIMD0_VMEM register description at address offset 0xd8
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_sbe_count_simd0_vmem
  * lm_ecc_sbe_count_simd0_vmem_reg register.
  */

typedef union {
  struct {
    uint32_t SBE_COUNT : 8;
    ///< Single Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
    ///< 0. Records the number of single-bit errors detected for this LM, since
    ///< the last time this counter was read. Thus, on each read to this register,
    ///< the counter is reset. On overflow this counter saturates to value
    ///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
    ///< register for this LM is asserted. See section 2.4.1 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_8 : 24;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_sbe_cnt_simd0_vmem_reg_t;

#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_WR_MASK (0x00000000U)


///< Single Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
///< 0. Records the number of single-bit errors detected for this LM, since
///< the last time this counter was read. Thus, on each read to this register,
///< the counter is reset. On overflow this counter saturates to value
///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
///< register for this LM is asserted. See section 2.4.1 for further details.
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_SBE_CNT_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_SBE_CNT_BF_WID ( 8)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_SBE_CNT_BF_MSK (0x000000FF)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_SBE_CNT_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_NA_31_8_BF_OFF ( 8)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_NA_31_8_BF_WID (24)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_NA_31_8_BF_MSK (0xFFFFFF00)
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_NA_31_8_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_ECC_DBE_COUNT_SIMD0_VMEM register description at address offset 0xdc
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_ecc_dbe_count_simd0_vmem
  * lm_ecc_dbe_count_simd0_vmem_reg register.
  */

typedef union {
  struct {
    uint32_t DBE_COUNT : 8;
    ///< Double Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
    ///< 0. Records the number of double-bit errors detected for this LM, since
    ///< the last time this counter was read. Thus, on each read to this register,
    ///< the counter is reset. On overflow this counter saturates to value
    ///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
    ///< register for this LM is asserted. See section 2.4.1 for further details.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_8 : 24;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_ecc_dbe_cnt_simd0_vmem_reg_t;

#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_WR_MASK (0x00000000U)


///< Double Bit ECC Error Counter for ECC-supporting Logical Memory (LM)
///< 0. Records the number of double-bit errors detected for this LM, since
///< the last time this counter was read. Thus, on each read to this register,
///< the counter is reset. On overflow this counter saturates to value
///< 255. Counting is enabled only if the ECC_COUNT_EN flag in the LM_ECC_CONTROL
///< register for this LM is asserted. See section 2.4.1 for further details.
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_DBE_CNT_BF_OFF ( 0)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_DBE_CNT_BF_WID ( 8)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_DBE_CNT_BF_MSK (0x000000FF)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_DBE_CNT_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_NA_31_8_BF_OFF ( 8)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_NA_31_8_BF_WID (24)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_NA_31_8_BF_MSK (0xFFFFFF00)
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_NA_31_8_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_SDFGATE_BPCA_BP_DMEM register description at address offset 0xe0
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_sdfgate_bpca_bp_dmem
  * lm_sdfgate_bpca_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t BPCA : 14;
    ///< SDF-Gate Base Pointer Copy Address for SDF-Gate contained in Logical
    ///< Memory (LM) 0 : Byte address in which the remote pointer for SDF channel
    ///< index 0 would be copied to. The addresses for the other channels are
    ///< located in successive 32-bit addresses, i.e. PCA[i] = base_PCA + 4*i
    ///< . All 32-bit write accesses via the external interface of this memory
    ///< after this register has been set will be detected as potential SDF-related
    ///< messages from remote nodes to this cell if their address is within
    ///< the range [base_PCA : base_PCA + PCA[#SDF-channels]].
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_14 : 18;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="14" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_sdfgate_bpca_bp_dmem_reg_t;

#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_WR_MASK (0x00003fffU)


///< SDF-Gate Base Pointer Copy Address for SDF-Gate contained in Logical
///< Memory (LM) 0 : Byte address in which the remote pointer for SDF channel
///< index 0 would be copied to. The addresses for the other channels are
///< located in successive 32-bit addresses, i.e. PCA[i] = base_PCA + 4*i
///< . All 32-bit write accesses via the external interface of this memory
///< after this register has been set will be detected as potential SDF-related
///< messages from remote nodes to this cell if their address is within
///< the range [base_PCA : base_PCA + PCA[#SDF-channels]].
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_BPCA_BF_OFF ( 0)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_BPCA_BF_WID (14)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_BPCA_BF_MSK (0x00003FFF)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_BPCA_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_NA_31_14_BF_OFF (14)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_NA_31_14_BF_WID (18)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_NA_31_14_BF_MSK (0xFFFFC000)
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_NA_31_14_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM register description at address offset 0xe4
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_sdfgate_ridc_int_ctrl_bp_dmem
  * lm_sdfgate_ridc_int_ctrl_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t IRQMSK_SDF : 1;
    ///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Request Mask flag
    ///< for the SDF-Gate contained in Logical Memory (LM) 0. When true, enable
    ///< interrupt request signalling for RIDC OOB errors in this LM, on the
    ///< interrupt request output interface of the Cell. When false, disable
    ///< interrupt request signalling.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_sdfgate_ridc_int_ctrl_bp_dmem_reg_t;

#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_WR_MASK (0x00000001U)


///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Request Mask flag
///< for the SDF-Gate contained in Logical Memory (LM) 0. When true, enable
///< interrupt request signalling for RIDC OOB errors in this LM, on the
///< interrupt request output interface of the Cell. When false, disable
///< interrupt request signalling.
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_IRQMSK_SDF_BF_OFF ( 0)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_IRQMSK_SDF_BF_WID ( 1)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_IRQMSK_SDF_BF_MSK (0x00000001)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_IRQMSK_SDF_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM register description at address offset 0xe8
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_sdfgate_ridc_irqprio_bp_dmem
  * lm_sdfgate_ridc_irqprio_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t IRQPRIO_SDF : 1;
    ///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Priority for the
    ///< SDF-Gate contained in Logical Memory (LM) 0. Sets priority of RIDC
    ///< OOB interrupts for this LM, where 0 indicates lowest priority, and
    ///< 2^Q-1 indicates highest priority. Write access to this register will
    ///< modify the register contents only if the corresponding interrupt is
    ///< masked in the IRQMSK_RIDC_OOB register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NA_31_1 : 31;
    ///< Reserved/unused.
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_sdfgate_ridc_irqprio_bp_dmem_reg_t;

#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_WR_MASK (0x00000001U)


///< SDF-Gate Remote Indicator Out-Of-Bounds Interrupt Priority for the
///< SDF-Gate contained in Logical Memory (LM) 0. Sets priority of RIDC
///< OOB interrupts for this LM, where 0 indicates lowest priority, and
///< 2^Q-1 indicates highest priority. Write access to this register will
///< modify the register contents only if the corresponding interrupt is
///< masked in the IRQMSK_RIDC_OOB register.
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_IRQPRIO_SDF_BF_OFF ( 0)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_IRQPRIO_SDF_BF_WID ( 1)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_IRQPRIO_SDF_BF_MSK (0x00000001)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_IRQPRIO_SDF_BF_DEF (0x00000000)

///< Reserved/unused.
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_NA_31_1_BF_OFF ( 1)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_NA_31_1_BF_WID (31)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_NA_31_1_BF_MSK (0xFFFFFFFE)
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_NA_31_1_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_LM_SDFGATE_RIDC_STAT_BP_DMEM register description at address offset 0xec
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/lm_sdfgate_ridc_stat_bp_dmem
  * lm_sdfgate_ridc_stat_bp_dmem_reg register.
  */

typedef union {
  struct {
    uint32_t RIDC_OOB_VAL : 16;
    ///< SDF-Gate Remote Indicator Out-Of_bound value for SDF-Gate contained
    ///< in Logical Memory (LM) 0. Records the remote indicator value for which
    ///< a RIDC_OOB interrupt is detected and a corresponding interrupt request
    ///< is generated. This register is frozen at the moment the interrupt
    ///< request flag for the LM in the IRQ_IDC_OOB register is set, and thus
    ///< represents the  value of the first remote indicator out-of-bounds
    ///< value that caused the interrupt request flag to be set. The register
    ///< is unfrozen and updated again following the clearing of the interrupt
    ///< request by writing the corresponding flag in the IRQCLR_RIDC_OOB register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t RIDC_OOB_CHID : 16;
    ///< SDF-Gate Remote Indicator Out-Of_bound channel-id for SDF-Gate contained
    ///< in Logical Memory (LM) 0. Records the remote indicator channel-id
    ///< for which a RIDC_OOB interrupt is detected and a corresponding interrupt
    ///< request is generated. This register is frozen at the moment the interrupt
    ///< request flag for the LM in the IRQ_IDC_OOB register is set, and thus
    ///< represents the  channel-id of the first remote indicator out-of-bounds
    ///< value that caused the interrupt request flag to be set. The register
    ///< is unfrozen and updated again following the clearing of the interrupt
    ///< request by writing the corresponding flag in the IRQCLR_RIDC_OOB register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_lm_sdfgate_ridc_stat_bp_dmem_reg_t;

#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_DEFAULT (0x00000000U)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RD_MASK (0xffffffffU)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_WR_MASK (0x00000000U)


///< SDF-Gate Remote Indicator Out-Of_bound value for SDF-Gate contained
///< in Logical Memory (LM) 0. Records the remote indicator value for which
///< a RIDC_OOB interrupt is detected and a corresponding interrupt request
///< is generated. This register is frozen at the moment the interrupt
///< request flag for the LM in the IRQ_IDC_OOB register is set, and thus
///< represents the  value of the first remote indicator out-of-bounds
///< value that caused the interrupt request flag to be set. The register
///< is unfrozen and updated again following the clearing of the interrupt
///< request by writing the corresponding flag in the IRQCLR_RIDC_OOB register.
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_VAL_BF_OFF ( 0)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_VAL_BF_WID (16)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_VAL_BF_MSK (0x0000FFFF)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_VAL_BF_DEF (0x00000000)

///< SDF-Gate Remote Indicator Out-Of_bound channel-id for SDF-Gate contained
///< in Logical Memory (LM) 0. Records the remote indicator channel-id
///< for which a RIDC_OOB interrupt is detected and a corresponding interrupt
///< request is generated. This register is frozen at the moment the interrupt
///< request flag for the LM in the IRQ_IDC_OOB register is set, and thus
///< represents the  channel-id of the first remote indicator out-of-bounds
///< value that caused the interrupt request flag to be set. The register
///< is unfrozen and updated again following the clearing of the interrupt
///< request by writing the corresponding flag in the IRQCLR_RIDC_OOB register.
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_CHID_BF_OFF (16)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_CHID_BF_WID (16)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_CHID_BF_MSK (0xFFFF0000)
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_RIDC_OOB_CHID_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_SEG_BASE_0_BP_XMEM_EXT_MEM_IF register description at address offset 0xf0
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/seg_base_0_bp_xmem_ext_mem_if
  * seg_base_0_bp_xmem_ext_mem_if_reg register.
  */

typedef union {
  struct {
    uint32_t BASE_ADDRESS : 32;
    ///< Base address for segment 0 of initiator interface bp_xmem_ext_mem_if
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_seg_base_0_bp_xmem_ext_if_reg_t;

#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_DEFAULT (0x00000000U)
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_RD_MASK (0xffffffffU)
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_WR_MASK (0xffffffffU)


///< Base address for segment 0 of initiator interface bp_xmem_ext_mem_if
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_BASE_BF_OFF ( 0)
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_BASE_BF_WID (32)
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_BASE_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_BASE_BF_DEF (0x00000000)


/** @brief VE32_CELL_MAP_MEM_VE32_CELL_MAP_SEG_BASE_0_SIMD0_XVMEM_EXT_MEM_IF register description at address offset 0xfc
  *
  * Register default value:        0x00000000
  * Register full path in IP: ve32_cell_map_MEM/ve32_cell_map/seg_base_0_simd0_xvmem_ext_mem_if
  * seg_base_0_simd0_xvmem_ext_mem_if_reg register.
  */

typedef union {
  struct {
    uint32_t BASE_ADDRESS : 32;
    ///< Base address for segment 0 of initiator interface simd0_xvmem_ext_mem_if
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} ve32_cell_seg_base_0_simd0_xvmem_ext_if_reg_t;

#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_DEFAULT (0x00000000U)
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_RD_MASK (0xffffffffU)
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_WR_MASK (0xffffffffU)


///< Base address for segment 0 of initiator interface simd0_xvmem_ext_mem_if
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_BASE_BF_OFF ( 0)
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_BASE_BF_WID (32)
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_BASE_BF_MSK (0xFFFFFFFF)
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_BASE_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define VE32_CELL_CTRL_REG(_BASE) ((ve32_cell_ctrl_reg_t*) VE32_CELL_CTRL_ADR(_BASE))
#define VE32_CELL_START_ADDR_REG(_BASE) ((ve32_cell_start_addr_reg_t*) VE32_CELL_START_ADDR_ADR(_BASE))
#define VE32_CELL_STAT_REG(_BASE) ((ve32_cell_stat_reg_t*) VE32_CELL_STAT_ADR(_BASE))
#define VE32_CELL_ID_REG(_BASE) ((ve32_cell_id_reg_t*) VE32_CELL_ID_ADR(_BASE))
#define VE32_CELL_CNT_EXE_LSBS_REG(_BASE) ((ve32_cell_cnt_exe_lsbs_reg_t*) VE32_CELL_CNT_EXE_LSBS_ADR(_BASE))
#define VE32_CELL_CNT_EXE_MSBS_REG(_BASE) ((ve32_cell_cnt_exe_msbs_reg_t*) VE32_CELL_CNT_EXE_MSBS_ADR(_BASE))
#define VE32_CELL_CNT_SLP_LSBS_REG(_BASE) ((ve32_cell_cnt_slp_lsbs_reg_t*) VE32_CELL_CNT_SLP_LSBS_ADR(_BASE))
#define VE32_CELL_CNT_SLP_MSBS_REG(_BASE) ((ve32_cell_cnt_slp_msbs_reg_t*) VE32_CELL_CNT_SLP_MSBS_ADR(_BASE))
#define VE32_CELL_CNT_CLK_LSBS_REG(_BASE) ((ve32_cell_cnt_clk_lsbs_reg_t*) VE32_CELL_CNT_CLK_LSBS_ADR(_BASE))
#define VE32_CELL_CNT_CLK_MSBS_REG(_BASE) ((ve32_cell_cnt_clk_msbs_reg_t*) VE32_CELL_CNT_CLK_MSBS_ADR(_BASE))
#define VE32_CELL_ECC_IRQ_SBE_REG(_BASE) ((ve32_cell_ecc_irq_sbe_reg_t*) VE32_CELL_ECC_IRQ_SBE_ADR(_BASE))
#define VE32_CELL_ECC_IRQ_DBE_REG(_BASE) ((ve32_cell_ecc_irq_dbe_reg_t*) VE32_CELL_ECC_IRQ_DBE_ADR(_BASE))
#define VE32_CELL_ECC_IRQCLR_SBE_REG(_BASE) ((ve32_cell_ecc_irqclr_sbe_reg_t*) VE32_CELL_ECC_IRQCLR_SBE_ADR(_BASE))
#define VE32_CELL_ECC_IRQCLR_DBE_REG(_BASE) ((ve32_cell_ecc_irqclr_dbe_reg_t*) VE32_CELL_ECC_IRQCLR_DBE_ADR(_BASE))
#define VE32_CELL_SEQUENCER_IRQ_STTR_REG(_BASE) ((ve32_cell_sequencer_irq_sttr_reg_t*) VE32_CELL_SEQUENCER_IRQ_STTR_ADR(_BASE))
#define VE32_CELL_IRQPRIO_STTR_IDLE_REG(_BASE) ((ve32_cell_irqprio_sttr_idle_reg_t*) VE32_CELL_IRQPRIO_STTR_IDLE_ADR(_BASE))
#define VE32_CELL_IRQPRIO_STTR_SLEEP_REG(_BASE) ((ve32_cell_irqprio_sttr_sleep_reg_t*) VE32_CELL_IRQPRIO_STTR_SLEEP_ADR(_BASE))
#define VE32_CELL_IRQPRIO_STTR_FALSE_START_REG(_BASE) ((ve32_cell_irqprio_sttr_false_start_reg_t*) VE32_CELL_IRQPRIO_STTR_FALSE_START_ADR(_BASE))
#define VE32_CELL_SDFGATE_IRQ_RIDC_OOB_REG(_BASE) ((ve32_cell_sdfgate_irq_ridc_oob_reg_t*) VE32_CELL_SDFGATE_IRQ_RIDC_OOB_ADR(_BASE))
#define VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_REG(_BASE) ((ve32_cell_sdfgate_irqclr_ridc_oob_reg_t*) VE32_CELL_SDFGATE_IRQCLR_RIDC_OOB_ADR(_BASE))
#define VE32_CELL_BP_DMEM_ARB_DMEM_REQ_REG(_BASE) ((ve32_cell_bp_dmem_arb_dmem_req_reg_t*) VE32_CELL_BP_DMEM_ARB_DMEM_REQ_ADR(_BASE))
#define VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_REG(_BASE) ((ve32_cell_simd0_vmem_arb_vmem_wp_reg_t*) VE32_CELL_SIMD0_VMEM_ARB_VMEM_WP_ADR(_BASE))
#define VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_REG(_BASE) ((ve32_cell_simd0_lutmem_arb_lutmem_wp_reg_t*) VE32_CELL_SIMD0_LUTMEM_ARB_LUTMEM_WP_ADR(_BASE))
#define VE32_CELL_LM_ECC_CTRL_BP_CFG_REG(_BASE) ((ve32_cell_lm_ecc_ctrl_bp_cfg_reg_t*) VE32_CELL_LM_ECC_CTRL_BP_CFG_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_REG(_BASE) ((ve32_cell_lm_ecc_sbe_irqprio_bp_cfg_reg_t*) VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_CFG_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_REG(_BASE) ((ve32_cell_lm_ecc_dbe_irqprio_bp_cfg_reg_t*) VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_CFG_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_REG(_BASE) ((ve32_cell_lm_ecc_sbe_bad_addr_bp_cfg_reg_t*) VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_CFG_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_REG(_BASE) ((ve32_cell_lm_ecc_dbe_bad_addr_bp_cfg_reg_t*) VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_CFG_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_REG(_BASE) ((ve32_cell_lm_ecc_sbe_cnt_bp_cfg_reg_t*) VE32_CELL_LM_ECC_SBE_CNT_BP_CFG_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_REG(_BASE) ((ve32_cell_lm_ecc_dbe_cnt_bp_cfg_reg_t*) VE32_CELL_LM_ECC_DBE_CNT_BP_CFG_ADR(_BASE))
#define VE32_CELL_LM_ECC_CTRL_BP_DMEM_REG(_BASE) ((ve32_cell_lm_ecc_ctrl_bp_dmem_reg_t*) VE32_CELL_LM_ECC_CTRL_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_REG(_BASE) ((ve32_cell_lm_ecc_sbe_irqprio_bp_dmem_reg_t*) VE32_CELL_LM_ECC_SBE_IRQPRIO_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_REG(_BASE) ((ve32_cell_lm_ecc_dbe_irqprio_bp_dmem_reg_t*) VE32_CELL_LM_ECC_DBE_IRQPRIO_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_REG(_BASE) ((ve32_cell_lm_ecc_sbe_bad_addr_bp_dmem_reg_t*) VE32_CELL_LM_ECC_SBE_BAD_ADDR_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_REG(_BASE) ((ve32_cell_lm_ecc_dbe_bad_addr_bp_dmem_reg_t*) VE32_CELL_LM_ECC_DBE_BAD_ADDR_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_REG(_BASE) ((ve32_cell_lm_ecc_sbe_cnt_bp_dmem_reg_t*) VE32_CELL_LM_ECC_SBE_CNT_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_REG(_BASE) ((ve32_cell_lm_ecc_dbe_cnt_bp_dmem_reg_t*) VE32_CELL_LM_ECC_DBE_CNT_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_REG(_BASE) ((ve32_cell_lm_ecc_ctrl_simd0_vmem_reg_t*) VE32_CELL_LM_ECC_CTRL_SIMD0_VMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_REG(_BASE) ((ve32_cell_lm_ecc_sbe_irqprio_simd0_vmem_reg_t*) VE32_CELL_LM_ECC_SBE_IRQPRIO_SIMD0_VMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_REG(_BASE) ((ve32_cell_lm_ecc_dbe_irqprio_simd0_vmem_reg_t*) VE32_CELL_LM_ECC_DBE_IRQPRIO_SIMD0_VMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_REG(_BASE) ((ve32_cell_lm_ecc_sbe_bad_addr_simd0_vmem_reg_t*) VE32_CELL_LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_REG(_BASE) ((ve32_cell_lm_ecc_dbe_bad_addr_simd0_vmem_reg_t*) VE32_CELL_LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_REG(_BASE) ((ve32_cell_lm_ecc_sbe_cnt_simd0_vmem_reg_t*) VE32_CELL_LM_ECC_SBE_CNT_SIMD0_VMEM_ADR(_BASE))
#define VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_REG(_BASE) ((ve32_cell_lm_ecc_dbe_cnt_simd0_vmem_reg_t*) VE32_CELL_LM_ECC_DBE_CNT_SIMD0_VMEM_ADR(_BASE))
#define VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_REG(_BASE) ((ve32_cell_lm_sdfgate_bpca_bp_dmem_reg_t*) VE32_CELL_LM_SDFGATE_BPCA_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_REG(_BASE) ((ve32_cell_lm_sdfgate_ridc_int_ctrl_bp_dmem_reg_t*) VE32_CELL_LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_REG(_BASE) ((ve32_cell_lm_sdfgate_ridc_irqprio_bp_dmem_reg_t*) VE32_CELL_LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM_ADR(_BASE))
#define VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_REG(_BASE) ((ve32_cell_lm_sdfgate_ridc_stat_bp_dmem_reg_t*) VE32_CELL_LM_SDFGATE_RIDC_STAT_BP_DMEM_ADR(_BASE))
#define VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_REG(_BASE) ((ve32_cell_seg_base_0_bp_xmem_ext_if_reg_t*) VE32_CELL_SEG_BASE_0_BP_XMEM_EXT_IF_ADR(_BASE))
#define VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_REG(_BASE) ((ve32_cell_seg_base_0_simd0_xvmem_ext_if_reg_t*) VE32_CELL_SEG_BASE_0_SIMD0_XVMEM_EXT_IF_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    ve32_cell_ctrl_reg_t CTRL; /*< Address offset = 0x0 */
    ve32_cell_start_addr_reg_t START_ADDR; /*< Address offset = 0x4 */
    ve32_cell_stat_reg_t STAT; /*< Address offset = 0x8 */
    ve32_cell_id_reg_t CELL_ID; /*< Address offset = 0xc */
    ve32_cell_cnt_exe_lsbs_reg_t CNT_EXE_LSBS; /*< Address offset = 0x10 */
    ve32_cell_cnt_exe_msbs_reg_t CNT_EXE_MSBS; /*< Address offset = 0x14 */
    ve32_cell_cnt_slp_lsbs_reg_t CNT_SLP_LSBS; /*< Address offset = 0x18 */
    ve32_cell_cnt_slp_msbs_reg_t CNT_SLP_MSBS; /*< Address offset = 0x1c */
    ve32_cell_cnt_clk_lsbs_reg_t CNT_CLK_LSBS; /*< Address offset = 0x20 */
    ve32_cell_cnt_clk_msbs_reg_t CNT_CLK_MSBS; /*< Address offset = 0x24 */
    ve32_cell_ecc_irq_sbe_reg_t ECC_IRQ_SBE; /*< Address offset = 0x28 */
    ve32_cell_ecc_irq_dbe_reg_t ECC_IRQ_DBE; /*< Address offset = 0x2c */
    ve32_cell_ecc_irqclr_sbe_reg_t ECC_IRQCLR_SBE; /*< Address offset = 0x30 */
    ve32_cell_ecc_irqclr_dbe_reg_t ECC_IRQCLR_DBE; /*< Address offset = 0x34 */
    ve32_cell_sequencer_irq_sttr_reg_t SEQUENCER_IRQ_STTR; /*< Address offset = 0x38 */
    const uint8_t        reservedArea0 [8];   /*< Address offset = 0x3c */
    ve32_cell_irqprio_sttr_idle_reg_t IRQPRIO_STTR_IDLE; /*< Address offset = 0x44 */
    ve32_cell_irqprio_sttr_sleep_reg_t IRQPRIO_STTR_SLEEP; /*< Address offset = 0x48 */
    ve32_cell_irqprio_sttr_false_start_reg_t IRQPRIO_STTR_FALSE_START; /*< Address offset = 0x4c */
    ve32_cell_sdfgate_irq_ridc_oob_reg_t SDFGATE_IRQ_RIDC_OOB; /*< Address offset = 0x50 */
    ve32_cell_sdfgate_irqclr_ridc_oob_reg_t SDFGATE_IRQCLR_RIDC_OOB; /*< Address offset = 0x54 */
    const uint8_t        reservedArea1 [40];  /*< Address offset = 0x58 */
    ve32_cell_bp_dmem_arb_dmem_req_reg_t BP_DMEM_ARB_DMEM_REQ; /*< Address offset = 0x80 */
    ve32_cell_simd0_vmem_arb_vmem_wp_reg_t SIMD0_VMEM_ARB_VMEM_WP; /*< Address offset = 0x84 */
    ve32_cell_simd0_lutmem_arb_lutmem_wp_reg_t SIMD0_LUTMEM_ARB_LUTMEM_WP; /*< Address offset = 0x88 */
    ve32_cell_lm_ecc_ctrl_bp_cfg_reg_t LM_ECC_CTRL_BP_CFG; /*< Address offset = 0x8c */
    ve32_cell_lm_ecc_sbe_irqprio_bp_cfg_reg_t LM_ECC_SBE_IRQPRIO_BP_CFG; /*< Address offset = 0x90 */
    ve32_cell_lm_ecc_dbe_irqprio_bp_cfg_reg_t LM_ECC_DBE_IRQPRIO_BP_CFG; /*< Address offset = 0x94 */
    ve32_cell_lm_ecc_sbe_bad_addr_bp_cfg_reg_t LM_ECC_SBE_BAD_ADDR_BP_CFG; /*< Address offset = 0x98 */
    ve32_cell_lm_ecc_dbe_bad_addr_bp_cfg_reg_t LM_ECC_DBE_BAD_ADDR_BP_CFG; /*< Address offset = 0x9c */
    ve32_cell_lm_ecc_sbe_cnt_bp_cfg_reg_t LM_ECC_SBE_CNT_BP_CFG; /*< Address offset = 0xa0 */
    ve32_cell_lm_ecc_dbe_cnt_bp_cfg_reg_t LM_ECC_DBE_CNT_BP_CFG; /*< Address offset = 0xa4 */
    ve32_cell_lm_ecc_ctrl_bp_dmem_reg_t LM_ECC_CTRL_BP_DMEM; /*< Address offset = 0xa8 */
    ve32_cell_lm_ecc_sbe_irqprio_bp_dmem_reg_t LM_ECC_SBE_IRQPRIO_BP_DMEM; /*< Address offset = 0xac */
    ve32_cell_lm_ecc_dbe_irqprio_bp_dmem_reg_t LM_ECC_DBE_IRQPRIO_BP_DMEM; /*< Address offset = 0xb0 */
    ve32_cell_lm_ecc_sbe_bad_addr_bp_dmem_reg_t LM_ECC_SBE_BAD_ADDR_BP_DMEM; /*< Address offset = 0xb4 */
    ve32_cell_lm_ecc_dbe_bad_addr_bp_dmem_reg_t LM_ECC_DBE_BAD_ADDR_BP_DMEM; /*< Address offset = 0xb8 */
    ve32_cell_lm_ecc_sbe_cnt_bp_dmem_reg_t LM_ECC_SBE_CNT_BP_DMEM; /*< Address offset = 0xbc */
    ve32_cell_lm_ecc_dbe_cnt_bp_dmem_reg_t LM_ECC_DBE_CNT_BP_DMEM; /*< Address offset = 0xc0 */
    ve32_cell_lm_ecc_ctrl_simd0_vmem_reg_t LM_ECC_CTRL_SIMD0_VMEM; /*< Address offset = 0xc4 */
    ve32_cell_lm_ecc_sbe_irqprio_simd0_vmem_reg_t LM_ECC_SBE_IRQPRIO_SIMD0_VMEM; /*< Address offset = 0xc8 */
    ve32_cell_lm_ecc_dbe_irqprio_simd0_vmem_reg_t LM_ECC_DBE_IRQPRIO_SIMD0_VMEM; /*< Address offset = 0xcc */
    ve32_cell_lm_ecc_sbe_bad_addr_simd0_vmem_reg_t LM_ECC_SBE_BAD_ADDR_SIMD0_VMEM; /*< Address offset = 0xd0 */
    ve32_cell_lm_ecc_dbe_bad_addr_simd0_vmem_reg_t LM_ECC_DBE_BAD_ADDR_SIMD0_VMEM; /*< Address offset = 0xd4 */
    ve32_cell_lm_ecc_sbe_cnt_simd0_vmem_reg_t LM_ECC_SBE_CNT_SIMD0_VMEM; /*< Address offset = 0xd8 */
    ve32_cell_lm_ecc_dbe_cnt_simd0_vmem_reg_t LM_ECC_DBE_CNT_SIMD0_VMEM; /*< Address offset = 0xdc */
    ve32_cell_lm_sdfgate_bpca_bp_dmem_reg_t LM_SDFGATE_BPCA_BP_DMEM; /*< Address offset = 0xe0 */
    ve32_cell_lm_sdfgate_ridc_int_ctrl_bp_dmem_reg_t LM_SDFGATE_RIDC_INT_CTRL_BP_DMEM; /*< Address offset = 0xe4 */
    ve32_cell_lm_sdfgate_ridc_irqprio_bp_dmem_reg_t LM_SDFGATE_RIDC_IRQPRIO_BP_DMEM; /*< Address offset = 0xe8 */
    ve32_cell_lm_sdfgate_ridc_stat_bp_dmem_reg_t LM_SDFGATE_RIDC_STAT_BP_DMEM; /*< Address offset = 0xec */
    ve32_cell_seg_base_0_bp_xmem_ext_if_reg_t SEG_BASE_0_BP_XMEM_EXT_IF; /*< Address offset = 0xf0 */
    const uint8_t        reservedArea2 [8];   /*< Address offset = 0xf4 */
    ve32_cell_seg_base_0_simd0_xvmem_ext_if_reg_t SEG_BASE_0_SIMD0_XVMEM_EXT_IF; /*< Address offset = 0xfc */
} ve32_cell_t;     // size: 0x00c8

// AddressSpace struct pointer
//
#define VEXABC0_SC_VE32_CELL   ((ve32_cell_t*) VEXABC0_SC_VE32_CELL_BASE)
#define VEXABC1_SC_VE32_CELL   ((ve32_cell_t*) VEXABC1_SC_VE32_CELL_BASE)
#define VEXABC2_SC_VE32_CELL   ((ve32_cell_t*) VEXABC2_SC_VE32_CELL_BASE)
#define VEXABC3_SC_VE32_CELL   ((ve32_cell_t*) VEXABC3_SC_VE32_CELL_BASE)
#define VEXABC4_SC_VE32_CELL   ((ve32_cell_t*) VEXABC4_SC_VE32_CELL_BASE)
#define VEXABC5_SC_VE32_CELL   ((ve32_cell_t*) VEXABC5_SC_VE32_CELL_BASE)
#define VEXABC6_SC_VE32_CELL   ((ve32_cell_t*) VEXABC6_SC_VE32_CELL_BASE)
#define VEXABC7_SC_VE32_CELL   ((ve32_cell_t*) VEXABC7_SC_VE32_CELL_BASE)
#define VEXABC8_SC_VE32_CELL   ((ve32_cell_t*) VEXABC8_SC_VE32_CELL_BASE)
#define VEXABC9_SC_VE32_CELL   ((ve32_cell_t*) VEXABC9_SC_VE32_CELL_BASE)
#define VEXABC10_SC_VE32_CELL  ((ve32_cell_t*) VEXABC10_SC_VE32_CELL_BASE)
#define VEXABC11_SC_VE32_CELL  ((ve32_cell_t*) VEXABC11_SC_VE32_CELL_BASE)
#define VEXABC12_SC_VE32_CELL  ((ve32_cell_t*) VEXABC12_SC_VE32_CELL_BASE)
#define VEXABC13_SC_VE32_CELL  ((ve32_cell_t*) VEXABC13_SC_VE32_CELL_BASE)
#define VEXABC14_SC_VE32_CELL  ((ve32_cell_t*) VEXABC14_SC_VE32_CELL_BASE)
#define VEXABC15_SC_VE32_CELL  ((ve32_cell_t*) VEXABC15_SC_VE32_CELL_BASE)
#define VEXABC16_SC_VE32_CELL  ((ve32_cell_t*) VEXABC16_SC_VE32_CELL_BASE)
#define VEXABC17_SC_VE32_CELL  ((ve32_cell_t*) VEXABC17_SC_VE32_CELL_BASE)
#define VEXABC18_SC_VE32_CELL  ((ve32_cell_t*) VEXABC18_SC_VE32_CELL_BASE)
#define VEXABC19_SC_VE32_CELL  ((ve32_cell_t*) VEXABC19_SC_VE32_CELL_BASE)
#define VEXABC20_SC_VE32_CELL  ((ve32_cell_t*) VEXABC20_SC_VE32_CELL_BASE)
#define VEXABC21_SC_VE32_CELL  ((ve32_cell_t*) VEXABC21_SC_VE32_CELL_BASE)
#define VEXABC22_SC_VE32_CELL  ((ve32_cell_t*) VEXABC22_SC_VE32_CELL_BASE)
#define VEXABC23_SC_VE32_CELL  ((ve32_cell_t*) VEXABC23_SC_VE32_CELL_BASE)
#define VEXABC24_SC_VE32_CELL  ((ve32_cell_t*) VEXABC24_SC_VE32_CELL_BASE)
#define VEXABC25_SC_VE32_CELL  ((ve32_cell_t*) VEXABC25_SC_VE32_CELL_BASE)
#define VEXABC26_SC_VE32_CELL  ((ve32_cell_t*) VEXABC26_SC_VE32_CELL_BASE)
#define VEXABC27_SC_VE32_CELL  ((ve32_cell_t*) VEXABC27_SC_VE32_CELL_BASE)
#define VEXABC28_SC_VE32_CELL  ((ve32_cell_t*) VEXABC28_SC_VE32_CELL_BASE)
#define VEXABC29_SC_VE32_CELL  ((ve32_cell_t*) VEXABC29_SC_VE32_CELL_BASE)
#define VEXABC30_SC_VE32_CELL  ((ve32_cell_t*) VEXABC30_SC_VE32_CELL_BASE)
#define VEXABC31_SC_VE32_CELL  ((ve32_cell_t*) VEXABC31_SC_VE32_CELL_BASE)
#define VEXABC32_SC_VE32_CELL  ((ve32_cell_t*) VEXABC32_SC_VE32_CELL_BASE)
#define VEXABC33_SC_VE32_CELL  ((ve32_cell_t*) VEXABC33_SC_VE32_CELL_BASE)
#define VEXABC34_SC_VE32_CELL  ((ve32_cell_t*) VEXABC34_SC_VE32_CELL_BASE)
#define VEXABC35_SC_VE32_CELL  ((ve32_cell_t*) VEXABC35_SC_VE32_CELL_BASE)
#define VEXABC36_SC_VE32_CELL  ((ve32_cell_t*) VEXABC36_SC_VE32_CELL_BASE)
#define VEXABC37_SC_VE32_CELL  ((ve32_cell_t*) VEXABC37_SC_VE32_CELL_BASE)
#define VEXABC38_SC_VE32_CELL  ((ve32_cell_t*) VEXABC38_SC_VE32_CELL_BASE)
#define VEXABC39_SC_VE32_CELL  ((ve32_cell_t*) VEXABC39_SC_VE32_CELL_BASE)

// ******************************************* /Address Space

#endif      // _VE32_CELL_H_

