#ifndef _PLL_LOCAL_H_
#define _PLL_LOCAL_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define MEM_CAP0_ANALOG_PLL_BASE  ( 0x041f1000 )
#define MEM_CAP1_ANALOG_PLL_BASE  ( 0x043f1000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_OFFSET ( 0x00000000U )
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_OFFSET ( 0x00000004U )
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_OFFSET ( 0x00000008U )
#define PLL_LOCAL_PLLREG3_CSR_FLB_OFFSET ( 0x0000000cU )
#define PLL_LOCAL_PLLREG4_CSR_DCO1_OFFSET ( 0x00000010U )
#define PLL_LOCAL_PLLREG5_CSR_DCO2_OFFSET ( 0x00000014U )
#define PLL_LOCAL_PLLREG6_CSR_LDO1_OFFSET ( 0x00000018U )
#define PLL_LOCAL_PLLREG7_CSR_LDO2_OFFSET ( 0x0000001cU )
#define PLL_LOCAL_PLLREG8_CSR_TDC_OFFSET ( 0x00000020U )
#define PLL_LOCAL_PLLREG9_CSR_START_OFFSET ( 0x00000024U )
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_OFFSET ( 0x00000028U )
#define PLL_LOCAL_PLLREG11_CSR_CAL_OFFSET ( 0x0000002cU )
#define PLL_LOCAL_PLLREG12_CSR_OPR1_OFFSET ( 0x00000030U )
#define PLL_LOCAL_PLLREG13_CSR_OPR2_OFFSET ( 0x00000034U )
#define PLL_LOCAL_PLLREG14_CSR_OPR3_OFFSET ( 0x00000038U )
#define PLL_LOCAL_PLLREG15_CSR_STICKY_OFFSET ( 0x0000003cU )
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_OFFSET ( 0x00000040U )
#define PLL_LOCAL_PLLREG17_CSR_AFS_OFFSET ( 0x00000044U )
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_OFFSET ( 0x00000048U )
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_OFFSET ( 0x0000004cU )
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_OFFSET ( 0x00000050U )
#define PLL_LOCAL_PLLREG21_CSR_MEM_OFFSET ( 0x00000054U )
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_OFFSET ( 0x00000058U )
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_OFFSET ( 0x0000005cU )
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_OFFSET ( 0x00000060U )
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_OFFSET ( 0x00000064U )
#define PLL_LOCAL_PLLREG26_CSR_DPD_OFFSET ( 0x00000068U )
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_OFFSET ( 0x0000006cU )
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_OFFSET ( 0x00000070U )
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_OFFSET ( 0x00000074U )
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_OFFSET ( 0x00000078U )
#define PLL_LOCAL_PLLREG31_CSR_DLF_OFFSET ( 0x0000007cU )
#define PLL_LOCAL_PLLREG32_CSR_DLF2_OFFSET ( 0x00000080U )
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_OFFSET ( 0x00000084U )
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_OFFSET ( 0x00000088U )
#define PLL_LOCAL_PLLREG35_CSR_RDTC_OFFSET ( 0x0000008cU )
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_OFFSET ( 0x00000090U )
#define PLL_LOCAL_PLLREG37_CSR_ASC1_OFFSET ( 0x00000094U )
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_OFFSET ( 0x00000098U )
#define PLL_LOCAL_PLLREG39_CSR_ASC2_OFFSET ( 0x0000009cU )
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_OFFSET ( 0x000000a0U )
#define PLL_LOCAL_PLLREG41_CSR_ASC3_OFFSET ( 0x000000a4U )
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_OFFSET ( 0x000000a8U )
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_OFFSET ( 0x000000acU )
#define PLL_LOCAL_PLLREG44_CSR_DBGM_OFFSET ( 0x000000b0U )
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_OFFSET ( 0x000000b4U )
#define PLL_LOCAL_PLLREG46_CSR_STAT1_OFFSET ( 0x000000b8U )
#define PLL_LOCAL_PLLREG47_CSR_STAT2_OFFSET ( 0x000000bcU )
#define PLL_LOCAL_PLLREG48_CSR_STAT3_OFFSET ( 0x000000c0U )
#define PLL_LOCAL_PLLREG49_CSR_STAT4_OFFSET ( 0x000000c4U )
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_OFFSET ( 0x000000c8U )
#define PLL_LOCAL_PLLREG51_CSR_SEQ_OFFSET ( 0x000000ccU )
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_OFFSET ( 0x000000d0U )
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_OFFSET ( 0x000000d4U )
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_OFFSET ( 0x000000d8U )
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_OFFSET ( 0x000000dcU )
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_OFFSET ( 0x000000e0U )
#define PLL_LOCAL_PLLREG57_CSR_VBAND_OFFSET ( 0x000000e4U )
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_OFFSET ( 0x000000e8U )
#define PLL_LOCAL_PLLREG59_CSR_PNC_OFFSET ( 0x000000ecU )
#define PLL_LOCAL_PLLREG60_CSR_AE_OFFSET ( 0x000000f0U )
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_OFFSET ( 0x000000f4U )
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_OFFSET ( 0x000000f8U )
#define PLL_LOCAL_PLLREG63_CSR_LDO3_OFFSET ( 0x000000fcU )
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_OFFSET ( 0x00000100U )
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_OFFSET ( 0x00000104U )
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_OFFSET ( 0x00000108U )
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_OFFSET ( 0x0000010cU )
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_OFFSET ( 0x00000110U )
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_OFFSET ( 0x00000114U )
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_OFFSET ( 0x00000118U )
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_OFFSET ( 0x0000011cU )
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_OFFSET ( 0x00000120U )
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_OFFSET ( 0x00000124U )
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_OFFSET ( 0x00000128U )
#define PLL_LOCAL_PLLREG75_CSR_STAT1_OFFSET ( 0x0000012cU )
#define PLL_LOCAL_PLLREG76_CSR_STAT2_OFFSET ( 0x00000130U )
#define PLL_LOCAL_PLLREG77_CSR_STAT3_OFFSET ( 0x00000134U )
#define PLL_LOCAL_PLLREG78_CSR_FLB1_OFFSET ( 0x00000138U )
#define PLL_LOCAL_PLLREG79_CSR_FLB2_OFFSET ( 0x0000013cU )
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_OFFSET ( 0x00000140U )
#define PLL_LOCAL_PLLREG81_CSR_STAT4_OFFSET ( 0x00000144U )
#define PLL_LOCAL_PLLREG82_CSR_STAT5_OFFSET ( 0x00000148U )
#define PLL_LOCAL_PLLREG83_CSR_STAT6_OFFSET ( 0x0000014cU )
#define PLL_LOCAL_PLLREG84_CSR_STAT7_OFFSET ( 0x00000150U )
#define PLL_LOCAL_PLLREG85_CSR_STAT8_OFFSET ( 0x00000154U )
#define PLL_LOCAL_PLLREG86_CSR_STAT9_OFFSET ( 0x00000158U )
#define PLL_LOCAL_PLLREG87_CSR_STAT10_OFFSET ( 0x0000015cU )
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_OFFSET ( 0x00000160U )
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_OFFSET ( 0x00000164U )
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_OFFSET ( 0x00000168U )
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_OFFSET ( 0x0000016cU )
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_OFFSET ( 0x00000170U )
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_OFFSET ( 0x00000174U )
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_OFFSET ( 0x00000178U )
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_OFFSET ( 0x0000017cU )
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_OFFSET ( 0x00000180U )
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_OFFSET ( 0x00000184U )
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_OFFSET ( 0x00000188U )
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_OFFSET ( 0x0000018cU )
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_OFFSET ( 0x00000190U )
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_OFFSET ( 0x00000194U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG0_CSR_CLKMUX_OFFSET ) ))
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG1_CSR_GENERAL_OFFSET ) ))
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG3_CSR_FLB_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG3_CSR_FLB_OFFSET ) ))
#define PLL_LOCAL_PLLREG4_CSR_DCO1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG4_CSR_DCO1_OFFSET ) ))
#define PLL_LOCAL_PLLREG5_CSR_DCO2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG5_CSR_DCO2_OFFSET ) ))
#define PLL_LOCAL_PLLREG6_CSR_LDO1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG6_CSR_LDO1_OFFSET ) ))
#define PLL_LOCAL_PLLREG7_CSR_LDO2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG7_CSR_LDO2_OFFSET ) ))
#define PLL_LOCAL_PLLREG8_CSR_TDC_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG8_CSR_TDC_OFFSET ) ))
#define PLL_LOCAL_PLLREG9_CSR_START_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG9_CSR_START_OFFSET ) ))
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_OFFSET ) ))
#define PLL_LOCAL_PLLREG11_CSR_CAL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG11_CSR_CAL_OFFSET ) ))
#define PLL_LOCAL_PLLREG12_CSR_OPR1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG12_CSR_OPR1_OFFSET ) ))
#define PLL_LOCAL_PLLREG13_CSR_OPR2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG13_CSR_OPR2_OFFSET ) ))
#define PLL_LOCAL_PLLREG14_CSR_OPR3_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG14_CSR_OPR3_OFFSET ) ))
#define PLL_LOCAL_PLLREG15_CSR_STICKY_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG15_CSR_STICKY_OFFSET ) ))
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_OFFSET ) ))
#define PLL_LOCAL_PLLREG17_CSR_AFS_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG17_CSR_AFS_OFFSET ) ))
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_OFFSET ) ))
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_OFFSET ) ))
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_OFFSET ) ))
#define PLL_LOCAL_PLLREG21_CSR_MEM_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG21_CSR_MEM_OFFSET ) ))
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_OFFSET ) ))
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG23_CSR_MEM_DATA_OFFSET ) ))
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG24_CSR_PE_GEAR_OFFSET ) ))
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG25_CSR_PE_INIT_OFFSET ) ))
#define PLL_LOCAL_PLLREG26_CSR_DPD_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG26_CSR_DPD_OFFSET ) ))
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_OFFSET ) ))
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG28_CSR_LOCKDET_OFFSET ) ))
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_OFFSET ) ))
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG30_CSR_JUMPDET_OFFSET ) ))
#define PLL_LOCAL_PLLREG31_CSR_DLF_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG31_CSR_DLF_OFFSET ) ))
#define PLL_LOCAL_PLLREG32_CSR_DLF2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG32_CSR_DLF2_OFFSET ) ))
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_OFFSET ) ))
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG34_CSR_MLFPE_OFFSET ) ))
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG35_CSR_RDTC_OFFSET ) ))
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_OFFSET ) ))
#define PLL_LOCAL_PLLREG37_CSR_ASC1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG37_CSR_ASC1_OFFSET ) ))
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_OFFSET ) ))
#define PLL_LOCAL_PLLREG39_CSR_ASC2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG39_CSR_ASC2_OFFSET ) ))
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_OFFSET ) ))
#define PLL_LOCAL_PLLREG41_CSR_ASC3_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG41_CSR_ASC3_OFFSET ) ))
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_OFFSET ) ))
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG43_CSR_ANA_CNT_OFFSET ) ))
#define PLL_LOCAL_PLLREG44_CSR_DBGM_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG44_CSR_DBGM_OFFSET ) ))
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG45_CSR_ANALOG_OFFSET ) ))
#define PLL_LOCAL_PLLREG46_CSR_STAT1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG46_CSR_STAT1_OFFSET ) ))
#define PLL_LOCAL_PLLREG47_CSR_STAT2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG47_CSR_STAT2_OFFSET ) ))
#define PLL_LOCAL_PLLREG48_CSR_STAT3_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG48_CSR_STAT3_OFFSET ) ))
#define PLL_LOCAL_PLLREG49_CSR_STAT4_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG49_CSR_STAT4_OFFSET ) ))
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_OFFSET ) ))
#define PLL_LOCAL_PLLREG51_CSR_SEQ_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG51_CSR_SEQ_OFFSET ) ))
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_OFFSET ) ))
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_OFFSET ) ))
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_OFFSET ) ))
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_OFFSET ) ))
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_OFFSET ) ))
#define PLL_LOCAL_PLLREG57_CSR_VBAND_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG57_CSR_VBAND_OFFSET ) ))
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_OFFSET ) ))
#define PLL_LOCAL_PLLREG59_CSR_PNC_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG59_CSR_PNC_OFFSET ) ))
#define PLL_LOCAL_PLLREG60_CSR_AE_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG60_CSR_AE_OFFSET ) ))
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_OFFSET ) ))
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG62_CSR_BIST_STAT_OFFSET ) ))
#define PLL_LOCAL_PLLREG63_CSR_LDO3_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG63_CSR_LDO3_OFFSET ) ))
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG64_CSR_CTRL1_OFFSET ) ))
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG65_CSR_DCOTC1_OFFSET ) ))
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG66_CSR_DCOTC2_OFFSET ) ))
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG67_CSR_DCOTC3_OFFSET ) ))
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG68_CSR_DCOTC4_OFFSET ) ))
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG69_CSR_PHLOCK1_OFFSET ) ))
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG70_CSR_PHLOCK2_OFFSET ) ))
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG71_CSR_PHLOCK3_OFFSET ) ))
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG72_CSR_PHLOCK4_OFFSET ) ))
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG73_CSR_PHLOCK5_OFFSET ) ))
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG74_CSR_PHLOCK6_OFFSET ) ))
#define PLL_LOCAL_PLLREG75_CSR_STAT1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG75_CSR_STAT1_OFFSET ) ))
#define PLL_LOCAL_PLLREG76_CSR_STAT2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG76_CSR_STAT2_OFFSET ) ))
#define PLL_LOCAL_PLLREG77_CSR_STAT3_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG77_CSR_STAT3_OFFSET ) ))
#define PLL_LOCAL_PLLREG78_CSR_FLB1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG78_CSR_FLB1_OFFSET ) ))
#define PLL_LOCAL_PLLREG79_CSR_FLB2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG79_CSR_FLB2_OFFSET ) ))
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG80_CSR_DLFX1_OFFSET ) ))
#define PLL_LOCAL_PLLREG81_CSR_STAT4_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG81_CSR_STAT4_OFFSET ) ))
#define PLL_LOCAL_PLLREG82_CSR_STAT5_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG82_CSR_STAT5_OFFSET ) ))
#define PLL_LOCAL_PLLREG83_CSR_STAT6_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG83_CSR_STAT6_OFFSET ) ))
#define PLL_LOCAL_PLLREG84_CSR_STAT7_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG84_CSR_STAT7_OFFSET ) ))
#define PLL_LOCAL_PLLREG85_CSR_STAT8_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG85_CSR_STAT8_OFFSET ) ))
#define PLL_LOCAL_PLLREG86_CSR_STAT9_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG86_CSR_STAT9_OFFSET ) ))
#define PLL_LOCAL_PLLREG87_CSR_STAT10_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG87_CSR_STAT10_OFFSET ) ))
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG88_CSR_SFTDC_OFFSET ) ))
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_OFFSET ) ))
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_OFFSET ) ))
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_OFFSET ) ))
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_OFFSET ) ))
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_OFFSET ) ))
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief PLL_LOCAL_REG_PLLREG0_CSR_CLKMUX register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg0_csr_clkmux
  * AnaRF PLL csr_clkmux
  */

typedef union {
  struct {
    uint32_t REGS_SEL : 1;
    ///< Switch the control over the clock mux that control the registers.
    ///< This signal flips the control! i.e if start point is seq_clk writing
    ///< 1 will flip to csr_clk and writng to 1 again will change back to seq_clk.
    ///< Has no effect in wb based DPLLs.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESERVED11 : 31;
    ///< reserved
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg0_csr_clkmux_reg_t;

#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_WR_MASK (0xffffffffU)


///< Switch the control over the clock mux that control the registers.
///< This signal flips the control! i.e if start point is seq_clk writing
///< 1 will flip to csr_clk and writng to 1 again will change back to seq_clk.
///< Has no effect in wb based DPLLs.
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_SEL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_SEL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_SEL_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_SEL_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_RESERVED11_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_RESERVED11_BF_WID (31)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_RESERVED11_BF_MSK (0xFFFFFFFE)
#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_RESERVED11_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG1_CSR_GENERAL register description at address offset 0x4
  *
  * Register default value:        0x3F800300
  * Register full path in IP: pll_local/reg/pllreg1_csr_general
  * AnaRF PLL csr_general
  */

typedef union {
  struct {
    uint32_t RESERVED27 : 8;
    ///< reserved
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PRI_ENC_BUBBLE_CORR_EN : 1;
    ///< Enable bubble correction in Encoder 0  - disable bubble correction
    ///< 1 - enable bubble correction
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint32_t PRI_ENC_REVERSE_BIT_ORDER : 1;
    ///< Reverse the bits order of TDC input to encoder.  0 - regular bits
    ///< order direction of encoder. 1 - reverse bits order direction of encoder.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint32_t AUTO_RELOCK : 1;
    ///< when this bit is set to 1 the DPLL on dlf_th_excd will set another
    ///< start pulse (will copy the effect of setting csr_start_now to 1)
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t RESERVED23 : 3;
    ///< reserved
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t PES_SW_RST : 1;
    ///< PES software reset
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t DPD_SW_RST : 1;
    ///< DPD software reset
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t DLF_SW_RST : 1;
    ///< DLF software reset
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t RESERVED19 : 5;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t MASK_INTERRUPT : 8;
    ///< Interrupt mask (OR condition between various bits) Bit 0 - dpd_lock_det_rise_sticky
    ///< Bit 1 - dpd_lock_det_fall_sticky Bit 2 - dpd_jump_det_sticky Bit 3
    ///< - dlf_th_excd Bit 4 - ana_cnt_meas_done Bit 5 - ctrl_flow_done Bit
    ///< 6 - dpd_lock_falied Bit 7 - opr_lock
    ///< AccessType="RW" BitOffset="22" ResetValue="0xFE"
    uint32_t GLOBAL_CLK_GATE_DISABLE : 1;
    ///< Disables DPLLs clock gates (RDTC, ASC, MLFPE and AFS) shoud be used
    ///< for debug only.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t RESERVED16 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg1_csr_general_reg_t;

#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DEFAULT (0x3f800300U)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_WR_MASK (0xffffffffU)


///< reserved
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED27_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED27_BF_WID ( 8)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED27_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED27_BF_DEF (0x00000000)

///< Enable bubble correction in Encoder 0  - disable bubble correction
///< 1 - enable bubble correction
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_BUBBLE_CORR_EN_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_BUBBLE_CORR_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_BUBBLE_CORR_EN_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_BUBBLE_CORR_EN_BF_DEF (0x00000100)

///< Reverse the bits order of TDC input to encoder.  0 - regular bits
///< order direction of encoder. 1 - reverse bits order direction of encoder.
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_REVERSE_BIT_ORDER_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_REVERSE_BIT_ORDER_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_REVERSE_BIT_ORDER_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PRI_ENC_REVERSE_BIT_ORDER_BF_DEF (0x00000200)

///< when this bit is set to 1 the DPLL on dlf_th_excd will set another
///< start pulse (will copy the effect of setting csr_start_now to 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_AUTO_RELOCK_BF_OFF (10)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_AUTO_RELOCK_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_AUTO_RELOCK_BF_MSK (0x00000400)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_AUTO_RELOCK_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED23_BF_OFF (11)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED23_BF_WID ( 3)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED23_BF_MSK (0x00003800)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED23_BF_DEF (0x00000000)

///< PES software reset
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PES_SW_RST_BF_OFF (14)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PES_SW_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PES_SW_RST_BF_MSK (0x00004000)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_PES_SW_RST_BF_DEF (0x00000000)

///< DPD software reset
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DPD_SW_RST_BF_OFF (15)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DPD_SW_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DPD_SW_RST_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DPD_SW_RST_BF_DEF (0x00000000)

///< DLF software reset
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DLF_SW_RST_BF_OFF (16)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DLF_SW_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DLF_SW_RST_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_DLF_SW_RST_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED19_BF_OFF (17)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED19_BF_WID ( 5)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED19_BF_MSK (0x003E0000)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED19_BF_DEF (0x00000000)

///< Interrupt mask (OR condition between various bits) Bit 0 - dpd_lock_det_rise_sticky
///< Bit 1 - dpd_lock_det_fall_sticky Bit 2 - dpd_jump_det_sticky Bit 3
///< - dlf_th_excd Bit 4 - ana_cnt_meas_done Bit 5 - ctrl_flow_done Bit
///< 6 - dpd_lock_falied Bit 7 - opr_lock
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_MASK_INTR_BF_OFF (22)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_MASK_INTR_BF_WID ( 8)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_MASK_INTR_BF_MSK (0x3FC00000)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_MASK_INTR_BF_DEF (0x3F800000)

///< Disables DPLLs clock gates (RDTC, ASC, MLFPE and AFS) shoud be used
///< for debug only.
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_GLOBAL_CLK_GATE_DIS_BF_OFF (30)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_GLOBAL_CLK_GATE_DIS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_GLOBAL_CLK_GATE_DIS_BF_MSK (0x40000000)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_GLOBAL_CLK_GATE_DIS_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED16_BF_OFF (31)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED16_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED16_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_RESERVED16_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG2_CSR_SYSTEM_CTRL register description at address offset 0x8
  *
  * Register default value:        0x002E0020
  * Register full path in IP: pll_local/reg/pllreg2_csr_system_ctrl
  * AnaRF PLL csr_system_ctrl
  */

typedef union {
  struct {
    uint32_t LVL_SHFT_EN : 1;
    ///< Enable level shiters (effective, 1-st tier D/A isolation)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAND_GAP_REF_EN : 1;
    ///< Enable bandgap reference
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DIG_ANA_ISOLATION_OFF : 1;
    ///< Analog (from digital) isolation off (if TRUE)
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t ANA_DIG_ISOLATION_OFF : 1;
    ///< Digital (from analog) isolation off (if TRUE)
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t MAIN_REF_CLK_EN : 1;
    ///< Enable reference clock to both TDC and APR
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t MAIN_REF_CLK_DIV_PD : 1;
    ///< Power down REF clock divider
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint32_t DIG_REF_CLK_EN : 1;
    ///< Enable REF clock inside the digital APR
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t IQ_DIV_EN : 1;
    ///< Enable IQ divider - need in order to lock the DPLL
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CONV_CLK_OUT_BUF_EN : 1;
    ///< Enable 1st stage of DCO dividers
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DCO_BUF_EN : 1;
    ///< Enable the DCO (oscillation frequency) output buffer
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t MIXER_Q_EN : 1;
    ///< Enable Q output - set when mixer should be active
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t MIXER_I_EN : 1;
    ///< Enable I output - set when mixer should be active
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CLK_MON_EN : 1;
    ///< Enable converters clock output to the TMUX
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CONV_CLK_CNF : 4;
    ///< converters output frequencies configuration
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t EXT_BYPCLK_DISN : 1;
    ///< global external bypass clock enable override
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint32_t LOPA_BYPCLK_ENN : 1;
    ///< PLL internal control for PLL lopa bypass clock
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint32_t CLKDIST_BYPCLK_ENN : 1;
    ///< PLL internal control for clkdist bypass clock
    ///< AccessType="RW" BitOffset="19" ResetValue="0x1"
    uint32_t DCO_REFCLK2SD_EN : 1;
    ///< reference clock to SDM enable instead of DCO/8
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t SEQ_CLK_EN : 1;
    ///< sequencer clock enable
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint32_t RESERVED31 : 10;
    ///< reserved
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg2_csr_sys_ctrl_reg_t;

#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DEFAULT (0x002e0020U)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_WR_MASK (0xffffffffU)


///< Enable level shiters (effective, 1-st tier D/A isolation)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LVL_SHFT_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LVL_SHFT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LVL_SHFT_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LVL_SHFT_EN_BF_DEF (0x00000000)

///< Enable bandgap reference
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_BAND_GAP_REF_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_BAND_GAP_REF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_BAND_GAP_REF_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_BAND_GAP_REF_EN_BF_DEF (0x00000000)

///< Analog (from digital) isolation off (if TRUE)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_ANA_ISOLATION_OFF_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_ANA_ISOLATION_OFF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_ANA_ISOLATION_OFF_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_ANA_ISOLATION_OFF_BF_DEF (0x00000000)

///< Digital (from analog) isolation off (if TRUE)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_ANA_DIG_ISOLATION_OFF_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_ANA_DIG_ISOLATION_OFF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_ANA_DIG_ISOLATION_OFF_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_ANA_DIG_ISOLATION_OFF_BF_DEF (0x00000000)

///< Enable reference clock to both TDC and APR
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_EN_BF_DEF (0x00000000)

///< Power down REF clock divider
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_DIV_PD_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_DIV_PD_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_DIV_PD_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MAIN_REF_CLK_DIV_PD_BF_DEF (0x00000020)

///< Enable REF clock inside the digital APR
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_REF_CLK_EN_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_REF_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_REF_CLK_EN_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DIG_REF_CLK_EN_BF_DEF (0x00000000)

///< Enable IQ divider - need in order to lock the DPLL
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_IQ_DIV_EN_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_IQ_DIV_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_IQ_DIV_EN_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_IQ_DIV_EN_BF_DEF (0x00000000)

///< Enable 1st stage of DCO dividers
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_OUT_BUF_EN_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_OUT_BUF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_OUT_BUF_EN_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_OUT_BUF_EN_BF_DEF (0x00000000)

///< Enable the DCO (oscillation frequency) output buffer
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_BUF_EN_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_BUF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_BUF_EN_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_BUF_EN_BF_DEF (0x00000000)

///< Enable Q output - set when mixer should be active
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_Q_EN_BF_OFF (10)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_Q_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_Q_EN_BF_MSK (0x00000400)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_Q_EN_BF_DEF (0x00000000)

///< Enable I output - set when mixer should be active
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_I_EN_BF_OFF (11)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_I_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_I_EN_BF_MSK (0x00000800)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_MIXER_I_EN_BF_DEF (0x00000000)

///< Enable converters clock output to the TMUX
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLK_MON_EN_BF_OFF (12)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLK_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLK_MON_EN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLK_MON_EN_BF_DEF (0x00000000)

///< converters output frequencies configuration
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_CNF_BF_OFF (13)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_CNF_BF_WID ( 4)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_CNF_BF_MSK (0x0001E000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CONV_CLK_CNF_BF_DEF (0x00000000)

///< global external bypass clock enable override
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_EXT_BYPCLK_DISN_BF_OFF (17)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_EXT_BYPCLK_DISN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_EXT_BYPCLK_DISN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_EXT_BYPCLK_DISN_BF_DEF (0x00020000)

///< PLL internal control for PLL lopa bypass clock
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LOPA_BYPCLK_ENN_BF_OFF (18)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LOPA_BYPCLK_ENN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LOPA_BYPCLK_ENN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_LOPA_BYPCLK_ENN_BF_DEF (0x00040000)

///< PLL internal control for clkdist bypass clock
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLKDIST_BYPCLK_ENN_BF_OFF (19)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLKDIST_BYPCLK_ENN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLKDIST_BYPCLK_ENN_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_CLKDIST_BYPCLK_ENN_BF_DEF (0x00080000)

///< reference clock to SDM enable instead of DCO/8
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_REFCLK2SD_EN_BF_OFF (20)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_REFCLK2SD_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_REFCLK2SD_EN_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_DCO_REFCLK2SD_EN_BF_DEF (0x00000000)

///< sequencer clock enable
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_SEQ_CLK_EN_BF_OFF (21)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_SEQ_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_SEQ_CLK_EN_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_SEQ_CLK_EN_BF_DEF (0x00200000)

///< reserved
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_RESERVED31_BF_OFF (22)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_RESERVED31_BF_WID (10)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_RESERVED31_BF_MSK (0xFFC00000)
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_RESERVED31_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG3_CSR_FLB register description at address offset 0xc
  *
  * Register default value:        0x00001041
  * Register full path in IP: pll_local/reg/pllreg3_csr_flb
  * AnaRF PLL csr_flb
  */

typedef union {
  struct {
    uint32_t OS_DIV_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t OS_DIV0_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t OS_DIV1_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t OS_DIV2_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t OS_DIV3_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SDM_ON : 1;
    ///< Turn the SigmaDelta modulator on (enable noise shaping). Activates
    ///< the clock and removes reset from the sampling registers.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t SDM_ORDER : 1;
    ///< Sigma Delta modulator order. 0 for 1st order SDM and 1 for 2nd order
    ///< SDM.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint32_t SDM_MAN_ON : 1;
    ///< Use manual SDM control.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t SDM_MAN_VAL : 3;
    ///< Decoded manual SDM control value.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t FT_CLK_INV : 1;
    ///< Use inversed version of the FT valid signal. Effectively increases
    ///< the loop delay by half  cycle. May alleviate timing/synchronization
    ///< problems.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t MTRX_CLK_LAG : 2;
    ///< Final row/col/band sampling clock. Always one clock behind smpl_clk_lag
    ///< (by design). Default value (1) ensures sync with OS output.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t SMPL_CLK_LAG : 2;
    ///< Sampling clock (both FT and CT data) lag.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t RSTN : 1;
    ///< acitve low reset to the fast logic (flb) block.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t RESERVED53 : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg3_csr_flb_reg_t;

#define PLL_LOCAL_PLLREG3_CSR_FLB_DEFAULT (0x00001041U)
#define PLL_LOCAL_PLLREG3_CSR_FLB_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG3_CSR_FLB_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV_PWRDN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV_PWRDN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV_PWRDN_BF_DEF (0x00000001)

///< To Be Done
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV0_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV0_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV0_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV0_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV1_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV1_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV1_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV1_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV2_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV2_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV2_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV2_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV3_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV3_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV3_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG3_CSR_FLB_OS_DIV3_EN_BF_DEF (0x00000000)

///< Turn the SigmaDelta modulator on (enable noise shaping). Activates
///< the clock and removes reset from the sampling registers.
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ON_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ON_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ON_BF_DEF (0x00000000)

///< Sigma Delta modulator order. 0 for 1st order SDM and 1 for 2nd order
///< SDM.
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ORDER_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ORDER_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ORDER_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_ORDER_BF_DEF (0x00000040)

///< Use manual SDM control.
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_ON_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_ON_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_ON_BF_DEF (0x00000000)

///< Decoded manual SDM control value.
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_VAL_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_VAL_BF_WID ( 3)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_VAL_BF_MSK (0x00000700)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SDM_MAN_VAL_BF_DEF (0x00000000)

///< Use inversed version of the FT valid signal. Effectively increases
///< the loop delay by half  cycle. May alleviate timing/synchronization
///< problems.
#define PLL_LOCAL_PLLREG3_CSR_FLB_FT_CLK_INV_BF_OFF (11)
#define PLL_LOCAL_PLLREG3_CSR_FLB_FT_CLK_INV_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_FT_CLK_INV_BF_MSK (0x00000800)
#define PLL_LOCAL_PLLREG3_CSR_FLB_FT_CLK_INV_BF_DEF (0x00000000)

///< Final row/col/band sampling clock. Always one clock behind smpl_clk_lag
///< (by design). Default value (1) ensures sync with OS output.
#define PLL_LOCAL_PLLREG3_CSR_FLB_MTRX_CLK_LAG_BF_OFF (12)
#define PLL_LOCAL_PLLREG3_CSR_FLB_MTRX_CLK_LAG_BF_WID ( 2)
#define PLL_LOCAL_PLLREG3_CSR_FLB_MTRX_CLK_LAG_BF_MSK (0x00003000)
#define PLL_LOCAL_PLLREG3_CSR_FLB_MTRX_CLK_LAG_BF_DEF (0x00001000)

///< Sampling clock (both FT and CT data) lag.
#define PLL_LOCAL_PLLREG3_CSR_FLB_SMPL_CLK_LAG_BF_OFF (14)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SMPL_CLK_LAG_BF_WID ( 2)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SMPL_CLK_LAG_BF_MSK (0x0000C000)
#define PLL_LOCAL_PLLREG3_CSR_FLB_SMPL_CLK_LAG_BF_DEF (0x00000000)

///< acitve low reset to the fast logic (flb) block.
#define PLL_LOCAL_PLLREG3_CSR_FLB_RSTN_BF_OFF (16)
#define PLL_LOCAL_PLLREG3_CSR_FLB_RSTN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG3_CSR_FLB_RSTN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG3_CSR_FLB_RSTN_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG3_CSR_FLB_RESERVED53_BF_OFF (17)
#define PLL_LOCAL_PLLREG3_CSR_FLB_RESERVED53_BF_WID (15)
#define PLL_LOCAL_PLLREG3_CSR_FLB_RESERVED53_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG3_CSR_FLB_RESERVED53_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG4_CSR_DCO1 register description at address offset 0x10
  *
  * Register default value:        0x0001C1FF
  * Register full path in IP: pll_local/reg/pllreg4_csr_dco1
  * AnaRF PLL csr_dco1
  */

typedef union {
  struct {
    uint32_t PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t VOL_CON : 8;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0xFF"
    uint32_t H2_SWCAP_CTRL : 5;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t BUF_LO_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint32_t BUF_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="15" ResetValue="0x1"
    uint32_t DIV_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t RESERVED70 : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg4_csr_dco1_reg_t;

#define PLL_LOCAL_PLLREG4_CSR_DCO1_DEFAULT (0x0001c1ffU)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG4_CSR_DCO1_PWRDN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_PWRDN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_PWRDN_BF_DEF (0x00000001)

///< To Be Done
#define PLL_LOCAL_PLLREG4_CSR_DCO1_VOL_CON_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_VOL_CON_BF_WID ( 8)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_VOL_CON_BF_MSK (0x000001FE)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_VOL_CON_BF_DEF (0x000001FE)

///< To Be Done
#define PLL_LOCAL_PLLREG4_CSR_DCO1_H2_SWCAP_CTRL_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_H2_SWCAP_CTRL_BF_WID ( 5)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_H2_SWCAP_CTRL_BF_MSK (0x00003E00)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_H2_SWCAP_CTRL_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_LO_PWRDN_BF_OFF (14)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_LO_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_LO_PWRDN_BF_MSK (0x00004000)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_LO_PWRDN_BF_DEF (0x00004000)

///< To Be Done
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_PWRDN_BF_OFF (15)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_PWRDN_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_BUF_PWRDN_BF_DEF (0x00008000)

///< To Be Done
#define PLL_LOCAL_PLLREG4_CSR_DCO1_DIV_PWRDN_BF_OFF (16)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_DIV_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_DIV_PWRDN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_DIV_PWRDN_BF_DEF (0x00010000)

///< reserved
#define PLL_LOCAL_PLLREG4_CSR_DCO1_RESERVED70_BF_OFF (17)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_RESERVED70_BF_WID (15)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_RESERVED70_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG4_CSR_DCO1_RESERVED70_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG5_CSR_DCO2 register description at address offset 0x14
  *
  * Register default value:        0x000071FF
  * Register full path in IP: pll_local/reg/pllreg5_csr_dco2
  * AnaRF PLL csr_dco2
  */

typedef union {
  struct {
    uint32_t PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t VOL_CON : 8;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0xFF"
    uint32_t H2_SWCAP_CTRL : 3;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t BUF_LO_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t BUF_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t DIV_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint32_t RESERVED80 : 17;
    ///< reserved
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg5_csr_dco2_reg_t;

#define PLL_LOCAL_PLLREG5_CSR_DCO2_DEFAULT (0x000071ffU)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG5_CSR_DCO2_PWRDN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_PWRDN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_PWRDN_BF_DEF (0x00000001)

///< To Be Done
#define PLL_LOCAL_PLLREG5_CSR_DCO2_VOL_CON_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_VOL_CON_BF_WID ( 8)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_VOL_CON_BF_MSK (0x000001FE)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_VOL_CON_BF_DEF (0x000001FE)

///< To Be Done
#define PLL_LOCAL_PLLREG5_CSR_DCO2_H2_SWCAP_CTRL_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_H2_SWCAP_CTRL_BF_WID ( 3)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_H2_SWCAP_CTRL_BF_MSK (0x00000E00)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_H2_SWCAP_CTRL_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_LO_PWRDN_BF_OFF (12)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_LO_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_LO_PWRDN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_LO_PWRDN_BF_DEF (0x00001000)

///< To Be Done
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_PWRDN_BF_OFF (13)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_PWRDN_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_BUF_PWRDN_BF_DEF (0x00002000)

///< To Be Done
#define PLL_LOCAL_PLLREG5_CSR_DCO2_DIV_PWRDN_BF_OFF (14)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_DIV_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_DIV_PWRDN_BF_MSK (0x00004000)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_DIV_PWRDN_BF_DEF (0x00004000)

///< reserved
#define PLL_LOCAL_PLLREG5_CSR_DCO2_RESERVED80_BF_OFF (15)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_RESERVED80_BF_WID (17)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_RESERVED80_BF_MSK (0xFFFF8000)
#define PLL_LOCAL_PLLREG5_CSR_DCO2_RESERVED80_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG6_CSR_LDO1 register description at address offset 0x18
  *
  * Register default value:        0xC0000100
  * Register full path in IP: pll_local/reg/pllreg6_csr_ldo1
  * AnaRF PLL csr_ldo1
  */

typedef union {
  struct {
    uint32_t CORE_LDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CORE_LDO_LP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CORE_LDO_HIGHZ_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CORE_LDO_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CORE_LDO_START_UP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CORE_LDO_MON_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CORE_LDO_VOUT_TUNE : 4;
    ///< DCO Core-LDO vout tune core_ldo_vout_tune[3]: 0: vcasc=0.8V, 1: vcasc=vref
    ///< core_ldo_vout_tune[2:0]: 0x0=0.6V, 0x1=0.65V, 0x2=0.7V, 0x3=0.75V
    ///< 0x4=0.8V, 0x5=0.85V, 0x6=0.9V, 0x7=0.95V
    ///< AccessType="RW" BitOffset="6" ResetValue="0x4"
    uint32_t CORE_LDO_SINK_CURR : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CORE_LDO_RES_CTRL : 4;
    ///< core_ldo_res_ctrl[2:0]: vref fine trim, 0x0=0V, 0x1=+10mV, 0x2=+20mV,
    ///< 0x3=+30mV, 0x4=+40mV, 0x5=+50mV
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DCODIG_LDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t DCODIG_LDO_LP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t DCODIG_LDO_HIGHZ_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t DCODIG_LDO_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DCODIG_LDO_START_UP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t DCODIG_LDO_MON_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t DCODIG_LDO_VOUT_TUNE : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DCODIG_LDO_SINK_CURR : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t DCODIG_LDO_RES_CTRL : 4;
    ///< dcodig_ldo_res_ctrl[3] is dcodig_ldo_vref_select (1'b0=0.7V, 1'b1=0.8V)
    ///< dcodig_ldo_res_ctrl[2:0] is dcodig_ldo_bias_trim[2:0] (default: 0x04)
    ///< AccessType="RW" BitOffset="28" ResetValue="0xC"
  } ;
  uint32_t value;
} pll_local_pllreg6_csr_ldo1_reg_t;

#define PLL_LOCAL_PLLREG6_CSR_LDO1_DEFAULT (0xc0000100U)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_LP_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_LP_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_LP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_HIGHZ_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_HIGHZ_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_HIGHZ_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_HIGHZ_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_BYP_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_BYP_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_BYP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_START_UP_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_START_UP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_START_UP_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_START_UP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_MON_EN_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_MON_EN_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_MON_EN_BF_DEF (0x00000000)

///< DCO Core-LDO vout tune core_ldo_vout_tune[3]: 0: vcasc=0.8V, 1: vcasc=vref
///< core_ldo_vout_tune[2:0]: 0x0=0.6V, 0x1=0.65V, 0x2=0.7V, 0x3=0.75V
///< 0x4=0.8V, 0x5=0.85V, 0x6=0.9V, 0x7=0.95V
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_VOUT_TUNE_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_VOUT_TUNE_BF_MSK (0x000003C0)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_VOUT_TUNE_BF_DEF (0x00000100)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_SINK_CURR_BF_OFF (10)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_SINK_CURR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_SINK_CURR_BF_MSK (0x00000C00)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_SINK_CURR_BF_DEF (0x00000000)

///< core_ldo_res_ctrl[2:0]: vref fine trim, 0x0=0V, 0x1=+10mV, 0x2=+20mV,
///< 0x3=+30mV, 0x4=+40mV, 0x5=+50mV
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_RES_CTRL_BF_OFF (12)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_RES_CTRL_BF_MSK (0x0000F000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_CORE_LDO_RES_CTRL_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_LP_EN_BF_OFF (17)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_LP_EN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_LP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_HIGHZ_EN_BF_OFF (18)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_HIGHZ_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_HIGHZ_EN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_HIGHZ_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_BYP_EN_BF_OFF (19)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_BYP_EN_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_BYP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_START_UP_EN_BF_OFF (20)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_START_UP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_START_UP_EN_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_START_UP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_MON_EN_BF_OFF (21)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_MON_EN_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_MON_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_VOUT_TUNE_BF_OFF (22)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_VOUT_TUNE_BF_MSK (0x03C00000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_VOUT_TUNE_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_SINK_CURR_BF_OFF (26)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_SINK_CURR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_SINK_CURR_BF_MSK (0x0C000000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_SINK_CURR_BF_DEF (0x00000000)

///< dcodig_ldo_res_ctrl[3] is dcodig_ldo_vref_select (1'b0=0.7V, 1'b1=0.8V)
///< dcodig_ldo_res_ctrl[2:0] is dcodig_ldo_bias_trim[2:0] (default: 0x04)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_RES_CTRL_BF_OFF (28)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_RES_CTRL_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG6_CSR_LDO1_DCODIG_LDO_RES_CTRL_BF_DEF (0xC0000000)


/** @brief PLL_LOCAL_REG_PLLREG7_CSR_LDO2 register description at address offset 0x1c
  *
  * Register default value:        0x00007010
  * Register full path in IP: pll_local/reg/pllreg7_csr_ldo2
  * AnaRF PLL csr_ldo2
  */

typedef union {
  struct {
    uint32_t FAST_LDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FAST_LDO_LP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t FAST_LDO_HIGHZ_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t FAST_LDO_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t FAST_LDO_START_UP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t FAST_LDO_MON_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t FAST_LDO_VOUT_TUNE : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t FAST_LDO_SINK_CURR : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t FAST_LDO_RES_CTRL : 4;
    ///< fast_ldo_res_ctrl[0] = TDC 2nd output stage enable fast_ldo_res_ctrl[1]
    ///< = +100uA in fast control loop  fast_ldo_res_ctrl[2] = +100uA in fast
    ///< control loop  fast_ldo_res_ctrl[3] = SFTDC LDO output stage enable
    ///< AccessType="RW" BitOffset="12" ResetValue="0x7"
    uint32_t DIG_LDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t DIG_LDO_LP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t DIG_LDO_HIGHZ_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t DIG_LDO_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DIG_LDO_START_UP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t DIG_LDO_MON_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t DIG_LDO_VOUT_TUNE : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DIG_LDO_SINK_CURR : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t DIG_LDO_RES_CTRL : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg7_csr_ldo2_reg_t;

#define PLL_LOCAL_PLLREG7_CSR_LDO2_DEFAULT (0x00007010U)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_LP_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_LP_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_LP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_HIGHZ_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_HIGHZ_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_HIGHZ_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_HIGHZ_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_BYP_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_BYP_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_BYP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_START_UP_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_START_UP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_START_UP_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_START_UP_EN_BF_DEF (0x00000010)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_MON_EN_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_MON_EN_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_MON_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_VOUT_TUNE_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_VOUT_TUNE_BF_MSK (0x000003C0)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_VOUT_TUNE_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_SINK_CURR_BF_OFF (10)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_SINK_CURR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_SINK_CURR_BF_MSK (0x00000C00)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_SINK_CURR_BF_DEF (0x00000000)

///< fast_ldo_res_ctrl[0] = TDC 2nd output stage enable fast_ldo_res_ctrl[1]
///< = +100uA in fast control loop  fast_ldo_res_ctrl[2] = +100uA in fast
///< control loop  fast_ldo_res_ctrl[3] = SFTDC LDO output stage enable
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_RES_CTRL_BF_OFF (12)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_RES_CTRL_BF_MSK (0x0000F000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_FAST_LDO_RES_CTRL_BF_DEF (0x00007000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_LP_EN_BF_OFF (17)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_LP_EN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_LP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_HIGHZ_EN_BF_OFF (18)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_HIGHZ_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_HIGHZ_EN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_HIGHZ_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_BYP_EN_BF_OFF (19)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_BYP_EN_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_BYP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_START_UP_EN_BF_OFF (20)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_START_UP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_START_UP_EN_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_START_UP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_MON_EN_BF_OFF (21)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_MON_EN_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_MON_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_VOUT_TUNE_BF_OFF (22)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_VOUT_TUNE_BF_MSK (0x03C00000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_VOUT_TUNE_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_SINK_CURR_BF_OFF (26)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_SINK_CURR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_SINK_CURR_BF_MSK (0x0C000000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_SINK_CURR_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_RES_CTRL_BF_OFF (28)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_RES_CTRL_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG7_CSR_LDO2_DIG_LDO_RES_CTRL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG8_CSR_TDC register description at address offset 0x20
  *
  * Register default value:        0x15D03101
  * Register full path in IP: pll_local/reg/pllreg8_csr_tdc
  * AnaRF PLL csr_tdc
  */

typedef union {
  struct {
    uint32_t PWRDN : 1;
    ///< Shut-down the TDC
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t REF_CLK_POLARITY_SEL : 1;
    ///< REF CLK polarity selection
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t PULSE_EN : 1;
    ///< Shortens the ref clock pulse to decrease the power spike
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t PULSE : 3;
    ///< Pulse  width control
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t GATING_BYPASS : 1;
    ///< Disable  FF gating
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t PMUX_PHROT_EN : 1;
    ///< Enable DCO phase mux
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t PMUX_PRS : 4;
    ///< Set the DCO phase mux position
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint32_t CUR_BST_EN : 1;
    ///< Enable the  Current Boost
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t CUR_BST_TUNE : 3;
    ///< Number of switched capacitors in the Current Boost
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t CUR_BST_XOR_EN : 1;
    ///< Enable the zor gate Current Boost
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t SFTDC_EN : 1;
    ///< Enable the SFTDC
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t SFTDC_RSTN : 1;
    ///< SFTDC RSTN, active low, 0 = reset active
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t SFTDC_GT_DIS : 1;
    ///< SFTDC clock gating disable, 1 = DCO clock always active
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SFTDC_GTSEL : 3;
    ///< SFTDC clock gating select, counter value for gate enable
    ///< AccessType="RW" BitOffset="20" ResetValue="0x5"
    uint32_t SFTDC_CSEL_DEC : 4;
    ///< SFTDC clock delay select for latch and decoder sftdc_csel_dec[1:0]
    ///< = latch delay select sftdc_csel_dec[3:2] = decoder register delay
    ///< select
    ///< AccessType="RW" BitOffset="23" ResetValue="0xB"
    uint32_t SFTDC_DRV : 2;
    ///< SFTDC DCO clock buffer driving strength / slope control
    ///< AccessType="RW" BitOffset="27" ResetValue="0x2"
    uint32_t RESERVED132 : 3;
    ///< reserved
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg8_csr_tdc_reg_t;

#define PLL_LOCAL_PLLREG8_CSR_TDC_DEFAULT (0x15d03101U)
#define PLL_LOCAL_PLLREG8_CSR_TDC_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG8_CSR_TDC_WR_MASK (0xffffffffU)


///< Shut-down the TDC
#define PLL_LOCAL_PLLREG8_CSR_TDC_PWRDN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PWRDN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PWRDN_BF_DEF (0x00000001)

///< REF CLK polarity selection
#define PLL_LOCAL_PLLREG8_CSR_TDC_REF_CLK_POLARITY_SEL_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_REF_CLK_POLARITY_SEL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_REF_CLK_POLARITY_SEL_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG8_CSR_TDC_REF_CLK_POLARITY_SEL_BF_DEF (0x00000000)

///< Shortens the ref clock pulse to decrease the power spike
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_EN_BF_DEF (0x00000000)

///< Pulse  width control
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_BF_MSK (0x00000038)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PULSE_BF_DEF (0x00000000)

///< Disable  FF gating
#define PLL_LOCAL_PLLREG8_CSR_TDC_GATING_BYP_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG8_CSR_TDC_GATING_BYP_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_GATING_BYP_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG8_CSR_TDC_GATING_BYP_BF_DEF (0x00000000)

///< Enable DCO phase mux
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PHROT_EN_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PHROT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PHROT_EN_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PHROT_EN_BF_DEF (0x00000000)

///< Set the DCO phase mux position
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PRS_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PRS_BF_WID ( 4)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PRS_BF_MSK (0x00000F00)
#define PLL_LOCAL_PLLREG8_CSR_TDC_PMUX_PRS_BF_DEF (0x00000100)

///< Enable the  Current Boost
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_EN_BF_OFF (12)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_EN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_EN_BF_DEF (0x00001000)

///< Number of switched capacitors in the Current Boost
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_TUNE_BF_OFF (13)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_TUNE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_TUNE_BF_MSK (0x0000E000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_TUNE_BF_DEF (0x00002000)

///< Enable the zor gate Current Boost
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_XOR_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_XOR_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_XOR_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_CUR_BST_XOR_EN_BF_DEF (0x00000000)

///< Enable the SFTDC
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_EN_BF_OFF (17)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_EN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_EN_BF_DEF (0x00000000)

///< SFTDC RSTN, active low, 0 = reset active
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_RSTN_BF_OFF (18)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_RSTN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_RSTN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_RSTN_BF_DEF (0x00000000)

///< SFTDC clock gating disable, 1 = DCO clock always active
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GT_DIS_BF_OFF (19)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GT_DIS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GT_DIS_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GT_DIS_BF_DEF (0x00000000)

///< SFTDC clock gating select, counter value for gate enable
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GTSEL_BF_OFF (20)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GTSEL_BF_WID ( 3)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GTSEL_BF_MSK (0x00700000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_GTSEL_BF_DEF (0x00500000)

///< SFTDC clock delay select for latch and decoder sftdc_csel_dec[1:0]
///< = latch delay select sftdc_csel_dec[3:2] = decoder register delay
///< select
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_CSEL_DEC_BF_OFF (23)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_CSEL_DEC_BF_WID ( 4)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_CSEL_DEC_BF_MSK (0x07800000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_CSEL_DEC_BF_DEF (0x05800000)

///< SFTDC DCO clock buffer driving strength / slope control
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_DRV_BF_OFF (27)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_DRV_BF_WID ( 2)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_DRV_BF_MSK (0x18000000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_SFTDC_DRV_BF_DEF (0x10000000)

///< reserved
#define PLL_LOCAL_PLLREG8_CSR_TDC_RESERVED132_BF_OFF (29)
#define PLL_LOCAL_PLLREG8_CSR_TDC_RESERVED132_BF_WID ( 3)
#define PLL_LOCAL_PLLREG8_CSR_TDC_RESERVED132_BF_MSK (0xE0000000)
#define PLL_LOCAL_PLLREG8_CSR_TDC_RESERVED132_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG9_CSR_START register description at address offset 0x24
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg9_csr_start
  * AnaRF PLL csr_start
  */

typedef union {
  struct {
    uint32_t NOW : 1;
    ///< start the lock of the DPLL
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESERVED152 : 31;
    ///< reserved
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg9_csr_start_reg_t;

#define PLL_LOCAL_PLLREG9_CSR_START_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG9_CSR_START_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG9_CSR_START_WR_MASK (0xffffffffU)


///< start the lock of the DPLL
#define PLL_LOCAL_PLLREG9_CSR_START_NOW_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG9_CSR_START_NOW_BF_WID ( 1)
#define PLL_LOCAL_PLLREG9_CSR_START_NOW_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG9_CSR_START_NOW_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG9_CSR_START_RESERVED152_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG9_CSR_START_RESERVED152_BF_WID (31)
#define PLL_LOCAL_PLLREG9_CSR_START_RESERVED152_BF_MSK (0xFFFFFFFE)
#define PLL_LOCAL_PLLREG9_CSR_START_RESERVED152_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG10_CSR_CTRL_FLOWS register description at address offset 0x28
  *
  * Register default value:        0x00000019
  * Register full path in IP: pll_local/reg/pllreg10_csr_ctrl_flows
  * AnaRF PLL csr_ctrl_flows
  */

typedef union {
  struct {
    uint32_t LOCK2PG : 2;
    ///< Number of page to lock to. 0 is kept as a non-page/stop-regular operation
    ///< code.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t RDTC_CAL : 1;
    ///< RDTC calibration flow
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t TDC_CAL : 1;
    ///< TDC calibration (SEM) flow
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t DCO_CAL : 1;
    ///< DCO calibration flow
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t DCOTC_CAL : 1;
    ///< DCO temperature calibration flow
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t RESERVED157 : 26;
    ///< reserved
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg10_csr_ctrl_flows_reg_t;

#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DEFAULT (0x00000019U)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_WR_MASK (0xffffffffU)


///< Number of page to lock to. 0 is kept as a non-page/stop-regular operation
///< code.
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_LOCK2PG_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_LOCK2PG_BF_WID ( 2)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_LOCK2PG_BF_MSK (0x00000003)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_LOCK2PG_BF_DEF (0x00000001)

///< RDTC calibration flow
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RDTC_CAL_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RDTC_CAL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RDTC_CAL_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RDTC_CAL_BF_DEF (0x00000000)

///< TDC calibration (SEM) flow
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_TDC_CAL_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_TDC_CAL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_TDC_CAL_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_TDC_CAL_BF_DEF (0x00000008)

///< DCO calibration flow
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCO_CAL_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCO_CAL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCO_CAL_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCO_CAL_BF_DEF (0x00000010)

///< DCO temperature calibration flow
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCOTC_CAL_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCOTC_CAL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCOTC_CAL_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_DCOTC_CAL_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RESERVED157_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RESERVED157_BF_WID (26)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RESERVED157_BF_MSK (0xFFFFFFC0)
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_RESERVED157_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG11_CSR_CAL register description at address offset 0x2c
  *
  * Register default value:        0x1F084800
  * Register full path in IP: pll_local/reg/pllreg11_csr_cal
  * AnaRF PLL csr_cal
  */

typedef union {
  struct {
    uint32_t FREQ : 32;
    ///< Calibration frequency. [31:24] - integer [23:4/8] - fractional part
    ///< for ULPN/LP Default corresponds to calibration frequency for opertinal
    ///< frequnecy 38.4x127 + 0x848.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1F084800"
  } ;
  uint32_t value;
} pll_local_pllreg11_csr_cal_reg_t;

#define PLL_LOCAL_PLLREG11_CSR_CAL_DEFAULT (0x1f084800U)
#define PLL_LOCAL_PLLREG11_CSR_CAL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG11_CSR_CAL_WR_MASK (0xffffffffU)


///< Calibration frequency. [31:24] - integer [23:4/8] - fractional part
///< for ULPN/LP Default corresponds to calibration frequency for opertinal
///< frequnecy 38.4x127 + 0x848.
#define PLL_LOCAL_PLLREG11_CSR_CAL_FREQ_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG11_CSR_CAL_FREQ_BF_WID (32)
#define PLL_LOCAL_PLLREG11_CSR_CAL_FREQ_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG11_CSR_CAL_FREQ_BF_DEF (0x1F084800)


/** @brief PLL_LOCAL_REG_PLLREG12_CSR_OPR1 register description at address offset 0x30
  *
  * Register default value:        0x20000000
  * Register full path in IP: pll_local/reg/pllreg12_csr_opr1
  * AnaRF PLL csr_opr1
  */

typedef union {
  struct {
    uint32_t FREQ : 32;
    ///< Operational frequency #1.  [31:24] - integer [23:4] - fractional part
    ///< for ULPN/LP Default corresponds to CI clock frequnecy 491.52*32=15.72864GHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x20000000"
  } ;
  uint32_t value;
} pll_local_pllreg12_csr_opr1_reg_t;

#define PLL_LOCAL_PLLREG12_CSR_OPR1_DEFAULT (0x20000000U)
#define PLL_LOCAL_PLLREG12_CSR_OPR1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG12_CSR_OPR1_WR_MASK (0xffffffffU)


///< Operational frequency #1.  [31:24] - integer [23:4] - fractional part
///< for ULPN/LP Default corresponds to CI clock frequnecy 491.52*32=15.72864GHz.
#define PLL_LOCAL_PLLREG12_CSR_OPR1_FREQ_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG12_CSR_OPR1_FREQ_BF_WID (32)
#define PLL_LOCAL_PLLREG12_CSR_OPR1_FREQ_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG12_CSR_OPR1_FREQ_BF_DEF (0x20000000)


/** @brief PLL_LOCAL_REG_PLLREG13_CSR_OPR2 register description at address offset 0x34
  *
  * Register default value:        0x80000000
  * Register full path in IP: pll_local/reg/pllreg13_csr_opr2
  * AnaRF PLL csr_opr2
  */

typedef union {
  struct {
    uint32_t FREQ : 32;
    ///< Operational frequency #2.  [31:24] - integer [23:4] - fractional part
    ///< for ULPN/LP Value 0x20000000 corresponds to CI clock frequnecy 491.52*32=15.72864GHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x80000000"
  } ;
  uint32_t value;
} pll_local_pllreg13_csr_opr2_reg_t;

#define PLL_LOCAL_PLLREG13_CSR_OPR2_DEFAULT (0x80000000U)
#define PLL_LOCAL_PLLREG13_CSR_OPR2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG13_CSR_OPR2_WR_MASK (0xffffffffU)


///< Operational frequency #2.  [31:24] - integer [23:4] - fractional part
///< for ULPN/LP Value 0x20000000 corresponds to CI clock frequnecy 491.52*32=15.72864GHz.
#define PLL_LOCAL_PLLREG13_CSR_OPR2_FREQ_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG13_CSR_OPR2_FREQ_BF_WID (32)
#define PLL_LOCAL_PLLREG13_CSR_OPR2_FREQ_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG13_CSR_OPR2_FREQ_BF_DEF (0x80000000)


/** @brief PLL_LOCAL_REG_PLLREG14_CSR_OPR3 register description at address offset 0x38
  *
  * Register default value:        0x80000000
  * Register full path in IP: pll_local/reg/pllreg14_csr_opr3
  * AnaRF PLL csr_opr3
  */

typedef union {
  struct {
    uint32_t FREQ : 32;
    ///< Operational frequency #3.  [31:24] integer [23:4] - fractional part
    ///< for ULPN/LP Value 0x20000000 corresponds to CI clock frequnecy 491.52*32=15.72864GHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x80000000"
  } ;
  uint32_t value;
} pll_local_pllreg14_csr_opr3_reg_t;

#define PLL_LOCAL_PLLREG14_CSR_OPR3_DEFAULT (0x80000000U)
#define PLL_LOCAL_PLLREG14_CSR_OPR3_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG14_CSR_OPR3_WR_MASK (0xffffffffU)


///< Operational frequency #3.  [31:24] integer [23:4] - fractional part
///< for ULPN/LP Value 0x20000000 corresponds to CI clock frequnecy 491.52*32=15.72864GHz.
#define PLL_LOCAL_PLLREG14_CSR_OPR3_FREQ_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG14_CSR_OPR3_FREQ_BF_WID (32)
#define PLL_LOCAL_PLLREG14_CSR_OPR3_FREQ_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG14_CSR_OPR3_FREQ_BF_DEF (0x80000000)


/** @brief PLL_LOCAL_REG_PLLREG15_CSR_STICKY register description at address offset 0x3c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg15_csr_sticky
  * AnaRF PLL csr_sticky
  */

typedef union {
  struct {
    uint32_t CLEAR : 1;
    ///< Clear all sticky bits. SW must write 1 (blocking any new sticky bit
    ///< assertion) and then write 0.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LATCH_INTERRUPT : 1;
    ///< Once set to 1 interrupt will not be set to 0 by HW clears (internal
    ///< resets will have no effect on interrupt). Only csr_sticky_clear can
    ///< clear interrupt. Does not influence interrupt's sources behavior
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t RESERVED182 : 30;
    ///< reserved
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg15_csr_sticky_reg_t;

#define PLL_LOCAL_PLLREG15_CSR_STICKY_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_WR_MASK (0xffffffffU)


///< Clear all sticky bits. SW must write 1 (blocking any new sticky bit
///< assertion) and then write 0.
#define PLL_LOCAL_PLLREG15_CSR_STICKY_CLR_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_CLR_BF_WID ( 1)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_CLR_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_CLR_BF_DEF (0x00000000)

///< Once set to 1 interrupt will not be set to 0 by HW clears (internal
///< resets will have no effect on interrupt). Only csr_sticky_clear can
///< clear interrupt. Does not influence interrupt's sources behavior
#define PLL_LOCAL_PLLREG15_CSR_STICKY_LATCH_INTR_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_LATCH_INTR_BF_WID ( 1)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_LATCH_INTR_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_LATCH_INTR_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG15_CSR_STICKY_RESERVED182_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_RESERVED182_BF_WID (30)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_RESERVED182_BF_MSK (0xFFFFFFFC)
#define PLL_LOCAL_PLLREG15_CSR_STICKY_RESERVED182_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG16_CSR_AFS_FLOW register description at address offset 0x40
  *
  * Register default value:        0x00000031
  * Register full path in IP: pll_local/reg/pllreg16_csr_afs_flow
  * AnaRF PLL csr_afs_flow
  */

typedef union {
  struct {
    uint32_t STEP0 : 4;
    ///< Step 0 of the AFS flow.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t STEP1 : 4;
    ///< Step 1 of the AFS flow.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x3"
    uint32_t STEP2 : 4;
    ///< Step 2 of the AFS flow.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t STEP3 : 4;
    ///< Step 3 of the AFS flow.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t STEP4 : 4;
    ///< Step 4 of the AFS flow.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t STEP5 : 4;
    ///< Step 5 of the AFS flow.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t STEP6 : 4;
    ///< Step 6 of the AFS flow.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t STEP7 : 4;
    ///< Step 7 of the AFS flow.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg16_csr_afs_flow_reg_t;

#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_DEFAULT (0x00000031U)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_WR_MASK (0xffffffffU)


///< Step 0 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP0_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP0_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP0_BF_MSK (0x0000000F)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP0_BF_DEF (0x00000001)

///< Step 1 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP1_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP1_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP1_BF_MSK (0x000000F0)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP1_BF_DEF (0x00000030)

///< Step 2 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP2_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP2_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP2_BF_MSK (0x00000F00)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP2_BF_DEF (0x00000000)

///< Step 3 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP3_BF_OFF (12)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP3_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP3_BF_MSK (0x0000F000)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP3_BF_DEF (0x00000000)

///< Step 4 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP4_BF_OFF (16)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP4_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP4_BF_MSK (0x000F0000)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP4_BF_DEF (0x00000000)

///< Step 5 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP5_BF_OFF (20)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP5_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP5_BF_MSK (0x00F00000)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP5_BF_DEF (0x00000000)

///< Step 6 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP6_BF_OFF (24)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP6_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP6_BF_MSK (0x0F000000)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP6_BF_DEF (0x00000000)

///< Step 7 of the AFS flow.
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP7_BF_OFF (28)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP7_BF_WID ( 4)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP7_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_STEP7_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG17_CSR_AFS register description at address offset 0x44
  *
  * Register default value:        0x0001FF1A
  * Register full path in IP: pll_local/reg/pllreg17_csr_afs
  * AnaRF PLL csr_afs
  */

typedef union {
  struct {
    uint32_t SMALL_JMP_TH : 3;
    ///< Small jump threshold. When PLL is locked, AFS will not be activated
    ///< for smaller expected count differences.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x2"
    uint32_t LOG2_CYCLE_NUM : 3;
    ///< The number of REF clock cycles is 2^(3+log2_cycle_num). Maximum supported
    ///< is 6.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x3"
    uint32_t TUNE_SRCH_DEPTH : 3;
    ///< Number of bits to search in sub-band. Up to 7.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x4"
    uint32_t TOP_SUB_BAND : 8;
    ///< Band code for the upper most sub-band
    ///< AccessType="RW" BitOffset="9" ResetValue="0xFF"
    uint32_t RESERVED199 : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg17_csr_afs_reg_t;

#define PLL_LOCAL_PLLREG17_CSR_AFS_DEFAULT (0x0001ff1aU)
#define PLL_LOCAL_PLLREG17_CSR_AFS_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG17_CSR_AFS_WR_MASK (0xffffffffU)


///< Small jump threshold. When PLL is locked, AFS will not be activated
///< for smaller expected count differences.
#define PLL_LOCAL_PLLREG17_CSR_AFS_SMALL_JMP_TH_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG17_CSR_AFS_SMALL_JMP_TH_BF_WID ( 3)
#define PLL_LOCAL_PLLREG17_CSR_AFS_SMALL_JMP_TH_BF_MSK (0x00000007)
#define PLL_LOCAL_PLLREG17_CSR_AFS_SMALL_JMP_TH_BF_DEF (0x00000002)

///< The number of REF clock cycles is 2^(3+log2_cycle_num). Maximum supported
///< is 6.
#define PLL_LOCAL_PLLREG17_CSR_AFS_LOG2_CYCLE_NUM_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG17_CSR_AFS_LOG2_CYCLE_NUM_BF_WID ( 3)
#define PLL_LOCAL_PLLREG17_CSR_AFS_LOG2_CYCLE_NUM_BF_MSK (0x00000038)
#define PLL_LOCAL_PLLREG17_CSR_AFS_LOG2_CYCLE_NUM_BF_DEF (0x00000018)

///< Number of bits to search in sub-band. Up to 7.
#define PLL_LOCAL_PLLREG17_CSR_AFS_TUNE_SRCH_DEPTH_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG17_CSR_AFS_TUNE_SRCH_DEPTH_BF_WID ( 3)
#define PLL_LOCAL_PLLREG17_CSR_AFS_TUNE_SRCH_DEPTH_BF_MSK (0x000001C0)
#define PLL_LOCAL_PLLREG17_CSR_AFS_TUNE_SRCH_DEPTH_BF_DEF (0x00000100)

///< Band code for the upper most sub-band
#define PLL_LOCAL_PLLREG17_CSR_AFS_TOP_SUB_BAND_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG17_CSR_AFS_TOP_SUB_BAND_BF_WID ( 8)
#define PLL_LOCAL_PLLREG17_CSR_AFS_TOP_SUB_BAND_BF_MSK (0x0001FE00)
#define PLL_LOCAL_PLLREG17_CSR_AFS_TOP_SUB_BAND_BF_DEF (0x0001FE00)

///< reserved
#define PLL_LOCAL_PLLREG17_CSR_AFS_RESERVED199_BF_OFF (17)
#define PLL_LOCAL_PLLREG17_CSR_AFS_RESERVED199_BF_WID (15)
#define PLL_LOCAL_PLLREG17_CSR_AFS_RESERVED199_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG17_CSR_AFS_RESERVED199_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG18_CSR_AFS_OVERRIDE register description at address offset 0x48
  *
  * Register default value:        0x0006FF95
  * Register full path in IP: pll_local/reg/pllreg18_csr_afs_override
  * AnaRF PLL csr_afs_override
  */

typedef union {
  struct {
    uint32_t INV_KD_VAL : 16;
    ///< Inverse normalized KDCO.  Computed via 2^(INV_DA_W+1-(6+3))x(fREF/KDCO).
    ///< Currently, INV_DA_W = 15 in all DPLL designs.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xFF95"
    uint32_t INV_KD_ON : 1;
    ///< Override table based computations with inv_kd.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t LOCK_ON : 1;
    ///< Override lock for single measurement
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint32_t OUT_OF_LOCK_ON : 1;
    ///< Override the band and the tune (with overwrite values) when performing
    ///< single measurement and is out of lock. Also enforces reset of PEST/DPD/DLF
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint32_t LUT_SHIFT_VAL : 8;
    ///< LUT correction override value (given in 2's complement).
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t LUT_SHIFT_ON : 1;
    ///< Turn on LUT correction override.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t RESERVED207 : 4;
    ///< reserved
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg18_csr_afs_ovrd_reg_t;

#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_DEFAULT (0x0006ff95U)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_WR_MASK (0xffffffffU)


///< Inverse normalized KDCO.  Computed via 2^(INV_DA_W+1-(6+3))x(fREF/KDCO).
///< Currently, INV_DA_W = 15 in all DPLL designs.
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_VAL_BF_WID (16)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_VAL_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_VAL_BF_DEF (0x0000FF95)

///< Override table based computations with inv_kd.
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_ON_BF_OFF (16)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_ON_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_INV_KD_ON_BF_DEF (0x00000000)

///< Override lock for single measurement
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LOCK_ON_BF_OFF (17)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LOCK_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LOCK_ON_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LOCK_ON_BF_DEF (0x00020000)

///< Override the band and the tune (with overwrite values) when performing
///< single measurement and is out of lock. Also enforces reset of PEST/DPD/DLF
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_OUT_OF_LOCK_ON_BF_OFF (18)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_OUT_OF_LOCK_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_OUT_OF_LOCK_ON_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_OUT_OF_LOCK_ON_BF_DEF (0x00040000)

///< LUT correction override value (given in 2's complement).
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_VAL_BF_OFF (19)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_VAL_BF_WID ( 8)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_VAL_BF_MSK (0x07F80000)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_VAL_BF_DEF (0x00000000)

///< Turn on LUT correction override.
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_ON_BF_OFF (27)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_ON_BF_MSK (0x08000000)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_LUT_SHIFT_ON_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_RESERVED207_BF_OFF (28)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_RESERVED207_BF_WID ( 4)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_RESERVED207_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_RESERVED207_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG19_CSR_AFS_OVERWRITE register description at address offset 0x4c
  *
  * Register default value:        0x0155540E
  * Register full path in IP: pll_local/reg/pllreg19_csr_afs_overwrite
  * AnaRF PLL csr_afs_overwrite
  */

typedef union {
  struct {
    uint32_t BAND_ON : 1;
    ///< Overwrite the band value with the content of band_val field.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAND_VAL : 8;
    ///< The band value to be used as: 1) Initial value for linear search 2)
    ///< Overwrite value if band_on = 1
    ///< AccessType="RW" BitOffset="1" ResetValue="0x7"
    uint32_t TUNE_ON : 1;
    ///< Overwrite the tune value with the content of tune_val field.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t TUNE_VAL : 16;
    ///< The tune value to be used as: 1) Tune value for all the band searches
    ///< (binary, linear and LUT based). 2) Overwrite value if tune_on = 1
    ///< AccessType="RW" BitOffset="10" ResetValue="0x5555"
    uint32_t RESERVED217 : 6;
    ///< reserved
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg19_csr_afs_overwrite_reg_t;

#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_DEFAULT (0x0155540eU)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_WR_MASK (0xffffffffU)


///< Overwrite the band value with the content of band_val field.
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_ON_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_ON_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_ON_BF_DEF (0x00000000)

///< The band value to be used as: 1) Initial value for linear search 2)
///< Overwrite value if band_on = 1
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_VAL_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_VAL_BF_WID ( 8)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_VAL_BF_MSK (0x000001FE)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_BAND_VAL_BF_DEF (0x0000000E)

///< Overwrite the tune value with the content of tune_val field.
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_ON_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_ON_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_ON_BF_DEF (0x00000000)

///< The tune value to be used as: 1) Tune value for all the band searches
///< (binary, linear and LUT based). 2) Overwrite value if tune_on = 1
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_VAL_BF_OFF (10)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_VAL_BF_WID (16)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_VAL_BF_MSK (0x03FFFC00)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_TUNE_VAL_BF_DEF (0x01555400)

///< reserved
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_RESERVED217_BF_OFF (26)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_RESERVED217_BF_WID ( 6)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_RESERVED217_BF_MSK (0xFC000000)
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_RESERVED217_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG20_CSR_SEM_GENERAL register description at address offset 0x50
  *
  * Register default value:        0x00000070
  * Register full path in IP: pll_local/reg/pllreg20_csr_sem_general
  * AnaRF PLL csr_sem_general
  */

typedef union {
  struct {
    uint32_t BYPASS_LUT : 1;
    ///< Bypass the SEM LUT.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t NO_NORM : 1;
    ///< Stop the SEM FSM once the extraction has finished. The flow will resume
    ///< once the bit is de-asserted. Intended as debug feature only.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t NORM_CEIL : 1;
    ///< Normalize the SEM content to upper edges (ceiling) of each cell.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t INDEX_POLARITY : 1;
    ///< Allows switching between rise and fall outputs. Needed for fall only
    ///< locking.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t INVERSE_DIR : 1;
    ///< Inverses the SEM output (both in bypass and LUT modes) to obtain positive
    ///< phase slope.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t CAL_LEN_MODE : 3;
    ///< Calibration length. The actual length will be  2^(SEM_MEM_WIDTH -
    ///< 1 + cal_len_mode). Values of up to 5 are supported for LP4P, and up
    ///< to 4 for LP8P designs.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x3"
    uint32_t RESERVED225 : 24;
    ///< reserved
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg20_csr_sem_general_reg_t;

#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_DEFAULT (0x00000070U)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_WR_MASK (0xffffffffU)


///< Bypass the SEM LUT.
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_BYP_LUT_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_BYP_LUT_BF_WID ( 1)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_BYP_LUT_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_BYP_LUT_BF_DEF (0x00000000)

///< Stop the SEM FSM once the extraction has finished. The flow will resume
///< once the bit is de-asserted. Intended as debug feature only.
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NO_NORM_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NO_NORM_BF_WID ( 1)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NO_NORM_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NO_NORM_BF_DEF (0x00000000)

///< Normalize the SEM content to upper edges (ceiling) of each cell.
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NORM_CEIL_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NORM_CEIL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NORM_CEIL_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_NORM_CEIL_BF_DEF (0x00000000)

///< Allows switching between rise and fall outputs. Needed for fall only
///< locking.
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INDEX_POLARITY_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INDEX_POLARITY_BF_WID ( 1)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INDEX_POLARITY_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INDEX_POLARITY_BF_DEF (0x00000000)

///< Inverses the SEM output (both in bypass and LUT modes) to obtain positive
///< phase slope.
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INVERSE_DIR_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INVERSE_DIR_BF_WID ( 1)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INVERSE_DIR_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_INVERSE_DIR_BF_DEF (0x00000010)

///< Calibration length. The actual length will be  2^(SEM_MEM_WIDTH -
///< 1 + cal_len_mode). Values of up to 5 are supported for LP4P, and up
///< to 4 for LP8P designs.
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_CAL_LEN_MODE_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_CAL_LEN_MODE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_CAL_LEN_MODE_BF_MSK (0x000000E0)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_CAL_LEN_MODE_BF_DEF (0x00000060)

///< reserved
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_RESERVED225_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_RESERVED225_BF_WID (24)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_RESERVED225_BF_MSK (0xFFFFFF00)
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_RESERVED225_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG21_CSR_MEM register description at address offset 0x54
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg21_csr_mem
  * AnaRF PLL csr_mem
  */

typedef union {
  struct {
    uint32_t EMAS_ACCESS : 1;
    ///< Controls the system access interface. Setting to 1 will disactivate
    ///< SEM translation. Effectively, switches selector for SEM clock :  0
    ///< - REF clk,  1 - MAC clock (used for SEM download)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t ENABLE_WR : 1;
    ///< Enable Downloading (Writing) from CSR to  SEM table 1
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t TARGET_LUT : 2;
    ///< 00-SEM LUT 01 - AFS/PRE CAL LUT 10 - RDTC LUT
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t LUT_ACCESS_TYPE : 2;
    ///< 00: one clock per access;  01: No auto increment;  10: CS dependent;
    ///< 11: TBD
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t RESERVED235 : 26;
    ///< reserved
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg21_csr_mem_reg_t;

#define PLL_LOCAL_PLLREG21_CSR_MEM_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG21_CSR_MEM_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG21_CSR_MEM_WR_MASK (0xffffffffU)


///< Controls the system access interface. Setting to 1 will disactivate
///< SEM translation. Effectively, switches selector for SEM clock :  0
///< - REF clk,  1 - MAC clock (used for SEM download)
#define PLL_LOCAL_PLLREG21_CSR_MEM_EMAS_ACCESS_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG21_CSR_MEM_EMAS_ACCESS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG21_CSR_MEM_EMAS_ACCESS_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG21_CSR_MEM_EMAS_ACCESS_BF_DEF (0x00000000)

///< Enable Downloading (Writing) from CSR to  SEM table 1
#define PLL_LOCAL_PLLREG21_CSR_MEM_EN_WR_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG21_CSR_MEM_EN_WR_BF_WID ( 1)
#define PLL_LOCAL_PLLREG21_CSR_MEM_EN_WR_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG21_CSR_MEM_EN_WR_BF_DEF (0x00000000)

///< 00-SEM LUT 01 - AFS/PRE CAL LUT 10 - RDTC LUT
#define PLL_LOCAL_PLLREG21_CSR_MEM_TARGET_LUT_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG21_CSR_MEM_TARGET_LUT_BF_WID ( 2)
#define PLL_LOCAL_PLLREG21_CSR_MEM_TARGET_LUT_BF_MSK (0x0000000C)
#define PLL_LOCAL_PLLREG21_CSR_MEM_TARGET_LUT_BF_DEF (0x00000000)

///< 00: one clock per access;  01: No auto increment;  10: CS dependent;
///< 11: TBD
#define PLL_LOCAL_PLLREG21_CSR_MEM_LUT_ACCESS_TYPE_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG21_CSR_MEM_LUT_ACCESS_TYPE_BF_WID ( 2)
#define PLL_LOCAL_PLLREG21_CSR_MEM_LUT_ACCESS_TYPE_BF_MSK (0x00000030)
#define PLL_LOCAL_PLLREG21_CSR_MEM_LUT_ACCESS_TYPE_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG21_CSR_MEM_RESERVED235_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG21_CSR_MEM_RESERVED235_BF_WID (26)
#define PLL_LOCAL_PLLREG21_CSR_MEM_RESERVED235_BF_MSK (0xFFFFFFC0)
#define PLL_LOCAL_PLLREG21_CSR_MEM_RESERVED235_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG22_CSR_MEM_ADDR register description at address offset 0x58
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg22_csr_mem_addr
  * AnaRF PLL csr_mem_addr
  */

typedef union {
  struct {
    uint32_t VAL : 10;
    ///< Target address for RD/WR of the LUT.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESERVED243 : 22;
    ///< reserved
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg22_csr_mem_addr_reg_t;

#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_WR_MASK (0xffffffffU)


///< Target address for RD/WR of the LUT.
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_VAL_BF_WID (10)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_VAL_BF_MSK (0x000003FF)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_VAL_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_RESERVED243_BF_OFF (10)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_RESERVED243_BF_WID (22)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_RESERVED243_BF_MSK (0xFFFFFC00)
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_RESERVED243_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG23_CSR_MEM_DATA register description at address offset 0x5c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg23_csr_mem_data
  * AnaRF PLL csr_mem_data
  */

typedef union {
  struct {
    uint32_t VAL : 32;
    ///< RW register allowing read/write of the internal LUT0. Each Read or
    ///< Write access to this address increments csr_sem_mem_addr.val by 1.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg23_csr_mem_data_reg_t;

#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_WR_MASK (0xffffffffU)


///< RW register allowing read/write of the internal LUT0. Each Read or
///< Write access to this address increments csr_sem_mem_addr.val by 1.
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_VAL_BF_WID (32)
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_VAL_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_VAL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG24_CSR_PE_GEAR register description at address offset 0x60
  *
  * Register default value:        0x017C71E4
  * Register full path in IP: pll_local/reg/pllreg24_csr_pe_gear
  * AnaRF PLL csr_pe_gear
  */

typedef union {
  struct {
    uint32_t VALUE0 : 2;
    ///< Gear box 1st value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t VALUE1 : 2;
    ///< Gear box 2nd value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t VALUE2 : 2;
    ///< Gear box 3rd value.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x2"
    uint32_t VALUE3 : 2;
    ///< Gear box 4th value.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x3"
    uint32_t TIME1 : 4;
    ///< Gear box 1st switch time.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint32_t TIME2 : 4;
    ///< Gear box 2nd switch time.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x7"
    uint32_t TIME3 : 4;
    ///< Gear box 3rd switch time.
    ///< AccessType="RW" BitOffset="16" ResetValue="0xC"
    uint32_t STOP_TIME : 4;
    ///< Time to stop the counter.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x7"
    uint32_t STOP_UPD : 1;
    ///< When asserted, stops updates once counter achieved stop_time.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x1"
    uint32_t RESERVED252 : 7;
    ///< reserved
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg24_csr_pe_gear_reg_t;

#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_DEFAULT (0x017c71e4U)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_WR_MASK (0xffffffffU)


///< Gear box 1st value.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL0_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL0_BF_WID ( 2)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL0_BF_MSK (0x00000003)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL0_BF_DEF (0x00000000)

///< Gear box 2nd value.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL1_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL1_BF_WID ( 2)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL1_BF_MSK (0x0000000C)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL1_BF_DEF (0x00000004)

///< Gear box 3rd value.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL2_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL2_BF_WID ( 2)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL2_BF_MSK (0x00000030)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL2_BF_DEF (0x00000020)

///< Gear box 4th value.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL3_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL3_BF_WID ( 2)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL3_BF_MSK (0x000000C0)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_VAL3_BF_DEF (0x000000C0)

///< Gear box 1st switch time.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME1_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME1_BF_WID ( 4)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME1_BF_MSK (0x00000F00)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME1_BF_DEF (0x00000100)

///< Gear box 2nd switch time.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME2_BF_OFF (12)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME2_BF_WID ( 4)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME2_BF_MSK (0x0000F000)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME2_BF_DEF (0x00007000)

///< Gear box 3rd switch time.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME3_BF_OFF (16)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME3_BF_WID ( 4)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME3_BF_MSK (0x000F0000)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_TIME3_BF_DEF (0x000C0000)

///< Time to stop the counter.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_TIME_BF_OFF (20)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_TIME_BF_WID ( 4)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_TIME_BF_MSK (0x00F00000)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_TIME_BF_DEF (0x00700000)

///< When asserted, stops updates once counter achieved stop_time.
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_UPD_BF_OFF (24)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_UPD_BF_WID ( 1)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_UPD_BF_MSK (0x01000000)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_STOP_UPD_BF_DEF (0x01000000)

///< reserved
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_RESERVED252_BF_OFF (25)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_RESERVED252_BF_WID ( 7)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_RESERVED252_BF_MSK (0xFE000000)
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_RESERVED252_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG25_CSR_PE_INIT register description at address offset 0x64
  *
  * Register default value:        0x00007FFF
  * Register full path in IP: pll_local/reg/pllreg25_csr_pe_init
  * AnaRF PLL csr_pe_init
  */

typedef union {
  struct {
    uint32_t EFF_P : 16;
    ///< Effective period value to be used at initialization.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7FFF"
    uint32_t EN : 1;
    ///< Enable use of CSR given value.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t RESERVED265 : 15;
    ///< reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg25_csr_pe_init_reg_t;

#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_DEFAULT (0x00007fffU)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_WR_MASK (0x0001ffffU)


///< Effective period value to be used at initialization.
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EFF_P_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EFF_P_BF_WID (16)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EFF_P_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EFF_P_BF_DEF (0x00007FFF)

///< Enable use of CSR given value.
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_EN_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_RESERVED265_BF_OFF (17)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_RESERVED265_BF_WID (15)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_RESERVED265_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_RESERVED265_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG26_CSR_DPD register description at address offset 0x68
  *
  * Register default value:        0x00000043
  * Register full path in IP: pll_local/reg/pllreg26_csr_dpd
  * AnaRF PLL csr_dpd
  */

typedef union {
  struct {
    uint32_t DOUBLE_EDGE_MODE : 1;
    ///< Use both rising and falling edged for phase error calculation.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t INST_FREQ_DERIV_TYPE : 2;
    ///< Type of derivative to employ.  Effectively [n]-[n-2^deriv_type]
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t INST_FREQ_REV_DIR : 1;
    ///< Reverse direction of the instantaneous frequency.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t FREQ_ERROR_INV : 1;
    ///< Inverse the frequency error.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t LOOP_DELAY : 3;
    ///< Number of cycles to delay the start of phase error computation. Used
    ///< to account for SEM and TDC delay.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x2"
    uint32_t INIT_ON : 1;
    ///< Use first frequency error. Not discarding will set the initial phase
    ///< on positive edge only.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t INIT_SEM_INDEX : 15;
    ///< The value to use as the initial phase on positive edge.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t SFTDC_DERIV_EN : 1;
    ///< Enable derivative for SFTDC
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t SFTDC_EN : 1;
    ///< Enable SFTDC in DPD
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t RESERVED271 : 6;
    ///< reserved
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg26_csr_dpd_reg_t;

#define PLL_LOCAL_PLLREG26_CSR_DPD_DEFAULT (0x00000043U)
#define PLL_LOCAL_PLLREG26_CSR_DPD_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG26_CSR_DPD_WR_MASK (0xffffffffU)


///< Use both rising and falling edged for phase error calculation.
#define PLL_LOCAL_PLLREG26_CSR_DPD_DOUBLE_EDGE_MODE_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG26_CSR_DPD_DOUBLE_EDGE_MODE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG26_CSR_DPD_DOUBLE_EDGE_MODE_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG26_CSR_DPD_DOUBLE_EDGE_MODE_BF_DEF (0x00000001)

///< Type of derivative to employ.  Effectively [n]-[n-2^deriv_type]
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_DERIV_TYPE_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_DERIV_TYPE_BF_WID ( 2)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_DERIV_TYPE_BF_MSK (0x00000006)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_DERIV_TYPE_BF_DEF (0x00000002)

///< Reverse direction of the instantaneous frequency.
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_REV_DIR_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_REV_DIR_BF_WID ( 1)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_REV_DIR_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INST_FREQ_REV_DIR_BF_DEF (0x00000000)

///< Inverse the frequency error.
#define PLL_LOCAL_PLLREG26_CSR_DPD_FREQ_ERR_INV_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG26_CSR_DPD_FREQ_ERR_INV_BF_WID ( 1)
#define PLL_LOCAL_PLLREG26_CSR_DPD_FREQ_ERR_INV_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG26_CSR_DPD_FREQ_ERR_INV_BF_DEF (0x00000000)

///< Number of cycles to delay the start of phase error computation. Used
///< to account for SEM and TDC delay.
#define PLL_LOCAL_PLLREG26_CSR_DPD_LOOP_DELAY_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG26_CSR_DPD_LOOP_DELAY_BF_WID ( 3)
#define PLL_LOCAL_PLLREG26_CSR_DPD_LOOP_DELAY_BF_MSK (0x000000E0)
#define PLL_LOCAL_PLLREG26_CSR_DPD_LOOP_DELAY_BF_DEF (0x00000040)

///< Use first frequency error. Not discarding will set the initial phase
///< on positive edge only.
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_ON_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_ON_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_ON_BF_DEF (0x00000000)

///< The value to use as the initial phase on positive edge.
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_SEM_INDEX_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_SEM_INDEX_BF_WID (15)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_SEM_INDEX_BF_MSK (0x00FFFE00)
#define PLL_LOCAL_PLLREG26_CSR_DPD_INIT_SEM_INDEX_BF_DEF (0x00000000)

///< Enable derivative for SFTDC
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_DERIV_EN_BF_OFF (24)
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_DERIV_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_DERIV_EN_BF_MSK (0x01000000)
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_DERIV_EN_BF_DEF (0x00000000)

///< Enable SFTDC in DPD
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_EN_BF_OFF (25)
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_EN_BF_MSK (0x02000000)
#define PLL_LOCAL_PLLREG26_CSR_DPD_SFTDC_EN_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG26_CSR_DPD_RESERVED271_BF_OFF (26)
#define PLL_LOCAL_PLLREG26_CSR_DPD_RESERVED271_BF_WID ( 6)
#define PLL_LOCAL_PLLREG26_CSR_DPD_RESERVED271_BF_MSK (0xFC000000)
#define PLL_LOCAL_PLLREG26_CSR_DPD_RESERVED271_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG27_CSR_DPD_OVERWRITE register description at address offset 0x6c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg27_csr_dpd_overwrite
  * AnaRF PLL csr_dpd_overwrite
  */

typedef union {
  struct {
    uint32_t VAL : 28;
    ///< Value to be used for overwrite.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESERVED285 : 3;
    ///< reserved
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t ON : 1;
    ///< Overwrite the DPD output.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg27_csr_dpd_overwrite_reg_t;

#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_WR_MASK (0xffffffffU)


///< Value to be used for overwrite.
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_VAL_BF_WID (28)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_VAL_BF_MSK (0x0FFFFFFF)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_VAL_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_RESERVED285_BF_OFF (28)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_RESERVED285_BF_WID ( 3)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_RESERVED285_BF_MSK (0x70000000)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_RESERVED285_BF_DEF (0x00000000)

///< Overwrite the DPD output.
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_ON_BF_OFF (31)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_ON_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_ON_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG28_CSR_LOCKDET register description at address offset 0x70
  *
  * Register default value:        0x0F405020
  * Register full path in IP: pll_local/reg/pllreg28_csr_lockdet
  * AnaRF PLL csr_lockdet
  */

typedef union {
  struct {
    uint32_t TST_TH : 8;
    ///< Test threshold (usually, noise standard deviation related)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x20"
    uint32_t SET_TH : 8;
    ///< IIR threshold for lock detect assertion
    ///< AccessType="RW" BitOffset="8" ResetValue="0x50"
    uint32_t RST_TH : 8;
    ///< IIR threshold for lock detect de-assertion
    ///< AccessType="RW" BitOffset="16" ResetValue="0x40"
    uint32_t ONETAP_ALPHA : 3;
    ///< log2(period of time)
    ///< AccessType="RW" BitOffset="24" ResetValue="0x7"
    uint32_t USE_SYM_TST : 1;
    ///< Use symmetry (avg_tst) test.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint32_t RESERVED290 : 4;
    ///< reserved
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg28_csr_lockdet_reg_t;

#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_DEFAULT (0x0f405020U)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_WR_MASK (0xffffffffU)


///< Test threshold (usually, noise standard deviation related)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_TST_TH_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_TST_TH_BF_WID ( 8)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_TST_TH_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_TST_TH_BF_DEF (0x00000020)

///< IIR threshold for lock detect assertion
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_SET_TH_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_SET_TH_BF_WID ( 8)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_SET_TH_BF_MSK (0x0000FF00)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_SET_TH_BF_DEF (0x00005000)

///< IIR threshold for lock detect de-assertion
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RST_TH_BF_OFF (16)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RST_TH_BF_WID ( 8)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RST_TH_BF_MSK (0x00FF0000)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RST_TH_BF_DEF (0x00400000)

///< log2(period of time)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_ONETAP_ALPHA_BF_OFF (24)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_ONETAP_ALPHA_BF_WID ( 3)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_ONETAP_ALPHA_BF_MSK (0x07000000)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_ONETAP_ALPHA_BF_DEF (0x07000000)

///< Use symmetry (avg_tst) test.
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_USE_SYM_TST_BF_OFF (27)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_USE_SYM_TST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_USE_SYM_TST_BF_MSK (0x08000000)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_USE_SYM_TST_BF_DEF (0x08000000)

///< reserved
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RESERVED290_BF_OFF (28)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RESERVED290_BF_WID ( 4)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RESERVED290_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_RESERVED290_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG29_CSR_LOCKDET_EXT_LOCK register description at address offset 0x74
  *
  * Register default value:        0x00001400
  * Register full path in IP: pll_local/reg/pllreg29_csr_lockdet_ext_lock
  * AnaRF PLL csr_lockdet_ext_lock
  */

typedef union {
  struct {
    uint32_t VAL : 12;
    ///< When to force lock signal.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x400"
    uint32_t EN : 1;
    ///< Enable lock detect assertion at ext_lock_val time step (after last
    ///< dpd_rst_l = 1)
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t RESERVED299 : 19;
    ///< reserved
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg29_csr_lockdet_ext_lock_reg_t;

#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_DEFAULT (0x00001400U)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_WR_MASK (0xffffffffU)


///< When to force lock signal.
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_VAL_BF_WID (12)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_VAL_BF_MSK (0x00000FFF)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_VAL_BF_DEF (0x00000400)

///< Enable lock detect assertion at ext_lock_val time step (after last
///< dpd_rst_l = 1)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_EN_BF_OFF (12)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_EN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_EN_BF_DEF (0x00001000)

///< reserved
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_RESERVED299_BF_OFF (13)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_RESERVED299_BF_WID (19)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_RESERVED299_BF_MSK (0xFFFFE000)
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_RESERVED299_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG30_CSR_JUMPDET register description at address offset 0x78
  *
  * Register default value:        0x0500501C
  * Register full path in IP: pll_local/reg/pllreg30_csr_jumpdet
  * AnaRF PLL csr_jumpdet
  */

typedef union {
  struct {
    uint32_t TST_TH : 8;
    ///< Test threshold (usually, noise standard deviation related)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1C"
    uint32_t SET_TH : 8;
    ///< IIR threshold for jump detection
    ///< AccessType="RW" BitOffset="8" ResetValue="0x50"
    uint32_t RESERVED307 : 8;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t ONETAP_ALPHA : 3;
    ///< log2(period of time)
    ///< AccessType="RW" BitOffset="24" ResetValue="0x5"
    uint32_t RESERVED305 : 5;
    ///< reserved
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg30_csr_jumpdet_reg_t;

#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_DEFAULT (0x0500501cU)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_WR_MASK (0xffffffffU)


///< Test threshold (usually, noise standard deviation related)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_TST_TH_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_TST_TH_BF_WID ( 8)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_TST_TH_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_TST_TH_BF_DEF (0x0000001C)

///< IIR threshold for jump detection
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_SET_TH_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_SET_TH_BF_WID ( 8)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_SET_TH_BF_MSK (0x0000FF00)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_SET_TH_BF_DEF (0x00005000)

///< reserved
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED307_BF_OFF (16)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED307_BF_WID ( 8)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED307_BF_MSK (0x00FF0000)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED307_BF_DEF (0x00000000)

///< log2(period of time)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_ONETAP_ALPHA_BF_OFF (24)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_ONETAP_ALPHA_BF_WID ( 3)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_ONETAP_ALPHA_BF_MSK (0x07000000)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_ONETAP_ALPHA_BF_DEF (0x05000000)

///< reserved
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED305_BF_OFF (27)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED305_BF_WID ( 5)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED305_BF_MSK (0xF8000000)
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_RESERVED305_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG31_CSR_DLF register description at address offset 0x7c
  *
  * Register default value:        0x5D580287
  * Register full path in IP: pll_local/reg/pllreg31_csr_dlf
  * AnaRF PLL csr_dlf
  */

typedef union {
  struct {
    uint32_t K_MNT : 5;
    ///< Mantissa of the common gain coefficient. Actual values would range
    ///< [1, 16]/2^DLF_PRM_W
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7"
    uint32_t K_EXP : 2;
    ///< Exponent of the common gain coefficient.  Actual values taken would
    ///< range [-5, -2]
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t BETA_EXP : 3;
    ///< Exponent of the proportionate gain. Actual values span [3, 10].
    ///< AccessType="RW" BitOffset="7" ResetValue="0x5"
    uint32_t ALPHA : 4;
    ///< Mantissa of the additional pole. Actual values would range [0, 15]/2^DLF_PRM_W
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t RESERVED319 : 4;
    ///< reserved
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t INV_P_DA_EXP : 4;
    ///< Exponent of the inv_p_da
    ///< AccessType="RW" BitOffset="18" ResetValue="0x6"
    uint32_t INV_P_DA_MNT : 6;
    ///< Mantissa of the inv_p_da
    ///< AccessType="RW" BitOffset="22" ResetValue="0x35"
    uint32_t INV_P_DA_SGN : 1;
    ///< Sign of the inv_p_da
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint32_t INV_P_DA_OVRD : 1;
    ///< Use CSR values to override the inv_p_da
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t INV_P_DA_UPD : 1;
    ///< Continue updating inv_p_da after lock has been achieved
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint32_t RESERVED313 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg31_csr_dlf_reg_t;

#define PLL_LOCAL_PLLREG31_CSR_DLF_DEFAULT (0x5d580287U)
#define PLL_LOCAL_PLLREG31_CSR_DLF_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG31_CSR_DLF_WR_MASK (0xffffffffU)


///< Mantissa of the common gain coefficient. Actual values would range
///< [1, 16]/2^DLF_PRM_W
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_MNT_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_MNT_BF_WID ( 5)
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_MNT_BF_MSK (0x0000001F)
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_MNT_BF_DEF (0x00000007)

///< Exponent of the common gain coefficient.  Actual values taken would
///< range [-5, -2]
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_EXP_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_EXP_BF_WID ( 2)
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_EXP_BF_MSK (0x00000060)
#define PLL_LOCAL_PLLREG31_CSR_DLF_K_EXP_BF_DEF (0x00000000)

///< Exponent of the proportionate gain. Actual values span [3, 10].
#define PLL_LOCAL_PLLREG31_CSR_DLF_BETA_EXP_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG31_CSR_DLF_BETA_EXP_BF_WID ( 3)
#define PLL_LOCAL_PLLREG31_CSR_DLF_BETA_EXP_BF_MSK (0x00000380)
#define PLL_LOCAL_PLLREG31_CSR_DLF_BETA_EXP_BF_DEF (0x00000280)

///< Mantissa of the additional pole. Actual values would range [0, 15]/2^DLF_PRM_W
#define PLL_LOCAL_PLLREG31_CSR_DLF_ALPHA_BF_OFF (10)
#define PLL_LOCAL_PLLREG31_CSR_DLF_ALPHA_BF_WID ( 4)
#define PLL_LOCAL_PLLREG31_CSR_DLF_ALPHA_BF_MSK (0x00003C00)
#define PLL_LOCAL_PLLREG31_CSR_DLF_ALPHA_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED319_BF_OFF (14)
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED319_BF_WID ( 4)
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED319_BF_MSK (0x0003C000)
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED319_BF_DEF (0x00000000)

///< Exponent of the inv_p_da
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_EXP_BF_OFF (18)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_EXP_BF_WID ( 4)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_EXP_BF_MSK (0x003C0000)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_EXP_BF_DEF (0x00180000)

///< Mantissa of the inv_p_da
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_MNT_BF_OFF (22)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_MNT_BF_WID ( 6)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_MNT_BF_MSK (0x0FC00000)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_MNT_BF_DEF (0x0D400000)

///< Sign of the inv_p_da
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_SGN_BF_OFF (28)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_SGN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_SGN_BF_MSK (0x10000000)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_SGN_BF_DEF (0x10000000)

///< Use CSR values to override the inv_p_da
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_OVRD_BF_OFF (29)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_OVRD_BF_WID ( 1)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_OVRD_BF_MSK (0x20000000)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_OVRD_BF_DEF (0x00000000)

///< Continue updating inv_p_da after lock has been achieved
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_UPD_BF_OFF (30)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_UPD_BF_WID ( 1)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_UPD_BF_MSK (0x40000000)
#define PLL_LOCAL_PLLREG31_CSR_DLF_INV_P_DA_UPD_BF_DEF (0x40000000)

///< reserved
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED313_BF_OFF (31)
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED313_BF_WID ( 1)
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED313_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG31_CSR_DLF_RESERVED313_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG32_CSR_DLF2 register description at address offset 0x80
  *
  * Register default value:        0x034A169A
  * Register full path in IP: pll_local/reg/pllreg32_csr_dlf2
  * AnaRF PLL csr_dlf2
  */

typedef union {
  struct {
    uint32_t LIMIT_MIN : 6;
    ///< Lower range limit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1A"
    uint32_t LIMIT_MAX : 6;
    ///< Upper range limit.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1A"
    uint32_t LIMIT_ENABLE : 1;
    ///< Enable application of range limit prior to locking
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t LIMIT_MANUAL : 1;
    ///< Manually apply range limit.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t RESERVED330 : 2;
    ///< reserved
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t TH_SET_VAL : 6;
    ///< Band-edge threshold distance (set).
    ///< AccessType="RW" BitOffset="16" ResetValue="0xA"
    uint32_t TH_RST_VAL : 6;
    ///< Band-edge threshold distance (reset).
    ///< AccessType="RW" BitOffset="22" ResetValue="0xD"
    uint32_t RESERVED327 : 4;
    ///< reserved
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg32_csr_dlf2_reg_t;

#define PLL_LOCAL_PLLREG32_CSR_DLF2_DEFAULT (0x034a169aU)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_WR_MASK (0xffffffffU)


///< Lower range limit.
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MIN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MIN_BF_WID ( 6)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MIN_BF_MSK (0x0000003F)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MIN_BF_DEF (0x0000001A)

///< Upper range limit.
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MAX_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MAX_BF_WID ( 6)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MAX_BF_MSK (0x00000FC0)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MAX_BF_DEF (0x00000680)

///< Enable application of range limit prior to locking
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_EN_BF_OFF (12)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_EN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_EN_BF_DEF (0x00001000)

///< Manually apply range limit.
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MANUAL_BF_OFF (13)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MANUAL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MANUAL_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_LIMIT_MANUAL_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED330_BF_OFF (14)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED330_BF_WID ( 2)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED330_BF_MSK (0x0000C000)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED330_BF_DEF (0x00000000)

///< Band-edge threshold distance (set).
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_SET_VAL_BF_OFF (16)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_SET_VAL_BF_WID ( 6)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_SET_VAL_BF_MSK (0x003F0000)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_SET_VAL_BF_DEF (0x000A0000)

///< Band-edge threshold distance (reset).
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_RST_VAL_BF_OFF (22)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_RST_VAL_BF_WID ( 6)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_RST_VAL_BF_MSK (0x0FC00000)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_TH_RST_VAL_BF_DEF (0x03400000)

///< reserved
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED327_BF_OFF (28)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED327_BF_WID ( 4)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED327_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG32_CSR_DLF2_RESERVED327_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG33_CSR_DLF_OVERWRITE register description at address offset 0x84
  *
  * Register default value:        0x00008000
  * Register full path in IP: pll_local/reg/pllreg33_csr_dlf_overwrite
  * AnaRF PLL csr_dlf_overwrite
  */

typedef union {
  struct {
    uint32_t VAL : 16;
    ///< Value to be used for DLF overwrite.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x8000"
    uint32_t ON : 1;
    ///< Use CSR value to overwrite the DLF output.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t RESERVED338 : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg33_csr_dlf_overwrite_reg_t;

#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_DEFAULT (0x00008000U)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_WR_MASK (0xffffffffU)


///< Value to be used for DLF overwrite.
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_VAL_BF_WID (16)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_VAL_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_VAL_BF_DEF (0x00008000)

///< Use CSR value to overwrite the DLF output.
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_ON_BF_OFF (16)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_ON_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_ON_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_RESERVED338_BF_OFF (17)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_RESERVED338_BF_WID (15)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_RESERVED338_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_RESERVED338_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG34_CSR_MLFPE register description at address offset 0x88
  *
  * Register default value:        0x000037D7
  * Register full path in IP: pll_local/reg/pllreg34_csr_mlfpe
  * AnaRF PLL csr_mlfpe
  */

typedef union {
  struct {
    uint32_t FP_EST_EN : 1;
    ///< Enable fractional frequency estimation. Effectively enables FastLock
    ///< assitant.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t FP_FIT_LENGTH : 2;
    ///< Number of phases to be accumulated = 2^(fit_length+3) in fractional
    ///< frequency estimation
    ///< AccessType="RW" BitOffset="1" ResetValue="0x3"
    uint32_t FP_NO_OF_STEPS : 3;
    ///< Number of steps in fractional frequency estimation flow.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x2"
    uint32_t T0_FIT_LENGTH : 2;
    ///< Number of phases to be accumulated = 2^(fit_length+3) in phase shift
    ///< estimation
    ///< AccessType="RW" BitOffset="6" ResetValue="0x3"
    uint32_t T0_NO_OF_STEPS : 4;
    ///< Number of steps in phase shift estimation flow.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x7"
    uint32_t DERIV_TYPE : 1;
    ///< Derivative type. Set to 1 only in circuits exposed to unclotrolled
    ///< reference clock deterministic jitter.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t LOOP_DELAY : 3;
    ///< Waiting period allowing corrected inputs to arrive at the MLFPE input.
    ///< Incurred mainly by TDC and SEM.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t RESERVED344 : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg34_csr_mlfpe_reg_t;

#define PLL_LOCAL_PLLREG34_CSR_MLFPE_DEFAULT (0x000037d7U)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_WR_MASK (0xffffffffU)


///< Enable fractional frequency estimation. Effectively enables FastLock
///< assitant.
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_EST_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_EST_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_EST_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_EST_EN_BF_DEF (0x00000001)

///< Number of phases to be accumulated = 2^(fit_length+3) in fractional
///< frequency estimation
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_FIT_LENGTH_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_FIT_LENGTH_BF_WID ( 2)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_FIT_LENGTH_BF_MSK (0x00000006)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_FIT_LENGTH_BF_DEF (0x00000006)

///< Number of steps in fractional frequency estimation flow.
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_NO_OF_STEPS_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_NO_OF_STEPS_BF_WID ( 3)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_NO_OF_STEPS_BF_MSK (0x00000038)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_FP_NO_OF_STEPS_BF_DEF (0x00000010)

///< Number of phases to be accumulated = 2^(fit_length+3) in phase shift
///< estimation
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_FIT_LENGTH_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_FIT_LENGTH_BF_WID ( 2)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_FIT_LENGTH_BF_MSK (0x000000C0)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_FIT_LENGTH_BF_DEF (0x000000C0)

///< Number of steps in phase shift estimation flow.
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_NO_OF_STEPS_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_NO_OF_STEPS_BF_WID ( 4)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_NO_OF_STEPS_BF_MSK (0x00000F00)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_T0_NO_OF_STEPS_BF_DEF (0x00000700)

///< Derivative type. Set to 1 only in circuits exposed to unclotrolled
///< reference clock deterministic jitter.
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_DERIV_TYPE_BF_OFF (12)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_DERIV_TYPE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_DERIV_TYPE_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_DERIV_TYPE_BF_DEF (0x00001000)

///< Waiting period allowing corrected inputs to arrive at the MLFPE input.
///< Incurred mainly by TDC and SEM.
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_LOOP_DELAY_BF_OFF (13)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_LOOP_DELAY_BF_WID ( 3)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_LOOP_DELAY_BF_MSK (0x0000E000)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_LOOP_DELAY_BF_DEF (0x00002000)

///< reserved
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_RESERVED344_BF_OFF (16)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_RESERVED344_BF_WID (16)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_RESERVED344_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_RESERVED344_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG35_CSR_RDTC register description at address offset 0x8c
  *
  * Register default value:        0x4ED415C4
  * Register full path in IP: pll_local/reg/pllreg35_csr_rdtc
  * AnaRF PLL csr_rdtc
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< Enable REF DTC dithering and correction. Calibration is not masked
    ///< by this bit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t OP_MODE : 1;
    ///< DTC operation mode: 0 for sequential scan, 1 for DSM-3
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t ROT_STEP : 4;
    ///< Step size of sequential scan mode
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t ROT_BOUND : 4;
    ///< Boundary of the sequetial scan mode (minus one).
    ///< AccessType="RW" BitOffset="6" ResetValue="0x7"
    uint32_t DSM_WORD : 16;
    ///< 16-bit DSM-3 control word.
    ///< AccessType="RW" BitOffset="10" ResetValue="0xB505"
    uint32_t LFSR_EN : 1;
    ///< Enable LFSR injection into the DSM mechanism.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x1"
    uint32_t LOOP_DELAY : 2;
    ///< Delay to be applied on the compensation samples.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint32_t DERIV_TYPE : 1;
    ///< If asserted, will alter DTC state only every second clock in operation
    ///< mode. Not relevant to calibration.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t BYPASS_GATING : 1;
    ///< Bypasses DTC buffer chain gating mechanism. Control passed directly
    ///< to the analog part.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint32_t RESERVED355 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg35_csr_rdtc_reg_t;

#define PLL_LOCAL_PLLREG35_CSR_RDTC_DEFAULT (0x4ed415c4U)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_WR_MASK (0xffffffffU)


///< Enable REF DTC dithering and correction. Calibration is not masked
///< by this bit.
#define PLL_LOCAL_PLLREG35_CSR_RDTC_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_EN_BF_DEF (0x00000000)

///< DTC operation mode: 0 for sequential scan, 1 for DSM-3
#define PLL_LOCAL_PLLREG35_CSR_RDTC_OP_MODE_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_OP_MODE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_OP_MODE_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_OP_MODE_BF_DEF (0x00000000)

///< Step size of sequential scan mode
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_STEP_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_STEP_BF_WID ( 4)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_STEP_BF_MSK (0x0000003C)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_STEP_BF_DEF (0x00000004)

///< Boundary of the sequetial scan mode (minus one).
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_BOUND_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_BOUND_BF_WID ( 4)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_BOUND_BF_MSK (0x000003C0)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_ROT_BOUND_BF_DEF (0x000001C0)

///< 16-bit DSM-3 control word.
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DSM_WORD_BF_OFF (10)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DSM_WORD_BF_WID (16)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DSM_WORD_BF_MSK (0x03FFFC00)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DSM_WORD_BF_DEF (0x02D41400)

///< Enable LFSR injection into the DSM mechanism.
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LFSR_EN_BF_OFF (26)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LFSR_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LFSR_EN_BF_MSK (0x04000000)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LFSR_EN_BF_DEF (0x04000000)

///< Delay to be applied on the compensation samples.
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LOOP_DELAY_BF_OFF (27)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LOOP_DELAY_BF_WID ( 2)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LOOP_DELAY_BF_MSK (0x18000000)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_LOOP_DELAY_BF_DEF (0x08000000)

///< If asserted, will alter DTC state only every second clock in operation
///< mode. Not relevant to calibration.
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DERIV_TYPE_BF_OFF (29)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DERIV_TYPE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DERIV_TYPE_BF_MSK (0x20000000)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_DERIV_TYPE_BF_DEF (0x00000000)

///< Bypasses DTC buffer chain gating mechanism. Control passed directly
///< to the analog part.
#define PLL_LOCAL_PLLREG35_CSR_RDTC_BYP_GATING_BF_OFF (30)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_BYP_GATING_BF_WID ( 1)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_BYP_GATING_BF_MSK (0x40000000)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_BYP_GATING_BF_DEF (0x40000000)

///< reserved
#define PLL_LOCAL_PLLREG35_CSR_RDTC_RESERVED355_BF_OFF (31)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_RESERVED355_BF_WID ( 1)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_RESERVED355_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG35_CSR_RDTC_RESERVED355_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG36_CSR_RDTC_OVERRIDE register description at address offset 0x90
  *
  * Register default value:        0x0000001B
  * Register full path in IP: pll_local/reg/pllreg36_csr_rdtc_override
  * AnaRF PLL csr_rdtc_override
  */

typedef union {
  struct {
    uint32_t DELAY_VAL : 15;
    ///< Value to be used for delay override.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1B"
    uint32_t DELAY_ON : 1;
    ///< In time of calibration, use delay overwrite value instead of estimation
    ///< issued by MLFPE.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t RESERVED368 : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg36_csr_rdtc_ovrd_reg_t;

#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DEFAULT (0x0000001bU)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_WR_MASK (0xffffffffU)


///< Value to be used for delay override.
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_VAL_BF_WID (15)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_VAL_BF_MSK (0x00007FFF)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_VAL_BF_DEF (0x0000001B)

///< In time of calibration, use delay overwrite value instead of estimation
///< issued by MLFPE.
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_ON_BF_OFF (15)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_ON_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_DELAY_ON_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_RESERVED368_BF_OFF (16)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_RESERVED368_BF_WID (16)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_RESERVED368_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_RESERVED368_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG37_CSR_ASC1 register description at address offset 0x94
  *
  * Register default value:        0x00003202
  * Register full path in IP: pll_local/reg/pllreg37_csr_asc1
  * AnaRF PLL csr_asc1
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< Enable the ASC mechanism. The actual activation occurs at assertion
    ///< of dpd_lock_det signal.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DPD_INJ : 1;
    ///< Correction point injection 0 - DLF output 1 - DPD input
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t TF : 6;
    ///< Transfer function phase. [0,2p] region is mapped into [0,63]. See
    ///< HAS for optimal value table.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t GE : 3;
    ///< Gain estimation. See HAS for optimal value table.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x2"
    uint32_t MU : 4;
    ///< Initial mu value. See HAS for optimal value table.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x6"
    uint32_t GEAR : 3;
    ///< Number of gear shifts to apply.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t GEAR_T : 4;
    ///< Single gear time 2^(gear_t)
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t DCMT_T : 3;
    ///< Decimation time. After all gear shifts have been exhausted, update
    ///< LMS every dcmt_t+1 cycles.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t RESERVED374 : 7;
    ///< reserved
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg37_csr_asc1_reg_t;

#define PLL_LOCAL_PLLREG37_CSR_ASC1_DEFAULT (0x00003202U)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_WR_MASK (0xffffffffU)


///< Enable the ASC mechanism. The actual activation occurs at assertion
///< of dpd_lock_det signal.
#define PLL_LOCAL_PLLREG37_CSR_ASC1_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_EN_BF_DEF (0x00000000)

///< Correction point injection 0 - DLF output 1 - DPD input
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DPD_INJ_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DPD_INJ_BF_WID ( 1)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DPD_INJ_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DPD_INJ_BF_DEF (0x00000002)

///< Transfer function phase. [0,2p] region is mapped into [0,63]. See
///< HAS for optimal value table.
#define PLL_LOCAL_PLLREG37_CSR_ASC1_TF_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_TF_BF_WID ( 6)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_TF_BF_MSK (0x000000FC)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_TF_BF_DEF (0x00000000)

///< Gain estimation. See HAS for optimal value table.
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GE_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GE_BF_MSK (0x00000700)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GE_BF_DEF (0x00000200)

///< Initial mu value. See HAS for optimal value table.
#define PLL_LOCAL_PLLREG37_CSR_ASC1_MU_BF_OFF (11)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_MU_BF_WID ( 4)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_MU_BF_MSK (0x00007800)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_MU_BF_DEF (0x00003000)

///< Number of gear shifts to apply.
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_BF_OFF (15)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_BF_WID ( 3)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_BF_MSK (0x00038000)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_BF_DEF (0x00000000)

///< Single gear time 2^(gear_t)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_T_BF_OFF (18)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_T_BF_WID ( 4)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_T_BF_MSK (0x003C0000)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_GEAR_T_BF_DEF (0x00000000)

///< Decimation time. After all gear shifts have been exhausted, update
///< LMS every dcmt_t+1 cycles.
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DCMT_T_BF_OFF (22)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DCMT_T_BF_WID ( 3)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DCMT_T_BF_MSK (0x01C00000)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_DCMT_T_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG37_CSR_ASC1_RESERVED374_BF_OFF (25)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_RESERVED374_BF_WID ( 7)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_RESERVED374_BF_MSK (0xFE000000)
#define PLL_LOCAL_PLLREG37_CSR_ASC1_RESERVED374_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG38_CSR_ASC1_SPUR register description at address offset 0x98
  *
  * Register default value:        0x00001000
  * Register full path in IP: pll_local/reg/pllreg38_csr_asc1_spur
  * AnaRF PLL csr_asc1_spur
  */

typedef union {
  struct {
    uint32_t FRAC : 16;
    ///< Spur fraction to cancel.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
    uint32_t RESERVED386 : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg38_csr_asc1_spur_reg_t;

#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_DEFAULT (0x00001000U)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_WR_MASK (0xffffffffU)


///< Spur fraction to cancel.
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_FRAC_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_FRAC_BF_WID (16)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_FRAC_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_FRAC_BF_DEF (0x00001000)

///< reserved
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_RESERVED386_BF_OFF (16)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_RESERVED386_BF_WID (16)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_RESERVED386_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_RESERVED386_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG39_CSR_ASC2 register description at address offset 0x9c
  *
  * Register default value:        0x00003202
  * Register full path in IP: pll_local/reg/pllreg39_csr_asc2
  * AnaRF PLL csr_asc2
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< Enable the ASC mechanism. The actual activation occurs at assertion
    ///< of dpd_lock_det signal.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DPD_INJ : 1;
    ///< Correction point injection 0 - DLF output 1 - DPD input
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t TF : 6;
    ///< Transfer function phase. [0,2p] region is mapped into [0,63]. See
    ///< HAS for optimal value table.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t GE : 3;
    ///< Gain estimation. See HAS for optimal value table.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x2"
    uint32_t MU : 4;
    ///< Initial mu value. See HAS for optimal value table.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x6"
    uint32_t GEAR : 3;
    ///< Number of gear shifts to apply.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t GEAR_T : 4;
    ///< Single gear time 2^(gear_t)
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t DCMT_T : 3;
    ///< Decimation time. After all gear shifts have been exhausted, update
    ///< LMS every dcmt_t+1 cycles.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t RESERVED391 : 7;
    ///< reserved
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg39_csr_asc2_reg_t;

#define PLL_LOCAL_PLLREG39_CSR_ASC2_DEFAULT (0x00003202U)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_WR_MASK (0xffffffffU)


///< Enable the ASC mechanism. The actual activation occurs at assertion
///< of dpd_lock_det signal.
#define PLL_LOCAL_PLLREG39_CSR_ASC2_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_EN_BF_DEF (0x00000000)

///< Correction point injection 0 - DLF output 1 - DPD input
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DPD_INJ_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DPD_INJ_BF_WID ( 1)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DPD_INJ_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DPD_INJ_BF_DEF (0x00000002)

///< Transfer function phase. [0,2p] region is mapped into [0,63]. See
///< HAS for optimal value table.
#define PLL_LOCAL_PLLREG39_CSR_ASC2_TF_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_TF_BF_WID ( 6)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_TF_BF_MSK (0x000000FC)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_TF_BF_DEF (0x00000000)

///< Gain estimation. See HAS for optimal value table.
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GE_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GE_BF_MSK (0x00000700)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GE_BF_DEF (0x00000200)

///< Initial mu value. See HAS for optimal value table.
#define PLL_LOCAL_PLLREG39_CSR_ASC2_MU_BF_OFF (11)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_MU_BF_WID ( 4)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_MU_BF_MSK (0x00007800)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_MU_BF_DEF (0x00003000)

///< Number of gear shifts to apply.
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_BF_OFF (15)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_BF_WID ( 3)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_BF_MSK (0x00038000)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_BF_DEF (0x00000000)

///< Single gear time 2^(gear_t)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_T_BF_OFF (18)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_T_BF_WID ( 4)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_T_BF_MSK (0x003C0000)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_GEAR_T_BF_DEF (0x00000000)

///< Decimation time. After all gear shifts have been exhausted, update
///< LMS every dcmt_t+1 cycles.
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DCMT_T_BF_OFF (22)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DCMT_T_BF_WID ( 3)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DCMT_T_BF_MSK (0x01C00000)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_DCMT_T_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG39_CSR_ASC2_RESERVED391_BF_OFF (25)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_RESERVED391_BF_WID ( 7)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_RESERVED391_BF_MSK (0xFE000000)
#define PLL_LOCAL_PLLREG39_CSR_ASC2_RESERVED391_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG40_CSR_ASC2_SPUR register description at address offset 0xa0
  *
  * Register default value:        0x00001000
  * Register full path in IP: pll_local/reg/pllreg40_csr_asc2_spur
  * AnaRF PLL csr_asc2_spur
  */

typedef union {
  struct {
    uint32_t FRAC : 16;
    ///< Spur fraction to cancel.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
    uint32_t RESERVED403 : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg40_csr_asc2_spur_reg_t;

#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_DEFAULT (0x00001000U)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_WR_MASK (0xffffffffU)


///< Spur fraction to cancel.
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_FRAC_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_FRAC_BF_WID (16)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_FRAC_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_FRAC_BF_DEF (0x00001000)

///< reserved
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_RESERVED403_BF_OFF (16)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_RESERVED403_BF_WID (16)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_RESERVED403_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_RESERVED403_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG41_CSR_ASC3 register description at address offset 0xa4
  *
  * Register default value:        0x00003202
  * Register full path in IP: pll_local/reg/pllreg41_csr_asc3
  * AnaRF PLL csr_asc3
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< Enable the ASC mechanism. The actual activation occurs at assertion
    ///< of dpd_lock_det signal.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DPD_INJ : 1;
    ///< Correction point injection 0 - DLF output 1 - DPD input
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t TF : 6;
    ///< Transfer function phase. [0,2p] region is mapped into [0,63]. See
    ///< HAS for optimal value table.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t GE : 3;
    ///< Gain estimation. See HAS for optimal value table.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x2"
    uint32_t MU : 4;
    ///< Initial mu value. See HAS for optimal value table.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x6"
    uint32_t GEAR : 3;
    ///< Number of gear shifts to apply.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t GEAR_T : 4;
    ///< Single gear time 2^(gear_t)
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t DCMT_T : 3;
    ///< Decimation time. After all gear shifts have been exhausted, update
    ///< LMS every dcmt_t+1 cycles.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t RESERVED408 : 7;
    ///< reserved
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg41_csr_asc3_reg_t;

#define PLL_LOCAL_PLLREG41_CSR_ASC3_DEFAULT (0x00003202U)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_WR_MASK (0xffffffffU)


///< Enable the ASC mechanism. The actual activation occurs at assertion
///< of dpd_lock_det signal.
#define PLL_LOCAL_PLLREG41_CSR_ASC3_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_EN_BF_DEF (0x00000000)

///< Correction point injection 0 - DLF output 1 - DPD input
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DPD_INJ_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DPD_INJ_BF_WID ( 1)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DPD_INJ_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DPD_INJ_BF_DEF (0x00000002)

///< Transfer function phase. [0,2p] region is mapped into [0,63]. See
///< HAS for optimal value table.
#define PLL_LOCAL_PLLREG41_CSR_ASC3_TF_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_TF_BF_WID ( 6)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_TF_BF_MSK (0x000000FC)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_TF_BF_DEF (0x00000000)

///< Gain estimation. See HAS for optimal value table.
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GE_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GE_BF_MSK (0x00000700)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GE_BF_DEF (0x00000200)

///< Initial mu value. See HAS for optimal value table.
#define PLL_LOCAL_PLLREG41_CSR_ASC3_MU_BF_OFF (11)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_MU_BF_WID ( 4)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_MU_BF_MSK (0x00007800)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_MU_BF_DEF (0x00003000)

///< Number of gear shifts to apply.
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_BF_OFF (15)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_BF_WID ( 3)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_BF_MSK (0x00038000)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_BF_DEF (0x00000000)

///< Single gear time 2^(gear_t)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_T_BF_OFF (18)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_T_BF_WID ( 4)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_T_BF_MSK (0x003C0000)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_GEAR_T_BF_DEF (0x00000000)

///< Decimation time. After all gear shifts have been exhausted, update
///< LMS every dcmt_t+1 cycles.
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DCMT_T_BF_OFF (22)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DCMT_T_BF_WID ( 3)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DCMT_T_BF_MSK (0x01C00000)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_DCMT_T_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG41_CSR_ASC3_RESERVED408_BF_OFF (25)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_RESERVED408_BF_WID ( 7)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_RESERVED408_BF_MSK (0xFE000000)
#define PLL_LOCAL_PLLREG41_CSR_ASC3_RESERVED408_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG42_CSR_ASC3_SPUR register description at address offset 0xa8
  *
  * Register default value:        0x00001000
  * Register full path in IP: pll_local/reg/pllreg42_csr_asc3_spur
  * AnaRF PLL csr_asc3_spur
  */

typedef union {
  struct {
    uint32_t FRAC : 16;
    ///< Spur fraction to cancel.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1000"
    uint32_t RESERVED420 : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg42_csr_asc3_spur_reg_t;

#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_DEFAULT (0x00001000U)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_WR_MASK (0xffffffffU)


///< Spur fraction to cancel.
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_FRAC_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_FRAC_BF_WID (16)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_FRAC_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_FRAC_BF_DEF (0x00001000)

///< reserved
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_RESERVED420_BF_OFF (16)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_RESERVED420_BF_WID (16)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_RESERVED420_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_RESERVED420_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG43_CSR_ANA_CNT register description at address offset 0xac
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg43_csr_ana_cnt
  * AnaRF PLL csr_ana_cnt
  */

typedef union {
  struct {
    uint32_t SINGLE_MEAS : 1;
    ///< Start single analog counter measurement
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CYCLIC_MEAS : 1;
    ///< need single meas to activate when this bit is set to 1 the dpll will
    ///< keep repeating single messure until single_meas is set to 0
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t RESERVED425 : 30;
    ///< reserved
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg43_csr_ana_cnt_reg_t;

#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_WR_MASK (0xffffffffU)


///< Start single analog counter measurement
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_SINGLE_MEAS_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_SINGLE_MEAS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_SINGLE_MEAS_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_SINGLE_MEAS_BF_DEF (0x00000000)

///< need single meas to activate when this bit is set to 1 the dpll will
///< keep repeating single messure until single_meas is set to 0
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_CYCLIC_MEAS_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_CYCLIC_MEAS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_CYCLIC_MEAS_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_CYCLIC_MEAS_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_RESERVED425_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_RESERVED425_BF_WID (30)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_RESERVED425_BF_MSK (0xFFFFFFFC)
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_RESERVED425_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG44_CSR_DBGM register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg44_csr_dbgm
  * AnaRF PLL csr_dbgm
  */

typedef union {
  struct {
    uint32_t DAT_SEL : 4;
    ///< selects the output to DBGM
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t EVENT_SEL : 3;
    ///< event selector (other then external start)
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t START : 1;
    ///< start recording by initiating valid on output to DBGM
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t OUT_ORDER_SEL : 1;
    ///< 0 - regular output 64 bit mode (data[63:0]). 1 - flips 32 MSB's to
    ///< LSB and 32 LSB's to MSB. output 32  mode ( data[31:0],data63:32] ).
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CLOCK_SHIFTER : 4;
    ///< debug monitor clock shifter. Shift the debug monitor output clock
    ///< phase (has no effect over internal registers). Bits [2:0] add relay
    ///< to phase (200-400ps per unit depands on silicon type) Bit  [3] invert
    ///< clock.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CNTR_EVENT_EN : 1;
    ///< debug counter enable  1'b1- the Event is Enabled; 1'b0- the event
    ///< is disabled.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CNTR_EVENT_BYTE_EN : 4;
    ///< the active bytes of the 32bit event
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CNTR_EVENT_CFG : 3;
    ///< determines the period of the counter event. The period of the event
    ///< is equal to (2^cntr_event_cfg).
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t CNTR_HEADER_EN : 1;
    ///< enables cntr_header, this will show the value 0x1CEBOODA for 90 ref
    ///< cycles.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t RESERVED431 : 10;
    ///< reserved
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg44_csr_dbgm_reg_t;

#define PLL_LOCAL_PLLREG44_CSR_DBGM_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_WR_MASK (0xffffffffU)


///< selects the output to DBGM
#define PLL_LOCAL_PLLREG44_CSR_DBGM_DAT_SEL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_DAT_SEL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_DAT_SEL_BF_MSK (0x0000000F)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_DAT_SEL_BF_DEF (0x00000000)

///< event selector (other then external start)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_EVENT_SEL_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_EVENT_SEL_BF_WID ( 3)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_EVENT_SEL_BF_MSK (0x00000070)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_EVENT_SEL_BF_DEF (0x00000000)

///< start recording by initiating valid on output to DBGM
#define PLL_LOCAL_PLLREG44_CSR_DBGM_START_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_START_BF_WID ( 1)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_START_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_START_BF_DEF (0x00000000)

///< 0 - regular output 64 bit mode (data[63:0]). 1 - flips 32 MSB's to
///< LSB and 32 LSB's to MSB. output 32  mode ( data[31:0],data63:32] ).
#define PLL_LOCAL_PLLREG44_CSR_DBGM_OUT_ORDER_SEL_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_OUT_ORDER_SEL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_OUT_ORDER_SEL_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_OUT_ORDER_SEL_BF_DEF (0x00000000)

///< debug monitor clock shifter. Shift the debug monitor output clock
///< phase (has no effect over internal registers). Bits [2:0] add relay
///< to phase (200-400ps per unit depands on silicon type) Bit  [3] invert
///< clock.
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CLK_SHIFTER_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CLK_SHIFTER_BF_WID ( 4)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CLK_SHIFTER_BF_MSK (0x00001E00)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CLK_SHIFTER_BF_DEF (0x00000000)

///< debug counter enable  1'b1- the Event is Enabled; 1'b0- the event
///< is disabled.
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_EN_BF_OFF (13)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_EN_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_EN_BF_DEF (0x00000000)

///< the active bytes of the 32bit event
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_BYTE_EN_BF_OFF (14)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_BYTE_EN_BF_WID ( 4)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_BYTE_EN_BF_MSK (0x0003C000)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_BYTE_EN_BF_DEF (0x00000000)

///< determines the period of the counter event. The period of the event
///< is equal to (2^cntr_event_cfg).
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_CFG_BF_OFF (18)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_CFG_BF_WID ( 3)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_CFG_BF_MSK (0x001C0000)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_EVENT_CFG_BF_DEF (0x00000000)

///< enables cntr_header, this will show the value 0x1CEBOODA for 90 ref
///< cycles.
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_HEADER_EN_BF_OFF (21)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_HEADER_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_HEADER_EN_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_CNTR_HEADER_EN_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG44_CSR_DBGM_RESERVED431_BF_OFF (22)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_RESERVED431_BF_WID (10)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_RESERVED431_BF_MSK (0xFFC00000)
#define PLL_LOCAL_PLLREG44_CSR_DBGM_RESERVED431_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG45_CSR_ANALOG register description at address offset 0xb4
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg45_csr_analog
  * AnaRF PLL csr_analog
  */

typedef union {
  struct {
    uint32_t SPARE : 16;
    ///< reserved for analog controls
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESERVED444 : 16;
    ///< reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg45_csr_analog_reg_t;

#define PLL_LOCAL_PLLREG45_CSR_ANALOG_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_WR_MASK (0x0000ffffU)


///< reserved for analog controls
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_SPARE_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_SPARE_BF_WID (16)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_SPARE_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_SPARE_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_RESERVED444_BF_OFF (16)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_RESERVED444_BF_WID (16)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_RESERVED444_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_RESERVED444_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG46_CSR_STAT1 register description at address offset 0xb8
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg46_csr_stat1
  * AnaRF PLL csr_stat1
  */

typedef union {
  struct {
    uint32_t DPD_LOCK_DET_RISE_STICKY : 1;
    ///< Sticky rise lock det
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t DPD_LOCK_DET_FALL_STICKY : 1;
    ///< Sticky fall lock det
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t DPD_LOCK_DET : 1;
    ///< Non Sticky lock det
    ///< AccessType="RO" BitOffset="2" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
    uint32_t DPD_LOCK_FAILED : 1;
    ///< dpd_ext_lock counter won the race with dpd_lock_det - sticky by definition
    ///< AccessType="RO" BitOffset="4" ResetValue="0x0"
    uint32_t DPD_JUMP_DET_STICKY : 1;
    ///< DPD jump detected (sticky version)
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint32_t DPD_JUMP_DET : 1;
    ///< DPD jump detected
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t DLF_TH_EXCD : 1;
    ///< Hysteresis based DLF threshold crossing
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
    uint32_t ANA_CNT_MEAS_DONE : 1;
    ///< Analog counter measurement is done
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t SEM_LUT_READY : 1;
    ///< SEM LUT ready
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t SEM_EXTRACT_DONE : 1;
    ///< If no_norm set this indicate data ready at LUT
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t AFS_DONE : 1;
    ///< AFS done signal
    ///< AccessType="RO" BitOffset="11" ResetValue="0x0"
    uint32_t AFS_LUT_READY : 1;
    ///< AFS LUT ready
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
    uint32_t RDTC_LUT_READY : 1;
    ///< RDTC LUT ready
    ///< AccessType="RO" BitOffset="13" ResetValue="0x0"
    uint32_t CTRL_FLOWS_TO_DO : 5;
    ///< Mirrored flows_to_do register of the controller
    ///< AccessType="RO" BitOffset="14" ResetValue="0x0"
    uint32_t CTRL_STATE : 3;
    ///< Current state of the controller FSM
    ///< AccessType="RO" BitOffset="19" ResetValue="0x0"
    uint32_t CTRL_FLOW_DONE : 1;
    ///< Controller FSM is at idle state
    ///< AccessType="RO" BitOffset="22" ResetValue="0x0"
    uint32_t SEM_STATE : 2;
    ///< Current state of the SEM FSM
    ///< AccessType="RO" BitOffset="23" ResetValue="0x0"
    uint32_t RESERVED449 : 7;
    ///< reserved
    ///< AccessType="RO" BitOffset="25" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg46_csr_stat1_reg_t;

#define PLL_LOCAL_PLLREG46_CSR_STAT1_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RD_MASK (0xfffffff7U)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_WR_MASK (0x00000000U)


///< Sticky rise lock det
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_RISE_STICKY_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_RISE_STICKY_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_RISE_STICKY_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_RISE_STICKY_BF_DEF (0x00000000)

///< Sticky fall lock det
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_FALL_STICKY_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_FALL_STICKY_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_FALL_STICKY_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_FALL_STICKY_BF_DEF (0x00000000)

///< Non Sticky lock det
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_DET_BF_DEF (0x00000000)

///< dpd_ext_lock counter won the race with dpd_lock_det - sticky by definition
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_FAILED_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_FAILED_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_FAILED_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_LOCK_FAILED_BF_DEF (0x00000000)

///< DPD jump detected (sticky version)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_STICKY_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_STICKY_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_STICKY_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_STICKY_BF_DEF (0x00000000)

///< DPD jump detected
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DPD_JUMP_DET_BF_DEF (0x00000000)

///< Hysteresis based DLF threshold crossing
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DLF_TH_EXCD_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DLF_TH_EXCD_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DLF_TH_EXCD_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_DLF_TH_EXCD_BF_DEF (0x00000000)

///< Analog counter measurement is done
#define PLL_LOCAL_PLLREG46_CSR_STAT1_ANA_CNT_MEAS_DONE_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_ANA_CNT_MEAS_DONE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_ANA_CNT_MEAS_DONE_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_ANA_CNT_MEAS_DONE_BF_DEF (0x00000000)

///< SEM LUT ready
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_LUT_READY_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_LUT_READY_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_LUT_READY_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_LUT_READY_BF_DEF (0x00000000)

///< If no_norm set this indicate data ready at LUT
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_EXTRACT_DONE_BF_OFF (10)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_EXTRACT_DONE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_EXTRACT_DONE_BF_MSK (0x00000400)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_EXTRACT_DONE_BF_DEF (0x00000000)

///< AFS done signal
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_DONE_BF_OFF (11)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_DONE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_DONE_BF_MSK (0x00000800)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_DONE_BF_DEF (0x00000000)

///< AFS LUT ready
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_LUT_READY_BF_OFF (12)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_LUT_READY_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_LUT_READY_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_AFS_LUT_READY_BF_DEF (0x00000000)

///< RDTC LUT ready
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RDTC_LUT_READY_BF_OFF (13)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RDTC_LUT_READY_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RDTC_LUT_READY_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RDTC_LUT_READY_BF_DEF (0x00000000)

///< Mirrored flows_to_do register of the controller
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOWS_TO_DO_BF_OFF (14)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOWS_TO_DO_BF_WID ( 5)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOWS_TO_DO_BF_MSK (0x0007C000)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOWS_TO_DO_BF_DEF (0x00000000)

///< Current state of the controller FSM
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_STATE_BF_OFF (19)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_STATE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_STATE_BF_MSK (0x00380000)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_STATE_BF_DEF (0x00000000)

///< Controller FSM is at idle state
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOW_DONE_BF_OFF (22)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOW_DONE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOW_DONE_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_CTRL_FLOW_DONE_BF_DEF (0x00000000)

///< Current state of the SEM FSM
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_STATE_BF_OFF (23)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_STATE_BF_WID ( 2)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_STATE_BF_MSK (0x01800000)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_SEM_STATE_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RESERVED449_BF_OFF (25)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RESERVED449_BF_WID ( 7)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RESERVED449_BF_MSK (0xFE000000)
#define PLL_LOCAL_PLLREG46_CSR_STAT1_RESERVED449_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG47_CSR_STAT2 register description at address offset 0xbc
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg47_csr_stat2
  * AnaRF PLL csr_stat2
  */

typedef union {
  struct {
    uint32_t EFF_PERIOD : 16;
    ///< Current effective period
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t INV_DA : 16;
    ///< Inverse of da = Kdco/2/f_ref*2^LOG2_CYCLE_NUM. calculated by the AFS
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg47_csr_stat2_reg_t;

#define PLL_LOCAL_PLLREG47_CSR_STAT2_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_WR_MASK (0x00000000U)


///< Current effective period
#define PLL_LOCAL_PLLREG47_CSR_STAT2_EFF_PERIOD_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_EFF_PERIOD_BF_WID (16)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_EFF_PERIOD_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_EFF_PERIOD_BF_DEF (0x00000000)

///< Inverse of da = Kdco/2/f_ref*2^LOG2_CYCLE_NUM. calculated by the AFS
#define PLL_LOCAL_PLLREG47_CSR_STAT2_INV_DA_BF_OFF (16)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_INV_DA_BF_WID (16)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_INV_DA_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG47_CSR_STAT2_INV_DA_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG48_CSR_STAT3 register description at address offset 0xc0
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg48_csr_stat3
  * AnaRF PLL csr_stat3
  */

typedef union {
  struct {
    uint32_t ANA_CNT_MEAS : 16;
    ///< Latest analog counter measurment result
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t DLF_OUT : 16;
    ///< Output of the DLF
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg48_csr_stat3_reg_t;

#define PLL_LOCAL_PLLREG48_CSR_STAT3_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_WR_MASK (0x00000000U)


///< Latest analog counter measurment result
#define PLL_LOCAL_PLLREG48_CSR_STAT3_ANA_CNT_MEAS_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_ANA_CNT_MEAS_BF_WID (16)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_ANA_CNT_MEAS_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_ANA_CNT_MEAS_BF_DEF (0x00000000)

///< Output of the DLF
#define PLL_LOCAL_PLLREG48_CSR_STAT3_DLF_OUT_BF_OFF (16)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_DLF_OUT_BF_WID (16)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_DLF_OUT_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG48_CSR_STAT3_DLF_OUT_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG49_CSR_STAT4 register description at address offset 0xc4
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg49_csr_stat4
  * AnaRF PLL csr_stat4
  */

typedef union {
  struct {
    uint32_t AFS_BAND : 8;
    ///< Sub-band word for afs
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t AFS_TUNE : 16;
    ///< Tune word for afs
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t AFS_INT_STATE : 2;
    ///< Internal AFS FSM state
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
    uint32_t AFS_FLOW : 4;
    ///< AFS flow being performed right now
    ///< AccessType="RO" BitOffset="26" ResetValue="0x0"
    uint32_t RESERVED480 : 2;
    ///< reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg49_csr_stat4_reg_t;

#define PLL_LOCAL_PLLREG49_CSR_STAT4_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_WR_MASK (0x00000000U)


///< Sub-band word for afs
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_BAND_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_BAND_BF_WID ( 8)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_BAND_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_BAND_BF_DEF (0x00000000)

///< Tune word for afs
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_TUNE_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_TUNE_BF_WID (16)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_TUNE_BF_MSK (0x00FFFF00)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_TUNE_BF_DEF (0x00000000)

///< Internal AFS FSM state
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_INT_STATE_BF_OFF (24)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_INT_STATE_BF_WID ( 2)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_INT_STATE_BF_MSK (0x03000000)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_INT_STATE_BF_DEF (0x00000000)

///< AFS flow being performed right now
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_FLOW_BF_OFF (26)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_FLOW_BF_WID ( 4)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_FLOW_BF_MSK (0x3C000000)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_AFS_FLOW_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG49_CSR_STAT4_RESERVED480_BF_OFF (30)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_RESERVED480_BF_WID ( 2)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_RESERVED480_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG49_CSR_STAT4_RESERVED480_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG50_CSR_START_UP_SEQ register description at address offset 0xc8
  *
  * Register default value:        0x7F324B96
  * Register full path in IP: pll_local/reg/pllreg50_csr_start_up_seq
  * AnaRF PLL csr_start_up_seq
  */

typedef union {
  struct {
    uint32_t BG_WAIT_CYC : 8;
    ///< Number of wake-up cycles (/16) for band gap reference. Set to 0 for
    ///< the sequencer to skip this stage. Default: 150*16=2400 Seqencer clock
    ///< cycles
    ///< AccessType="RW" BitOffset="0" ResetValue="0x96"
    uint32_t LDO_WAIT_CYC : 8;
    ///< Number of wake-up cycles (/16) for LDO (10.4us for LDO start up with
    ///< 38.4 MHz clock). Set to 0 for the sequencer to skip this stage. Default:
    ///< 75*16=1200 Seqencer clock cycles
    ///< AccessType="RW" BitOffset="8" ResetValue="0x4B"
    uint32_t DCO_WAIT_CYC : 8;
    ///< Number of wake-up cycles (/16) for DCO (2us for DCO start up). Set
    ///< to 0 for the sequencer to skip this stage. Default: 50*16=800 Seqencer
    ///< clock cycles
    ///< AccessType="RW" BitOffset="16" ResetValue="0x32"
    uint32_t PWRDN_CTRL : 3;
    ///< controls the sequncer power down sequence bit[0] - do dco pwrdn_stage
    ///< bit[1] - do ldo pwrdn_stage bit[2] - do bg pwrdn_stage
    ///< AccessType="RW" BitOffset="24" ResetValue="0x7"
    uint32_t LDO_STARTUP_CYC_RATIO : 2;
    ///< Ratio of ldo_wait_cyc for LDO startup signal activation. Only active
    ///< when ldo_wait_cyc is active and config_ldo_startup_en = 1. Ratio is
    ///< as follows: 0x0 = 1/4, 0x1 = 1/2, 0x2 = 3/4, 0x3 = 1.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x3"
    uint32_t FILTER_BYPASS_CYC_RATIO : 2;
    ///< Ratio of bg_wait_cyc for VREF filter bypass signal activation. Only
    ///< active when ldo_wait_cyc is active and config_filter_bypass_en = 1.
    ///< Ratio is as follows: 0x0 = 1/4, 0x1 = 1/2, 0x2 = 3/4, 0x3 = 1.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x3"
    uint32_t START_UP_SEQ_SPARE : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg50_csr_start_up_seq_reg_t;

#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_DEFAULT (0x7f324b96U)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_WR_MASK (0xffffffffU)


///< Number of wake-up cycles (/16) for band gap reference. Set to 0 for
///< the sequencer to skip this stage. Default: 150*16=2400 Seqencer clock
///< cycles
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_BG_WAIT_CYC_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_BG_WAIT_CYC_BF_WID ( 8)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_BG_WAIT_CYC_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_BG_WAIT_CYC_BF_DEF (0x00000096)

///< Number of wake-up cycles (/16) for LDO (10.4us for LDO start up with
///< 38.4 MHz clock). Set to 0 for the sequencer to skip this stage. Default:
///< 75*16=1200 Seqencer clock cycles
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_WAIT_CYC_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_WAIT_CYC_BF_WID ( 8)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_WAIT_CYC_BF_MSK (0x0000FF00)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_WAIT_CYC_BF_DEF (0x00004B00)

///< Number of wake-up cycles (/16) for DCO (2us for DCO start up). Set
///< to 0 for the sequencer to skip this stage. Default: 50*16=800 Seqencer
///< clock cycles
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_DCO_WAIT_CYC_BF_OFF (16)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_DCO_WAIT_CYC_BF_WID ( 8)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_DCO_WAIT_CYC_BF_MSK (0x00FF0000)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_DCO_WAIT_CYC_BF_DEF (0x00320000)

///< controls the sequncer power down sequence bit[0] - do dco pwrdn_stage
///< bit[1] - do ldo pwrdn_stage bit[2] - do bg pwrdn_stage
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_PWRDN_CTRL_BF_OFF (24)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_PWRDN_CTRL_BF_WID ( 3)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_PWRDN_CTRL_BF_MSK (0x07000000)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_PWRDN_CTRL_BF_DEF (0x07000000)

///< Ratio of ldo_wait_cyc for LDO startup signal activation. Only active
///< when ldo_wait_cyc is active and config_ldo_startup_en = 1. Ratio is
///< as follows: 0x0 = 1/4, 0x1 = 1/2, 0x2 = 3/4, 0x3 = 1.
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_STARTUP_CYC_RATIO_BF_OFF (27)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_STARTUP_CYC_RATIO_BF_WID ( 2)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_STARTUP_CYC_RATIO_BF_MSK (0x18000000)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_LDO_STARTUP_CYC_RATIO_BF_DEF (0x18000000)

///< Ratio of bg_wait_cyc for VREF filter bypass signal activation. Only
///< active when ldo_wait_cyc is active and config_filter_bypass_en = 1.
///< Ratio is as follows: 0x0 = 1/4, 0x1 = 1/2, 0x2 = 3/4, 0x3 = 1.
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_FILTER_BYP_CYC_RATIO_BF_OFF (29)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_FILTER_BYP_CYC_RATIO_BF_WID ( 2)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_FILTER_BYP_CYC_RATIO_BF_MSK (0x60000000)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_FILTER_BYP_CYC_RATIO_BF_DEF (0x60000000)

///< reserved
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_START_UP_SEQ_SPARE_BF_OFF (31)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_START_UP_SEQ_SPARE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_START_UP_SEQ_SPARE_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_START_UP_SEQ_SPARE_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG51_CSR_SEQ register description at address offset 0xcc
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg51_csr_seq
  * AnaRF PLL csr_seq
  */

typedef union {
  struct {
    uint32_t START : 1;
    ///< rise -start the power on sequencer fall - start the power off sequencer
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESERVED498 : 31;
    ///< reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg51_csr_seq_reg_t;

#define PLL_LOCAL_PLLREG51_CSR_SEQ_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_WR_MASK (0x00000001U)


///< rise -start the power on sequencer fall - start the power off sequencer
#define PLL_LOCAL_PLLREG51_CSR_SEQ_START_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_START_BF_WID ( 1)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_START_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_START_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG51_CSR_SEQ_RESERVED498_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_RESERVED498_BF_WID (31)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_RESERVED498_BF_MSK (0xFFFFFFFE)
#define PLL_LOCAL_PLLREG51_CSR_SEQ_RESERVED498_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG52_CSR_SEQ_ON_CONFIG register description at address offset 0xd0
  *
  * Register default value:        0xFBF441FF
  * Register full path in IP: pll_local/reg/pllreg52_csr_seq_on_config
  * AnaRF PLL csr_seq_on_config
  */

typedef union {
  struct {
    uint32_t LVL_SHIFT_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t BAND_GAP_REF_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t DIG_ANA_ISOLATION_OFF : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t TDC_FLDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t LDO_DIG_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t LDO_DCODIG_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint32_t LDO_CORE_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint32_t ANA_DIG_ISOLATION_OFF : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint32_t MAIN_REF_CLK_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint32_t TDC_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t DCO1_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t DCO1_BUF_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t DCO1_BUF_LO_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DCO1_DIV_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t DIG_REF_CLK_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint32_t FLB_OS_DIV_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t FLB_OS_DIV0_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t FLB_OS_DIV1_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FLB_OS_DIV2_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint32_t FLB_OS_DIV3_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t FLB_RSTN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="20" ResetValue="0x1"
    uint32_t FLB_SDM_ON : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint32_t IQ_DIV_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="22" ResetValue="0x1"
    uint32_t MIXER_I_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="23" ResetValue="0x1"
    uint32_t DCO_BUF_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="24" ResetValue="0x1"
    uint32_t CONV_CLK_OUT_BUF_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="25" ResetValue="0x1"
    uint32_t DPD_SW_RST : 1;
    ///< Control the reset to dpd.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t START_NOW : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="27" ResetValue="0x1"
    uint32_t LDO_LOPA_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint32_t LDO_AUX_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="29" ResetValue="0x1"
    uint32_t FILTER_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="30" ResetValue="0x1"
    uint32_t LDO_STARTUP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="31" ResetValue="0x1"
  } ;
  uint32_t value;
} pll_local_pllreg52_csr_seq_on_cfg_reg_t;

#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DEFAULT (0xfbf441ffU)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LVL_SHIFT_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LVL_SHIFT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LVL_SHIFT_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LVL_SHIFT_EN_BF_DEF (0x00000001)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_BAND_GAP_REF_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_BAND_GAP_REF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_BAND_GAP_REF_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_BAND_GAP_REF_EN_BF_DEF (0x00000002)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_ANA_ISOLATION_OFF_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_ANA_ISOLATION_OFF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_ANA_ISOLATION_OFF_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_ANA_ISOLATION_OFF_BF_DEF (0x00000004)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_FLDO_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_FLDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_FLDO_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_FLDO_EN_BF_DEF (0x00000008)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DIG_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DIG_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DIG_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DIG_EN_BF_DEF (0x00000010)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DCODIG_EN_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DCODIG_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DCODIG_EN_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_DCODIG_EN_BF_DEF (0x00000020)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_CORE_EN_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_CORE_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_CORE_EN_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_CORE_EN_BF_DEF (0x00000040)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_ANA_DIG_ISOLATION_OFF_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_ANA_DIG_ISOLATION_OFF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_ANA_DIG_ISOLATION_OFF_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_ANA_DIG_ISOLATION_OFF_BF_DEF (0x00000080)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MAIN_REF_CLK_EN_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MAIN_REF_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MAIN_REF_CLK_EN_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MAIN_REF_CLK_EN_BF_DEF (0x00000100)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_PWRDN_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_PWRDN_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_TDC_PWRDN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_PWRDN_BF_OFF (10)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_PWRDN_BF_MSK (0x00000400)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_PWRDN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_PWRDN_BF_OFF (11)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_PWRDN_BF_MSK (0x00000800)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_PWRDN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_LO_PWRDN_BF_OFF (12)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_LO_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_LO_PWRDN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_BUF_LO_PWRDN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_DIV_PWRDN_BF_OFF (13)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_DIV_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_DIV_PWRDN_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO1_DIV_PWRDN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_REF_CLK_EN_BF_OFF (14)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_REF_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_REF_CLK_EN_BF_MSK (0x00004000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DIG_REF_CLK_EN_BF_DEF (0x00004000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV_PWRDN_BF_OFF (15)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV_PWRDN_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV_PWRDN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV0_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV0_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV0_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV0_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV1_EN_BF_OFF (17)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV1_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV1_EN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV1_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV2_EN_BF_OFF (18)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV2_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV2_EN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV2_EN_BF_DEF (0x00040000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV3_EN_BF_OFF (19)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV3_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV3_EN_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_OS_DIV3_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_RSTN_BF_OFF (20)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_RSTN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_RSTN_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_RSTN_BF_DEF (0x00100000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_SDM_ON_BF_OFF (21)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_SDM_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_SDM_ON_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FLB_SDM_ON_BF_DEF (0x00200000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_IQ_DIV_EN_BF_OFF (22)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_IQ_DIV_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_IQ_DIV_EN_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_IQ_DIV_EN_BF_DEF (0x00400000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MIXER_I_EN_BF_OFF (23)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MIXER_I_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MIXER_I_EN_BF_MSK (0x00800000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_MIXER_I_EN_BF_DEF (0x00800000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO_BUF_EN_BF_OFF (24)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO_BUF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO_BUF_EN_BF_MSK (0x01000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DCO_BUF_EN_BF_DEF (0x01000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_CONV_CLK_OUT_BUF_EN_BF_OFF (25)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_CONV_CLK_OUT_BUF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_CONV_CLK_OUT_BUF_EN_BF_MSK (0x02000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_CONV_CLK_OUT_BUF_EN_BF_DEF (0x02000000)

///< Control the reset to dpd.
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DPD_SW_RST_BF_OFF (26)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DPD_SW_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DPD_SW_RST_BF_MSK (0x04000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_DPD_SW_RST_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_START_NOW_BF_OFF (27)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_START_NOW_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_START_NOW_BF_MSK (0x08000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_START_NOW_BF_DEF (0x08000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_LOPA_EN_BF_OFF (28)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_LOPA_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_LOPA_EN_BF_MSK (0x10000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_LOPA_EN_BF_DEF (0x10000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_AUX_EN_BF_OFF (29)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_AUX_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_AUX_EN_BF_MSK (0x20000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_AUX_EN_BF_DEF (0x20000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FILTER_BYP_EN_BF_OFF (30)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FILTER_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FILTER_BYP_EN_BF_MSK (0x40000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_FILTER_BYP_EN_BF_DEF (0x40000000)

///< To Be Done
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_STARTUP_EN_BF_OFF (31)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_STARTUP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_STARTUP_EN_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_LDO_STARTUP_EN_BF_DEF (0x80000000)


/** @brief PLL_LOCAL_REG_PLLREG53_CSR_SEQ_OFF_CONFIG register description at address offset 0xd4
  *
  * Register default value:        0x3400BE00
  * Register full path in IP: pll_local/reg/pllreg53_csr_seq_off_config
  * AnaRF PLL csr_seq_off_config
  */

typedef union {
  struct {
    uint32_t LVL_SHIFT_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BAND_GAP_REF_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DIG_ANA_ISOLATION_OFF : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t TDC_FLDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LDO_DIG_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t LDO_DCODIG_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t LDO_CORE_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t ANA_DIG_ISOLATION_OFF : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t MAIN_REF_CLK_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TDC_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint32_t DCO1_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="10" ResetValue="0x1"
    uint32_t DCO1_BUF_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="11" ResetValue="0x1"
    uint32_t DCO1_BUF_LO_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t DCO1_DIV_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t DIG_REF_CLK_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t FLB_OS_DIV_PWRDN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="15" ResetValue="0x1"
    uint32_t FLB_OS_DIV0_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t FLB_OS_DIV1_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FLB_OS_DIV2_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t FLB_OS_DIV3_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t FLB_RSTN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t FLB_SDM_ON : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t IQ_DIV_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t MIXER_I_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t DCO_BUF_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t CONV_CLK_OUT_BUF_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t DPD_SW_RST : 1;
    ///< Controls the reset to dpd.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x1"
    uint32_t START_NOW : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t LDO_LOPA_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="28" ResetValue="0x1"
    uint32_t LDO_AUX_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="29" ResetValue="0x1"
    uint32_t SEQ_OFF_SPARE0 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t SEQ_OFF_SPARE1 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg53_csr_seq_off_cfg_reg_t;

#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DEFAULT (0x3400be00U)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LVL_SHIFT_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LVL_SHIFT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LVL_SHIFT_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LVL_SHIFT_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_BAND_GAP_REF_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_BAND_GAP_REF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_BAND_GAP_REF_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_BAND_GAP_REF_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_ANA_ISOLATION_OFF_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_ANA_ISOLATION_OFF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_ANA_ISOLATION_OFF_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_ANA_ISOLATION_OFF_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_FLDO_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_FLDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_FLDO_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_FLDO_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DIG_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DIG_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DIG_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DIG_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DCODIG_EN_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DCODIG_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DCODIG_EN_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_DCODIG_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_CORE_EN_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_CORE_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_CORE_EN_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_CORE_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_ANA_DIG_ISOLATION_OFF_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_ANA_DIG_ISOLATION_OFF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_ANA_DIG_ISOLATION_OFF_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_ANA_DIG_ISOLATION_OFF_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MAIN_REF_CLK_EN_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MAIN_REF_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MAIN_REF_CLK_EN_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MAIN_REF_CLK_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_PWRDN_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_PWRDN_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_TDC_PWRDN_BF_DEF (0x00000200)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_PWRDN_BF_OFF (10)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_PWRDN_BF_MSK (0x00000400)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_PWRDN_BF_DEF (0x00000400)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_PWRDN_BF_OFF (11)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_PWRDN_BF_MSK (0x00000800)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_PWRDN_BF_DEF (0x00000800)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_LO_PWRDN_BF_OFF (12)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_LO_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_LO_PWRDN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_BUF_LO_PWRDN_BF_DEF (0x00001000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_DIV_PWRDN_BF_OFF (13)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_DIV_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_DIV_PWRDN_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO1_DIV_PWRDN_BF_DEF (0x00002000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_REF_CLK_EN_BF_OFF (14)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_REF_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_REF_CLK_EN_BF_MSK (0x00004000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DIG_REF_CLK_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV_PWRDN_BF_OFF (15)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV_PWRDN_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV_PWRDN_BF_DEF (0x00008000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV0_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV0_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV0_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV0_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV1_EN_BF_OFF (17)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV1_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV1_EN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV1_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV2_EN_BF_OFF (18)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV2_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV2_EN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV2_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV3_EN_BF_OFF (19)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV3_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV3_EN_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_OS_DIV3_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_RSTN_BF_OFF (20)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_RSTN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_RSTN_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_RSTN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_SDM_ON_BF_OFF (21)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_SDM_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_SDM_ON_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_FLB_SDM_ON_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_IQ_DIV_EN_BF_OFF (22)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_IQ_DIV_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_IQ_DIV_EN_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_IQ_DIV_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MIXER_I_EN_BF_OFF (23)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MIXER_I_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MIXER_I_EN_BF_MSK (0x00800000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_MIXER_I_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO_BUF_EN_BF_OFF (24)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO_BUF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO_BUF_EN_BF_MSK (0x01000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DCO_BUF_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_CONV_CLK_OUT_BUF_EN_BF_OFF (25)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_CONV_CLK_OUT_BUF_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_CONV_CLK_OUT_BUF_EN_BF_MSK (0x02000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_CONV_CLK_OUT_BUF_EN_BF_DEF (0x00000000)

///< Controls the reset to dpd.
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DPD_SW_RST_BF_OFF (26)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DPD_SW_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DPD_SW_RST_BF_MSK (0x04000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_DPD_SW_RST_BF_DEF (0x04000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_START_NOW_BF_OFF (27)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_START_NOW_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_START_NOW_BF_MSK (0x08000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_START_NOW_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_LOPA_EN_BF_OFF (28)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_LOPA_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_LOPA_EN_BF_MSK (0x10000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_LOPA_EN_BF_DEF (0x10000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_AUX_EN_BF_OFF (29)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_AUX_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_AUX_EN_BF_MSK (0x20000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_LDO_AUX_EN_BF_DEF (0x20000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE0_BF_OFF (30)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE0_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE0_BF_MSK (0x40000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE0_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE1_BF_OFF (31)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE1_BF_WID ( 1)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE1_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_SEQ_OFF_SPARE1_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG54_CSR_MEMORY_CTRL1 register description at address offset 0xd8
  *
  * Register default value:        0x00000A54
  * Register full path in IP: pll_local/reg/pllreg54_csr_memory_ctrl1
  * AnaRF PLL csr_memory_ctrl1
  */

typedef union {
  struct {
    uint32_t SRAM_TEST1 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t SRAM_TEST_RNM : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SRAM_RME : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t SRAM_RM : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0xA"
    uint32_t TPTAM_RA : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t SRAM_WA : 3;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="9" ResetValue="0x5"
    uint32_t SRAM_WPULSE : 3;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t SRAM_BC1 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t SRAM_BC2 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t RESERVED573 : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg54_csr_memory_ctrl1_reg_t;

#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_DEFAULT (0x00000a54U)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST1_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST1_BF_WID ( 1)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST1_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST1_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST_RNM_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST_RNM_BF_WID ( 1)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST_RNM_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_TEST_RNM_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RME_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RME_BF_WID ( 1)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RME_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RME_BF_DEF (0x00000004)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RM_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RM_BF_WID ( 4)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RM_BF_MSK (0x00000078)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_RM_BF_DEF (0x00000050)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_TPTAM_RA_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_TPTAM_RA_BF_WID ( 2)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_TPTAM_RA_BF_MSK (0x00000180)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_TPTAM_RA_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WA_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WA_BF_WID ( 3)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WA_BF_MSK (0x00000E00)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WA_BF_DEF (0x00000A00)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WPULSE_BF_OFF (12)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WPULSE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WPULSE_BF_MSK (0x00007000)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_WPULSE_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC1_BF_OFF (15)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC1_BF_WID ( 1)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC1_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC1_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC2_BF_OFF (16)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC2_BF_WID ( 1)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC2_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_SRAM_BC2_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_RESERVED573_BF_OFF (17)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_RESERVED573_BF_WID (15)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_RESERVED573_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_RESERVED573_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG55_CSR_MEMORY_CTRL2 register description at address offset 0xdc
  *
  * Register default value:        0x001014A8
  * Register full path in IP: pll_local/reg/pllreg55_csr_memory_ctrl2
  * AnaRF PLL csr_memory_ctrl2
  */

typedef union {
  struct {
    uint32_t TPRAM_TEST1 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t TPRAM_TEST_RNM : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t TPRAM_TESTRWM : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t TPRAM_RME : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t TPRAM_RM : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0xA"
    uint32_t TPTAM_RA : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TPRAM_WA : 3;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="10" ResetValue="0x5"
    uint32_t TPRAM_WPULSE : 3;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t TPRAM_BC1 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t TPRAM_BC2 : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t LS : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t FISO : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DSB : 1;
    ///< deep sleep bar
    ///< AccessType="RW" BitOffset="20" ResetValue="0x1"
    uint32_t SD : 1;
    ///< shut down control
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t RESERVED586 : 10;
    ///< reserved
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg55_csr_memory_ctrl2_reg_t;

#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_DEFAULT (0x001014a8U)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST1_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST1_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST1_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST1_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST_RNM_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST_RNM_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST_RNM_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TEST_RNM_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TESTRWM_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TESTRWM_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TESTRWM_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_TESTRWM_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RME_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RME_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RME_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RME_BF_DEF (0x00000008)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RM_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RM_BF_WID ( 4)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RM_BF_MSK (0x000000F0)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_RM_BF_DEF (0x000000A0)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPTAM_RA_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPTAM_RA_BF_WID ( 2)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPTAM_RA_BF_MSK (0x00000300)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPTAM_RA_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WA_BF_OFF (10)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WA_BF_WID ( 3)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WA_BF_MSK (0x00001C00)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WA_BF_DEF (0x00001400)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WPULSE_BF_OFF (13)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WPULSE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WPULSE_BF_MSK (0x0000E000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_WPULSE_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC1_BF_OFF (16)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC1_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC1_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC1_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC2_BF_OFF (17)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC2_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC2_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_TPRAM_BC2_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_LS_BF_OFF (18)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_LS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_LS_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_LS_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_FISO_BF_OFF (19)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_FISO_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_FISO_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_FISO_BF_DEF (0x00000000)

///< deep sleep bar
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_DSB_BF_OFF (20)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_DSB_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_DSB_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_DSB_BF_DEF (0x00100000)

///< shut down control
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_SD_BF_OFF (21)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_SD_BF_WID ( 1)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_SD_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_SD_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_RESERVED586_BF_OFF (22)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_RESERVED586_BF_WID (10)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_RESERVED586_BF_MSK (0xFFC00000)
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_RESERVED586_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG56_CSR_VBAND_DIV_BIAS register description at address offset 0xe0
  *
  * Register default value:        0x00010000
  * Register full path in IP: pll_local/reg/pllreg56_csr_vband_div_bias
  * AnaRF PLL csr_vband_div_bias
  */

typedef union {
  struct {
    uint32_t DAC_P_EN : 1;
    ///< PMOS DAC enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DAC_P_CTRL : 7;
    ///< PMOS DAC voltage control
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DAC_N_EN : 1;
    ///< NMOS DAC enable
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DAC_N_CTRL : 7;
    ///< NMOS DAC voltage control
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t PWRDN : 1;
    ///< Divider power down
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t RESERVED604 : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg56_csr_vband_div_bias_reg_t;

#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DEFAULT (0x00010000U)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_WR_MASK (0xffffffffU)


///< PMOS DAC enable
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_EN_BF_DEF (0x00000000)

///< PMOS DAC voltage control
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_CTRL_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_CTRL_BF_WID ( 7)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_CTRL_BF_MSK (0x000000FE)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_P_CTRL_BF_DEF (0x00000000)

///< NMOS DAC enable
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_EN_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_EN_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_EN_BF_DEF (0x00000000)

///< NMOS DAC voltage control
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_CTRL_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_CTRL_BF_WID ( 7)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_CTRL_BF_MSK (0x0000FE00)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_DAC_N_CTRL_BF_DEF (0x00000000)

///< Divider power down
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_PWRDN_BF_OFF (16)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_PWRDN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_PWRDN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_PWRDN_BF_DEF (0x00010000)

///< reserved
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_RESERVED604_BF_OFF (17)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_RESERVED604_BF_WID (15)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_RESERVED604_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_RESERVED604_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG57_CSR_VBAND register description at address offset 0xe4
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg57_csr_vband
  * AnaRF PLL csr_vband
  */

typedef union {
  struct {
    uint32_t DCO_BIAS_EN : 4;
    ///< De-muxed (MUTEX-1) DCO<3:0> bias enable. LSB for the lowest band,
    ///< MSB for the highest.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DCO_BIAS_CTRL : 8;
    ///< DCO bias control
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t MUX_BIAS_EN : 1;
    ///< Bias of the MUX output driver enable.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t MUX_BIAS_CTRL : 7;
    ///< Bias of the MUX output driver control.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t RESERVED613 : 12;
    ///< reserved
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg57_csr_vband_reg_t;

#define PLL_LOCAL_PLLREG57_CSR_VBAND_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_WR_MASK (0xffffffffU)


///< De-muxed (MUTEX-1) DCO<3:0> bias enable. LSB for the lowest band,
///< MSB for the highest.
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_EN_BF_WID ( 4)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_EN_BF_MSK (0x0000000F)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_EN_BF_DEF (0x00000000)

///< DCO bias control
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_CTRL_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_CTRL_BF_WID ( 8)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_CTRL_BF_MSK (0x00000FF0)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_DCO_BIAS_CTRL_BF_DEF (0x00000000)

///< Bias of the MUX output driver enable.
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_EN_BF_OFF (12)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_EN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_EN_BF_DEF (0x00000000)

///< Bias of the MUX output driver control.
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_CTRL_BF_OFF (13)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_CTRL_BF_WID ( 7)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_CTRL_BF_MSK (0x000FE000)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_MUX_BIAS_CTRL_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG57_CSR_VBAND_RESERVED613_BF_OFF (20)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_RESERVED613_BF_WID (12)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_RESERVED613_BF_MSK (0xFFF00000)
#define PLL_LOCAL_PLLREG57_CSR_VBAND_RESERVED613_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG58_CSR_TDC_CLK_GATING register description at address offset 0xe8
  *
  * Register default value:        0x00003C13
  * Register full path in IP: pll_local/reg/pllreg58_csr_tdc_clk_gating
  * AnaRF PLL csr_tdc_clk_gating
  */

typedef union {
  struct {
    uint32_t FF_GRP_PWRDN : 10;
    ///< Power down a group of flip flops (start counting from the end of TDC
    ///< AccessType="RW" BitOffset="0" ResetValue="0x13"
    uint32_t MUX_CTRL : 10;
    ///< Controls the gating (ref clock) MUX
    ///< AccessType="RW" BitOffset="10" ResetValue="0xF"
    uint32_t RESERVED621 : 12;
    ///< reserved
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg58_csr_tdc_clk_gating_reg_t;

#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_DEFAULT (0x00003c13U)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_WR_MASK (0xffffffffU)


///< Power down a group of flip flops (start counting from the end of TDC
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_FF_GRP_PWRDN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_FF_GRP_PWRDN_BF_WID (10)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_FF_GRP_PWRDN_BF_MSK (0x000003FF)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_FF_GRP_PWRDN_BF_DEF (0x00000013)

///< Controls the gating (ref clock) MUX
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_MUX_CTRL_BF_OFF (10)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_MUX_CTRL_BF_WID (10)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_MUX_CTRL_BF_MSK (0x000FFC00)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_MUX_CTRL_BF_DEF (0x00003C00)

///< reserved
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_RESERVED621_BF_OFF (20)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_RESERVED621_BF_WID (12)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_RESERVED621_BF_MSK (0xFFF00000)
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_RESERVED621_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG59_CSR_PNC register description at address offset 0xec
  *
  * Register default value:        0x0406461C
  * Register full path in IP: pll_local/reg/pllreg59_csr_pnc
  * AnaRF PLL csr_pnc
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< Global PNC enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DPD_BIT_SEL : 5;
    ///< DPD bit select (31 signed ->8 signed). Defined as right shifts followed
    ///< by round and saturation check. Need to support up to 31-8+1=24 right
    ///< shifts where the extra state is for zero input.
    ///< AccessType="RW" BitOffset="1" ResetValue="0xE"
    uint32_t DRATE : 8;
    ///< DPLL rate control word.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x18"
    uint32_t MRATE : 8;
    ///< Modem rate control word.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x19"
    uint32_t SAT : 1;
    ///< Input bit select saturation sticky bit
    ///< AccessType="RO" BitOffset="22" ResetValue="0x0"
    uint32_t CLOCK_SHIFTER : 4;
    ///< pnc out data clock shifter. Shift the output clock phase (has effect
    ///< over pnc_clk domain  internal registers). Bits [2:0] add relay to
    ///< phase (200-400ps per unit depands on silicon type) Bit  [3] invert
    ///< clock.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x8"
    uint32_t RESERVED627 : 5;
    ///< reserved
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg59_csr_pnc_reg_t;

#define PLL_LOCAL_PLLREG59_CSR_PNC_DEFAULT (0x0406461cU)
#define PLL_LOCAL_PLLREG59_CSR_PNC_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG59_CSR_PNC_WR_MASK (0xffbfffffU)


///< Global PNC enable
#define PLL_LOCAL_PLLREG59_CSR_PNC_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG59_CSR_PNC_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG59_CSR_PNC_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG59_CSR_PNC_EN_BF_DEF (0x00000000)

///< DPD bit select (31 signed ->8 signed). Defined as right shifts followed
///< by round and saturation check. Need to support up to 31-8+1=24 right
///< shifts where the extra state is for zero input.
#define PLL_LOCAL_PLLREG59_CSR_PNC_DPD_BIT_SEL_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG59_CSR_PNC_DPD_BIT_SEL_BF_WID ( 5)
#define PLL_LOCAL_PLLREG59_CSR_PNC_DPD_BIT_SEL_BF_MSK (0x0000003E)
#define PLL_LOCAL_PLLREG59_CSR_PNC_DPD_BIT_SEL_BF_DEF (0x0000001C)

///< DPLL rate control word.
#define PLL_LOCAL_PLLREG59_CSR_PNC_DRATE_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG59_CSR_PNC_DRATE_BF_WID ( 8)
#define PLL_LOCAL_PLLREG59_CSR_PNC_DRATE_BF_MSK (0x00003FC0)
#define PLL_LOCAL_PLLREG59_CSR_PNC_DRATE_BF_DEF (0x00000600)

///< Modem rate control word.
#define PLL_LOCAL_PLLREG59_CSR_PNC_MRATE_BF_OFF (14)
#define PLL_LOCAL_PLLREG59_CSR_PNC_MRATE_BF_WID ( 8)
#define PLL_LOCAL_PLLREG59_CSR_PNC_MRATE_BF_MSK (0x003FC000)
#define PLL_LOCAL_PLLREG59_CSR_PNC_MRATE_BF_DEF (0x00064000)

///< Input bit select saturation sticky bit
#define PLL_LOCAL_PLLREG59_CSR_PNC_SAT_BF_OFF (22)
#define PLL_LOCAL_PLLREG59_CSR_PNC_SAT_BF_WID ( 1)
#define PLL_LOCAL_PLLREG59_CSR_PNC_SAT_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG59_CSR_PNC_SAT_BF_DEF (0x00000000)

///< pnc out data clock shifter. Shift the output clock phase (has effect
///< over pnc_clk domain  internal registers). Bits [2:0] add relay to
///< phase (200-400ps per unit depands on silicon type) Bit  [3] invert
///< clock.
#define PLL_LOCAL_PLLREG59_CSR_PNC_CLK_SHIFTER_BF_OFF (23)
#define PLL_LOCAL_PLLREG59_CSR_PNC_CLK_SHIFTER_BF_WID ( 4)
#define PLL_LOCAL_PLLREG59_CSR_PNC_CLK_SHIFTER_BF_MSK (0x07800000)
#define PLL_LOCAL_PLLREG59_CSR_PNC_CLK_SHIFTER_BF_DEF (0x04000000)

///< reserved
#define PLL_LOCAL_PLLREG59_CSR_PNC_RESERVED627_BF_OFF (27)
#define PLL_LOCAL_PLLREG59_CSR_PNC_RESERVED627_BF_WID ( 5)
#define PLL_LOCAL_PLLREG59_CSR_PNC_RESERVED627_BF_MSK (0xF8000000)
#define PLL_LOCAL_PLLREG59_CSR_PNC_RESERVED627_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG60_CSR_AE register description at address offset 0xf0
  *
  * Register default value:        0x003E07E4
  * Register full path in IP: pll_local/reg/pllreg60_csr_ae
  * AnaRF PLL csr_ae
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< enables the analog emualtor
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RDTC_DELAY : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x2"
    uint32_t KDCO : 2;
    ///< kdco- Band gain to full scale. actual kdco is 2^(2-csr_ae_kdco)
    ///< AccessType="RW" BitOffset="5" ResetValue="0x3"
    uint32_t PMAX_BASE : 9;
    ///< Maximum period (effectively, the TDC resolution)
    ///< AccessType="RW" BitOffset="7" ResetValue="0xF"
    uint32_t DCO_BASE : 8;
    ///< this is the dco frequency base (8 bit integer).
    ///< AccessType="RW" BitOffset="16" ResetValue="0x3E"
    uint32_t RESERVED637 : 8;
    ///< reserved
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg60_csr_ae_reg_t;

#define PLL_LOCAL_PLLREG60_CSR_AE_DEFAULT (0x003e07e4U)
#define PLL_LOCAL_PLLREG60_CSR_AE_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG60_CSR_AE_WR_MASK (0xffffffffU)


///< enables the analog emualtor
#define PLL_LOCAL_PLLREG60_CSR_AE_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG60_CSR_AE_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG60_CSR_AE_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG60_CSR_AE_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG60_CSR_AE_RDTC_DELAY_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG60_CSR_AE_RDTC_DELAY_BF_WID ( 4)
#define PLL_LOCAL_PLLREG60_CSR_AE_RDTC_DELAY_BF_MSK (0x0000001E)
#define PLL_LOCAL_PLLREG60_CSR_AE_RDTC_DELAY_BF_DEF (0x00000004)

///< kdco- Band gain to full scale. actual kdco is 2^(2-csr_ae_kdco)
#define PLL_LOCAL_PLLREG60_CSR_AE_KDCO_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG60_CSR_AE_KDCO_BF_WID ( 2)
#define PLL_LOCAL_PLLREG60_CSR_AE_KDCO_BF_MSK (0x00000060)
#define PLL_LOCAL_PLLREG60_CSR_AE_KDCO_BF_DEF (0x00000060)

///< Maximum period (effectively, the TDC resolution)
#define PLL_LOCAL_PLLREG60_CSR_AE_PMAX_BASE_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG60_CSR_AE_PMAX_BASE_BF_WID ( 9)
#define PLL_LOCAL_PLLREG60_CSR_AE_PMAX_BASE_BF_MSK (0x0000FF80)
#define PLL_LOCAL_PLLREG60_CSR_AE_PMAX_BASE_BF_DEF (0x00000780)

///< this is the dco frequency base (8 bit integer).
#define PLL_LOCAL_PLLREG60_CSR_AE_DCO_BASE_BF_OFF (16)
#define PLL_LOCAL_PLLREG60_CSR_AE_DCO_BASE_BF_WID ( 8)
#define PLL_LOCAL_PLLREG60_CSR_AE_DCO_BASE_BF_MSK (0x00FF0000)
#define PLL_LOCAL_PLLREG60_CSR_AE_DCO_BASE_BF_DEF (0x003E0000)

///< reserved
#define PLL_LOCAL_PLLREG60_CSR_AE_RESERVED637_BF_OFF (24)
#define PLL_LOCAL_PLLREG60_CSR_AE_RESERVED637_BF_WID ( 8)
#define PLL_LOCAL_PLLREG60_CSR_AE_RESERVED637_BF_MSK (0xFF000000)
#define PLL_LOCAL_PLLREG60_CSR_AE_RESERVED637_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG61_CSR_LDO_PDOS register description at address offset 0xf4
  *
  * Register default value:        0x00000001
  * Register full path in IP: pll_local/reg/pllreg61_csr_ldo_pdos
  * AnaRF PLL csr_ldo_pdos
  */

typedef union {
  struct {
    uint32_t W1C : 1;
    ///< pdos feature. Once written cannot be set to 1 again (unless hw reset)
    ///< Setting to 0 will disable the option to write to any LDO bypass_en.
    ///< Has priority over 8585 modes. It is W1C register and not defined in
    ///< such a way because of gap in essence. should not be check for read
    ///< in VP.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x1"
    uint32_t RESERVED646 : 31;
    ///< reserved
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg61_csr_ldo_pdos_reg_t;

#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_DEFAULT (0x00000001U)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_WR_MASK (0xfffffffeU)


///< pdos feature. Once written cannot be set to 1 again (unless hw reset)
///< Setting to 0 will disable the option to write to any LDO bypass_en.
///< Has priority over 8585 modes. It is W1C register and not defined in
///< such a way because of gap in essence. should not be check for read
///< in VP.
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_W1C_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_W1C_BF_WID ( 1)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_W1C_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_W1C_BF_DEF (0x00000001)

///< reserved
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_RESERVED646_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_RESERVED646_BF_WID (31)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_RESERVED646_BF_MSK (0xFFFFFFFE)
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_RESERVED646_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG62_CSR_BIST_STAT register description at address offset 0xf8
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg62_csr_bist_stat
  * AnaRF PLL csr_bist_stat
  */

typedef union {
  struct {
    uint32_t BIST_ON : 1;
    ///< bist status indication.
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t BIST_CFG : 4;
    ///< shows bist config status
    ///< AccessType="RO" BitOffset="1" ResetValue="0x0"
    uint32_t TEST_DP_DONE : 1;
    ///< indicates if datapath test is done
    ///< AccessType="RO" BitOffset="5" ResetValue="0x0"
    uint32_t TEST_DP_PASS : 1;
    ///< indicates if datapath test passed
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t TEST_MEM_DONE : 1;
    ///< indicates if memories test is done
    ///< AccessType="RO" BitOffset="7" ResetValue="0x0"
    uint32_t TEST_MEM_PASS : 1;
    ///< indicates if memories test passed
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t TEST_REG_DONE : 1;
    ///< indicates if registers test is done
    ///< AccessType="RO" BitOffset="9" ResetValue="0x0"
    uint32_t TEST_REG_PASS : 1;
    ///< indicates if registers test passed
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t BIST_MEM_FAIL_NUM : 2;
    ///< indicates which mem failed (only in case of test_mem_pass == 0)  0
    ///< - sem 1 -afs 2- rdtc
    ///< AccessType="RO" BitOffset="11" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="13" ResetValue="None"
    uint32_t BIST_MEM_FAIL_SEQ : 2;
    ///< indicates which sequence failed in memory test (only in case of test_mem_pass
    ///< == 0)
    ///< AccessType="RO" BitOffset="14" ResetValue="0x0"
    uint32_t BIST_CRC : 16;
    ///< shows current output of the CRC.
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg62_csr_bist_stat_reg_t;

#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_RD_MASK (0xffffdfffU)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_WR_MASK (0x00000000U)


///< bist status indication.
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_ON_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_ON_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_ON_BF_DEF (0x00000000)

///< shows bist config status
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CFG_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CFG_BF_WID ( 4)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CFG_BF_MSK (0x0000001E)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CFG_BF_DEF (0x00000000)

///< indicates if datapath test is done
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_DONE_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_DONE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_DONE_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_DONE_BF_DEF (0x00000000)

///< indicates if datapath test passed
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_PASS_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_PASS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_PASS_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DP_PASS_BF_DEF (0x00000000)

///< indicates if memories test is done
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_DONE_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_DONE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_DONE_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_DONE_BF_DEF (0x00000000)

///< indicates if memories test passed
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_PASS_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_PASS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_PASS_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_MEM_PASS_BF_DEF (0x00000000)

///< indicates if registers test is done
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DONE_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DONE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DONE_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_DONE_BF_DEF (0x00000000)

///< indicates if registers test passed
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_PASS_BF_OFF (10)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_PASS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_PASS_BF_MSK (0x00000400)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_TEST_PASS_BF_DEF (0x00000000)

///< indicates which mem failed (only in case of test_mem_pass == 0)  0
///< - sem 1 -afs 2- rdtc
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_NUM_BF_OFF (11)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_NUM_BF_WID ( 2)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_NUM_BF_MSK (0x00001800)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_NUM_BF_DEF (0x00000000)

///< indicates which sequence failed in memory test (only in case of test_mem_pass
///< == 0)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_SEQ_BF_OFF (14)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_SEQ_BF_WID ( 2)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_SEQ_BF_MSK (0x0000C000)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_MEM_FAIL_SEQ_BF_DEF (0x00000000)

///< shows current output of the CRC.
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CRC_BF_OFF (16)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CRC_BF_WID (16)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CRC_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_BIST_CRC_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG63_CSR_LDO3 register description at address offset 0xfc
  *
  * Register default value:        0x00000140
  * Register full path in IP: pll_local/reg/pllreg63_csr_ldo3
  * AnaRF PLL csr_ldo3
  */

typedef union {
  struct {
    uint32_t LOPA_LDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LOPA_LDO_LP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t LOPA_LDO_HIGHZ_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t LOPA_LDO_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LOPA_LDO_START_UP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t LOPA_LDO_MON_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t LOPA_LDO_VOUT_TUNE : 4;
    ///< lopa_ldo_vlout_tune[1:0] = tune VREF for LOPA-LDO lopa_ldo_vlout_tune[3:2]
    ///< = tune VREF for SYSREF/AUX/FAST LDOs lopa_ldo_vlout_tune[1:0]: 0x0=0.7V,
    ///< 0x1=0.8V, 0x2=0.9V, 0x3=1.0V  lopa_ldo_vlout_tune[3:2]: 0x0=0.7V,
    ///< 0x1=0.8V, 0x2=0.9V, 0x3=1.0V
    ///< AccessType="RW" BitOffset="6" ResetValue="0x5"
    uint32_t LOPA_LDO_SINK_CURR : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t LOPA_LDO_RES_CTRL : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t AUX_LDO_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t AUX_LDO_LP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t AUX_LDO_HIGHZ_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t AUX_LDO_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t AUX_LDO_START_UP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t AUX_LDO_MON_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t AUX_LDO_VOUT_TUNE : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t AUX_LDO_SINK_CURR : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t AUX_LDO_RES_CTRL : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg63_csr_ldo3_reg_t;

#define PLL_LOCAL_PLLREG63_CSR_LDO3_DEFAULT (0x00000140U)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_LP_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_LP_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_LP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_HIGHZ_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_HIGHZ_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_HIGHZ_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_HIGHZ_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_BYP_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_BYP_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_BYP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_START_UP_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_START_UP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_START_UP_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_START_UP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_MON_EN_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_MON_EN_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_MON_EN_BF_DEF (0x00000000)

///< lopa_ldo_vlout_tune[1:0] = tune VREF for LOPA-LDO lopa_ldo_vlout_tune[3:2]
///< = tune VREF for SYSREF/AUX/FAST LDOs lopa_ldo_vlout_tune[1:0]: 0x0=0.7V,
///< 0x1=0.8V, 0x2=0.9V, 0x3=1.0V  lopa_ldo_vlout_tune[3:2]: 0x0=0.7V,
///< 0x1=0.8V, 0x2=0.9V, 0x3=1.0V
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_VOUT_TUNE_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_VOUT_TUNE_BF_MSK (0x000003C0)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_VOUT_TUNE_BF_DEF (0x00000140)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_SINK_CURR_BF_OFF (10)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_SINK_CURR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_SINK_CURR_BF_MSK (0x00000C00)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_SINK_CURR_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_RES_CTRL_BF_OFF (12)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_RES_CTRL_BF_MSK (0x0000F000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_LOPA_LDO_RES_CTRL_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_LP_EN_BF_OFF (17)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_LP_EN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_LP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_HIGHZ_EN_BF_OFF (18)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_HIGHZ_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_HIGHZ_EN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_HIGHZ_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_BYP_EN_BF_OFF (19)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_BYP_EN_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_BYP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_START_UP_EN_BF_OFF (20)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_START_UP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_START_UP_EN_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_START_UP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_MON_EN_BF_OFF (21)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_MON_EN_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_MON_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_VOUT_TUNE_BF_OFF (22)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_VOUT_TUNE_BF_MSK (0x03C00000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_VOUT_TUNE_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_SINK_CURR_BF_OFF (26)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_SINK_CURR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_SINK_CURR_BF_MSK (0x0C000000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_SINK_CURR_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_RES_CTRL_BF_OFF (28)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_RES_CTRL_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG63_CSR_LDO3_AUX_LDO_RES_CTRL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG64_CSR_ABC_CTRL1 register description at address offset 0x100
  *
  * Register default value:        0x00006900
  * Register full path in IP: pll_local/reg/pllreg64_csr_abc_ctrl1
  * AnaRF PLL csr_abc_ctrl1
  */

typedef union {
  struct {
    uint32_t BGP_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BGP_TRIM : 3;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t BGP_LDO_BYPASS_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t BGP_LDO_VOUT_TUNE : 3;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t SEQ_CLK_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint32_t SEQ_CLK_DIV : 4;
    ///< default: 0x4 = divide by 16
    ///< AccessType="RW" BitOffset="9" ResetValue="0x4"
    uint32_t REF_CLK_OUT_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t REF_CLK_OUT_DIV : 4;
    ///< default: 0x1 = divide by 2
    ///< AccessType="RW" BitOffset="14" ResetValue="0x1"
    uint32_t FREQ_SEL_INT_VAL : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t FREQ_SEL_INT_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DIG_SPARE : 9;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg64_csr_ctrl1_reg_t;

#define PLL_LOCAL_PLLREG64_CSR_CTRL1_DEFAULT (0x00006900U)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_TRIM_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_TRIM_BF_WID ( 3)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_TRIM_BF_MSK (0x0000000E)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_TRIM_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_BYP_EN_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_BYP_EN_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_BYP_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_VOUT_TUNE_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_VOUT_TUNE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_VOUT_TUNE_BF_MSK (0x000000E0)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_BGP_LDO_VOUT_TUNE_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_EN_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_EN_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_EN_BF_DEF (0x00000100)

///< default: 0x4 = divide by 16
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_DIV_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_DIV_BF_WID ( 4)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_DIV_BF_MSK (0x00001E00)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_SEQ_CLK_DIV_BF_DEF (0x00000800)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_EN_BF_OFF (13)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_EN_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_EN_BF_DEF (0x00002000)

///< default: 0x1 = divide by 2
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_DIV_BF_OFF (14)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_DIV_BF_WID ( 4)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_DIV_BF_MSK (0x0003C000)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REF_CLK_OUT_DIV_BF_DEF (0x00004000)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_VAL_BF_OFF (18)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_VAL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_VAL_BF_MSK (0x003C0000)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_VAL_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_EN_BF_OFF (22)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_EN_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_FREQ_SEL_INT_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_DIG_SPARE_BF_OFF (23)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_DIG_SPARE_BF_WID ( 9)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_DIG_SPARE_BF_MSK (0xFF800000)
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_DIG_SPARE_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG65_CSR_ABC_DCOTC1 register description at address offset 0x104
  *
  * Register default value:        0x00140204
  * Register full path in IP: pll_local/reg/pllreg65_csr_abc_dcotc1
  * AnaRF PLL csr_abc_dcotc1
  */

typedef union {
  struct {
    uint32_t DCOTC1_CTRL_SDM_ON : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DCOTC1_CTRL_SDM_ORDER : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DCOTC1_CTRL_SDM_CLK_LAG : 2;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t DCOTC1_CTRL_SDM_CLK_DIV : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t DCOTC1_CTRL_DEC_1HOT_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DCOTC1_CTRL_DEC_CLK_EN : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint32_t DCOTC1_DATA : 12;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="10" ResetValue="0x500"
    uint32_t RESERVED700 : 10;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg65_csr_dcotc1_reg_t;

#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_DEFAULT (0x00140204U)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ON_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ON_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ON_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ORDER_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ORDER_BF_WID ( 1)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ORDER_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_ORDER_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_LAG_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_LAG_BF_WID ( 2)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_LAG_BF_MSK (0x0000000C)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_LAG_BF_DEF (0x00000004)

///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_DIV_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_DIV_BF_WID ( 4)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_DIV_BF_MSK (0x000000F0)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_SDM_CLK_DIV_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_1HOT_EN_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_1HOT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_1HOT_EN_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_1HOT_EN_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_CLK_EN_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_CLK_EN_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_CTRL_DEC_CLK_EN_BF_DEF (0x00000200)

///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_DATA_BF_OFF (10)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_DATA_BF_WID (12)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_DATA_BF_MSK (0x003FFC00)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_DATA_BF_DEF (0x00140000)

///< To Be Done
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_RESERVED700_BF_OFF (22)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_RESERVED700_BF_WID (10)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_RESERVED700_BF_MSK (0xFFC00000)
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_RESERVED700_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG66_CSR_ABC_DCOTC2 register description at address offset 0x108
  *
  * Register default value:        0x007BCD40
  * Register full path in IP: pll_local/reg/pllreg66_csr_abc_dcotc2
  * AnaRF PLL csr_abc_dcotc2
  */

typedef union {
  struct {
    uint32_t DCOTC2_WAIT_CYCLES : 8;
    ///< #cycles to wait for settling and average, ~4ns / LSB @ 245.76MHz
    ///< AccessType="RW" BitOffset="0" ResetValue="0x40"
    uint32_t DCOTC2_WAIT_CYCLES_MULT : 3;
    ///< cycle multiplier: 0x0=1,0x11=2,0x2=4,...,0x4=16,...,0x7=128
    ///< AccessType="RW" BitOffset="8" ResetValue="0x5"
    uint32_t DCOTC2_IIR_GEAR : 2;
    ///< gear value 0 to 3
    ///< AccessType="RW" BitOffset="11" ResetValue="0x1"
    uint32_t DCOTC2_FSM_RESET : 1;
    ///< manual FSM reset
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t DCOTC2_CAL_CYCLES : 5;
    ///< number of calibration steps / mem addr for readback after cal.
    ///< AccessType="RW" BitOffset="14" ResetValue="0xF"
    uint32_t DCOTC2_RAMP_DELAY : 8;
    ///< #cycles to wait for settling and average, ~4ns / LSB @ 245.76MHz
    ///< AccessType="RW" BitOffset="19" ResetValue="0xF"
    uint32_t DCOTC2_RAMP_DELAY_MULT : 3;
    ///< cycle multiplier: 0=1,1=2,2=4,...,4=16,...,7=128
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t DCOTC2_OPMODE : 2;
    ///< 0:disable, 1:dlf_th_ind, 2:tc_tresh_center, 3:tc_tresh_top/bot
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg66_csr_dcotc2_reg_t;

#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_DEFAULT (0x007bcd40U)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WR_MASK (0xffffffffU)


///< #cycles to wait for settling and average, ~4ns / LSB @ 245.76MHz
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_BF_WID ( 8)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_BF_DEF (0x00000040)

///< cycle multiplier: 0x0=1,0x11=2,0x2=4,...,0x4=16,...,0x7=128
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_MULT_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_MULT_BF_WID ( 3)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_MULT_BF_MSK (0x00000700)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_WAIT_CYCLES_MULT_BF_DEF (0x00000500)

///< gear value 0 to 3
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_IIR_GEAR_BF_OFF (11)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_IIR_GEAR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_IIR_GEAR_BF_MSK (0x00001800)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_IIR_GEAR_BF_DEF (0x00000800)

///< manual FSM reset
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_FSM_RST_BF_OFF (13)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_FSM_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_FSM_RST_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_FSM_RST_BF_DEF (0x00000000)

///< number of calibration steps / mem addr for readback after cal.
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_CAL_CYCLES_BF_OFF (14)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_CAL_CYCLES_BF_WID ( 5)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_CAL_CYCLES_BF_MSK (0x0007C000)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_CAL_CYCLES_BF_DEF (0x0003C000)

///< #cycles to wait for settling and average, ~4ns / LSB @ 245.76MHz
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_BF_OFF (19)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_BF_WID ( 8)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_BF_MSK (0x07F80000)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_BF_DEF (0x00780000)

///< cycle multiplier: 0=1,1=2,2=4,...,4=16,...,7=128
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_MULT_BF_OFF (27)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_MULT_BF_WID ( 3)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_MULT_BF_MSK (0x38000000)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_RAMP_DELAY_MULT_BF_DEF (0x00000000)

///< 0:disable, 1:dlf_th_ind, 2:tc_tresh_center, 3:tc_tresh_top/bot
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_OPMODE_BF_OFF (30)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_OPMODE_BF_WID ( 2)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_OPMODE_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_OPMODE_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG67_CSR_ABC_DCOTC3 register description at address offset 0x10c
  *
  * Register default value:        0x00011808
  * Register full path in IP: pll_local/reg/pllreg67_csr_abc_dcotc3
  * AnaRF PLL csr_abc_dcotc3
  */

typedef union {
  struct {
    uint32_t DCOTC3_TCMODE : 2;
    ///< 0: direct switch, 1: ramp with sdm
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DCOTC3_RAMP_STEP : 3;
    ///< step size for ramp 2^dcotc3_ramp_step
    ///< AccessType="RW" BitOffset="2" ResetValue="0x2"
    uint32_t DCOTC3_SPARE1 : 5;
    ///< spare1 signal tbd
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t DCOTC3_DLF_TH_VAL : 6;
    ///< treshold for activation of switching 0x1000
    ///< AccessType="RW" BitOffset="10" ResetValue="0x6"
    uint32_t DCOTC3_TH_FROM_CAL : 1;
    ///< 0:th from register dcotc3_dlf_th_val, 1:th from calibration
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t DCOTC3_SPARE2 : 15;
    ///< spare2 signal tbd
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg67_csr_dcotc3_reg_t;

#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_DEFAULT (0x00011808U)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_WR_MASK (0xffffffffU)


///< 0: direct switch, 1: ramp with sdm
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TCMODE_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TCMODE_BF_WID ( 2)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TCMODE_BF_MSK (0x00000003)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TCMODE_BF_DEF (0x00000000)

///< step size for ramp 2^dcotc3_ramp_step
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_RAMP_STEP_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_RAMP_STEP_BF_WID ( 3)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_RAMP_STEP_BF_MSK (0x0000001C)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_RAMP_STEP_BF_DEF (0x00000008)

///< spare1 signal tbd
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE1_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE1_BF_WID ( 5)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE1_BF_MSK (0x000003E0)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE1_BF_DEF (0x00000000)

///< treshold for activation of switching 0x1000
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_DLF_TH_VAL_BF_OFF (10)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_DLF_TH_VAL_BF_WID ( 6)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_DLF_TH_VAL_BF_MSK (0x0000FC00)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_DLF_TH_VAL_BF_DEF (0x00001800)

///< 0:th from register dcotc3_dlf_th_val, 1:th from calibration
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TH_FROM_CAL_BF_OFF (16)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TH_FROM_CAL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TH_FROM_CAL_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_TH_FROM_CAL_BF_DEF (0x00010000)

///< spare2 signal tbd
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE2_BF_OFF (17)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE2_BF_WID (15)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE2_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_SPARE2_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG68_CSR_ABC_DCOTC4 register description at address offset 0x110
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg68_csr_abc_dcotc4
  * AnaRF PLL csr_abc_dcotc4
  */

typedef union {
  struct {
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t DCOTC4_CALMEM_DATA : 6;
    ///< csr_abc_dcotc4_rdata =  csr_abc_dcotc4_reg[31:16],csr_abc_dcotc4_calmem_data_i
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t DCOTC4_CALMEM_ADDR : 4;
    ///< calibration memory address
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t DCOTC4_CALMEM_WR_STRB : 1;
    ///< calibration memory write strobe
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t RESERVED731 : 11;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg68_csr_dcotc4_reg_t;

#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_RD_MASK (0xfffffc00U)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_WR_MASK (0xfffffc00U)


///< csr_abc_dcotc4_rdata =  csr_abc_dcotc4_reg[31:16],csr_abc_dcotc4_calmem_data_i
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_DATA_BF_OFF (10)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_DATA_BF_WID ( 6)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_DATA_BF_MSK (0x0000FC00)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_DATA_BF_DEF (0x00000000)

///< calibration memory address
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_ADDR_BF_OFF (16)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_ADDR_BF_WID ( 4)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_ADDR_BF_MSK (0x000F0000)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_ADDR_BF_DEF (0x00000000)

///< calibration memory write strobe
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_WR_STRB_BF_OFF (20)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_WR_STRB_BF_WID ( 1)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_WR_STRB_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_CALMEM_WR_STRB_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_RESERVED731_BF_OFF (21)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_RESERVED731_BF_WID (11)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_RESERVED731_BF_MSK (0xFFE00000)
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_RESERVED731_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG69_CSR_ABC_PHLOCK1 register description at address offset 0x114
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg69_csr_abc_phlock1
  * AnaRF PLL csr_abc_phlock1
  */

typedef union {
  struct {
    uint32_t PHLOCK1_TARGET_NEG : 10;
    ///< target phase for falling edge
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PHLOCK1_TARGET_POS : 10;
    ///< target phase for rising edge
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t PHLOCK1_FSM_RESET : 1;
    ///< 0=normal operation, 1=force fsm reset to idle state
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t RESERVED738 : 11;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg69_csr_phlock1_reg_t;

#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_WR_MASK (0xffffffffU)


///< target phase for falling edge
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_NEG_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_NEG_BF_WID (10)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_NEG_BF_MSK (0x000003FF)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_NEG_BF_DEF (0x00000000)

///< target phase for rising edge
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_POS_BF_OFF (10)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_POS_BF_WID (10)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_POS_BF_MSK (0x000FFC00)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_TARGET_POS_BF_DEF (0x00000000)

///< 0=normal operation, 1=force fsm reset to idle state
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_FSM_RST_BF_OFF (20)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_FSM_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_FSM_RST_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_FSM_RST_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_RESERVED738_BF_OFF (21)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_RESERVED738_BF_WID (11)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_RESERVED738_BF_MSK (0xFFE00000)
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_RESERVED738_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG70_CSR_ABC_PHLOCK2 register description at address offset 0x118
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg70_csr_abc_phlock2
  * AnaRF PLL csr_abc_phlock2
  */

typedef union {
  struct {
    uint32_t PHLOCK2_STROBE : 1;
    ///< inject strobe control bit
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PHLOCK2_MODE1 : 2;
    ///< 0=manual rising strobe, 1=manual double strobe, 2=auto, 3=phaselock
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t PHLOCK2_MODE2 : 2;
    ///< 0=manual rising strobe, 1=DPD, 2=LockDet, 3=TBD
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t PHLOCK2_TARGET_EDGE : 2;
    ///< 0=falling, 1=rising, 2=fall then rise, 3=rise then fall
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t PHLOCK2_IIR_ON : 1;
    ///< 0=iir controlled by FSM, 1=always enable iir
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t PHLOCK2_IIR_GEAR : 2;
    ///< gear value 0 to 3, good value is 0x2
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t PHLOCK2_STOP_COND : 2;
    ///< 0=falling strobe, 1=phaselock ok, 2, 3=TBD
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t PHLOCK2_ERR_SHIFT : 4;
    ///< phase error multiplier (left shift) , good value is 0x4
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t PHLOCK2_WAIT_CYCLES : 16;
    ///< #cycles to wait for settling and average
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg70_csr_phlock2_reg_t;

#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_WR_MASK (0xffffffffU)


///< inject strobe control bit
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STROBE_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STROBE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STROBE_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STROBE_BF_DEF (0x00000000)

///< 0=manual rising strobe, 1=manual double strobe, 2=auto, 3=phaselock
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE1_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE1_BF_WID ( 2)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE1_BF_MSK (0x00000006)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE1_BF_DEF (0x00000000)

///< 0=manual rising strobe, 1=DPD, 2=LockDet, 3=TBD
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE2_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE2_BF_WID ( 2)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE2_BF_MSK (0x00000018)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_MODE2_BF_DEF (0x00000000)

///< 0=falling, 1=rising, 2=fall then rise, 3=rise then fall
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_TARGET_EDGE_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_TARGET_EDGE_BF_WID ( 2)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_TARGET_EDGE_BF_MSK (0x00000060)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_TARGET_EDGE_BF_DEF (0x00000000)

///< 0=iir controlled by FSM, 1=always enable iir
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_ON_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_ON_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_ON_BF_DEF (0x00000000)

///< gear value 0 to 3, good value is 0x2
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_GEAR_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_GEAR_BF_WID ( 2)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_GEAR_BF_MSK (0x00000300)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_IIR_GEAR_BF_DEF (0x00000000)

///< 0=falling strobe, 1=phaselock ok, 2, 3=TBD
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STOP_COND_BF_OFF (10)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STOP_COND_BF_WID ( 2)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STOP_COND_BF_MSK (0x00000C00)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_STOP_COND_BF_DEF (0x00000000)

///< phase error multiplier (left shift) , good value is 0x4
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_ERR_SHIFT_BF_OFF (12)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_ERR_SHIFT_BF_WID ( 4)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_ERR_SHIFT_BF_MSK (0x0000F000)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_ERR_SHIFT_BF_DEF (0x00000000)

///< #cycles to wait for settling and average
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_WAIT_CYCLES_BF_OFF (16)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_WAIT_CYCLES_BF_WID (16)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_WAIT_CYCLES_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_WAIT_CYCLES_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG71_CSR_ABC_PHLOCK3 register description at address offset 0x11c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg71_csr_abc_phlock3
  * AnaRF PLL csr_abc_phlock3
  */

typedef union {
  struct {
    uint32_t PHLOCK3_INJECT_VAL : 20;
    ///< inject value word
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PHLOCK3_SPARE : 12;
    ///< spare
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg71_csr_phlock3_reg_t;

#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_WR_MASK (0xffffffffU)


///< inject value word
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_INJECT_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_INJECT_VAL_BF_WID (20)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_INJECT_VAL_BF_MSK (0x000FFFFF)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_INJECT_VAL_BF_DEF (0x00000000)

///< spare
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_SPARE_BF_OFF (20)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_SPARE_BF_WID (12)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_SPARE_BF_MSK (0xFFF00000)
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_SPARE_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG72_CSR_ABC_PHLOCK4 register description at address offset 0x120
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg72_csr_abc_phlock4
  * AnaRF PLL csr_abc_phlock4
  */

typedef union {
  struct {
    uint32_t PHLOCK4_SFTDC_STUP_SEQ_ON : 1;
    ///< SFTDC startup sequencer on
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_INIT_SEQ_ON : 1;
    ///< SFTDC init sequencer on
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_LOCK_SEQ_ON : 1;
    ///< SFTDC lock sequencer on
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_TARG_EDGE : 1;
    ///< phaselock target edge (0=falling, 1=rising)
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_STUP_CCM1 : 2;
    ///< cyclecount_multiplyer1 for the TDC
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_STUP_CCM2 : 2;
    ///< cyclecount_multiplyer2 for the TDC
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_STUP_CCM3 : 2;
    ///< cyclecount_multiplyer3 for the TDC
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_IIR_GEAR_I : 2;
    ///< iir gear in phaselock for phase search
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_START_PHASE : 10;
    ///< starting phase for phase search
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_ERR_SHIFT : 4;
    ///< phase error scaling, #bits shift for phase error generation
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_PHASE_STEP : 4;
    ///< phase step for linear search
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_FSM_RESET : 1;
    ///< SFTDC FSM reset
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t PHLOCK4_SFTDC_SEM_INDEX_REG_EN : 1;
    ///< enable output register
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg72_csr_phlock4_reg_t;

#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_WR_MASK (0xffffffffU)


///< SFTDC startup sequencer on
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_SEQ_ON_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_SEQ_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_SEQ_ON_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_SEQ_ON_BF_DEF (0x00000000)

///< SFTDC init sequencer on
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_INIT_SEQ_ON_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_INIT_SEQ_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_INIT_SEQ_ON_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_INIT_SEQ_ON_BF_DEF (0x00000000)

///< SFTDC lock sequencer on
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_LOCK_SEQ_ON_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_LOCK_SEQ_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_LOCK_SEQ_ON_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_LOCK_SEQ_ON_BF_DEF (0x00000000)

///< phaselock target edge (0=falling, 1=rising)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_TARG_EDGE_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_TARG_EDGE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_TARG_EDGE_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_TARG_EDGE_BF_DEF (0x00000000)

///< cyclecount_multiplyer1 for the TDC
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM1_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM1_BF_WID ( 2)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM1_BF_MSK (0x00000030)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM1_BF_DEF (0x00000000)

///< cyclecount_multiplyer2 for the TDC
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM2_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM2_BF_WID ( 2)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM2_BF_MSK (0x000000C0)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM2_BF_DEF (0x00000000)

///< cyclecount_multiplyer3 for the TDC
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM3_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM3_BF_WID ( 2)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM3_BF_MSK (0x00000300)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_STUP_CCM3_BF_DEF (0x00000000)

///< iir gear in phaselock for phase search
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_IIR_GEAR_I_BF_OFF (10)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_IIR_GEAR_I_BF_WID ( 2)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_IIR_GEAR_I_BF_MSK (0x00000C00)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_IIR_GEAR_I_BF_DEF (0x00000000)

///< starting phase for phase search
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_START_PHASE_BF_OFF (12)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_START_PHASE_BF_WID (10)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_START_PHASE_BF_MSK (0x003FF000)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_START_PHASE_BF_DEF (0x00000000)

///< phase error scaling, #bits shift for phase error generation
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_ERR_SHIFT_BF_OFF (22)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_ERR_SHIFT_BF_WID ( 4)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_ERR_SHIFT_BF_MSK (0x03C00000)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_ERR_SHIFT_BF_DEF (0x00000000)

///< phase step for linear search
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_PHASE_STEP_BF_OFF (26)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_PHASE_STEP_BF_WID ( 4)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_PHASE_STEP_BF_MSK (0x3C000000)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_PHASE_STEP_BF_DEF (0x00000000)

///< SFTDC FSM reset
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_FSM_RST_BF_OFF (30)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_FSM_RST_BF_WID ( 1)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_FSM_RST_BF_MSK (0x40000000)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_FSM_RST_BF_DEF (0x00000000)

///< enable output register
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_SEM_INDEX_EN_BF_OFF (31)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_SEM_INDEX_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_SEM_INDEX_EN_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_SFTDC_SEM_INDEX_EN_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG73_CSR_ABC_PHLOCK5 register description at address offset 0x124
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg73_csr_abc_phlock5
  * AnaRF PLL csr_abc_phlock5
  */

typedef union {
  struct {
    uint32_t PHLOCK5_SFTDC_SEM_START_PHASE_I : 15;
    ///< start phase for SFTDC search
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PHLOCK5_SFTDC_SEM_START_OVRD_I : 1;
    ///< if 1 use phlock5_sftdc_sem_start_phase_i
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t PHLOCK5_SFTDC_SEM_END_PHASE_I : 15;
    ///< end phase for SFTDC search
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t PHLOCK5_SFTDC_SEM_END_OVRD_I : 1;
    ///< if 1 use phlock5_sftdc_sem_end_phase_i
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg73_csr_phlock5_reg_t;

#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_WR_MASK (0xffffffffU)


///< start phase for SFTDC search
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_PHASE_I_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_PHASE_I_BF_WID (15)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_PHASE_I_BF_MSK (0x00007FFF)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_PHASE_I_BF_DEF (0x00000000)

///< if 1 use phlock5_sftdc_sem_start_phase_i
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_OVRD_I_BF_OFF (15)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_OVRD_I_BF_WID ( 1)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_OVRD_I_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_START_OVRD_I_BF_DEF (0x00000000)

///< end phase for SFTDC search
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_PHASE_I_BF_OFF (16)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_PHASE_I_BF_WID (15)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_PHASE_I_BF_MSK (0x7FFF0000)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_PHASE_I_BF_DEF (0x00000000)

///< if 1 use phlock5_sftdc_sem_end_phase_i
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_OVRD_I_BF_OFF (31)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_OVRD_I_BF_WID ( 1)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_OVRD_I_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_SFTDC_SEM_END_OVRD_I_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG74_CSR_ABC_PHLOCK6 register description at address offset 0x128
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg74_csr_abc_phlock6
  * AnaRF PLL csr_abc_phlock6
  */

typedef union {
  struct {
    uint32_t PHLOCK6_SFTDC_DONE_INJ_EN_I : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PHLOCK6_SFTDC_PHLOCK_DONE0_OVRD_I : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t PHLOCK6_SFTDC_PHLOCK_DONE1_OVRD_I : 1;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t RESERVED779 : 29;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg74_csr_phlock6_reg_t;

#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_WR_MASK (0xffffffffU)


///< To Be Done
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_DONE_INJ_EN_I_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_DONE_INJ_EN_I_BF_WID ( 1)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_DONE_INJ_EN_I_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_DONE_INJ_EN_I_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE0_OVRD_I_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE0_OVRD_I_BF_WID ( 1)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE0_OVRD_I_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE0_OVRD_I_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE1_OVRD_I_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE1_OVRD_I_BF_WID ( 1)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE1_OVRD_I_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_SFTDC_PHLOCK_DONE1_OVRD_I_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_RESERVED779_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_RESERVED779_BF_WID (29)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_RESERVED779_BF_MSK (0xFFFFFFF8)
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_RESERVED779_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG75_CSR_ABC_STAT1 register description at address offset 0x12c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg75_csr_abc_stat1
  * AnaRF PLL csr_abc_stat1
  */

typedef union {
  struct {
    uint32_t PHLOCK_PRI_ENC_IIR_NEG_S : 10;
    ///< phlock_pri_enc_iir_neg_s neg word
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t PHLOCK_PRI_ENC_IIR_POS_S : 10;
    ///< phlock_pri_enc_iir_pos_s pos word
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t PHLOCK_FSM_STATE_S : 4;
    ///< phlock_fsm_state_s state value
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t PHLOCK_FSM_SFTDC_STATE_S : 4;
    ///< phlock_fsm_sftdc_state_s signal TDC state
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
    uint32_t D_SFTDC_PHLOCK_DONE0_S : 1;
    ///< d_sftdc_phlock_done0_s signal for done
    ///< AccessType="RO" BitOffset="28" ResetValue="0x0"
    uint32_t D_SFTDC_PHLOCK_DONE1_S : 1;
    ///< d_sftdc_phlock_done1_s signal for done
    ///< AccessType="RO" BitOffset="29" ResetValue="0x0"
    uint32_t RESERVED791 : 2;
    ///< To Be Done
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg75_csr_stat1_reg_t;

#define PLL_LOCAL_PLLREG75_CSR_STAT1_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_WR_MASK (0x00000000U)


///< phlock_pri_enc_iir_neg_s neg word
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_NEG_S_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_NEG_S_BF_WID (10)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_NEG_S_BF_MSK (0x000003FF)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_NEG_S_BF_DEF (0x00000000)

///< phlock_pri_enc_iir_pos_s pos word
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_POS_S_BF_OFF (10)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_POS_S_BF_WID (10)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_POS_S_BF_MSK (0x000FFC00)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_PRI_ENC_IIR_POS_S_BF_DEF (0x00000000)

///< phlock_fsm_state_s state value
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_STATE_S_BF_OFF (20)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_STATE_S_BF_WID ( 4)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_STATE_S_BF_MSK (0x00F00000)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_STATE_S_BF_DEF (0x00000000)

///< phlock_fsm_sftdc_state_s signal TDC state
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_SFTDC_STATE_S_BF_OFF (24)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_SFTDC_STATE_S_BF_WID ( 4)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_SFTDC_STATE_S_BF_MSK (0x0F000000)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_PHLOCK_FSM_SFTDC_STATE_S_BF_DEF (0x00000000)

///< d_sftdc_phlock_done0_s signal for done
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE0_S_BF_OFF (28)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE0_S_BF_WID ( 1)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE0_S_BF_MSK (0x10000000)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE0_S_BF_DEF (0x00000000)

///< d_sftdc_phlock_done1_s signal for done
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE1_S_BF_OFF (29)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE1_S_BF_WID ( 1)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE1_S_BF_MSK (0x20000000)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_D_SFTDC_PHLOCK_DONE1_S_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG75_CSR_STAT1_RESERVED791_BF_OFF (30)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_RESERVED791_BF_WID ( 2)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_RESERVED791_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG75_CSR_STAT1_RESERVED791_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG76_CSR_ABC_STAT2 register description at address offset 0x130
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg76_csr_abc_stat2
  * AnaRF PLL csr_abc_stat2
  */

typedef union {
  struct {
    uint32_t DCOTC_CAL_MEM_RDBK : 16;
    ///< dcotc_cal_mem_rdbk_s[DLF_WIDTH-1:0] mem readback
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t DCOTC_FSM_CAL_STATE : 3;
    ///< dcotc_fsm_cal_state_s[2:0] dco state word
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t D_DSNT_DCO_TC_DATA : 12;
    ///< d_dsnt_dco_tc_data_s[11:0] dco word
    ///< AccessType="RO" BitOffset="19" ResetValue="0x0"
    uint32_t AVC_STAT2_SPARE : 1;
    ///< spare
    ///< AccessType="RO" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg76_csr_stat2_reg_t;

#define PLL_LOCAL_PLLREG76_CSR_STAT2_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_WR_MASK (0x00000000U)


///< dcotc_cal_mem_rdbk_s[DLF_WIDTH-1:0] mem readback
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_CAL_MEM_RDBK_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_CAL_MEM_RDBK_BF_WID (16)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_CAL_MEM_RDBK_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_CAL_MEM_RDBK_BF_DEF (0x00000000)

///< dcotc_fsm_cal_state_s[2:0] dco state word
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_FSM_CAL_STATE_BF_OFF (16)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_FSM_CAL_STATE_BF_WID ( 3)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_FSM_CAL_STATE_BF_MSK (0x00070000)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_DCOTC_FSM_CAL_STATE_BF_DEF (0x00000000)

///< d_dsnt_dco_tc_data_s[11:0] dco word
#define PLL_LOCAL_PLLREG76_CSR_STAT2_D_DSNT_DCO_TC_DATA_BF_OFF (19)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_D_DSNT_DCO_TC_DATA_BF_WID (12)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_D_DSNT_DCO_TC_DATA_BF_MSK (0x7FF80000)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_D_DSNT_DCO_TC_DATA_BF_DEF (0x00000000)

///< spare
#define PLL_LOCAL_PLLREG76_CSR_STAT2_AVC_STAT2_SPARE_BF_OFF (31)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_AVC_STAT2_SPARE_BF_WID ( 1)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_AVC_STAT2_SPARE_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG76_CSR_STAT2_AVC_STAT2_SPARE_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG77_CSR_ABC_STAT3 register description at address offset 0x134
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg77_csr_abc_stat3
  * AnaRF PLL csr_abc_stat3
  */

typedef union {
  struct {
    uint32_t DCOTC_DLF_IIR : 16;
    ///< dcotc_dlf_iir_s[15:0] iir word
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t CSR_ABC_DCOTC4_CALMEM_DATA : 16;
    ///< csr_abc_dcotc4_calmem_data_s[15:0] selected by csr_abc_dcotc4.dcotc4_calmem_addr
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg77_csr_stat3_reg_t;

#define PLL_LOCAL_PLLREG77_CSR_STAT3_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_WR_MASK (0x00000000U)


///< dcotc_dlf_iir_s[15:0] iir word
#define PLL_LOCAL_PLLREG77_CSR_STAT3_DCOTC_DLF_IIR_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_DCOTC_DLF_IIR_BF_WID (16)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_DCOTC_DLF_IIR_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_DCOTC_DLF_IIR_BF_DEF (0x00000000)

///< csr_abc_dcotc4_calmem_data_s[15:0] selected by csr_abc_dcotc4.dcotc4_calmem_addr
#define PLL_LOCAL_PLLREG77_CSR_STAT3_CSR_DCOTC4_CALMEM_DATA_BF_OFF (16)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_CSR_DCOTC4_CALMEM_DATA_BF_WID (16)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_CSR_DCOTC4_CALMEM_DATA_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG77_CSR_STAT3_CSR_DCOTC4_CALMEM_DATA_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG78_CSR_ABC_FLB1 register description at address offset 0x138
  *
  * Register default value:        0x0001100B
  * Register full path in IP: pll_local/reg/pllreg78_csr_abc_flb1
  * AnaRF PLL csr_abc_flb1
  */

typedef union {
  struct {
    uint32_t SDM_ON_SX : 1;
    ///< Turn the Sigma-Delata modulator on (enable noise shaping). Activates
    ///< the clock and removes reset from the sampling registers.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t RSTN_SX : 1;
    ///< acitve low reset to the fast logic (flb) block.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t FT_CLK_INV_SX : 1;
    ///< Use inversed version of the FT valid signal. Effectively increases
    ///< the loop delay by 1/2 cycle. May alleviate timing/synchronization
    ///< problems.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t FT_CLK_EN_SX : 1;
    ///< clock enable for Sigma-Delta modulator
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t SDM_MAN_ON_SX : 1;
    ///< Use manual SDM control.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SDM_MAN_VAL_SX : 3;
    ///< Decoded manual SDM control value.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t SDM_CTRL_SX : 4;
    ///< To Be Done
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t MTRX_CLK_LAG_SX : 2;
    ///< Final row/col/band sampling clock. Always one clock behind smpl_clk_lag
    ///< (by design). Default value (1) ensures sync with OS output
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t SMPL_CLK_LAG_SX : 2;
    ///< Sampling clock (both FT and CT data) lag.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SDM_ORDER_SX : 1;
    ///< Sampling clock (both FT and CT data) lag.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t CSR_ABC_FLB1_SPARE14B : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg78_csr_flb1_reg_t;

#define PLL_LOCAL_PLLREG78_CSR_FLB1_DEFAULT (0x0001100bU)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_WR_MASK (0xffffffffU)


///< Turn the Sigma-Delata modulator on (enable noise shaping). Activates
///< the clock and removes reset from the sampling registers.
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ON_SX_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ON_SX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ON_SX_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ON_SX_BF_DEF (0x00000001)

///< acitve low reset to the fast logic (flb) block.
#define PLL_LOCAL_PLLREG78_CSR_FLB1_RSTN_SX_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_RSTN_SX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_RSTN_SX_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_RSTN_SX_BF_DEF (0x00000002)

///< Use inversed version of the FT valid signal. Effectively increases
///< the loop delay by 1/2 cycle. May alleviate timing/synchronization
///< problems.
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_INV_SX_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_INV_SX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_INV_SX_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_INV_SX_BF_DEF (0x00000000)

///< clock enable for Sigma-Delta modulator
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_EN_SX_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_EN_SX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_EN_SX_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_FT_CLK_EN_SX_BF_DEF (0x00000008)

///< Use manual SDM control.
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_ON_SX_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_ON_SX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_ON_SX_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_ON_SX_BF_DEF (0x00000000)

///< Decoded manual SDM control value.
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_VAL_SX_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_VAL_SX_BF_WID ( 3)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_VAL_SX_BF_MSK (0x000000E0)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_MAN_VAL_SX_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_CTRL_SX_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_CTRL_SX_BF_WID ( 4)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_CTRL_SX_BF_MSK (0x00000F00)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_CTRL_SX_BF_DEF (0x00000000)

///< Final row/col/band sampling clock. Always one clock behind smpl_clk_lag
///< (by design). Default value (1) ensures sync with OS output
#define PLL_LOCAL_PLLREG78_CSR_FLB1_MTRX_CLK_LAG_SX_BF_OFF (12)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_MTRX_CLK_LAG_SX_BF_WID ( 2)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_MTRX_CLK_LAG_SX_BF_MSK (0x00003000)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_MTRX_CLK_LAG_SX_BF_DEF (0x00001000)

///< Sampling clock (both FT and CT data) lag.
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SMPL_CLK_LAG_SX_BF_OFF (14)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SMPL_CLK_LAG_SX_BF_WID ( 2)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SMPL_CLK_LAG_SX_BF_MSK (0x0000C000)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SMPL_CLK_LAG_SX_BF_DEF (0x00000000)

///< Sampling clock (both FT and CT data) lag.
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ORDER_SX_BF_OFF (16)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ORDER_SX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ORDER_SX_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_SDM_ORDER_SX_BF_DEF (0x00010000)

///< reserved
#define PLL_LOCAL_PLLREG78_CSR_FLB1_CSR_FLB1_SPARE14B_BF_OFF (17)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_CSR_FLB1_SPARE14B_BF_WID (15)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_CSR_FLB1_SPARE14B_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG78_CSR_FLB1_CSR_FLB1_SPARE14B_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG79_CSR_ABC_FLB2 register description at address offset 0x13c
  *
  * Register default value:        0x0001100B
  * Register full path in IP: pll_local/reg/pllreg79_csr_abc_flb2
  * AnaRF PLL csr_abc_flb2
  */

typedef union {
  struct {
    uint32_t SDM_ON_DX : 1;
    ///< Turn the Sigma-Delata modulator on (enable noise shaping). Activates
    ///< the clock and removes reset from the sampling registers.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t RSTN_DX : 1;
    ///< acitve low reset to the fast logic (flb) block.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t FT_CLK_INV_DX : 1;
    ///< Use inversed version of the FT valid signal. Effectively increases
    ///< the loop delay by 1/2 cycle. May alleviate timing/synchronization
    ///< problems.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t FT_CLK_EN_DX : 1;
    ///< clock enable for Sigma-Delta modulator
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t SDM_MAN_ON_DX : 1;
    ///< Use manual SDM control.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SDM_MAN_VAL_DX : 3;
    ///< Decoded manual SDM control value.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t SDM_CTRL_DX : 4;
    ///< csr_abc_flbdx_sdm_ctrl_dx[0] = csr_abc_flbdx_sdm4x_on csr_abc_flbdx_sdm_ctrl_dx[1]
    ///< = csr_abc_flbdx_offset_mode_on
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t MTRX_CLK_LAG_DX : 2;
    ///< Final row/col/band sampling clock. Always one clock behind smpl_clk_lag
    ///< (by design). Default value (1) ensures sync with OS output
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t SMPL_CLK_LAG_DX : 2;
    ///< Sampling clock (both FT and CT data) lag.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SDM_ORDER_DX : 1;
    ///< Sampling clock (both FT and CT data) lag.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t CSR_ABC_FLB2_SPARE14B : 15;
    ///< reserved
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg79_csr_flb2_reg_t;

#define PLL_LOCAL_PLLREG79_CSR_FLB2_DEFAULT (0x0001100bU)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_WR_MASK (0xffffffffU)


///< Turn the Sigma-Delata modulator on (enable noise shaping). Activates
///< the clock and removes reset from the sampling registers.
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ON_DX_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ON_DX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ON_DX_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ON_DX_BF_DEF (0x00000001)

///< acitve low reset to the fast logic (flb) block.
#define PLL_LOCAL_PLLREG79_CSR_FLB2_RSTN_DX_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_RSTN_DX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_RSTN_DX_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_RSTN_DX_BF_DEF (0x00000002)

///< Use inversed version of the FT valid signal. Effectively increases
///< the loop delay by 1/2 cycle. May alleviate timing/synchronization
///< problems.
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_INV_DX_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_INV_DX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_INV_DX_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_INV_DX_BF_DEF (0x00000000)

///< clock enable for Sigma-Delta modulator
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_EN_DX_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_EN_DX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_EN_DX_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_FT_CLK_EN_DX_BF_DEF (0x00000008)

///< Use manual SDM control.
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_ON_DX_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_ON_DX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_ON_DX_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_ON_DX_BF_DEF (0x00000000)

///< Decoded manual SDM control value.
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_VAL_DX_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_VAL_DX_BF_WID ( 3)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_VAL_DX_BF_MSK (0x000000E0)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_MAN_VAL_DX_BF_DEF (0x00000000)

///< csr_abc_flbdx_sdm_ctrl_dx[0] = csr_abc_flbdx_sdm4x_on csr_abc_flbdx_sdm_ctrl_dx[1]
///< = csr_abc_flbdx_offset_mode_on
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_CTRL_DX_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_CTRL_DX_BF_WID ( 4)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_CTRL_DX_BF_MSK (0x00000F00)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_CTRL_DX_BF_DEF (0x00000000)

///< Final row/col/band sampling clock. Always one clock behind smpl_clk_lag
///< (by design). Default value (1) ensures sync with OS output
#define PLL_LOCAL_PLLREG79_CSR_FLB2_MTRX_CLK_LAG_DX_BF_OFF (12)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_MTRX_CLK_LAG_DX_BF_WID ( 2)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_MTRX_CLK_LAG_DX_BF_MSK (0x00003000)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_MTRX_CLK_LAG_DX_BF_DEF (0x00001000)

///< Sampling clock (both FT and CT data) lag.
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SMPL_CLK_LAG_DX_BF_OFF (14)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SMPL_CLK_LAG_DX_BF_WID ( 2)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SMPL_CLK_LAG_DX_BF_MSK (0x0000C000)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SMPL_CLK_LAG_DX_BF_DEF (0x00000000)

///< Sampling clock (both FT and CT data) lag.
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ORDER_DX_BF_OFF (16)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ORDER_DX_BF_WID ( 1)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ORDER_DX_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_SDM_ORDER_DX_BF_DEF (0x00010000)

///< reserved
#define PLL_LOCAL_PLLREG79_CSR_FLB2_CSR_FLB2_SPARE14B_BF_OFF (17)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_CSR_FLB2_SPARE14B_BF_WID (15)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_CSR_FLB2_SPARE14B_BF_MSK (0xFFFE0000)
#define PLL_LOCAL_PLLREG79_CSR_FLB2_CSR_FLB2_SPARE14B_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG80_CSR_ABC_DLFX1 register description at address offset 0x140
  *
  * Register default value:        0x80443F7F
  * Register full path in IP: pll_local/reg/pllreg80_csr_abc_dlfx1
  * AnaRF PLL csr_abc_dlfx1
  */

typedef union {
  struct {
    uint32_t SDM_OFS : 8;
    ///< SDM offset for DLF hysteresis mode
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7F"
    uint32_t SDM_TH : 8;
    ///< SDM treshold for DLF hysteresis mode
    ///< AccessType="RW" BitOffset="8" ResetValue="0x3F"
    uint32_t HYST_ON : 1;
    ///< hyst_on = 1: use SDM hysteresis, offset_mode_on must be 1, both SDM
    ///< enabled or SDM4x enabled
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t MTRX_MOD : 2;
    ///< 0=linear, 1=ping-pong, 2=both-SDM (0=MM_LINEAR, 1=MM_PINGPONG, 2=MM_BOTHSDM)
    ///< AccessType="RW" BitOffset="17" ResetValue="0x2"
    uint32_t MTRX_SWAP : 1;
    ///< 0: MTRX_SX before MTRX_DX, 1: MTRX_DX before MTRX_SX
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t MTRX_SX_DIS : 1;
    ///< 1: MTRX_SX disabled
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t MTRX_DX_DIS : 1;
    ///< 1: MTRX_DX disabled
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t OFFSET_MODE_ON : 1;
    ///< 1: dlfx offset mode on flb_dx_offset_mode_on_s = csr_abc_flbdx_sdm_on_dx
    ///< & csr_abc_flbdx_sdm4x_on & csr_abc_flbdx_offset_mode_on dlfx1_offset_mode_on_s
    ///< = csr_abc_flbsx_sdm_on_sx & csr_abc_flbdx_sdm_on_dx & csr_abc_dlfx1_offset_mode_on;
    ///< // both sdm on and enabled
    ///< AccessType="RW" BitOffset="22" ResetValue="0x1"
    uint32_t FIX_CONFIG : 1;
    ///< 1: fix config problems for dlfx1_mtrx_mode_s
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t MTRX_DIS_VAL : 8;
    ///< value applied to disabled matrix
    ///< AccessType="RW" BitOffset="24" ResetValue="0x80"
  } ;
  uint32_t value;
} pll_local_pllreg80_csr_dlfx1_reg_t;

#define PLL_LOCAL_PLLREG80_CSR_DLFX1_DEFAULT (0x80443f7fU)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_WR_MASK (0xffffffffU)


///< SDM offset for DLF hysteresis mode
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_OFS_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_OFS_BF_WID ( 8)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_OFS_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_OFS_BF_DEF (0x0000007F)

///< SDM treshold for DLF hysteresis mode
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_TH_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_TH_BF_WID ( 8)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_TH_BF_MSK (0x0000FF00)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_SDM_TH_BF_DEF (0x00003F00)

///< hyst_on = 1: use SDM hysteresis, offset_mode_on must be 1, both SDM
///< enabled or SDM4x enabled
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_HYST_ON_BF_OFF (16)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_HYST_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_HYST_ON_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_HYST_ON_BF_DEF (0x00000000)

///< 0=linear, 1=ping-pong, 2=both-SDM (0=MM_LINEAR, 1=MM_PINGPONG, 2=MM_BOTHSDM)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_MOD_BF_OFF (17)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_MOD_BF_WID ( 2)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_MOD_BF_MSK (0x00060000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_MOD_BF_DEF (0x00040000)

///< 0: MTRX_SX before MTRX_DX, 1: MTRX_DX before MTRX_SX
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SWAP_BF_OFF (19)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SWAP_BF_WID ( 1)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SWAP_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SWAP_BF_DEF (0x00000000)

///< 1: MTRX_SX disabled
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SX_DIS_BF_OFF (20)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SX_DIS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SX_DIS_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_SX_DIS_BF_DEF (0x00000000)

///< 1: MTRX_DX disabled
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DX_DIS_BF_OFF (21)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DX_DIS_BF_WID ( 1)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DX_DIS_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DX_DIS_BF_DEF (0x00000000)

///< 1: dlfx offset mode on flb_dx_offset_mode_on_s = csr_abc_flbdx_sdm_on_dx
///< & csr_abc_flbdx_sdm4x_on & csr_abc_flbdx_offset_mode_on dlfx1_offset_mode_on_s
///< = csr_abc_flbsx_sdm_on_sx & csr_abc_flbdx_sdm_on_dx & csr_abc_dlfx1_offset_mode_on;
///< // both sdm on and enabled
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_OFFSET_MODE_ON_BF_OFF (22)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_OFFSET_MODE_ON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_OFFSET_MODE_ON_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_OFFSET_MODE_ON_BF_DEF (0x00400000)

///< 1: fix config problems for dlfx1_mtrx_mode_s
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_FIX_CFG_BF_OFF (23)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_FIX_CFG_BF_WID ( 1)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_FIX_CFG_BF_MSK (0x00800000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_FIX_CFG_BF_DEF (0x00000000)

///< value applied to disabled matrix
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DIS_VAL_BF_OFF (24)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DIS_VAL_BF_WID ( 8)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DIS_VAL_BF_MSK (0xFF000000)
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_MTRX_DIS_VAL_BF_DEF (0x80000000)


/** @brief PLL_LOCAL_REG_PLLREG81_CSR_ABC_STAT4 register description at address offset 0x144
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg81_csr_abc_stat4
  * AnaRF PLL csr_abc_stat4
  */

typedef union {
  struct {
    uint32_t D_SFTDC_ZM0_I : 8;
    ///< d_sftdc_zm0_i tdc zm0
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t D_SFTDC_ZM1_I : 8;
    ///< d_sftdc_zm1_i tdc zm1
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t D_SFTDC_ALL0_S : 2;
    ///< d_sftdc_all0_s all zero
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t D_SFTDC_ALL1_S : 2;
    ///< d_sftdc_all1_s all one
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
    uint32_t PHLOCK_FSM_PL_STATE_S : 4;
    ///< phlock_fsm_pl_state_s state word
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t PHLOCK_FSM_SFTDC_STATE_S : 4;
    ///< phlock_fsm_sftdc_state_s state word
    ///< AccessType="RO" BitOffset="24" ResetValue="0x0"
    uint32_t RESERVED852 : 4;
    ///< reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg81_csr_stat4_reg_t;

#define PLL_LOCAL_PLLREG81_CSR_STAT4_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_WR_MASK (0x00000000U)


///< d_sftdc_zm0_i tdc zm0
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM0_I_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM0_I_BF_WID ( 8)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM0_I_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM0_I_BF_DEF (0x00000000)

///< d_sftdc_zm1_i tdc zm1
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM1_I_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM1_I_BF_WID ( 8)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM1_I_BF_MSK (0x0000FF00)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ZM1_I_BF_DEF (0x00000000)

///< d_sftdc_all0_s all zero
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL0_S_BF_OFF (16)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL0_S_BF_WID ( 2)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL0_S_BF_MSK (0x00030000)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL0_S_BF_DEF (0x00000000)

///< d_sftdc_all1_s all one
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL1_S_BF_OFF (18)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL1_S_BF_WID ( 2)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL1_S_BF_MSK (0x000C0000)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_D_SFTDC_ALL1_S_BF_DEF (0x00000000)

///< phlock_fsm_pl_state_s state word
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_PL_STATE_S_BF_OFF (20)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_PL_STATE_S_BF_WID ( 4)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_PL_STATE_S_BF_MSK (0x00F00000)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_PL_STATE_S_BF_DEF (0x00000000)

///< phlock_fsm_sftdc_state_s state word
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_SFTDC_STATE_S_BF_OFF (24)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_SFTDC_STATE_S_BF_WID ( 4)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_SFTDC_STATE_S_BF_MSK (0x0F000000)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_PHLOCK_FSM_SFTDC_STATE_S_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG81_CSR_STAT4_RESERVED852_BF_OFF (28)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_RESERVED852_BF_WID ( 4)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_RESERVED852_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG81_CSR_STAT4_RESERVED852_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG82_CSR_ABC_STAT5 register description at address offset 0x148
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg82_csr_abc_stat5
  * AnaRF PLL csr_abc_stat5
  */

typedef union {
  struct {
    uint32_t PRI_ENC_INDEX_NEG : 10;
    ///< pri_enc_index_neg index neg
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t PRI_ENC_INDEX_POS : 10;
    ///< pri_enc_index_pos index pos
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t PHLOCK_PRI_ENC_IIR_NEG_S : 10;
    ///< phlock_pri_enc_iir_neg_s iir neg
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t RESERVED862 : 2;
    ///< reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg82_csr_stat5_reg_t;

#define PLL_LOCAL_PLLREG82_CSR_STAT5_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_WR_MASK (0x00000000U)


///< pri_enc_index_neg index neg
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_NEG_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_NEG_BF_WID (10)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_NEG_BF_MSK (0x000003FF)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_NEG_BF_DEF (0x00000000)

///< pri_enc_index_pos index pos
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_POS_BF_OFF (10)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_POS_BF_WID (10)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_POS_BF_MSK (0x000FFC00)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PRI_ENC_INDEX_POS_BF_DEF (0x00000000)

///< phlock_pri_enc_iir_neg_s iir neg
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PHLOCK_PRI_ENC_IIR_NEG_S_BF_OFF (20)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PHLOCK_PRI_ENC_IIR_NEG_S_BF_WID (10)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PHLOCK_PRI_ENC_IIR_NEG_S_BF_MSK (0x3FF00000)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_PHLOCK_PRI_ENC_IIR_NEG_S_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG82_CSR_STAT5_RESERVED862_BF_OFF (30)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_RESERVED862_BF_WID ( 2)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_RESERVED862_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG82_CSR_STAT5_RESERVED862_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG83_CSR_ABC_STAT6 register description at address offset 0x14c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg83_csr_abc_stat6
  * AnaRF PLL csr_abc_stat6
  */

typedef union {
  struct {
    uint32_t D_SFTDC_ZM0_I : 8;
    ///< d_sftdc_zm0_i zm zero
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t D_SFTDC_ZM1_I : 8;
    ///< d_sftdc_zm1_i zm one
    ///< AccessType="RO" BitOffset="8" ResetValue="0x0"
    uint32_t D_SFTDC_ALL0_S : 2;
    ///< d_sftdc_all0_s all zero
    ///< AccessType="RO" BitOffset="16" ResetValue="0x0"
    uint32_t D_SFTDC_ALL1_S : 2;
    ///< d_sftdc_all1_s all one
    ///< AccessType="RO" BitOffset="18" ResetValue="0x0"
    uint32_t D_PHTDC_TARGET_PHASE_MS : 10;
    ///< d_phtdc_target_phase_ms target phase word
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t RESERVED869 : 2;
    ///< reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg83_csr_stat6_reg_t;

#define PLL_LOCAL_PLLREG83_CSR_STAT6_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_WR_MASK (0x00000000U)


///< d_sftdc_zm0_i zm zero
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM0_I_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM0_I_BF_WID ( 8)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM0_I_BF_MSK (0x000000FF)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM0_I_BF_DEF (0x00000000)

///< d_sftdc_zm1_i zm one
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM1_I_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM1_I_BF_WID ( 8)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM1_I_BF_MSK (0x0000FF00)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ZM1_I_BF_DEF (0x00000000)

///< d_sftdc_all0_s all zero
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL0_S_BF_OFF (16)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL0_S_BF_WID ( 2)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL0_S_BF_MSK (0x00030000)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL0_S_BF_DEF (0x00000000)

///< d_sftdc_all1_s all one
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL1_S_BF_OFF (18)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL1_S_BF_WID ( 2)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL1_S_BF_MSK (0x000C0000)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_SFTDC_ALL1_S_BF_DEF (0x00000000)

///< d_phtdc_target_phase_ms target phase word
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_PHTDC_TARGET_PHASE_MS_BF_OFF (20)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_PHTDC_TARGET_PHASE_MS_BF_WID (10)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_PHTDC_TARGET_PHASE_MS_BF_MSK (0x3FF00000)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_D_PHTDC_TARGET_PHASE_MS_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG83_CSR_STAT6_RESERVED869_BF_OFF (30)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_RESERVED869_BF_WID ( 2)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_RESERVED869_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG83_CSR_STAT6_RESERVED869_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG84_CSR_ABC_STAT7 register description at address offset 0x150
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg84_csr_abc_stat7
  * AnaRF PLL csr_abc_stat7
  */

typedef union {
  struct {
    uint32_t D_SFTDC_RANGE_START_PHASE_MS : 10;
    ///< d_sftdc_range_start_phase_ms start phase
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t D_SFTDC_RANGE_END_PHASE_MS : 10;
    ///< d_sftdc_range_end_phase_ms edn phase
    ///< AccessType="RO" BitOffset="10" ResetValue="0x0"
    uint32_t D_SFTDC_RANGE_MID_PHASE_MS : 10;
    ///< d_sftdc_range_mid_phase_ms mid phase
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t RESERVED878 : 2;
    ///< reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg84_csr_stat7_reg_t;

#define PLL_LOCAL_PLLREG84_CSR_STAT7_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_WR_MASK (0x00000000U)


///< d_sftdc_range_start_phase_ms start phase
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_START_PHASE_MS_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_START_PHASE_MS_BF_WID (10)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_START_PHASE_MS_BF_MSK (0x000003FF)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_START_PHASE_MS_BF_DEF (0x00000000)

///< d_sftdc_range_end_phase_ms edn phase
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_END_PHASE_MS_BF_OFF (10)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_END_PHASE_MS_BF_WID (10)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_END_PHASE_MS_BF_MSK (0x000FFC00)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_END_PHASE_MS_BF_DEF (0x00000000)

///< d_sftdc_range_mid_phase_ms mid phase
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_MID_PHASE_MS_BF_OFF (20)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_MID_PHASE_MS_BF_WID (10)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_MID_PHASE_MS_BF_MSK (0x3FF00000)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_D_SFTDC_RANGE_MID_PHASE_MS_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG84_CSR_STAT7_RESERVED878_BF_OFF (30)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_RESERVED878_BF_WID ( 2)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_RESERVED878_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG84_CSR_STAT7_RESERVED878_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG85_CSR_ABC_STAT8 register description at address offset 0x154
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg85_csr_abc_stat8
  * AnaRF PLL csr_abc_stat8
  */

typedef union {
  struct {
    uint32_t D_SFTDC_SEM_START_PHASE_MS : 15;
    ///< d_sftdc_sem_start_phase_ms start phase
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t D_SFTDC_SEM_END_PHASE_MS : 15;
    ///< d_sftdc_sem_end_phase_ms end phase
    ///< AccessType="RO" BitOffset="15" ResetValue="0x0"
    uint32_t RESERVED885 : 2;
    ///< reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg85_csr_stat8_reg_t;

#define PLL_LOCAL_PLLREG85_CSR_STAT8_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_WR_MASK (0x00000000U)


///< d_sftdc_sem_start_phase_ms start phase
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_START_PHASE_MS_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_START_PHASE_MS_BF_WID (15)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_START_PHASE_MS_BF_MSK (0x00007FFF)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_START_PHASE_MS_BF_DEF (0x00000000)

///< d_sftdc_sem_end_phase_ms end phase
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_END_PHASE_MS_BF_OFF (15)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_END_PHASE_MS_BF_WID (15)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_END_PHASE_MS_BF_MSK (0x3FFF8000)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_D_SFTDC_SEM_END_PHASE_MS_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG85_CSR_STAT8_RESERVED885_BF_OFF (30)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_RESERVED885_BF_WID ( 2)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_RESERVED885_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG85_CSR_STAT8_RESERVED885_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG86_CSR_ABC_STAT9 register description at address offset 0x158
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg86_csr_abc_stat9
  * AnaRF PLL csr_abc_stat9
  */

typedef union {
  struct {
    uint32_t D_SEM_INDEX_POS_IIR_M : 15;
    ///< d_sem_index_pos_iir_m pos iir
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t D_SEM_INDEX_NEG_IIR_M : 15;
    ///< d_sem_index_neg_iir_m neg iir
    ///< AccessType="RO" BitOffset="15" ResetValue="0x0"
    uint32_t RESERVED891 : 2;
    ///< reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg86_csr_stat9_reg_t;

#define PLL_LOCAL_PLLREG86_CSR_STAT9_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_WR_MASK (0x00000000U)


///< d_sem_index_pos_iir_m pos iir
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_POS_IIR_M_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_POS_IIR_M_BF_WID (15)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_POS_IIR_M_BF_MSK (0x00007FFF)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_POS_IIR_M_BF_DEF (0x00000000)

///< d_sem_index_neg_iir_m neg iir
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_NEG_IIR_M_BF_OFF (15)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_NEG_IIR_M_BF_WID (15)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_NEG_IIR_M_BF_MSK (0x3FFF8000)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_D_SEM_INDEX_NEG_IIR_M_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG86_CSR_STAT9_RESERVED891_BF_OFF (30)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_RESERVED891_BF_WID ( 2)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_RESERVED891_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG86_CSR_STAT9_RESERVED891_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG87_CSR_ABC_STAT10 register description at address offset 0x15c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg87_csr_abc_stat10
  * AnaRF PLL csr_abc_stat10
  */

typedef union {
  struct {
    uint32_t DLF_INV_P_DA_EXP : 6;
    ///< dlf_inv_p_da_exp da exp
    ///< AccessType="RO" BitOffset="0" ResetValue="0x0"
    uint32_t DLF_INV_P_DA_MNT : 6;
    ///< dlf_inv_p_da_mnt da mnt
    ///< AccessType="RO" BitOffset="6" ResetValue="0x0"
    uint32_t RESERVED897 : 20;
    ///< reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg87_csr_stat10_reg_t;

#define PLL_LOCAL_PLLREG87_CSR_STAT10_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_WR_MASK (0x00000000U)


///< dlf_inv_p_da_exp da exp
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_EXP_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_EXP_BF_WID ( 6)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_EXP_BF_MSK (0x0000003F)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_EXP_BF_DEF (0x00000000)

///< dlf_inv_p_da_mnt da mnt
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_MNT_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_MNT_BF_WID ( 6)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_MNT_BF_MSK (0x00000FC0)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_DLF_INV_P_DA_MNT_BF_DEF (0x00000000)

///< reserved
#define PLL_LOCAL_PLLREG87_CSR_STAT10_RESERVED897_BF_OFF (12)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_RESERVED897_BF_WID (20)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_RESERVED897_BF_MSK (0xFFFFF000)
#define PLL_LOCAL_PLLREG87_CSR_STAT10_RESERVED897_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG88_CSR_ABC_SFTDC register description at address offset 0x160
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg88_csr_abc_sftdc
  * AnaRF PLL csr_abc_sftdc
  */

typedef union {
  struct {
    uint32_t CSR_ABC_SFTDC_CTRL : 32;
    ///< SFTDC control register
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg88_csr_sftdc_reg_t;

#define PLL_LOCAL_PLLREG88_CSR_SFTDC_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_WR_MASK (0xffffffffU)


///< SFTDC control register
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_CSR_SFTDC_CTRL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_CSR_SFTDC_CTRL_BF_WID (32)
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_CSR_SFTDC_CTRL_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_CSR_SFTDC_CTRL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG89_CSR_ABC_DCG_CTRL register description at address offset 0x164
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg89_csr_abc_dcg_ctrl
  * AnaRF PLL csr_abc_dcg_ctrl
  */

typedef union {
  struct {
    uint32_t CSR_ABC_DCG_CTRL : 32;
    ///< Digital Clock Generator control register
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg89_csr_dcg_ctrl_reg_t;

#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_WR_MASK (0xffffffffU)


///< Digital Clock Generator control register
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_CSR_DCG_CTRL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_CSR_DCG_CTRL_BF_WID (32)
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_CSR_DCG_CTRL_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_CSR_DCG_CTRL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG90_CSR_ABC_DCO_LDO1_CTRL register description at address offset 0x168
  *
  * Register default value:        0x00000DC0
  * Register full path in IP: pll_local/reg/pllreg90_csr_abc_dco_ldo1_ctrl
  * AnaRF PLL csr_abc_dco_ldo1_ctrl
  */

typedef union {
  struct {
    uint32_t DCO_CORE_LDO_EN : 1;
    ///< dco_core_ldo_en ldo enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DCO_CORE_LDO_LP_EN : 1;
    ///< dco_core_ldo_lp_en ldo lp enable
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DCO_CORE_LDO_BYP_EN : 1;
    ///< dco_core_ldo_byp_en ldo bypass enable
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DCO_CORE_LDO_MON_EN : 1;
    ///< dco_core_ldo_mon_en ldo monitor enable
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DCO_CORE_LDO_VOUT_TUNE : 4;
    ///< dco_core_ldo_vout_tune vout tune
    ///< AccessType="RW" BitOffset="4" ResetValue="0xC"
    uint32_t DCO_CORE_LDO_VCAS_TUNE : 4;
    ///< dco_core_ldo_vout_tune vout tune cascode
    ///< AccessType="RW" BitOffset="8" ResetValue="0xD"
    uint32_t DCO_CORE_LDO_VREF_SRC : 1;
    ///< dco_core_ldo_vref_src ldo vref source
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t DCO_CORE_LDO_VCAS_SRC : 1;
    ///< dco_core_ldo_vref_src ldo vref source cascode
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t DCO_CORE_LDO_RES_CTRL : 4;
    ///< dco_core_ldo_res_ctrl ldo resistor control
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t VREF_TRIM : 3;
    ///< vref_trim reference voltage trim
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t FILTER_BYP_EN : 1;
    ///< filter_byp_en filter bypass enable
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t BGP_EN : 1;
    ///< bgp_en bandgap enable
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t BGP_TRIM : 3;
    ///< bgp_trim bandgap trim
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t DCO_LDO1_CTRL_SPARE6B : 6;
    ///< abc_dco_ldo1_ctrl_spare6b ldo1 spare
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg90_csr_dco_ldo1_ctrl_reg_t;

#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DEFAULT (0x00000dc0U)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_WR_MASK (0xffffffffU)


///< dco_core_ldo_en ldo enable
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_EN_BF_DEF (0x00000000)

///< dco_core_ldo_lp_en ldo lp enable
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_LP_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_LP_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_LP_EN_BF_DEF (0x00000000)

///< dco_core_ldo_byp_en ldo bypass enable
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_BYP_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_BYP_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_BYP_EN_BF_DEF (0x00000000)

///< dco_core_ldo_mon_en ldo monitor enable
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_MON_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_MON_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_MON_EN_BF_DEF (0x00000000)

///< dco_core_ldo_vout_tune vout tune
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VOUT_TUNE_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VOUT_TUNE_BF_MSK (0x000000F0)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VOUT_TUNE_BF_DEF (0x000000C0)

///< dco_core_ldo_vout_tune vout tune cascode
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_TUNE_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_TUNE_BF_MSK (0x00000F00)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_TUNE_BF_DEF (0x00000D00)

///< dco_core_ldo_vref_src ldo vref source
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VREF_SRC_BF_OFF (12)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VREF_SRC_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VREF_SRC_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VREF_SRC_BF_DEF (0x00000000)

///< dco_core_ldo_vref_src ldo vref source cascode
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_SRC_BF_OFF (13)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_SRC_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_SRC_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_VCAS_SRC_BF_DEF (0x00000000)

///< dco_core_ldo_res_ctrl ldo resistor control
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_RES_CTRL_BF_OFF (14)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_RES_CTRL_BF_MSK (0x0003C000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_CORE_LDO_RES_CTRL_BF_DEF (0x00000000)

///< vref_trim reference voltage trim
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_VREF_TRIM_BF_OFF (18)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_VREF_TRIM_BF_WID ( 3)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_VREF_TRIM_BF_MSK (0x001C0000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_VREF_TRIM_BF_DEF (0x00000000)

///< filter_byp_en filter bypass enable
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_FILTER_BYP_EN_BF_OFF (21)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_FILTER_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_FILTER_BYP_EN_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_FILTER_BYP_EN_BF_DEF (0x00000000)

///< bgp_en bandgap enable
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_EN_BF_OFF (22)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_EN_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_EN_BF_DEF (0x00000000)

///< bgp_trim bandgap trim
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_TRIM_BF_OFF (23)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_TRIM_BF_WID ( 3)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_TRIM_BF_MSK (0x03800000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_BGP_TRIM_BF_DEF (0x00000000)

///< abc_dco_ldo1_ctrl_spare6b ldo1 spare
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_LDO1_CTRL_SPARE6B_BF_OFF (26)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_LDO1_CTRL_SPARE6B_BF_WID ( 6)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_LDO1_CTRL_SPARE6B_BF_MSK (0xFC000000)
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_DCO_LDO1_CTRL_SPARE6B_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG91_CSR_ABC_DCO_LDO2_CTRL register description at address offset 0x16c
  *
  * Register default value:        0x000000D0
  * Register full path in IP: pll_local/reg/pllreg91_csr_abc_dco_ldo2_ctrl
  * AnaRF PLL csr_abc_dco_ldo2_ctrl
  */

typedef union {
  struct {
    uint32_t DCO_LOPA_LDO_EN : 1;
    ///< dco_lopa_ldo_en enable LDO
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t DCO_LOPA_LDO_LP_EN : 1;
    ///< dco_lopa_ldo lp en enable
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t DCO_LOPA_LDO_BYP_EN : 1;
    ///< dco_lopa_ldo byp en
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t DCO_LOPA_LDO_MON_EN : 1;
    ///< dco_lopa_ldo mon en
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t DCO_LOPA_LDO_VOUT_TUNE : 4;
    ///< dco_lopa_ldo vout tune
    ///< AccessType="RW" BitOffset="4" ResetValue="0xD"
    uint32_t DCO_LOPA_LDO_VREF_SRC : 1;
    ///< 0=dco_lopa_ldo_vref_src is voltage divider, 1=dco_lopa_ldo_vref_src
    ///< is bgp
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t DCO_LOPA_LDO_RES_CTRL : 4;
    ///< dco_lopa_ldo res ctrl
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_EN : 1;
    ///< dco_dig_ldo en enable
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_LP_EN : 1;
    ///< dco_dig_ldo lp en
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_HIGHZ_EN : 1;
    ///< dco_dig_ldo highz en
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_BYP_EN : 1;
    ///< dco_dig_ldo byp en
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_START_UP_EN : 1;
    ///< dco_dig_ldo start_up en
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_MON_EN : 1;
    ///< dco_dig_ldo mon en
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_VOUT_TUNE : 4;
    ///< dco_dig_ldo vout tune
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_SINK_CURRENT : 2;
    ///< dco_dig_ldo sink current
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t DCO_DIG_LDO_BIAS_SEL : 3;
    ///< dco_dig_ldo_bias_sel ldo bias sel
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t DCO_LDO2_CTRL_SPARE4B : 4;
    ///< abc_dco_ldo2_ctrl_spare4b
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg91_csr_dco_ldo2_ctrl_reg_t;

#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DEFAULT (0x000000d0U)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_WR_MASK (0xffffffffU)


///< dco_lopa_ldo_en enable LDO
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_EN_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_EN_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_EN_BF_DEF (0x00000000)

///< dco_lopa_ldo lp en enable
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_LP_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_LP_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_LP_EN_BF_DEF (0x00000000)

///< dco_lopa_ldo byp en
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_BYP_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_BYP_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_BYP_EN_BF_DEF (0x00000000)

///< dco_lopa_ldo mon en
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_MON_EN_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_MON_EN_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_MON_EN_BF_DEF (0x00000000)

///< dco_lopa_ldo vout tune
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VOUT_TUNE_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VOUT_TUNE_BF_MSK (0x000000F0)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VOUT_TUNE_BF_DEF (0x000000D0)

///< 0=dco_lopa_ldo_vref_src is voltage divider, 1=dco_lopa_ldo_vref_src
///< is bgp
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VREF_SRC_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VREF_SRC_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VREF_SRC_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_VREF_SRC_BF_DEF (0x00000000)

///< dco_lopa_ldo res ctrl
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_RES_CTRL_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_RES_CTRL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_RES_CTRL_BF_MSK (0x00001E00)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LOPA_LDO_RES_CTRL_BF_DEF (0x00000000)

///< dco_dig_ldo en enable
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_EN_BF_OFF (13)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_EN_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_EN_BF_DEF (0x00000000)

///< dco_dig_ldo lp en
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_LP_EN_BF_OFF (14)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_LP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_LP_EN_BF_MSK (0x00004000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_LP_EN_BF_DEF (0x00000000)

///< dco_dig_ldo highz en
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_HIGHZ_EN_BF_OFF (15)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_HIGHZ_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_HIGHZ_EN_BF_MSK (0x00008000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_HIGHZ_EN_BF_DEF (0x00000000)

///< dco_dig_ldo byp en
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BYP_EN_BF_OFF (16)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BYP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BYP_EN_BF_MSK (0x00010000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BYP_EN_BF_DEF (0x00000000)

///< dco_dig_ldo start_up en
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_START_UP_EN_BF_OFF (17)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_START_UP_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_START_UP_EN_BF_MSK (0x00020000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_START_UP_EN_BF_DEF (0x00000000)

///< dco_dig_ldo mon en
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_MON_EN_BF_OFF (18)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_MON_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_MON_EN_BF_MSK (0x00040000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_MON_EN_BF_DEF (0x00000000)

///< dco_dig_ldo vout tune
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_VOUT_TUNE_BF_OFF (19)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_VOUT_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_VOUT_TUNE_BF_MSK (0x00780000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_VOUT_TUNE_BF_DEF (0x00000000)

///< dco_dig_ldo sink current
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_SINK_CURRENT_BF_OFF (23)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_SINK_CURRENT_BF_WID ( 2)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_SINK_CURRENT_BF_MSK (0x01800000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_SINK_CURRENT_BF_DEF (0x00000000)

///< dco_dig_ldo_bias_sel ldo bias sel
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BIAS_SEL_BF_OFF (25)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BIAS_SEL_BF_WID ( 3)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BIAS_SEL_BF_MSK (0x0E000000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_DIG_LDO_BIAS_SEL_BF_DEF (0x00000000)

///< abc_dco_ldo2_ctrl_spare4b
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LDO2_CTRL_SPARE4B_BF_OFF (28)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LDO2_CTRL_SPARE4B_BF_WID ( 4)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LDO2_CTRL_SPARE4B_BF_MSK (0xF0000000)
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_DCO_LDO2_CTRL_SPARE4B_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG92_CSR_ABC_TDC_LDO1_CTRL register description at address offset 0x170
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg92_csr_abc_tdc_ldo1_ctrl
  * AnaRF PLL csr_abc_tdc_ldo1_ctrl
  */

typedef union {
  struct {
    uint32_t CSR_ABC_TDC_LDO1_CTRL : 32;
    ///< TDC LDO1 control register
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg92_csr_tdc_ldo1_ctrl_reg_t;

#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_WR_MASK (0xffffffffU)


///< TDC LDO1 control register
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_CSR_TDC_LDO1_CTRL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_CSR_TDC_LDO1_CTRL_BF_WID (32)
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_CSR_TDC_LDO1_CTRL_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_CSR_TDC_LDO1_CTRL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG93_CSR_ABC_TDC_LDO2_CTRL register description at address offset 0x174
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg93_csr_abc_tdc_ldo2_ctrl
  * AnaRF PLL csr_abc_tdc_ldo2_ctrl
  */

typedef union {
  struct {
    uint32_t CSR_ABC_TDC_LDO2_CTRL : 32;
    ///< TDC LDO2 control register
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg93_csr_tdc_ldo2_ctrl_reg_t;

#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_WR_MASK (0xffffffffU)


///< TDC LDO2 control register
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_CSR_TDC_LDO2_CTRL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_CSR_TDC_LDO2_CTRL_BF_WID (32)
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_CSR_TDC_LDO2_CTRL_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_CSR_TDC_LDO2_CTRL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG94_CSR_ABC_DPLL_DIG_LDO_CTRL register description at address offset 0x178
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg94_csr_abc_dpll_dig_ldo_ctrl
  * AnaRF PLL csr_abc_dpll_dig_ldo_ctrl
  */

typedef union {
  struct {
    uint32_t CSR_ABC_DPLL_DIG_LDO_CTRL : 32;
    ///< DPLL DIG LDO control register
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg94_csr_dpll_dig_ldo_ctrl_reg_t;

#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_WR_MASK (0xffffffffU)


///< DPLL DIG LDO control register
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_CSR_DPLL_DIG_LDO_CTRL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_CSR_DPLL_DIG_LDO_CTRL_BF_WID (32)
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_CSR_DPLL_DIG_LDO_CTRL_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_CSR_DPLL_DIG_LDO_CTRL_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG95_CSR_ABC_BIAS_VREF_CTRL register description at address offset 0x17c
  *
  * Register default value:        0x00C6318C
  * Register full path in IP: pll_local/reg/pllreg95_csr_abc_bias_vref_ctrl
  * AnaRF PLL csr_abc_bias_vref_ctrl
  */

typedef union {
  struct {
    uint32_t DCO_DIG_LDO_VREF_TUNE : 4;
    ///< dco_dig_ldo vref tune
    ///< AccessType="RW" BitOffset="0" ResetValue="0xC"
    uint32_t DCO_DIG_LDO_VREF_SRC : 1;
    ///< 0=xxx_ldo_vref_src is voltage divider, 1=xxx_ldo_vref_src is bandgap
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SYSREF_LDO_VREF_TUNE : 4;
    ///< sysref_ldo vref tune
    ///< AccessType="RW" BitOffset="5" ResetValue="0xC"
    uint32_t SYSREF_LDO_VREF_SRC : 1;
    ///< 0=xxx_ldo_vref_src is voltage divider, 1=xxx_ldo_vref_src is bandgap
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t TDC_FAST_LDO_VREF_TUNE : 4;
    ///< tdc_fast_ldo vref tune
    ///< AccessType="RW" BitOffset="10" ResetValue="0xC"
    uint32_t TDC_FAST_LDO_VREF_SRC : 1;
    ///< 0=xxx_ldo_vref_src is voltage divider, 1=xxx_ldo_vref_src is bandgap
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t DIG_LDO_VREF_TUNE : 4;
    ///< dig_ldo vref tune
    ///< AccessType="RW" BitOffset="15" ResetValue="0xC"
    uint32_t DIG_LDO_VREF_SRC : 1;
    ///< Bias and VREF control register
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t BIAS_VREF_CTRL_SPARE12B : 12;
    ///< Bias and VREF control spare 12 bits
    ///< AccessType="RW" BitOffset="20" ResetValue="0xC"
  } ;
  uint32_t value;
} pll_local_pllreg95_csr_bias_vref_ctrl_reg_t;

#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DEFAULT (0x00c6318cU)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_WR_MASK (0xffffffffU)


///< dco_dig_ldo vref tune
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_TUNE_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_TUNE_BF_MSK (0x0000000F)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_TUNE_BF_DEF (0x0000000C)

///< 0=xxx_ldo_vref_src is voltage divider, 1=xxx_ldo_vref_src is bandgap
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_SRC_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_SRC_BF_WID ( 1)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_SRC_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DCO_DIG_LDO_VREF_SRC_BF_DEF (0x00000000)

///< sysref_ldo vref tune
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_TUNE_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_TUNE_BF_MSK (0x000001E0)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_TUNE_BF_DEF (0x00000180)

///< 0=xxx_ldo_vref_src is voltage divider, 1=xxx_ldo_vref_src is bandgap
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_SRC_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_SRC_BF_WID ( 1)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_SRC_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_SYSREF_LDO_VREF_SRC_BF_DEF (0x00000000)

///< tdc_fast_ldo vref tune
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_TUNE_BF_OFF (10)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_TUNE_BF_MSK (0x00003C00)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_TUNE_BF_DEF (0x00003000)

///< 0=xxx_ldo_vref_src is voltage divider, 1=xxx_ldo_vref_src is bandgap
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_SRC_BF_OFF (14)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_SRC_BF_WID ( 1)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_SRC_BF_MSK (0x00004000)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_TDC_FAST_LDO_VREF_SRC_BF_DEF (0x00000000)

///< dig_ldo vref tune
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_TUNE_BF_OFF (15)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_TUNE_BF_WID ( 4)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_TUNE_BF_MSK (0x00078000)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_TUNE_BF_DEF (0x00060000)

///< Bias and VREF control register
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_SRC_BF_OFF (19)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_SRC_BF_WID ( 1)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_SRC_BF_MSK (0x00080000)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_DIG_LDO_VREF_SRC_BF_DEF (0x00000000)

///< Bias and VREF control spare 12 bits
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_BIAS_VREF_CTRL_SPARE12B_BF_OFF (20)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_BIAS_VREF_CTRL_SPARE12B_BF_WID (12)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_BIAS_VREF_CTRL_SPARE12B_BF_MSK (0xFFF00000)
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_BIAS_VREF_CTRL_SPARE12B_BF_DEF (0x00C00000)


/** @brief PLL_LOCAL_REG_PLLREG96_CSR_ABC_LOPA_CLKREF_CTRL register description at address offset 0x180
  *
  * Register default value:        0x01A03264
  * Register full path in IP: pll_local/reg/pllreg96_csr_abc_lopa_clkref_ctrl
  * AnaRF PLL csr_abc_lopa_clkref_ctrl
  */

typedef union {
  struct {
    uint32_t SYSCLK_SHAPER_PON : 1;
    ///< 1=sysclk shaper pon
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t SYSCLK_DIV2_DIG_EN : 1;
    ///< 1=sysclk div2 dig en
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CLKREF_LDO_EN : 1;
    ///< 1=clkref ldo en
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t CLKREF_LDO_BYP : 1;
    ///< 1=clkref ldo byp
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CLKREF_LDO_VREF_FILTER_BYP : 1;
    ///< 1=clkref_ldo vref_filter byp
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SEQ_CLK_EN : 1;
    ///< 1=seq clk en
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint32_t SEQ_CLKDIV_RSTN : 1;
    ///< 0=reset active
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint32_t SEQ_CLK_DIV_VAL : 4;
    ///< default: 0x4 = divide by 16
    ///< AccessType="RW" BitOffset="7" ResetValue="0x4"
    uint32_t SYSCLK_DIV2_ANA_EN : 1;
    ///< 1=sysclk_div2 ana en
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CLKREF_SYSCLK2PLL_OUT_EN : 1;
    ///< 1=clkref_sysclk2pll out en
    ///< AccessType="RW" BitOffset="12" ResetValue="0x1"
    uint32_t CLKREF_SYSCLK2JESD_OUT_EN : 1;
    ///< 1=clkref_sysclk2jesd out en
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t SYSCLK_SHAPER_RTERM : 4;
    ///< Sysclk shaper rterm
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CLKREF_CTRL_SPARE2B : 2;
    ///< Clkref ctrl spare2b
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t DCO_LOPA_DIV_PWD : 1;
    ///< 1=dco_lopa div pwd
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t DCO_LOPA_BYPCLK_ENN : 1;
    ///< 0=dco_lopa bypclk enn
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint32_t DCO_EXT_BYPCLK_EN : 1;
    ///< 1=dco_ext bypclk en
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t DCO_EXT_BYPCLK_DISN : 1;
    ///< 1=dco_ext bypclk disn
    ///< AccessType="RW" BitOffset="23" ResetValue="0x1"
    uint32_t DCO_CLKDIST_BYPCLK_ENN : 1;
    ///< 0=dco_clkdist bypclk enn
    ///< AccessType="RW" BitOffset="24" ResetValue="0x1"
    uint32_t LOPA_CTRL_SPARE7B : 7;
    ///< lopa_ctrl_spare7b
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg96_csr_lopa_clkref_ctrl_reg_t;

#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DEFAULT (0x01a03264U)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_WR_MASK (0xffffffffU)


///< 1=sysclk shaper pon
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_PON_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_PON_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_PON_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_PON_BF_DEF (0x00000000)

///< 1=sysclk div2 dig en
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_DIG_EN_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_DIG_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_DIG_EN_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_DIG_EN_BF_DEF (0x00000000)

///< 1=clkref ldo en
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_EN_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_EN_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_EN_BF_DEF (0x00000004)

///< 1=clkref ldo byp
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_BYP_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_BYP_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_BYP_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_BYP_BF_DEF (0x00000000)

///< 1=clkref_ldo vref_filter byp
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_VREF_FILTER_BYP_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_VREF_FILTER_BYP_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_VREF_FILTER_BYP_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_LDO_VREF_FILTER_BYP_BF_DEF (0x00000000)

///< 1=seq clk en
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_EN_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_EN_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_EN_BF_DEF (0x00000020)

///< 0=reset active
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLKDIV_RSTN_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLKDIV_RSTN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLKDIV_RSTN_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLKDIV_RSTN_BF_DEF (0x00000040)

///< default: 0x4 = divide by 16
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_DIV_VAL_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_DIV_VAL_BF_WID ( 4)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_DIV_VAL_BF_MSK (0x00000780)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SEQ_CLK_DIV_VAL_BF_DEF (0x00000200)

///< 1=sysclk_div2 ana en
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_ANA_EN_BF_OFF (11)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_ANA_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_ANA_EN_BF_MSK (0x00000800)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_DIV2_ANA_EN_BF_DEF (0x00000000)

///< 1=clkref_sysclk2pll out en
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2PLL_OUT_EN_BF_OFF (12)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2PLL_OUT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2PLL_OUT_EN_BF_MSK (0x00001000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2PLL_OUT_EN_BF_DEF (0x00001000)

///< 1=clkref_sysclk2jesd out en
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2JESD_OUT_EN_BF_OFF (13)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2JESD_OUT_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2JESD_OUT_EN_BF_MSK (0x00002000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_SYSCLK2JESD_OUT_EN_BF_DEF (0x00002000)

///< Sysclk shaper rterm
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_RTERM_BF_OFF (14)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_RTERM_BF_WID ( 4)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_RTERM_BF_MSK (0x0003C000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_SYSCLK_SHAPER_RTERM_BF_DEF (0x00000000)

///< Clkref ctrl spare2b
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_CTRL_SPARE2B_BF_OFF (18)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_CTRL_SPARE2B_BF_WID ( 2)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_CTRL_SPARE2B_BF_MSK (0x000C0000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_CLKREF_CTRL_SPARE2B_BF_DEF (0x00000000)

///< 1=dco_lopa div pwd
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_DIV_PWD_BF_OFF (20)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_DIV_PWD_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_DIV_PWD_BF_MSK (0x00100000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_DIV_PWD_BF_DEF (0x00000000)

///< 0=dco_lopa bypclk enn
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_BYPCLK_ENN_BF_OFF (21)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_BYPCLK_ENN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_BYPCLK_ENN_BF_MSK (0x00200000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_LOPA_BYPCLK_ENN_BF_DEF (0x00200000)

///< 1=dco_ext bypclk en
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_EN_BF_OFF (22)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_EN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_EN_BF_MSK (0x00400000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_EN_BF_DEF (0x00000000)

///< 1=dco_ext bypclk disn
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_DISN_BF_OFF (23)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_DISN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_DISN_BF_MSK (0x00800000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_EXT_BYPCLK_DISN_BF_DEF (0x00800000)

///< 0=dco_clkdist bypclk enn
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_CLKDIST_BYPCLK_ENN_BF_OFF (24)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_CLKDIST_BYPCLK_ENN_BF_WID ( 1)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_CLKDIST_BYPCLK_ENN_BF_MSK (0x01000000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_DCO_CLKDIST_BYPCLK_ENN_BF_DEF (0x01000000)

///< lopa_ctrl_spare7b
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_LOPA_CTRL_SPARE7B_BF_OFF (25)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_LOPA_CTRL_SPARE7B_BF_WID ( 7)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_LOPA_CTRL_SPARE7B_BF_MSK (0xFE000000)
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_LOPA_CTRL_SPARE7B_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG97_CSR_ABC_PLL_CLKDIST_CONF0 register description at address offset 0x184
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg97_csr_abc_pll_clkdist_conf0
  * AnaRF PLL csr_abc_pll_clkdist_conf0
  */

typedef union {
  struct {
    uint32_t ENLDO : 1;
    ///< enables the 16G CLKDIST LDO
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t ENINBUF : 1;
    ///< enable the ai_c_pll_rfclk16g_p/n input buffer which propagate the
    ///< clock to the transceivers
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ENBUF_01 : 1;
    ///< enable 16G/24G clock stage buffer TRX0 and TRX1 sections
    ///< AccessType="RW/V" BitOffset="2" ResetValue="0x0"
    uint32_t ENBUFFB1 : 1;
    ///< enable 16G/24G clock stage buffer FBX1 section
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x0"
    uint32_t ENBUF_23 : 1;
    ///< enable 16G/24G clock stage buffer TRX2 and TRX3 sections
    ///< AccessType="RW/V" BitOffset="4" ResetValue="0x0"
    uint32_t ENBUF_45 : 1;
    ///< enable 16G/24G clock stage buffer TRX4 and TRX5 sections
    ///< AccessType="RW/V" BitOffset="5" ResetValue="0x0"
    uint32_t ENBUFFB0 : 1;
    ///< enable 16G/24G clock stage buffer FBX0 section
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t ENBUF_67 : 1;
    ///< enable 16G/24G clock stage buffer TRX6 and TRX7 sections
    ///< AccessType="RW/V" BitOffset="7" ResetValue="0x0"
    uint32_t ENADCBUF_01 : 1;
    ///< enable 16G/24G clock output stage buffer for the RX0 and RX1 RX_ADC
    ///< AccessType="RW/V" BitOffset="8" ResetValue="0x0"
    uint32_t ENADCBUF_23 : 1;
    ///< enable 16G/24G clock output stage buffer for the RX2 and RX3 RX_ADC
    ///< AccessType="RW/V" BitOffset="9" ResetValue="0x0"
    uint32_t ENADCBUF_45 : 1;
    ///< enable 16G/24G clock output stage buffer for the RX4 and RX5 RX_ADC
    ///< AccessType="RW/V" BitOffset="10" ResetValue="0x0"
    uint32_t ENADCBUF_67 : 1;
    ///< enable 16G/24G clock output stage buffer for the RX6 and RX7 RX_ADC
    ///< AccessType="RW/V" BitOffset="11" ResetValue="0x0"
    uint32_t ENFBADCBUF_1_0 : 2;
    ///< enable 16G/24G clock output stage buffer for the FB0..1 RX_ADC
    ///< AccessType="RW/V" BitOffset="12" ResetValue="0x0"
    uint32_t ENDACBUF_7_0 : 8;
    ///< enable 16G/24G clock output stage buffer for the TRX0..7 TX_DAC
    ///< AccessType="RW/V" BitOffset="14" ResetValue="0x0"
    uint32_t ENCALDACBUF_1_0 : 2;
    ///< enable 16G/24G clock output stage buffer for the FB0..1 CALDAC
    ///< AccessType="RW/V" BitOffset="22" ResetValue="0x0"
    uint32_t ENNEGRES : 1;
    ///< enable crosscoupling inverters
    ///< AccessType="RW/V" BitOffset="24" ResetValue="0x0"
    uint32_t HIGHBAND : 1;
    ///< enablle the detune resonance network for highband (24G)
    ///< AccessType="RW/V" BitOffset="25" ResetValue="0x0"
    uint32_t EN1GHZ : 1;
    ///< enable di_c_pll_syncclk1g 1GHz clock synchronization for the transceivers
    ///< AccessType="RW/V" BitOffset="26" ResetValue="0x0"
    uint32_t ENBYPOUTBUF : 1;
    ///< enable the 16G/24G chip output buffer to measure the clock jitter
    ///< AccessType="RW/V" BitOffset="27" ResetValue="0x0"
    uint32_t ENCHIPLETBUF : 1;
    ///< enable chiplet output buffer
    ///< AccessType="RW/V" BitOffset="28" ResetValue="0x0"
    uint32_t ENBYPINBUF : 1;
    ///< enable bypass input buffer
    ///< AccessType="RW/V" BitOffset="29" ResetValue="0x0"
    uint32_t RESERVED : 2;
    ///< To Be Done
    ///< AccessType="RW/V" BitOffset="30" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg97_csr_pll_clkdist_conf0_reg_t;

#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_WR_MASK (0xffffffffU)


///< enables the 16G CLKDIST LDO
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENLDO_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENLDO_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENLDO_BF_MSK (0x00000001)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENLDO_BF_DEF (0x00000000)

///< enable the ai_c_pll_rfclk16g_p/n input buffer which propagate the
///< clock to the transceivers
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENINBUF_BF_OFF ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENINBUF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENINBUF_BF_MSK (0x00000002)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENINBUF_BF_DEF (0x00000000)

///< enable 16G/24G clock stage buffer TRX0 and TRX1 sections
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_01_BF_OFF ( 2)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_01_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_01_BF_MSK (0x00000004)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_01_BF_DEF (0x00000000)

///< enable 16G/24G clock stage buffer FBX1 section
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB1_BF_OFF ( 3)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB1_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB1_BF_MSK (0x00000008)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB1_BF_DEF (0x00000000)

///< enable 16G/24G clock stage buffer TRX2 and TRX3 sections
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_23_BF_OFF ( 4)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_23_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_23_BF_MSK (0x00000010)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_23_BF_DEF (0x00000000)

///< enable 16G/24G clock stage buffer TRX4 and TRX5 sections
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_45_BF_OFF ( 5)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_45_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_45_BF_MSK (0x00000020)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_45_BF_DEF (0x00000000)

///< enable 16G/24G clock stage buffer FBX0 section
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB0_BF_OFF ( 6)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB0_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB0_BF_MSK (0x00000040)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUFFB0_BF_DEF (0x00000000)

///< enable 16G/24G clock stage buffer TRX6 and TRX7 sections
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_67_BF_OFF ( 7)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_67_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_67_BF_MSK (0x00000080)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBUF_67_BF_DEF (0x00000000)

///< enable 16G/24G clock output stage buffer for the RX0 and RX1 RX_ADC
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_01_BF_OFF ( 8)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_01_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_01_BF_MSK (0x00000100)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_01_BF_DEF (0x00000000)

///< enable 16G/24G clock output stage buffer for the RX2 and RX3 RX_ADC
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_23_BF_OFF ( 9)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_23_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_23_BF_MSK (0x00000200)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_23_BF_DEF (0x00000000)

///< enable 16G/24G clock output stage buffer for the RX4 and RX5 RX_ADC
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_45_BF_OFF (10)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_45_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_45_BF_MSK (0x00000400)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_45_BF_DEF (0x00000000)

///< enable 16G/24G clock output stage buffer for the RX6 and RX7 RX_ADC
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_67_BF_OFF (11)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_67_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_67_BF_MSK (0x00000800)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENADCBUF_67_BF_DEF (0x00000000)

///< enable 16G/24G clock output stage buffer for the FB0..1 RX_ADC
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENFBADCBUF_1_0_BF_OFF (12)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENFBADCBUF_1_0_BF_WID ( 2)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENFBADCBUF_1_0_BF_MSK (0x00003000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENFBADCBUF_1_0_BF_DEF (0x00000000)

///< enable 16G/24G clock output stage buffer for the TRX0..7 TX_DAC
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENDACBUF_7_0_BF_OFF (14)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENDACBUF_7_0_BF_WID ( 8)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENDACBUF_7_0_BF_MSK (0x003FC000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENDACBUF_7_0_BF_DEF (0x00000000)

///< enable 16G/24G clock output stage buffer for the FB0..1 CALDAC
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCALDACBUF_1_0_BF_OFF (22)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCALDACBUF_1_0_BF_WID ( 2)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCALDACBUF_1_0_BF_MSK (0x00C00000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCALDACBUF_1_0_BF_DEF (0x00000000)

///< enable crosscoupling inverters
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENNEGRES_BF_OFF (24)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENNEGRES_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENNEGRES_BF_MSK (0x01000000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENNEGRES_BF_DEF (0x00000000)

///< enablle the detune resonance network for highband (24G)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_HIGHBAND_BF_OFF (25)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_HIGHBAND_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_HIGHBAND_BF_MSK (0x02000000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_HIGHBAND_BF_DEF (0x00000000)

///< enable di_c_pll_syncclk1g 1GHz clock synchronization for the transceivers
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_EN1GHZ_BF_OFF (26)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_EN1GHZ_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_EN1GHZ_BF_MSK (0x04000000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_EN1GHZ_BF_DEF (0x00000000)

///< enable the 16G/24G chip output buffer to measure the clock jitter
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPOUTBUF_BF_OFF (27)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPOUTBUF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPOUTBUF_BF_MSK (0x08000000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPOUTBUF_BF_DEF (0x00000000)

///< enable chiplet output buffer
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCHIPLETBUF_BF_OFF (28)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCHIPLETBUF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCHIPLETBUF_BF_MSK (0x10000000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENCHIPLETBUF_BF_DEF (0x00000000)

///< enable bypass input buffer
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPINBUF_BF_OFF (29)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPINBUF_BF_WID ( 1)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPINBUF_BF_MSK (0x20000000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ENBYPINBUF_BF_DEF (0x00000000)

///< To Be Done
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_RESERVED_BF_OFF (30)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_RESERVED_BF_WID ( 2)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_RESERVED_BF_MSK (0xC0000000)
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_RESERVED_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG98_CSR_ABC_PLL_CLKDIST_CONF1 register description at address offset 0x188
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg98_csr_abc_pll_clkdist_conf1
  * AnaRF PLL csr_abc_pll_clkdist_conf1
  */

typedef union {
  struct {
    uint32_t CSR_ABC_PLL_CLKDIST_CONF1 : 32;
    ///< Clockdist config register 1
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg98_csr_pll_clkdist_conf1_reg_t;

#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_WR_MASK (0xffffffffU)


///< Clockdist config register 1
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_CSR_PLL_CLKDIST_CONF1_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_CSR_PLL_CLKDIST_CONF1_BF_WID (32)
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_CSR_PLL_CLKDIST_CONF1_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_CSR_PLL_CLKDIST_CONF1_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG99_CSR_ABC_PLL_CLKDIST_CONF2 register description at address offset 0x18c
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg99_csr_abc_pll_clkdist_conf2
  * AnaRF PLL csr_abc_pll_clkdist_conf2
  */

typedef union {
  struct {
    uint32_t CSR_ABC_PLL_CLKDIST_CONF2 : 32;
    ///< Clockdist config register 2
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg99_csr_pll_clkdist_conf2_reg_t;

#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_WR_MASK (0xffffffffU)


///< Clockdist config register 2
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_CSR_PLL_CLKDIST_CONF2_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_CSR_PLL_CLKDIST_CONF2_BF_WID (32)
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_CSR_PLL_CLKDIST_CONF2_BF_MSK (0xFFFFFFFF)
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_CSR_PLL_CLKDIST_CONF2_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG100_CSR_ABC_PLL_CLKJESDANA_CONF0 register description at address offset 0x190
  *
  * Register default value:        0x00000000
  * Register full path in IP: pll_local/reg/pllreg100_csr_abc_pll_clkjesdana_conf0
  * AnaRF PLL csr_abc_pll_clkjesdana_conf0
  */

typedef union {
  struct {
    uint32_t CSR_ABC_PLL_CLKJESDANA_CONF0 : 16;
    ///< JESD CLKJESD DIG JESD clock control enables
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CSR_ABC_PLL_CLKJESDANA_CONF1 : 16;
    ///< JESD CLKJESD ANA control and LDO
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg100_csr_pll_clkjesdana_conf0_reg_t;

#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_DEFAULT (0x00000000U)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_WR_MASK (0xffffffffU)


///< JESD CLKJESD DIG JESD clock control enables
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF0_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF0_BF_WID (16)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF0_BF_MSK (0x0000FFFF)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF0_BF_DEF (0x00000000)

///< JESD CLKJESD ANA control and LDO
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF1_BF_OFF (16)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF1_BF_WID (16)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF1_BF_MSK (0xFFFF0000)
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_CSR_PLL_CLKJESDANA_CONF1_BF_DEF (0x00000000)


/** @brief PLL_LOCAL_REG_PLLREG1023_APB_BRIDGE_STATUS register description at address offset 0x194
  *
  * Register default value:        0x00010000
  * Register full path in IP: pll_local/reg/pllreg1023_apb_bridge_status
  * AnaRF PLL apb_bridge_status
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module revision number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgment had error bit set
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pll_local_pllreg1023_apb_brdg_stat_reg_t;

#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module revision number
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgment had error bit set
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define PLL_LOCAL_PLLREG0_CSR_CLKMUX_REG(_BASE) ((pll_local_pllreg0_csr_clkmux_reg_t*) PLL_LOCAL_PLLREG0_CSR_CLKMUX_ADR(_BASE))
#define PLL_LOCAL_PLLREG1_CSR_GENERAL_REG(_BASE) ((pll_local_pllreg1_csr_general_reg_t*) PLL_LOCAL_PLLREG1_CSR_GENERAL_ADR(_BASE))
#define PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_REG(_BASE) ((pll_local_pllreg2_csr_sys_ctrl_reg_t*) PLL_LOCAL_PLLREG2_CSR_SYS_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG3_CSR_FLB_REG(_BASE) ((pll_local_pllreg3_csr_flb_reg_t*) PLL_LOCAL_PLLREG3_CSR_FLB_ADR(_BASE))
#define PLL_LOCAL_PLLREG4_CSR_DCO1_REG(_BASE) ((pll_local_pllreg4_csr_dco1_reg_t*) PLL_LOCAL_PLLREG4_CSR_DCO1_ADR(_BASE))
#define PLL_LOCAL_PLLREG5_CSR_DCO2_REG(_BASE) ((pll_local_pllreg5_csr_dco2_reg_t*) PLL_LOCAL_PLLREG5_CSR_DCO2_ADR(_BASE))
#define PLL_LOCAL_PLLREG6_CSR_LDO1_REG(_BASE) ((pll_local_pllreg6_csr_ldo1_reg_t*) PLL_LOCAL_PLLREG6_CSR_LDO1_ADR(_BASE))
#define PLL_LOCAL_PLLREG7_CSR_LDO2_REG(_BASE) ((pll_local_pllreg7_csr_ldo2_reg_t*) PLL_LOCAL_PLLREG7_CSR_LDO2_ADR(_BASE))
#define PLL_LOCAL_PLLREG8_CSR_TDC_REG(_BASE) ((pll_local_pllreg8_csr_tdc_reg_t*) PLL_LOCAL_PLLREG8_CSR_TDC_ADR(_BASE))
#define PLL_LOCAL_PLLREG9_CSR_START_REG(_BASE) ((pll_local_pllreg9_csr_start_reg_t*) PLL_LOCAL_PLLREG9_CSR_START_ADR(_BASE))
#define PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_REG(_BASE) ((pll_local_pllreg10_csr_ctrl_flows_reg_t*) PLL_LOCAL_PLLREG10_CSR_CTRL_FLOWS_ADR(_BASE))
#define PLL_LOCAL_PLLREG11_CSR_CAL_REG(_BASE) ((pll_local_pllreg11_csr_cal_reg_t*) PLL_LOCAL_PLLREG11_CSR_CAL_ADR(_BASE))
#define PLL_LOCAL_PLLREG12_CSR_OPR1_REG(_BASE) ((pll_local_pllreg12_csr_opr1_reg_t*) PLL_LOCAL_PLLREG12_CSR_OPR1_ADR(_BASE))
#define PLL_LOCAL_PLLREG13_CSR_OPR2_REG(_BASE) ((pll_local_pllreg13_csr_opr2_reg_t*) PLL_LOCAL_PLLREG13_CSR_OPR2_ADR(_BASE))
#define PLL_LOCAL_PLLREG14_CSR_OPR3_REG(_BASE) ((pll_local_pllreg14_csr_opr3_reg_t*) PLL_LOCAL_PLLREG14_CSR_OPR3_ADR(_BASE))
#define PLL_LOCAL_PLLREG15_CSR_STICKY_REG(_BASE) ((pll_local_pllreg15_csr_sticky_reg_t*) PLL_LOCAL_PLLREG15_CSR_STICKY_ADR(_BASE))
#define PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_REG(_BASE) ((pll_local_pllreg16_csr_afs_flow_reg_t*) PLL_LOCAL_PLLREG16_CSR_AFS_FLOW_ADR(_BASE))
#define PLL_LOCAL_PLLREG17_CSR_AFS_REG(_BASE) ((pll_local_pllreg17_csr_afs_reg_t*) PLL_LOCAL_PLLREG17_CSR_AFS_ADR(_BASE))
#define PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_REG(_BASE) ((pll_local_pllreg18_csr_afs_ovrd_reg_t*) PLL_LOCAL_PLLREG18_CSR_AFS_OVRD_ADR(_BASE))
#define PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_REG(_BASE) ((pll_local_pllreg19_csr_afs_overwrite_reg_t*) PLL_LOCAL_PLLREG19_CSR_AFS_OVERWRITE_ADR(_BASE))
#define PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_REG(_BASE) ((pll_local_pllreg20_csr_sem_general_reg_t*) PLL_LOCAL_PLLREG20_CSR_SEM_GENERAL_ADR(_BASE))
#define PLL_LOCAL_PLLREG21_CSR_MEM_REG(_BASE) ((pll_local_pllreg21_csr_mem_reg_t*) PLL_LOCAL_PLLREG21_CSR_MEM_ADR(_BASE))
#define PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_REG(_BASE) ((pll_local_pllreg22_csr_mem_addr_reg_t*) PLL_LOCAL_PLLREG22_CSR_MEM_ADDR_ADR(_BASE))
#define PLL_LOCAL_PLLREG23_CSR_MEM_DATA_REG(_BASE) ((pll_local_pllreg23_csr_mem_data_reg_t*) PLL_LOCAL_PLLREG23_CSR_MEM_DATA_ADR(_BASE))
#define PLL_LOCAL_PLLREG24_CSR_PE_GEAR_REG(_BASE) ((pll_local_pllreg24_csr_pe_gear_reg_t*) PLL_LOCAL_PLLREG24_CSR_PE_GEAR_ADR(_BASE))
#define PLL_LOCAL_PLLREG25_CSR_PE_INIT_REG(_BASE) ((pll_local_pllreg25_csr_pe_init_reg_t*) PLL_LOCAL_PLLREG25_CSR_PE_INIT_ADR(_BASE))
#define PLL_LOCAL_PLLREG26_CSR_DPD_REG(_BASE) ((pll_local_pllreg26_csr_dpd_reg_t*) PLL_LOCAL_PLLREG26_CSR_DPD_ADR(_BASE))
#define PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_REG(_BASE) ((pll_local_pllreg27_csr_dpd_overwrite_reg_t*) PLL_LOCAL_PLLREG27_CSR_DPD_OVERWRITE_ADR(_BASE))
#define PLL_LOCAL_PLLREG28_CSR_LOCKDET_REG(_BASE) ((pll_local_pllreg28_csr_lockdet_reg_t*) PLL_LOCAL_PLLREG28_CSR_LOCKDET_ADR(_BASE))
#define PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_REG(_BASE) ((pll_local_pllreg29_csr_lockdet_ext_lock_reg_t*) PLL_LOCAL_PLLREG29_CSR_LOCKDET_EXT_LOCK_ADR(_BASE))
#define PLL_LOCAL_PLLREG30_CSR_JUMPDET_REG(_BASE) ((pll_local_pllreg30_csr_jumpdet_reg_t*) PLL_LOCAL_PLLREG30_CSR_JUMPDET_ADR(_BASE))
#define PLL_LOCAL_PLLREG31_CSR_DLF_REG(_BASE) ((pll_local_pllreg31_csr_dlf_reg_t*) PLL_LOCAL_PLLREG31_CSR_DLF_ADR(_BASE))
#define PLL_LOCAL_PLLREG32_CSR_DLF2_REG(_BASE) ((pll_local_pllreg32_csr_dlf2_reg_t*) PLL_LOCAL_PLLREG32_CSR_DLF2_ADR(_BASE))
#define PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_REG(_BASE) ((pll_local_pllreg33_csr_dlf_overwrite_reg_t*) PLL_LOCAL_PLLREG33_CSR_DLF_OVERWRITE_ADR(_BASE))
#define PLL_LOCAL_PLLREG34_CSR_MLFPE_REG(_BASE) ((pll_local_pllreg34_csr_mlfpe_reg_t*) PLL_LOCAL_PLLREG34_CSR_MLFPE_ADR(_BASE))
#define PLL_LOCAL_PLLREG35_CSR_RDTC_REG(_BASE) ((pll_local_pllreg35_csr_rdtc_reg_t*) PLL_LOCAL_PLLREG35_CSR_RDTC_ADR(_BASE))
#define PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_REG(_BASE) ((pll_local_pllreg36_csr_rdtc_ovrd_reg_t*) PLL_LOCAL_PLLREG36_CSR_RDTC_OVRD_ADR(_BASE))
#define PLL_LOCAL_PLLREG37_CSR_ASC1_REG(_BASE) ((pll_local_pllreg37_csr_asc1_reg_t*) PLL_LOCAL_PLLREG37_CSR_ASC1_ADR(_BASE))
#define PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_REG(_BASE) ((pll_local_pllreg38_csr_asc1_spur_reg_t*) PLL_LOCAL_PLLREG38_CSR_ASC1_SPUR_ADR(_BASE))
#define PLL_LOCAL_PLLREG39_CSR_ASC2_REG(_BASE) ((pll_local_pllreg39_csr_asc2_reg_t*) PLL_LOCAL_PLLREG39_CSR_ASC2_ADR(_BASE))
#define PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_REG(_BASE) ((pll_local_pllreg40_csr_asc2_spur_reg_t*) PLL_LOCAL_PLLREG40_CSR_ASC2_SPUR_ADR(_BASE))
#define PLL_LOCAL_PLLREG41_CSR_ASC3_REG(_BASE) ((pll_local_pllreg41_csr_asc3_reg_t*) PLL_LOCAL_PLLREG41_CSR_ASC3_ADR(_BASE))
#define PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_REG(_BASE) ((pll_local_pllreg42_csr_asc3_spur_reg_t*) PLL_LOCAL_PLLREG42_CSR_ASC3_SPUR_ADR(_BASE))
#define PLL_LOCAL_PLLREG43_CSR_ANA_CNT_REG(_BASE) ((pll_local_pllreg43_csr_ana_cnt_reg_t*) PLL_LOCAL_PLLREG43_CSR_ANA_CNT_ADR(_BASE))
#define PLL_LOCAL_PLLREG44_CSR_DBGM_REG(_BASE) ((pll_local_pllreg44_csr_dbgm_reg_t*) PLL_LOCAL_PLLREG44_CSR_DBGM_ADR(_BASE))
#define PLL_LOCAL_PLLREG45_CSR_ANALOG_REG(_BASE) ((pll_local_pllreg45_csr_analog_reg_t*) PLL_LOCAL_PLLREG45_CSR_ANALOG_ADR(_BASE))
#define PLL_LOCAL_PLLREG46_CSR_STAT1_REG(_BASE) ((pll_local_pllreg46_csr_stat1_reg_t*) PLL_LOCAL_PLLREG46_CSR_STAT1_ADR(_BASE))
#define PLL_LOCAL_PLLREG47_CSR_STAT2_REG(_BASE) ((pll_local_pllreg47_csr_stat2_reg_t*) PLL_LOCAL_PLLREG47_CSR_STAT2_ADR(_BASE))
#define PLL_LOCAL_PLLREG48_CSR_STAT3_REG(_BASE) ((pll_local_pllreg48_csr_stat3_reg_t*) PLL_LOCAL_PLLREG48_CSR_STAT3_ADR(_BASE))
#define PLL_LOCAL_PLLREG49_CSR_STAT4_REG(_BASE) ((pll_local_pllreg49_csr_stat4_reg_t*) PLL_LOCAL_PLLREG49_CSR_STAT4_ADR(_BASE))
#define PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_REG(_BASE) ((pll_local_pllreg50_csr_start_up_seq_reg_t*) PLL_LOCAL_PLLREG50_CSR_START_UP_SEQ_ADR(_BASE))
#define PLL_LOCAL_PLLREG51_CSR_SEQ_REG(_BASE) ((pll_local_pllreg51_csr_seq_reg_t*) PLL_LOCAL_PLLREG51_CSR_SEQ_ADR(_BASE))
#define PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_REG(_BASE) ((pll_local_pllreg52_csr_seq_on_cfg_reg_t*) PLL_LOCAL_PLLREG52_CSR_SEQ_ON_CFG_ADR(_BASE))
#define PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_REG(_BASE) ((pll_local_pllreg53_csr_seq_off_cfg_reg_t*) PLL_LOCAL_PLLREG53_CSR_SEQ_OFF_CFG_ADR(_BASE))
#define PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_REG(_BASE) ((pll_local_pllreg54_csr_memory_ctrl1_reg_t*) PLL_LOCAL_PLLREG54_CSR_MEMORY_CTRL1_ADR(_BASE))
#define PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_REG(_BASE) ((pll_local_pllreg55_csr_memory_ctrl2_reg_t*) PLL_LOCAL_PLLREG55_CSR_MEMORY_CTRL2_ADR(_BASE))
#define PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_REG(_BASE) ((pll_local_pllreg56_csr_vband_div_bias_reg_t*) PLL_LOCAL_PLLREG56_CSR_VBAND_DIV_BIAS_ADR(_BASE))
#define PLL_LOCAL_PLLREG57_CSR_VBAND_REG(_BASE) ((pll_local_pllreg57_csr_vband_reg_t*) PLL_LOCAL_PLLREG57_CSR_VBAND_ADR(_BASE))
#define PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_REG(_BASE) ((pll_local_pllreg58_csr_tdc_clk_gating_reg_t*) PLL_LOCAL_PLLREG58_CSR_TDC_CLK_GATING_ADR(_BASE))
#define PLL_LOCAL_PLLREG59_CSR_PNC_REG(_BASE) ((pll_local_pllreg59_csr_pnc_reg_t*) PLL_LOCAL_PLLREG59_CSR_PNC_ADR(_BASE))
#define PLL_LOCAL_PLLREG60_CSR_AE_REG(_BASE) ((pll_local_pllreg60_csr_ae_reg_t*) PLL_LOCAL_PLLREG60_CSR_AE_ADR(_BASE))
#define PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_REG(_BASE) ((pll_local_pllreg61_csr_ldo_pdos_reg_t*) PLL_LOCAL_PLLREG61_CSR_LDO_PDOS_ADR(_BASE))
#define PLL_LOCAL_PLLREG62_CSR_BIST_STAT_REG(_BASE) ((pll_local_pllreg62_csr_bist_stat_reg_t*) PLL_LOCAL_PLLREG62_CSR_BIST_STAT_ADR(_BASE))
#define PLL_LOCAL_PLLREG63_CSR_LDO3_REG(_BASE) ((pll_local_pllreg63_csr_ldo3_reg_t*) PLL_LOCAL_PLLREG63_CSR_LDO3_ADR(_BASE))
#define PLL_LOCAL_PLLREG64_CSR_CTRL1_REG(_BASE) ((pll_local_pllreg64_csr_ctrl1_reg_t*) PLL_LOCAL_PLLREG64_CSR_CTRL1_ADR(_BASE))
#define PLL_LOCAL_PLLREG65_CSR_DCOTC1_REG(_BASE) ((pll_local_pllreg65_csr_dcotc1_reg_t*) PLL_LOCAL_PLLREG65_CSR_DCOTC1_ADR(_BASE))
#define PLL_LOCAL_PLLREG66_CSR_DCOTC2_REG(_BASE) ((pll_local_pllreg66_csr_dcotc2_reg_t*) PLL_LOCAL_PLLREG66_CSR_DCOTC2_ADR(_BASE))
#define PLL_LOCAL_PLLREG67_CSR_DCOTC3_REG(_BASE) ((pll_local_pllreg67_csr_dcotc3_reg_t*) PLL_LOCAL_PLLREG67_CSR_DCOTC3_ADR(_BASE))
#define PLL_LOCAL_PLLREG68_CSR_DCOTC4_REG(_BASE) ((pll_local_pllreg68_csr_dcotc4_reg_t*) PLL_LOCAL_PLLREG68_CSR_DCOTC4_ADR(_BASE))
#define PLL_LOCAL_PLLREG69_CSR_PHLOCK1_REG(_BASE) ((pll_local_pllreg69_csr_phlock1_reg_t*) PLL_LOCAL_PLLREG69_CSR_PHLOCK1_ADR(_BASE))
#define PLL_LOCAL_PLLREG70_CSR_PHLOCK2_REG(_BASE) ((pll_local_pllreg70_csr_phlock2_reg_t*) PLL_LOCAL_PLLREG70_CSR_PHLOCK2_ADR(_BASE))
#define PLL_LOCAL_PLLREG71_CSR_PHLOCK3_REG(_BASE) ((pll_local_pllreg71_csr_phlock3_reg_t*) PLL_LOCAL_PLLREG71_CSR_PHLOCK3_ADR(_BASE))
#define PLL_LOCAL_PLLREG72_CSR_PHLOCK4_REG(_BASE) ((pll_local_pllreg72_csr_phlock4_reg_t*) PLL_LOCAL_PLLREG72_CSR_PHLOCK4_ADR(_BASE))
#define PLL_LOCAL_PLLREG73_CSR_PHLOCK5_REG(_BASE) ((pll_local_pllreg73_csr_phlock5_reg_t*) PLL_LOCAL_PLLREG73_CSR_PHLOCK5_ADR(_BASE))
#define PLL_LOCAL_PLLREG74_CSR_PHLOCK6_REG(_BASE) ((pll_local_pllreg74_csr_phlock6_reg_t*) PLL_LOCAL_PLLREG74_CSR_PHLOCK6_ADR(_BASE))
#define PLL_LOCAL_PLLREG75_CSR_STAT1_REG(_BASE) ((pll_local_pllreg75_csr_stat1_reg_t*) PLL_LOCAL_PLLREG75_CSR_STAT1_ADR(_BASE))
#define PLL_LOCAL_PLLREG76_CSR_STAT2_REG(_BASE) ((pll_local_pllreg76_csr_stat2_reg_t*) PLL_LOCAL_PLLREG76_CSR_STAT2_ADR(_BASE))
#define PLL_LOCAL_PLLREG77_CSR_STAT3_REG(_BASE) ((pll_local_pllreg77_csr_stat3_reg_t*) PLL_LOCAL_PLLREG77_CSR_STAT3_ADR(_BASE))
#define PLL_LOCAL_PLLREG78_CSR_FLB1_REG(_BASE) ((pll_local_pllreg78_csr_flb1_reg_t*) PLL_LOCAL_PLLREG78_CSR_FLB1_ADR(_BASE))
#define PLL_LOCAL_PLLREG79_CSR_FLB2_REG(_BASE) ((pll_local_pllreg79_csr_flb2_reg_t*) PLL_LOCAL_PLLREG79_CSR_FLB2_ADR(_BASE))
#define PLL_LOCAL_PLLREG80_CSR_DLFX1_REG(_BASE) ((pll_local_pllreg80_csr_dlfx1_reg_t*) PLL_LOCAL_PLLREG80_CSR_DLFX1_ADR(_BASE))
#define PLL_LOCAL_PLLREG81_CSR_STAT4_REG(_BASE) ((pll_local_pllreg81_csr_stat4_reg_t*) PLL_LOCAL_PLLREG81_CSR_STAT4_ADR(_BASE))
#define PLL_LOCAL_PLLREG82_CSR_STAT5_REG(_BASE) ((pll_local_pllreg82_csr_stat5_reg_t*) PLL_LOCAL_PLLREG82_CSR_STAT5_ADR(_BASE))
#define PLL_LOCAL_PLLREG83_CSR_STAT6_REG(_BASE) ((pll_local_pllreg83_csr_stat6_reg_t*) PLL_LOCAL_PLLREG83_CSR_STAT6_ADR(_BASE))
#define PLL_LOCAL_PLLREG84_CSR_STAT7_REG(_BASE) ((pll_local_pllreg84_csr_stat7_reg_t*) PLL_LOCAL_PLLREG84_CSR_STAT7_ADR(_BASE))
#define PLL_LOCAL_PLLREG85_CSR_STAT8_REG(_BASE) ((pll_local_pllreg85_csr_stat8_reg_t*) PLL_LOCAL_PLLREG85_CSR_STAT8_ADR(_BASE))
#define PLL_LOCAL_PLLREG86_CSR_STAT9_REG(_BASE) ((pll_local_pllreg86_csr_stat9_reg_t*) PLL_LOCAL_PLLREG86_CSR_STAT9_ADR(_BASE))
#define PLL_LOCAL_PLLREG87_CSR_STAT10_REG(_BASE) ((pll_local_pllreg87_csr_stat10_reg_t*) PLL_LOCAL_PLLREG87_CSR_STAT10_ADR(_BASE))
#define PLL_LOCAL_PLLREG88_CSR_SFTDC_REG(_BASE) ((pll_local_pllreg88_csr_sftdc_reg_t*) PLL_LOCAL_PLLREG88_CSR_SFTDC_ADR(_BASE))
#define PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_REG(_BASE) ((pll_local_pllreg89_csr_dcg_ctrl_reg_t*) PLL_LOCAL_PLLREG89_CSR_DCG_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_REG(_BASE) ((pll_local_pllreg90_csr_dco_ldo1_ctrl_reg_t*) PLL_LOCAL_PLLREG90_CSR_DCO_LDO1_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_REG(_BASE) ((pll_local_pllreg91_csr_dco_ldo2_ctrl_reg_t*) PLL_LOCAL_PLLREG91_CSR_DCO_LDO2_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_REG(_BASE) ((pll_local_pllreg92_csr_tdc_ldo1_ctrl_reg_t*) PLL_LOCAL_PLLREG92_CSR_TDC_LDO1_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_REG(_BASE) ((pll_local_pllreg93_csr_tdc_ldo2_ctrl_reg_t*) PLL_LOCAL_PLLREG93_CSR_TDC_LDO2_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_REG(_BASE) ((pll_local_pllreg94_csr_dpll_dig_ldo_ctrl_reg_t*) PLL_LOCAL_PLLREG94_CSR_DPLL_DIG_LDO_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_REG(_BASE) ((pll_local_pllreg95_csr_bias_vref_ctrl_reg_t*) PLL_LOCAL_PLLREG95_CSR_BIAS_VREF_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_REG(_BASE) ((pll_local_pllreg96_csr_lopa_clkref_ctrl_reg_t*) PLL_LOCAL_PLLREG96_CSR_LOPA_CLKREF_CTRL_ADR(_BASE))
#define PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_REG(_BASE) ((pll_local_pllreg97_csr_pll_clkdist_conf0_reg_t*) PLL_LOCAL_PLLREG97_CSR_PLL_CLKDIST_CONF0_ADR(_BASE))
#define PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_REG(_BASE) ((pll_local_pllreg98_csr_pll_clkdist_conf1_reg_t*) PLL_LOCAL_PLLREG98_CSR_PLL_CLKDIST_CONF1_ADR(_BASE))
#define PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_REG(_BASE) ((pll_local_pllreg99_csr_pll_clkdist_conf2_reg_t*) PLL_LOCAL_PLLREG99_CSR_PLL_CLKDIST_CONF2_ADR(_BASE))
#define PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_REG(_BASE) ((pll_local_pllreg100_csr_pll_clkjesdana_conf0_reg_t*) PLL_LOCAL_PLLREG100_CSR_PLL_CLKJESDANA_CONF0_ADR(_BASE))
#define PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_REG(_BASE) ((pll_local_pllreg1023_apb_brdg_stat_reg_t*) PLL_LOCAL_PLLREG1023_APB_BRDG_STAT_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    pll_local_pllreg0_csr_clkmux_reg_t PLLREG0_CSR_CLKMUX; /*< Address offset = 0x0 */
    pll_local_pllreg1_csr_general_reg_t PLLREG1_CSR_GENERAL; /*< Address offset = 0x4 */
    pll_local_pllreg2_csr_sys_ctrl_reg_t PLLREG2_CSR_SYS_CTRL; /*< Address offset = 0x8 */
    pll_local_pllreg3_csr_flb_reg_t PLLREG3_CSR_FLB; /*< Address offset = 0xc */
    pll_local_pllreg4_csr_dco1_reg_t PLLREG4_CSR_DCO1; /*< Address offset = 0x10 */
    pll_local_pllreg5_csr_dco2_reg_t PLLREG5_CSR_DCO2; /*< Address offset = 0x14 */
    pll_local_pllreg6_csr_ldo1_reg_t PLLREG6_CSR_LDO1; /*< Address offset = 0x18 */
    pll_local_pllreg7_csr_ldo2_reg_t PLLREG7_CSR_LDO2; /*< Address offset = 0x1c */
    pll_local_pllreg8_csr_tdc_reg_t PLLREG8_CSR_TDC; /*< Address offset = 0x20 */
    pll_local_pllreg9_csr_start_reg_t PLLREG9_CSR_START; /*< Address offset = 0x24 */
    pll_local_pllreg10_csr_ctrl_flows_reg_t PLLREG10_CSR_CTRL_FLOWS; /*< Address offset = 0x28 */
    pll_local_pllreg11_csr_cal_reg_t PLLREG11_CSR_CAL; /*< Address offset = 0x2c */
    pll_local_pllreg12_csr_opr1_reg_t PLLREG12_CSR_OPR1; /*< Address offset = 0x30 */
    pll_local_pllreg13_csr_opr2_reg_t PLLREG13_CSR_OPR2; /*< Address offset = 0x34 */
    pll_local_pllreg14_csr_opr3_reg_t PLLREG14_CSR_OPR3; /*< Address offset = 0x38 */
    pll_local_pllreg15_csr_sticky_reg_t PLLREG15_CSR_STICKY; /*< Address offset = 0x3c */
    pll_local_pllreg16_csr_afs_flow_reg_t PLLREG16_CSR_AFS_FLOW; /*< Address offset = 0x40 */
    pll_local_pllreg17_csr_afs_reg_t PLLREG17_CSR_AFS; /*< Address offset = 0x44 */
    pll_local_pllreg18_csr_afs_ovrd_reg_t PLLREG18_CSR_AFS_OVRD; /*< Address offset = 0x48 */
    pll_local_pllreg19_csr_afs_overwrite_reg_t PLLREG19_CSR_AFS_OVERWRITE; /*< Address offset = 0x4c */
    pll_local_pllreg20_csr_sem_general_reg_t PLLREG20_CSR_SEM_GENERAL; /*< Address offset = 0x50 */
    pll_local_pllreg21_csr_mem_reg_t PLLREG21_CSR_MEM; /*< Address offset = 0x54 */
    pll_local_pllreg22_csr_mem_addr_reg_t PLLREG22_CSR_MEM_ADDR; /*< Address offset = 0x58 */
    pll_local_pllreg23_csr_mem_data_reg_t PLLREG23_CSR_MEM_DATA; /*< Address offset = 0x5c */
    pll_local_pllreg24_csr_pe_gear_reg_t PLLREG24_CSR_PE_GEAR; /*< Address offset = 0x60 */
    pll_local_pllreg25_csr_pe_init_reg_t PLLREG25_CSR_PE_INIT; /*< Address offset = 0x64 */
    pll_local_pllreg26_csr_dpd_reg_t PLLREG26_CSR_DPD; /*< Address offset = 0x68 */
    pll_local_pllreg27_csr_dpd_overwrite_reg_t PLLREG27_CSR_DPD_OVERWRITE; /*< Address offset = 0x6c */
    pll_local_pllreg28_csr_lockdet_reg_t PLLREG28_CSR_LOCKDET; /*< Address offset = 0x70 */
    pll_local_pllreg29_csr_lockdet_ext_lock_reg_t PLLREG29_CSR_LOCKDET_EXT_LOCK; /*< Address offset = 0x74 */
    pll_local_pllreg30_csr_jumpdet_reg_t PLLREG30_CSR_JUMPDET; /*< Address offset = 0x78 */
    pll_local_pllreg31_csr_dlf_reg_t PLLREG31_CSR_DLF; /*< Address offset = 0x7c */
    pll_local_pllreg32_csr_dlf2_reg_t PLLREG32_CSR_DLF2; /*< Address offset = 0x80 */
    pll_local_pllreg33_csr_dlf_overwrite_reg_t PLLREG33_CSR_DLF_OVERWRITE; /*< Address offset = 0x84 */
    pll_local_pllreg34_csr_mlfpe_reg_t PLLREG34_CSR_MLFPE; /*< Address offset = 0x88 */
    pll_local_pllreg35_csr_rdtc_reg_t PLLREG35_CSR_RDTC; /*< Address offset = 0x8c */
    pll_local_pllreg36_csr_rdtc_ovrd_reg_t PLLREG36_CSR_RDTC_OVRD; /*< Address offset = 0x90 */
    pll_local_pllreg37_csr_asc1_reg_t PLLREG37_CSR_ASC1; /*< Address offset = 0x94 */
    pll_local_pllreg38_csr_asc1_spur_reg_t PLLREG38_CSR_ASC1_SPUR; /*< Address offset = 0x98 */
    pll_local_pllreg39_csr_asc2_reg_t PLLREG39_CSR_ASC2; /*< Address offset = 0x9c */
    pll_local_pllreg40_csr_asc2_spur_reg_t PLLREG40_CSR_ASC2_SPUR; /*< Address offset = 0xa0 */
    pll_local_pllreg41_csr_asc3_reg_t PLLREG41_CSR_ASC3; /*< Address offset = 0xa4 */
    pll_local_pllreg42_csr_asc3_spur_reg_t PLLREG42_CSR_ASC3_SPUR; /*< Address offset = 0xa8 */
    pll_local_pllreg43_csr_ana_cnt_reg_t PLLREG43_CSR_ANA_CNT; /*< Address offset = 0xac */
    pll_local_pllreg44_csr_dbgm_reg_t PLLREG44_CSR_DBGM; /*< Address offset = 0xb0 */
    pll_local_pllreg45_csr_analog_reg_t PLLREG45_CSR_ANALOG; /*< Address offset = 0xb4 */
    pll_local_pllreg46_csr_stat1_reg_t PLLREG46_CSR_STAT1; /*< Address offset = 0xb8 */
    pll_local_pllreg47_csr_stat2_reg_t PLLREG47_CSR_STAT2; /*< Address offset = 0xbc */
    pll_local_pllreg48_csr_stat3_reg_t PLLREG48_CSR_STAT3; /*< Address offset = 0xc0 */
    pll_local_pllreg49_csr_stat4_reg_t PLLREG49_CSR_STAT4; /*< Address offset = 0xc4 */
    pll_local_pllreg50_csr_start_up_seq_reg_t PLLREG50_CSR_START_UP_SEQ; /*< Address offset = 0xc8 */
    pll_local_pllreg51_csr_seq_reg_t PLLREG51_CSR_SEQ; /*< Address offset = 0xcc */
    pll_local_pllreg52_csr_seq_on_cfg_reg_t PLLREG52_CSR_SEQ_ON_CFG; /*< Address offset = 0xd0 */
    pll_local_pllreg53_csr_seq_off_cfg_reg_t PLLREG53_CSR_SEQ_OFF_CFG; /*< Address offset = 0xd4 */
    pll_local_pllreg54_csr_memory_ctrl1_reg_t PLLREG54_CSR_MEMORY_CTRL1; /*< Address offset = 0xd8 */
    pll_local_pllreg55_csr_memory_ctrl2_reg_t PLLREG55_CSR_MEMORY_CTRL2; /*< Address offset = 0xdc */
    pll_local_pllreg56_csr_vband_div_bias_reg_t PLLREG56_CSR_VBAND_DIV_BIAS; /*< Address offset = 0xe0 */
    pll_local_pllreg57_csr_vband_reg_t PLLREG57_CSR_VBAND; /*< Address offset = 0xe4 */
    pll_local_pllreg58_csr_tdc_clk_gating_reg_t PLLREG58_CSR_TDC_CLK_GATING; /*< Address offset = 0xe8 */
    pll_local_pllreg59_csr_pnc_reg_t PLLREG59_CSR_PNC; /*< Address offset = 0xec */
    pll_local_pllreg60_csr_ae_reg_t PLLREG60_CSR_AE; /*< Address offset = 0xf0 */
    pll_local_pllreg61_csr_ldo_pdos_reg_t PLLREG61_CSR_LDO_PDOS; /*< Address offset = 0xf4 */
    pll_local_pllreg62_csr_bist_stat_reg_t PLLREG62_CSR_BIST_STAT; /*< Address offset = 0xf8 */
    pll_local_pllreg63_csr_ldo3_reg_t PLLREG63_CSR_LDO3; /*< Address offset = 0xfc */
    pll_local_pllreg64_csr_ctrl1_reg_t PLLREG64_CSR_CTRL1; /*< Address offset = 0x100 */
    pll_local_pllreg65_csr_dcotc1_reg_t PLLREG65_CSR_DCOTC1; /*< Address offset = 0x104 */
    pll_local_pllreg66_csr_dcotc2_reg_t PLLREG66_CSR_DCOTC2; /*< Address offset = 0x108 */
    pll_local_pllreg67_csr_dcotc3_reg_t PLLREG67_CSR_DCOTC3; /*< Address offset = 0x10c */
    pll_local_pllreg68_csr_dcotc4_reg_t PLLREG68_CSR_DCOTC4; /*< Address offset = 0x110 */
    pll_local_pllreg69_csr_phlock1_reg_t PLLREG69_CSR_PHLOCK1; /*< Address offset = 0x114 */
    pll_local_pllreg70_csr_phlock2_reg_t PLLREG70_CSR_PHLOCK2; /*< Address offset = 0x118 */
    pll_local_pllreg71_csr_phlock3_reg_t PLLREG71_CSR_PHLOCK3; /*< Address offset = 0x11c */
    pll_local_pllreg72_csr_phlock4_reg_t PLLREG72_CSR_PHLOCK4; /*< Address offset = 0x120 */
    pll_local_pllreg73_csr_phlock5_reg_t PLLREG73_CSR_PHLOCK5; /*< Address offset = 0x124 */
    pll_local_pllreg74_csr_phlock6_reg_t PLLREG74_CSR_PHLOCK6; /*< Address offset = 0x128 */
    pll_local_pllreg75_csr_stat1_reg_t PLLREG75_CSR_STAT1; /*< Address offset = 0x12c */
    pll_local_pllreg76_csr_stat2_reg_t PLLREG76_CSR_STAT2; /*< Address offset = 0x130 */
    pll_local_pllreg77_csr_stat3_reg_t PLLREG77_CSR_STAT3; /*< Address offset = 0x134 */
    pll_local_pllreg78_csr_flb1_reg_t PLLREG78_CSR_FLB1; /*< Address offset = 0x138 */
    pll_local_pllreg79_csr_flb2_reg_t PLLREG79_CSR_FLB2; /*< Address offset = 0x13c */
    pll_local_pllreg80_csr_dlfx1_reg_t PLLREG80_CSR_DLFX1; /*< Address offset = 0x140 */
    pll_local_pllreg81_csr_stat4_reg_t PLLREG81_CSR_STAT4; /*< Address offset = 0x144 */
    pll_local_pllreg82_csr_stat5_reg_t PLLREG82_CSR_STAT5; /*< Address offset = 0x148 */
    pll_local_pllreg83_csr_stat6_reg_t PLLREG83_CSR_STAT6; /*< Address offset = 0x14c */
    pll_local_pllreg84_csr_stat7_reg_t PLLREG84_CSR_STAT7; /*< Address offset = 0x150 */
    pll_local_pllreg85_csr_stat8_reg_t PLLREG85_CSR_STAT8; /*< Address offset = 0x154 */
    pll_local_pllreg86_csr_stat9_reg_t PLLREG86_CSR_STAT9; /*< Address offset = 0x158 */
    pll_local_pllreg87_csr_stat10_reg_t PLLREG87_CSR_STAT10; /*< Address offset = 0x15c */
    pll_local_pllreg88_csr_sftdc_reg_t PLLREG88_CSR_SFTDC; /*< Address offset = 0x160 */
    pll_local_pllreg89_csr_dcg_ctrl_reg_t PLLREG89_CSR_DCG_CTRL; /*< Address offset = 0x164 */
    pll_local_pllreg90_csr_dco_ldo1_ctrl_reg_t PLLREG90_CSR_DCO_LDO1_CTRL; /*< Address offset = 0x168 */
    pll_local_pllreg91_csr_dco_ldo2_ctrl_reg_t PLLREG91_CSR_DCO_LDO2_CTRL; /*< Address offset = 0x16c */
    pll_local_pllreg92_csr_tdc_ldo1_ctrl_reg_t PLLREG92_CSR_TDC_LDO1_CTRL; /*< Address offset = 0x170 */
    pll_local_pllreg93_csr_tdc_ldo2_ctrl_reg_t PLLREG93_CSR_TDC_LDO2_CTRL; /*< Address offset = 0x174 */
    pll_local_pllreg94_csr_dpll_dig_ldo_ctrl_reg_t PLLREG94_CSR_DPLL_DIG_LDO_CTRL; /*< Address offset = 0x178 */
    pll_local_pllreg95_csr_bias_vref_ctrl_reg_t PLLREG95_CSR_BIAS_VREF_CTRL; /*< Address offset = 0x17c */
    pll_local_pllreg96_csr_lopa_clkref_ctrl_reg_t PLLREG96_CSR_LOPA_CLKREF_CTRL; /*< Address offset = 0x180 */
    pll_local_pllreg97_csr_pll_clkdist_conf0_reg_t PLLREG97_CSR_PLL_CLKDIST_CONF0; /*< Address offset = 0x184 */
    pll_local_pllreg98_csr_pll_clkdist_conf1_reg_t PLLREG98_CSR_PLL_CLKDIST_CONF1; /*< Address offset = 0x188 */
    pll_local_pllreg99_csr_pll_clkdist_conf2_reg_t PLLREG99_CSR_PLL_CLKDIST_CONF2; /*< Address offset = 0x18c */
    pll_local_pllreg100_csr_pll_clkjesdana_conf0_reg_t PLLREG100_CSR_PLL_CLKJESDANA_CONF0; /*< Address offset = 0x190 */
    pll_local_pllreg1023_apb_brdg_stat_reg_t PLLREG1023_APB_BRDG_STAT; /*< Address offset = 0x194 */
} pll_local_t;     // size: 0x0198

// AddressSpace struct pointer
//
#define MEM_CAP0_ANALOG_PLL  ((pll_local_t*) MEM_CAP0_ANALOG_PLL_BASE)
#define MEM_CAP1_ANALOG_PLL  ((pll_local_t*) MEM_CAP1_ANALOG_PLL_BASE)

// ******************************************* /Address Space

#endif      // _PLL_LOCAL_H_

