#ifndef _PMA_ANACMNPLL_MSG_H_
#define _PMA_ANACMNPLL_MSG_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define DLNK_JESD0_PHY_PMA0_ANACMNPLLA_BASE  ( 0x06021800 )
#define DLNK_JESD0_PHY_PMA0_ANACMNPLLB_BASE  ( 0x06022800 )
#define DLNK_JESD1_PHY_PMA0_ANACMNPLLA_BASE  ( 0x06821800 )
#define DLNK_JESD1_PHY_PMA0_ANACMNPLLB_BASE  ( 0x06822800 )
#define DLNK_JESD2_PHY_PMA0_ANACMNPLLA_BASE  ( 0x07021800 )
#define DLNK_JESD2_PHY_PMA0_ANACMNPLLB_BASE  ( 0x07022800 )
#define DLNK_JESD3_PHY_PMA0_ANACMNPLLA_BASE  ( 0x07821800 )
#define DLNK_JESD3_PHY_PMA0_ANACMNPLLB_BASE  ( 0x07822800 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define PMA_ANACMNPLL_MSG_DIV0_OFFSET ( 0x00000000U )
#define PMA_ANACMNPLL_MSG_DIV1_OFFSET ( 0x00000004U )
#define PMA_ANACMNPLL_MSG_ADL0_OFFSET ( 0x00000008U )
#define PMA_ANACMNPLL_MSG_ADL1_OFFSET ( 0x0000000cU )
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_OFFSET ( 0x00000010U )
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_OFFSET ( 0x00000014U )
#define PMA_ANACMNPLL_MSG_TDC0_OFFSET ( 0x00000018U )
#define PMA_ANACMNPLL_MSG_TDC1_OFFSET ( 0x0000001cU )
#define PMA_ANACMNPLL_MSG_TDC2_OFFSET ( 0x00000020U )
#define PMA_ANACMNPLL_MSG_TDC3_OFFSET ( 0x00000024U )
#define PMA_ANACMNPLL_MSG_TAP_OVRD_OFFSET ( 0x00000028U )
#define PMA_ANACMNPLL_MSG_DFX_DCO_OFFSET ( 0x0000002cU )
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_OFFSET ( 0x00000030U )
#define PMA_ANACMNPLL_MSG_VISA_CTRL_OFFSET ( 0x00000034U )
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_OFFSET ( 0x00000038U )
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_OFFSET ( 0x0000003cU )
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_OFFSET ( 0x00000040U )
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_OFFSET ( 0x00000044U )
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_OFFSET ( 0x00000048U )
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_OFFSET ( 0x0000004cU )
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_OFFSET ( 0x00000050U )
#define PMA_ANACMNPLL_MSG_CALIB0_OFFSET ( 0x00000054U )
#define PMA_ANACMNPLL_MSG_CALIB1_OFFSET ( 0x00000058U )
#define PMA_ANACMNPLL_MSG_CALIB2_OFFSET ( 0x0000005cU )
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_OFFSET ( 0x00000060U )
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_OFFSET ( 0x00000064U )
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_OFFSET ( 0x00000068U )
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_OFFSET ( 0x0000006cU )
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_OFFSET ( 0x00000070U )
#define PMA_ANACMNPLL_MSG_DFX0_OFFSET ( 0x00000074U )
#define PMA_ANACMNPLL_MSG_DFX1_OFFSET ( 0x00000078U )
#define PMA_ANACMNPLL_MSG_LDO0_OFFSET ( 0x0000007cU )
#define PMA_ANACMNPLL_MSG_LDO1_OFFSET ( 0x00000080U )
#define PMA_ANACMNPLL_MSG_KVCC0_OFFSET ( 0x00000084U )
#define PMA_ANACMNPLL_MSG_KVCC1_OFFSET ( 0x00000088U )
#define PMA_ANACMNPLL_MSG_KVCC2_OFFSET ( 0x0000008cU )
#define PMA_ANACMNPLL_MSG_SPARE0_OFFSET ( 0x00000090U )
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_OFFSET ( 0x00000094U )
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_OFFSET ( 0x00000098U )
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_OFFSET ( 0x0000009cU )
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_OFFSET ( 0x000000a0U )
#define PMA_ANACMNPLL_MSG_RO_TDC_OFFSET ( 0x000000a4U )
#define PMA_ANACMNPLL_MSG_STAT_OFFSET ( 0x000000a8U )
#define PMA_ANACMNPLL_MSG_STAT1_OFFSET ( 0x000000acU )
#define PMA_ANACMNPLL_MSG_STAT2_OFFSET ( 0x000000b0U )
#define PMA_ANACMNPLL_MSG_STAT3_OFFSET ( 0x000000b4U )
#define PMA_ANACMNPLL_MSG_SPARE1_OFFSET ( 0x000000b8U )
#define PMA_ANACMNPLL_MSG_SPARE_STAT_OFFSET ( 0x000000bcU )
#define PMA_ANACMNPLL_MSG_DCO_SWING0_OFFSET ( 0x000000c0U )
#define PMA_ANACMNPLL_MSG_DCO_SWING1_OFFSET ( 0x000000c4U )
#define PMA_ANACMNPLL_MSG_TDC4_OFFSET ( 0x000000c8U )
#define PMA_ANACMNPLL_MSG_STAT4_OFFSET ( 0x000000ccU )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define PMA_ANACMNPLL_MSG_DIV0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DIV0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_DIV1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DIV1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_ADL0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_ADL0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_ADL1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_ADL1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_FRAC_LOCK0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_FRAC_LOCK1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_TDC0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_TDC0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_TDC1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_TDC1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_TDC2_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_TDC2_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_TDC3_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_TDC3_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_TAP_OVRD_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_TAP_OVRD_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_DFX_DCO_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DFX_DCO_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DFX_TDC_CRO_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_VISA_CTRL_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_VISA_CTRL_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_TDC_DCO0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_TDC_DCO1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_TDC_DCO2_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_TDC_DCO3_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_CALIB0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_CALIB0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_CALIB1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_CALIB1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_CALIB2_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_CALIB2_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_TEMP_TRACKING_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_ANA_CTRL1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_ANA_CTRL2_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_ANA_CTRL3_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_DFX0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DFX0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_DFX1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DFX1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_LDO0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_LDO0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_LDO1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_LDO1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_KVCC0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_KVCC0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_KVCC1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_KVCC1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_KVCC2_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_KVCC2_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_SPARE0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_SPARE0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_DIV_BIAS_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_BWM_LF_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_DCO_CALIB_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_RO_TDC_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_RO_TDC_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_STAT_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_STAT_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_STAT1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_STAT1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_STAT2_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_STAT2_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_STAT3_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_STAT3_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_SPARE1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_SPARE1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_SPARE_STAT_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_SPARE_STAT_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_DCO_SWING0_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DCO_SWING0_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_DCO_SWING1_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_DCO_SWING1_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_TDC4_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_TDC4_OFFSET ) ))
#define PMA_ANACMNPLL_MSG_STAT4_ADR(_BASE) (( ( _BASE ) + ( PMA_ANACMNPLL_MSG_STAT4_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DIV0 register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_div0
  * LCPLL_DIV0 Register
  */

typedef union {
  struct {
    uint32_t O_FBDIV_FRAC : 32;
    ///< Feedback divider fractional ratio.                          Total
    ///< ratio is:                         If cfg_dcodiv2_to_fbdiv_bypass=1
    ///< : (integer+fractional/2^32)                         otherwise : (integer+fractional/2^32)
    ///< x 2
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_div0_reg_t;

#define PMA_ANACMNPLL_MSG_DIV0_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_DIV0_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_DIV0_WR_MASK (0xffffffffU)


///< Feedback divider fractional ratio.                          Total
///< ratio is:                         If cfg_dcodiv2_to_fbdiv_bypass=1
///< : (integer+fractional/2^32)                         otherwise : (integer+fractional/2^32)
///< x 2
#define PMA_ANACMNPLL_MSG_DIV0_O_FBDIV_FRAC_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DIV0_O_FBDIV_FRAC_BF_WID (32)
#define PMA_ANACMNPLL_MSG_DIV0_O_FBDIV_FRAC_BF_MSK (0xFFFFFFFF)
#define PMA_ANACMNPLL_MSG_DIV0_O_FBDIV_FRAC_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DIV1 register description at address offset 0x4
  *
  * Register default value:        0x00003050
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_div1
  * LCPLL_DIV1 Register
  */

typedef union {
  struct {
    uint32_t O_FBDIV_INTGR : 10;
    ///< Feedback divider integer ratio                         Total ratio
    ///< is:                         If cfg_dcodiv2_to_fbdiv_bypass=1 : (integer+fractional/2^32)
    ///< otherwise : (integer+fractional/2^32) x 2
    ///< Default is 80 for main common PLL (refclk 156.25MHz and Fdco 12.5GHz)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x50"
    uint32_t O_FRACNEN_H : 1;
    ///< Enables fractional ratio.                         Set this bit to
    ///< 0 if fractional ratio is 0, else to 1.                         If
    ///< this bit is 1 while fractional is 0 then fbclk to refclk phase won't
    ///< be deterministic.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CFG_REFCLK_CNT_LIMIT : 3;
    ///< Defines number of refclk cycles in frequency measurement during AFC
    ///< calibration.                         Number of cycles = 2^reg
    ///< For 156MHz clock and 12.5GHz DCO clock, HS counter (@Fdco/2) samples
    ///< 40 cycles per refclk (=fbdiv_intgr).                         DTR step
    ///< size is 20MHz, so to achieve accuracy of 5MHz, HS counter should reach
    ///< 12.5G/5M=2500.                         Therefore refclk cycles = 2500/40=62.5,
    ///< so 2^6 would be appropriate.
    ///< use the following formula for other frequencies (Frefclk after prediv):
    ///< cfg_refclk_cnt_limit = round(log2(2*Frefclk/5MHz))
    ///< AccessType="RW" BitOffset="11" ResetValue="0x6"
    uint32_t CFG_FRACN_SD_STEP_EN : 1;
    ///< Injects an impulse into fracN SD accumulator.
    ///< This inject a step in the feed-forward offset and as a result would
    ///< create a step on the PLL phase.                         This feature
    ///< can be useful in case of coupling between PLLs that run at exact same
    ///< frequency (both at fracN)
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CFG_FRACN_SD_STEP : 6;
    ///< Sets magnitude of step in fracN SD accumulator, which is added to
    ///< the MSB of the SD bus.                         Each LSB here would
    ///< shift PLL phase by 2xTdco/2^6
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t CFG_LF_BAND_INUSE : 1;
    ///< SERDES_LANE_ANA_PLL::DIV1::cfg_lf_band_inuse
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t CFG_LF_BAND_SEL : 1;
    ///< SERDES_LANE_ANA_PLL::DIV1::cfg_lf_band_sel
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t  : 9;
    ///< Reserved
    ///< AccessType="RO" BitOffset="23" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_div1_reg_t;

#define PMA_ANACMNPLL_MSG_DIV1_DEFAULT (0x00003050U)
#define PMA_ANACMNPLL_MSG_DIV1_RD_MASK (0x007fffffU)
#define PMA_ANACMNPLL_MSG_DIV1_WR_MASK (0x007fffffU)


///< Feedback divider integer ratio                         Total ratio
///< is:                         If cfg_dcodiv2_to_fbdiv_bypass=1 : (integer+fractional/2^32)
///< otherwise : (integer+fractional/2^32) x 2
///< Default is 80 for main common PLL (refclk 156.25MHz and Fdco 12.5GHz)
#define PMA_ANACMNPLL_MSG_DIV1_O_FBDIV_INTGR_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DIV1_O_FBDIV_INTGR_BF_WID (10)
#define PMA_ANACMNPLL_MSG_DIV1_O_FBDIV_INTGR_BF_MSK (0x000003FF)
#define PMA_ANACMNPLL_MSG_DIV1_O_FBDIV_INTGR_BF_DEF (0x00000050)

///< Enables fractional ratio.                         Set this bit to
///< 0 if fractional ratio is 0, else to 1.                         If
///< this bit is 1 while fractional is 0 then fbclk to refclk phase won't
///< be deterministic.
#define PMA_ANACMNPLL_MSG_DIV1_O_FRACNEN_H_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_DIV1_O_FRACNEN_H_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DIV1_O_FRACNEN_H_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_DIV1_O_FRACNEN_H_BF_DEF (0x00000000)

///< Defines number of refclk cycles in frequency measurement during AFC
///< calibration.                         Number of cycles = 2^reg
///< For 156MHz clock and 12.5GHz DCO clock, HS counter (@Fdco/2) samples
///< 40 cycles per refclk (=fbdiv_intgr).                         DTR step
///< size is 20MHz, so to achieve accuracy of 5MHz, HS counter should reach
///< 12.5G/5M=2500.                         Therefore refclk cycles = 2500/40=62.5,
///< so 2^6 would be appropriate.
///< use the following formula for other frequencies (Frefclk after prediv):
///< cfg_refclk_cnt_limit = round(log2(2*Frefclk/5MHz))
#define PMA_ANACMNPLL_MSG_DIV1_CFG_REFCLK_CNT_LIMIT_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_REFCLK_CNT_LIMIT_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_REFCLK_CNT_LIMIT_BF_MSK (0x00003800)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_REFCLK_CNT_LIMIT_BF_DEF (0x00003000)

///< Injects an impulse into fracN SD accumulator.
///< This inject a step in the feed-forward offset and as a result would
///< create a step on the PLL phase.                         This feature
///< can be useful in case of coupling between PLLs that run at exact same
///< frequency (both at fracN)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_EN_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_EN_BF_MSK (0x00004000)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_EN_BF_DEF (0x00000000)

///< Sets magnitude of step in fracN SD accumulator, which is added to
///< the MSB of the SD bus.                         Each LSB here would
///< shift PLL phase by 2xTdco/2^6
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_BF_OFF (15)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_BF_MSK (0x001F8000)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_FRACN_SD_STEP_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DIV1::cfg_lf_band_inuse
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_INUSE_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_INUSE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_INUSE_BF_MSK (0x00200000)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_INUSE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DIV1::cfg_lf_band_sel
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_SEL_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_SEL_BF_MSK (0x00400000)
#define PMA_ANACMNPLL_MSG_DIV1_CFG_LF_BAND_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_ADL0 register description at address offset 0x8
  *
  * Register default value:        0x01800007
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_adl0
  * SERDES_LANE_ANA_PLL::ADL0
  */

typedef union {
  struct {
    uint32_t CFG_ADL_ENABLE : 1;
    ///< Enable adaptive delay line in fracN mode (only when o_fracnen_h=1).
    ///< While '1' it is also disable feed-forward cancellation.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t CFG_ADL_RANGE : 3;
    ///< Configs ADL range to be used. The formula (prelay results, need to
    ///< be updated):                         round((138.75 - 1.2e12/Fdco)/13.266)
    ///< [Fdco in Hz]
    ///< AccessType="RW" BitOffset="1" ResetValue="0x3"
    uint32_t CFG_ADL_POS_OFFSET : 8;
    ///< Positive ADL INL compensation.                         Each register
    ///< bit corresponding to each cap_ctrl bus bit.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CFG_ADL_NEG_OFFSET : 8;
    ///< Negative ADL INL compensation.                         Each register
    ///< bit corresponding to each cap_ctrl bus bit.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_ADL_ENABLE_OVR_EN : 1;
    ///< adl bypass/enable force (see adl_enable_ovr_val).
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t CFG_ADL_ENABLE_OVR_VAL : 1;
    ///< While adl_enable_ovr_en= 1.                         0 - force adl
    ///< bypass.                         1 - force adl enable.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t CFG_ADL_CAP_CTRL_OVR_EN : 1;
    ///< Override enable for cfg_adl_cap_ctrl_ovr_val[8:0]
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t CFG_ADL_CAP_CTRL_OVR_VAL : 9;
    ///< Override value for cap_ctrl bus to ADL.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x3"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_adl0_reg_t;

#define PMA_ANACMNPLL_MSG_ADL0_DEFAULT (0x01800007U)
#define PMA_ANACMNPLL_MSG_ADL0_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_ADL0_WR_MASK (0xffffffffU)


///< Enable adaptive delay line in fracN mode (only when o_fracnen_h=1).
///< While '1' it is also disable feed-forward cancellation.
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_BF_DEF (0x00000001)

///< Configs ADL range to be used. The formula (prelay results, need to
///< be updated):                         round((138.75 - 1.2e12/Fdco)/13.266)
///< [Fdco in Hz]
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_RANGE_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_RANGE_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_RANGE_BF_MSK (0x0000000E)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_RANGE_BF_DEF (0x00000006)

///< Positive ADL INL compensation.                         Each register
///< bit corresponding to each cap_ctrl bus bit.
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_POS_OFFSET_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_POS_OFFSET_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_POS_OFFSET_BF_MSK (0x00000FF0)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_POS_OFFSET_BF_DEF (0x00000000)

///< Negative ADL INL compensation.                         Each register
///< bit corresponding to each cap_ctrl bus bit.
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_NEG_OFFSET_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_NEG_OFFSET_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_NEG_OFFSET_BF_MSK (0x000FF000)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_NEG_OFFSET_BF_DEF (0x00000000)

///< adl bypass/enable force (see adl_enable_ovr_val).
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_EN_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_EN_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_EN_BF_DEF (0x00000000)

///< While adl_enable_ovr_en= 1.                         0 - force adl
///< bypass.                         1 - force adl enable.
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_VAL_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_VAL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_VAL_BF_MSK (0x00200000)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_EN_OVR_VAL_BF_DEF (0x00000000)

///< Override enable for cfg_adl_cap_ctrl_ovr_val[8:0]
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_EN_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_EN_BF_MSK (0x00400000)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_EN_BF_DEF (0x00000000)

///< Override value for cap_ctrl bus to ADL.
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_VAL_BF_OFF (23)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_VAL_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_VAL_BF_MSK (0xFF800000)
#define PMA_ANACMNPLL_MSG_ADL0_CFG_ADL_CAP_CTRL_OVR_VAL_BF_DEF (0x01800000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_ADL1 register description at address offset 0xc
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_adl1
  * SERDES_LANE_ANA_PLL::ADL1
  */

typedef union {
  struct {
    uint32_t CFG_ADL_MONITOR_OCT_SEL : 8;
    ///< SERDES_LANE_ANA_PLL::ADL1::cfg_adl_monitor_oct_sel
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_TDC_STATUS_EN : 1;
    ///< SERDES_LANE_ANA_PLL::ADL1::cfg_tdc_status_en
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_ADL_MONITOR_THR : 5;
    ///< SERDES_LANE_ANA_PLL::ADL1::cfg_adl_monitor_thr
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_adl1_reg_t;

#define PMA_ANACMNPLL_MSG_ADL1_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_ADL1_RD_MASK (0x00003fffU)
#define PMA_ANACMNPLL_MSG_ADL1_WR_MASK (0x00003fffU)


///< SERDES_LANE_ANA_PLL::ADL1::cfg_adl_monitor_oct_sel
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_OCT_SEL_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_OCT_SEL_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_OCT_SEL_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_OCT_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ADL1::cfg_tdc_status_en
#define PMA_ANACMNPLL_MSG_ADL1_CFG_TDC_STAT_EN_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_TDC_STAT_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_TDC_STAT_EN_BF_MSK (0x00000100)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_TDC_STAT_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ADL1::cfg_adl_monitor_thr
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_THR_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_THR_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_THR_BF_MSK (0x00003E00)
#define PMA_ANACMNPLL_MSG_ADL1_CFG_ADL_MON_THR_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_FRAC_LOCK0 register description at address offset 0x10
  *
  * Register default value:        0x00002D0C
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_frac_lock0
  * LCPLL_FRAC_LOCK Register
  */

typedef union {
  struct {
    uint32_t O_FEEDFWRDGAIN : 8;
    ///< Feed-forward gain for fractional mode.                         When
    ///< o_feedfwrdcal_en_h=0, this will determine the gain.
    ///< When o_feedfwrdcal_en_h=1, this will determine initial value of the
    ///< gain.                          Use the following formula:
    ///< Full rate: o_feedfwrdgain = 1/(Fdco*tdc_fine_step)
    ///< Half rate: o_feedfwrdgain = 2/(Fdco*tdc_fine_step)
    ///< For franN mode, tdc_fine_step is 6.5psec.
    ///< AccessType="RW" BitOffset="0" ResetValue="0xC"
    uint32_t O_FEEDFWRDCAL_EN_H : 1;
    ///< Feedfward gain adaptive mode enable
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1"
    uint32_t O_FEEDFWRDCAL_PAUSE_H : 1;
    ///< This bit is for dynamically turning on and off feed forward gain adaptive
    ///< mode.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t O_DCODITHEREN_H : 1;
    ///< DCO fine dithering enable signal.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x1"
    uint32_t O_LOCK_CRITERIA : 3;
    ///< Phase lock indicator criteria. Asserted high when phase error is less
    ///< than or equal to the threshold value for:
    ///< 000: 16 consecutive cycles                         001: 32 consecutive
    ///< cycles                         010: 48 consecutive cycles
    ///< 011: 64 consecutive cycles                         100: 80 consecutive
    ///< cycles                         101: 96 consecutive cycles
    ///< 110: 112 consecutive cycles                         111: 128 consecutive
    ///< cycles
    ///< AccessType="RW" BitOffset="11" ResetValue="0x5"
    uint32_t O_FBDIV_STROBE_H : 1;
    ///< Enables sampling feedback ratio (integer+fractional) into PLL logic.
    ///< Before changing feedback ratio dynamically (while PLL is running),
    ///< one should deassert this bit until new ratio is udpated in registers.
    ///< This is to ensure safe and synchronoius update of ratio.
    ///< The feedback ratio will propagate automatically into PLL logic while
    ///< PLL is off until DCO settle state is done.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t O_DITHER_VALUE : 5;
    ///< DCO Dither Override Value (in case o_dither_ovrd=1).
    ///< 5 MSB of the filter fractional code (rest 4 LSBs are set to 0).
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t CFG_SIGMA_DELTA2_SEL : 1;
    ///< 0 - Uses the first order sigma delta modulator for the feed forward
    ///< cancellation mechanism.                         1 - Uses the second
    ///< order sigma delta modulator for the feed forward cancellation mechanism.
    ///< Note that in this mode the adaptive ffgain feature doesn't work.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t CFG_HIGH_SPEED_SD_EN : 1;
    ///< SERDES_LANE_ANA_PLL::FRAC_LOCK0::cfg_high_speed_sd_en
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_frac_lock0_reg_t;

#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_DEFAULT (0x00002d0cU)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_RD_MASK (0x003fffffU)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_WR_MASK (0x003fffffU)


///< Feed-forward gain for fractional mode.                         When
///< o_feedfwrdcal_en_h=0, this will determine the gain.
///< When o_feedfwrdcal_en_h=1, this will determine initial value of the
///< gain.                          Use the following formula:
///< Full rate: o_feedfwrdgain = 1/(Fdco*tdc_fine_step)
///< Half rate: o_feedfwrdgain = 2/(Fdco*tdc_fine_step)
///< For franN mode, tdc_fine_step is 6.5psec.
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDGAIN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDGAIN_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDGAIN_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDGAIN_BF_DEF (0x0000000C)

///< Feedfward gain adaptive mode enable
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_EN_H_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_EN_H_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_EN_H_BF_MSK (0x00000100)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_EN_H_BF_DEF (0x00000100)

///< This bit is for dynamically turning on and off feed forward gain adaptive
///< mode.
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_PAUSE_H_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_PAUSE_H_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_PAUSE_H_BF_MSK (0x00000200)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FEEDFWRDCAL_PAUSE_H_BF_DEF (0x00000000)

///< DCO fine dithering enable signal.
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DCODITHEREN_H_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DCODITHEREN_H_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DCODITHEREN_H_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DCODITHEREN_H_BF_DEF (0x00000400)

///< Phase lock indicator criteria. Asserted high when phase error is less
///< than or equal to the threshold value for:
///< 000: 16 consecutive cycles                         001: 32 consecutive
///< cycles                         010: 48 consecutive cycles
///< 011: 64 consecutive cycles                         100: 80 consecutive
///< cycles                         101: 96 consecutive cycles
///< 110: 112 consecutive cycles                         111: 128 consecutive
///< cycles
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_LOCK_CRITERIA_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_LOCK_CRITERIA_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_LOCK_CRITERIA_BF_MSK (0x00003800)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_LOCK_CRITERIA_BF_DEF (0x00002800)

///< Enables sampling feedback ratio (integer+fractional) into PLL logic.
///< Before changing feedback ratio dynamically (while PLL is running),
///< one should deassert this bit until new ratio is udpated in registers.
///< This is to ensure safe and synchronoius update of ratio.
///< The feedback ratio will propagate automatically into PLL logic while
///< PLL is off until DCO settle state is done.
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FBDIV_STROBE_H_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FBDIV_STROBE_H_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FBDIV_STROBE_H_BF_MSK (0x00004000)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_FBDIV_STROBE_H_BF_DEF (0x00000000)

///< DCO Dither Override Value (in case o_dither_ovrd=1).
///< 5 MSB of the filter fractional code (rest 4 LSBs are set to 0).
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DITHER_VAL_BF_OFF (15)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DITHER_VAL_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DITHER_VAL_BF_MSK (0x000F8000)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_O_DITHER_VAL_BF_DEF (0x00000000)

///< 0 - Uses the first order sigma delta modulator for the feed forward
///< cancellation mechanism.                         1 - Uses the second
///< order sigma delta modulator for the feed forward cancellation mechanism.
///< Note that in this mode the adaptive ffgain feature doesn't work.
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_SIGMA_DELTA2_SEL_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_SIGMA_DELTA2_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_SIGMA_DELTA2_SEL_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_SIGMA_DELTA2_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::FRAC_LOCK0::cfg_high_speed_sd_en
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_HIGH_SPEED_SD_EN_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_HIGH_SPEED_SD_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_HIGH_SPEED_SD_EN_BF_MSK (0x00200000)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_CFG_HIGH_SPEED_SD_EN_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_FRAC_LOCK1 register description at address offset 0x14
  *
  * Register default value:        0x00000045
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_frac_lock1
  * SERDES_LANE_ANA_PLL::FRAC_LOCK1
  */

typedef union {
  struct {
    uint32_t CFG_LOCK_THRESH : 5;
    ///< Phase lock detect threshold.                         The PLL will
    ///< generate plllockout when the TDC phase error is within lockthresh
    ///< for a number of cycles determined by o_lock_criteria.
    ///< 0 is forbidden value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x5"
    uint32_t CFG_FINE_FIRST_BOOST_REPEAT : 3;
    ///< Determines the number of repetitions of the boost gain counter for
    ///< the first stage of the fine boost.                         The number
    ///< of overall repetitions is equal to cfg_fine_first_boost_repeat + 1
    ///< Set this to non-zero when PLL needs to lock on SSC'ed refclk, to allow
    ///< enough time for the boost to handle fast cap-swap.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x2"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_frac_lock1_reg_t;

#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_DEFAULT (0x00000045U)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_RD_MASK (0x000000ffU)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_WR_MASK (0x000000ffU)


///< Phase lock detect threshold.                         The PLL will
///< generate plllockout when the TDC phase error is within lockthresh
///< for a number of cycles determined by o_lock_criteria.
///< 0 is forbidden value.
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_LOCK_THRESH_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_LOCK_THRESH_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_LOCK_THRESH_BF_MSK (0x0000001F)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_LOCK_THRESH_BF_DEF (0x00000005)

///< Determines the number of repetitions of the boost gain counter for
///< the first stage of the fine boost.                         The number
///< of overall repetitions is equal to cfg_fine_first_boost_repeat + 1
///< Set this to non-zero when PLL needs to lock on SSC'ed refclk, to allow
///< enough time for the boost to handle fast cap-swap.
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_FINE_FIRST_BOOST_REPEAT_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_FINE_FIRST_BOOST_REPEAT_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_FINE_FIRST_BOOST_REPEAT_BF_MSK (0x000000E0)
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_CFG_FINE_FIRST_BOOST_REPEAT_BF_DEF (0x00000040)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_TDC0 register description at address offset 0x18
  *
  * Register default value:        0x0F00033F
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_tdc0
  * LCPLL_TDC0 Register
  */

typedef union {
  struct {
    uint32_t CFG_VTDC_REFCLK_CNT_LIMIT : 4;
    ///< Number of reference clock cycles used in TDC clock calibration
    ///< AccessType="RW" BitOffset="0" ResetValue="0xF"
    uint32_t CFG_VTDC_FAST_SEL : 1;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fast_sel
    ///< AccessType="RW" BitOffset="4" ResetValue="0x1"
    uint32_t CFG_VTDC_OFFSET_CALIB_EN : 1;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_offset_calib_en
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint32_t CFG_VTDC_PLUS_STDC : 1;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_plus_stdc
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CFG_VTDC_FINE_OFFSET_CHIKEN_BIT : 1;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fine_offset_chiken_bit
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CFG_VTDC_OFFSET_TIMER_LIMIT : 4;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_offset_timer_limit
    ///< AccessType="RW" BitOffset="8" ResetValue="0x3"
    uint32_t CFG_VTDC_FINE_OFFSET_OVRD : 1;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fine_offset_ovrd
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_VTDC_FINE_OFFSET_OVRD_VAL : 5;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fine_offset_ovrd_val
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CFG_TDCPE_OFFSET : 5;
    ///< Adding offset to 2's comp tdc value (integer signed)
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t CFG_TDC_BB_INPUT_SEL : 1;
    ///< 1'b0 - Uses bb TDC signal from analog                         1'b1
    ///< - Uses MSB of tdceff signal as bb TDC input signal (TDC sign bit)
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t CFG_STDC_STDDEV_INIT : 4;
    ///< Initial value for stddev control bus before STDC calibration.
    ///< AccessType="RW" BitOffset="24" ResetValue="0xF"
    uint32_t CFG_FORCE_VTDC_OSC : 1;
    ///< Forces VTDC to RO mode
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t CFG_VTDC_OFFSET_RANGE : 1;
    ///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_offset_range
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_tdc0_reg_t;

#define PMA_ANACMNPLL_MSG_TDC0_DEFAULT (0x0f00033fU)
#define PMA_ANACMNPLL_MSG_TDC0_RD_MASK (0x3fffffffU)
#define PMA_ANACMNPLL_MSG_TDC0_WR_MASK (0x3fffffffU)


///< Number of reference clock cycles used in TDC clock calibration
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_REFCLK_CNT_LIMIT_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_REFCLK_CNT_LIMIT_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_REFCLK_CNT_LIMIT_BF_MSK (0x0000000F)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_REFCLK_CNT_LIMIT_BF_DEF (0x0000000F)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fast_sel
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FAST_SEL_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FAST_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FAST_SEL_BF_MSK (0x00000010)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FAST_SEL_BF_DEF (0x00000010)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_offset_calib_en
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_CALIB_EN_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_CALIB_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_CALIB_EN_BF_MSK (0x00000020)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_CALIB_EN_BF_DEF (0x00000020)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_plus_stdc
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_PLUS_STDC_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_PLUS_STDC_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_PLUS_STDC_BF_MSK (0x00000040)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_PLUS_STDC_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fine_offset_chiken_bit
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_CHIKEN_BIT_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_CHIKEN_BIT_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_CHIKEN_BIT_BF_MSK (0x00000080)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_CHIKEN_BIT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_offset_timer_limit
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_TIMER_LIMIT_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_TIMER_LIMIT_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_TIMER_LIMIT_BF_MSK (0x00000F00)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_TIMER_LIMIT_BF_DEF (0x00000300)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fine_offset_ovrd
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_fine_offset_ovrd_val
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_VAL_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_VAL_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_VAL_BF_MSK (0x0003E000)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_FINE_OFFSET_OVRD_VAL_BF_DEF (0x00000000)

///< Adding offset to 2's comp tdc value (integer signed)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDCPE_OFFSET_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDCPE_OFFSET_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDCPE_OFFSET_BF_MSK (0x007C0000)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDCPE_OFFSET_BF_DEF (0x00000000)

///< 1'b0 - Uses bb TDC signal from analog                         1'b1
///< - Uses MSB of tdceff signal as bb TDC input signal (TDC sign bit)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDC_BB_INPUT_SEL_BF_OFF (23)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDC_BB_INPUT_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDC_BB_INPUT_SEL_BF_MSK (0x00800000)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_TDC_BB_INPUT_SEL_BF_DEF (0x00000000)

///< Initial value for stddev control bus before STDC calibration.
#define PMA_ANACMNPLL_MSG_TDC0_CFG_STDC_STDDEV_INIT_BF_OFF (24)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_STDC_STDDEV_INIT_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_STDC_STDDEV_INIT_BF_MSK (0x0F000000)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_STDC_STDDEV_INIT_BF_DEF (0x0F000000)

///< Forces VTDC to RO mode
#define PMA_ANACMNPLL_MSG_TDC0_CFG_FORCE_VTDC_OSC_BF_OFF (28)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_FORCE_VTDC_OSC_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_FORCE_VTDC_OSC_BF_MSK (0x10000000)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_FORCE_VTDC_OSC_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TDC0::cfg_vtdc_offset_range
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_RANGE_BF_OFF (29)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_RANGE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_RANGE_BF_MSK (0x20000000)
#define PMA_ANACMNPLL_MSG_TDC0_CFG_VTDC_OFFSET_RANGE_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_TDC1 register description at address offset 0x1c
  *
  * Register default value:        0x001E80AA
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_tdc1
  * SERDES_LANE_ANA_PLL::TDC1
  */

typedef union {
  struct {
    uint32_t CFG_PE_DISABLE : 1;
    ///< Force values of 0 on TDC output.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_TDC_LADDER_MAX : 2;
    ///< Max trim ladder code value alowed during lock adquisition.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t CFG_TDC_LADDER_MIN : 2;
    ///< Min trim ladder code value alowed during lock adquisition.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t CFG_SELECT_STDC_FILTER : 1;
    ///< Select STDC output to filter.                         Will select
    ///< only after FSM enables.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint32_t CFG_SELECT_STDC_DFX : 1;
    ///< Select STDC output to DFX path (PE min/max, raw lock, VISA, RO reg)
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CFG_STDC_PROP_COEFF : 5;
    ///< Fine Kp = 2^(-reg) to be used with STDC (signed value)
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint32_t CFG_STDC_INT_COEFF : 5;
    ///< Fine Ki = 2^(-reg) to be used with STDC
    ///< AccessType="RW" BitOffset="12" ResetValue="0x8"
    uint32_t CFG_VTDC_ANA_EN : 1;
    ///< SERDES_LANE_ANA_PLL::TDC1::cfg_vtdc_ana_en
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint32_t CFG_STDC_ANA_EN : 1;
    ///< SERDES_LANE_ANA_PLL::TDC1::cfg_stdc_ana_en
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint32_t CFG_TDC_SAMP_BYPASS : 1;
    ///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_samp_bypass
    ///< AccessType="RW" BitOffset="19" ResetValue="0x1"
    uint32_t CFG_STDC_SAMP_BYPASS : 1;
    ///< SERDES_LANE_ANA_PLL::TDC1::cfg_stdc_samp_bypass
    ///< AccessType="RW" BitOffset="20" ResetValue="0x1"
    uint32_t CFG_TDC_STATUS_MODE : 1;
    ///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_status_mode
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t CFG_TDC_HISTOGRAM_MODE : 1;
    ///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_histogram_mode
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t CFG_TDC_HISTOGRAM_VALUE : 6;
    ///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_histogram_value
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_tdc1_reg_t;

#define PMA_ANACMNPLL_MSG_TDC1_DEFAULT (0x001e80aaU)
#define PMA_ANACMNPLL_MSG_TDC1_RD_MASK (0x1fffffffU)
#define PMA_ANACMNPLL_MSG_TDC1_WR_MASK (0x1fffffffU)


///< Force values of 0 on TDC output.
#define PMA_ANACMNPLL_MSG_TDC1_CFG_PE_DIS_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_PE_DIS_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_PE_DIS_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_PE_DIS_BF_DEF (0x00000000)

///< Max trim ladder code value alowed during lock adquisition.
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MAX_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MAX_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MAX_BF_MSK (0x00000006)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MAX_BF_DEF (0x00000002)

///< Min trim ladder code value alowed during lock adquisition.
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MIN_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MIN_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MIN_BF_MSK (0x00000018)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_LADDER_MIN_BF_DEF (0x00000008)

///< Select STDC output to filter.                         Will select
///< only after FSM enables.
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_FILTER_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_FILTER_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_FILTER_BF_MSK (0x00000020)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_FILTER_BF_DEF (0x00000020)

///< Select STDC output to DFX path (PE min/max, raw lock, VISA, RO reg)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_DFX_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_DFX_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_DFX_BF_MSK (0x00000040)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_SEL_STDC_DFX_BF_DEF (0x00000000)

///< Fine Kp = 2^(-reg) to be used with STDC (signed value)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_PROP_COEFF_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_PROP_COEFF_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_PROP_COEFF_BF_MSK (0x00000F80)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_PROP_COEFF_BF_DEF (0x00000080)

///< Fine Ki = 2^(-reg) to be used with STDC
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_INT_COEFF_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_INT_COEFF_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_INT_COEFF_BF_MSK (0x0001F000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_INT_COEFF_BF_DEF (0x00008000)

///< SERDES_LANE_ANA_PLL::TDC1::cfg_vtdc_ana_en
#define PMA_ANACMNPLL_MSG_TDC1_CFG_VTDC_ANA_EN_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_VTDC_ANA_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_VTDC_ANA_EN_BF_MSK (0x00020000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_VTDC_ANA_EN_BF_DEF (0x00020000)

///< SERDES_LANE_ANA_PLL::TDC1::cfg_stdc_ana_en
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_ANA_EN_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_ANA_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_ANA_EN_BF_MSK (0x00040000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_ANA_EN_BF_DEF (0x00040000)

///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_samp_bypass
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_SAMP_BYP_BF_OFF (19)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_SAMP_BYP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_SAMP_BYP_BF_MSK (0x00080000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_SAMP_BYP_BF_DEF (0x00080000)

///< SERDES_LANE_ANA_PLL::TDC1::cfg_stdc_samp_bypass
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_SAMP_BYP_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_SAMP_BYP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_SAMP_BYP_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_STDC_SAMP_BYP_BF_DEF (0x00100000)

///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_status_mode
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_STAT_MODE_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_STAT_MODE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_STAT_MODE_BF_MSK (0x00200000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_STAT_MODE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_histogram_mode
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_MODE_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_MODE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_MODE_BF_MSK (0x00400000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_MODE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TDC1::cfg_tdc_histogram_value
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_VAL_BF_OFF (23)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_VAL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_VAL_BF_MSK (0x1F800000)
#define PMA_ANACMNPLL_MSG_TDC1_CFG_TDC_HISTOGRAM_VAL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_TDC2 register description at address offset 0x20
  *
  * Register default value:        0x002483EF
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_tdc2
  * SERDES_LANE_ANA_PLL::TDC2
  */

typedef union {
  struct {
    uint32_t CFG_TDC_ADAPTIVE_WIN_IN : 5;
    ///< TDC code threshold to switch ladder with higher resolution.
    ///< Need to be below that value during cfg_tdc_adaptive_max_count cycle
    ///< time window
    ///< AccessType="RW" BitOffset="0" ResetValue="0xF"
    uint32_t CFG_TDC_ADAPTIVE_WIN_OUT : 5;
    ///< TDC code threshold to switch ladder with lower resolution.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1F"
    uint32_t CFG_TDC_ADAPTIVE_MAX_COUNT : 6;
    ///< Defines the number of cycles for time window of TDC ladder adaptive
    ///< switching
    ///< AccessType="RW" BitOffset="10" ResetValue="0x20"
    uint32_t CFG_TDC_TRIM_OVRD : 1;
    ///< tdc chain trim ovrd enable
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_TDC_TRIM_VAL : 2;
    ///< tdc chain trim ovrd value
    ///< AccessType="RW" BitOffset="17" ResetValue="0x2"
    uint32_t CFG_KPKI_COMPENSATE_VAL : 2;
    ///< SERDES_LANE_ANA_PLL::TDC2::cfg_kpki_compensate_val
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t CFG_STDC_BIAS_EN : 1;
    ///< Enables internal STDC bias.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x1"
    uint32_t CFG_FORCE_STDC_OSC : 1;
    ///< Forces internal STDC oscilator to enable.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t CFG_STDC_STDDEV_OVRD_EN : 1;
    ///< Enables override for stddev control bus.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t CFG_STDC_OSC_DIV4 : 1;
    ///< Enables internal STDC divider for internal oscilator output.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t CFG_STDCPE_OFFSET : 5;
    ///< Adding offset to 2's comp stdc value (integer signed)
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_tdc2_reg_t;

#define PMA_ANACMNPLL_MSG_TDC2_DEFAULT (0x002483efU)
#define PMA_ANACMNPLL_MSG_TDC2_RD_MASK (0x3fffffffU)
#define PMA_ANACMNPLL_MSG_TDC2_WR_MASK (0x3fffffffU)


///< TDC code threshold to switch ladder with higher resolution.
///< Need to be below that value during cfg_tdc_adaptive_max_count cycle
///< time window
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_IN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_IN_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_IN_BF_MSK (0x0000001F)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_IN_BF_DEF (0x0000000F)

///< TDC code threshold to switch ladder with lower resolution.
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_OUT_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_OUT_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_OUT_BF_MSK (0x000003E0)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_WIN_OUT_BF_DEF (0x000003E0)

///< Defines the number of cycles for time window of TDC ladder adaptive
///< switching
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_MAX_CNT_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_MAX_CNT_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_MAX_CNT_BF_MSK (0x0000FC00)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_ADAPTIVE_MAX_CNT_BF_DEF (0x00008000)

///< tdc chain trim ovrd enable
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_OVRD_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_OVRD_BF_MSK (0x00010000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_OVRD_BF_DEF (0x00000000)

///< tdc chain trim ovrd value
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_VAL_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_VAL_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_VAL_BF_MSK (0x00060000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_TDC_TRIM_VAL_BF_DEF (0x00040000)

///< SERDES_LANE_ANA_PLL::TDC2::cfg_kpki_compensate_val
#define PMA_ANACMNPLL_MSG_TDC2_CFG_KPKI_COMPENSATE_VAL_BF_OFF (19)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_KPKI_COMPENSATE_VAL_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_KPKI_COMPENSATE_VAL_BF_MSK (0x00180000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_KPKI_COMPENSATE_VAL_BF_DEF (0x00000000)

///< Enables internal STDC bias.
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_BIAS_EN_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_BIAS_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_BIAS_EN_BF_MSK (0x00200000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_BIAS_EN_BF_DEF (0x00200000)

///< Forces internal STDC oscilator to enable.
#define PMA_ANACMNPLL_MSG_TDC2_CFG_FORCE_STDC_OSC_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_FORCE_STDC_OSC_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_FORCE_STDC_OSC_BF_MSK (0x00400000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_FORCE_STDC_OSC_BF_DEF (0x00000000)

///< Enables override for stddev control bus.
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_STDDEV_OVRD_EN_BF_OFF (23)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_STDDEV_OVRD_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_STDDEV_OVRD_EN_BF_MSK (0x00800000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_STDDEV_OVRD_EN_BF_DEF (0x00000000)

///< Enables internal STDC divider for internal oscilator output.
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_OSC_DIV4_BF_OFF (24)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_OSC_DIV4_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_OSC_DIV4_BF_MSK (0x01000000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDC_OSC_DIV4_BF_DEF (0x00000000)

///< Adding offset to 2's comp stdc value (integer signed)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDCPE_OFFSET_BF_OFF (25)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDCPE_OFFSET_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDCPE_OFFSET_BF_MSK (0x3E000000)
#define PMA_ANACMNPLL_MSG_TDC2_CFG_STDCPE_OFFSET_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_TDC3 register description at address offset 0x24
  *
  * Register default value:        0x000003A3
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_tdc3
  * SERDES_LANE_ANA_PLL::TDC3
  */

typedef union {
  struct {
    uint32_t CFG_STDC_TARGET_CNT : 8;
    ///< Calibration target for STDC oscilator during calibration.
    ///< The formula: int(2^(2 + cfg_stdc_cnt_limit)*(3e9/Frefclk))
    ///< AccessType="RW" BitOffset="0" ResetValue="0xA3"
    uint32_t CFG_STDC_CNT_LIMIT : 2;
    ///< Number of cycles to count STDC oscilator edges during calibration.
    ///< Value = 2^(2 + reg)
    ///< AccessType="RW" BitOffset="8" ResetValue="0x3"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_tdc3_reg_t;

#define PMA_ANACMNPLL_MSG_TDC3_DEFAULT (0x000003a3U)
#define PMA_ANACMNPLL_MSG_TDC3_RD_MASK (0x000003ffU)
#define PMA_ANACMNPLL_MSG_TDC3_WR_MASK (0x000003ffU)


///< Calibration target for STDC oscilator during calibration.
///< The formula: int(2^(2 + cfg_stdc_cnt_limit)*(3e9/Frefclk))
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_TARGET_CNT_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_TARGET_CNT_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_TARGET_CNT_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_TARGET_CNT_BF_DEF (0x000000A3)

///< Number of cycles to count STDC oscilator edges during calibration.
///< Value = 2^(2 + reg)
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_CNT_LIMIT_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_CNT_LIMIT_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_CNT_LIMIT_BF_MSK (0x00000300)
#define PMA_ANACMNPLL_MSG_TDC3_CFG_STDC_CNT_LIMIT_BF_DEF (0x00000300)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_TAP_OVRD register description at address offset 0x28
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_tap_ovrd
  * LCPLL_TAP_OVRD Register
  */

typedef union {
  struct {
    uint32_t CFG_PLL_ENABLE : 1;
    ///< Replaces direct pin of PLL enable signal (in case cfg_pll_en_mode_ctrl
    ///< = 1).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_PLL_EN_MODE_CTRL : 1;
    ///< Effective PLL enable:                         0 - Enable signal from
    ///< PLL interface                         1 - Enable signal from PLL register
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CFG_LDO_ENABLE : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldo_enable
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CFG_VREFGEN_EN_OVRD : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_vrefgen_en_ovrd
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CFG_VREFGEN_EN_OVRD_VAL : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_vrefgen_en_ovrd_val
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CFG_LDO_BIAS_EN_OVRD : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldo_bias_en_ovrd
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CFG_LDO_BIAS_EN_OVRD_VAL : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldo_bias_en_ovrd_val
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CFG_LDOCLK_EN_OVRD : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldoclk_en_ovrd
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CFG_LDOCLK_EN_OVRD_VAL : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldoclk_en_ovrd_val
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_LDODCO_EN_OVRD : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldodco_en_ovrd
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CFG_LDODCO_EN_OVRD_VAL : 1;
    ///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldodco_en_ovrd_val
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t O_DFX_TDC_DISABLE : 1;
    ///< Set to turn off TDC. Mainly to study impact of TDC self noise on PLL
    ///< jitter
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t  : 20;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_tap_ovrd_reg_t;

#define PMA_ANACMNPLL_MSG_TAP_OVRD_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_RD_MASK (0x00000fffU)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_WR_MASK (0x00000fffU)


///< Replaces direct pin of PLL enable signal (in case cfg_pll_en_mode_ctrl
///< = 1).
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_BF_DEF (0x00000000)

///< Effective PLL enable:                         0 - Enable signal from
///< PLL interface                         1 - Enable signal from PLL register
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_MODE_CTRL_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_MODE_CTRL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_MODE_CTRL_BF_MSK (0x00000002)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_PLL_EN_MODE_CTRL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldo_enable
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_EN_BF_OFF ( 2)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_EN_BF_MSK (0x00000004)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_vrefgen_en_ovrd
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_BF_MSK (0x00000008)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_vrefgen_en_ovrd_val
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_VAL_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_VAL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_VAL_BF_MSK (0x00000010)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_VREFGEN_EN_OVRD_VAL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldo_bias_en_ovrd
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_BF_MSK (0x00000020)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldo_bias_en_ovrd_val
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_VAL_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_VAL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_VAL_BF_MSK (0x00000040)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDO_BIAS_EN_OVRD_VAL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldoclk_en_ovrd
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_BF_MSK (0x00000080)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldoclk_en_ovrd_val
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_VAL_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_VAL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_VAL_BF_MSK (0x00000100)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDOCLK_EN_OVRD_VAL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldodco_en_ovrd
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_BF_MSK (0x00000200)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::TAP_OVRD::cfg_ldodco_en_ovrd_val
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_VAL_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_VAL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_VAL_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_CFG_LDODCO_EN_OVRD_VAL_BF_DEF (0x00000000)

///< Set to turn off TDC. Mainly to study impact of TDC self noise on PLL
///< jitter
#define PMA_ANACMNPLL_MSG_TAP_OVRD_O_DFX_TDC_DIS_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_O_DFX_TDC_DIS_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_O_DFX_TDC_DIS_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_TAP_OVRD_O_DFX_TDC_DIS_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DFX_DCO register description at address offset 0x2c
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_dfx_dco
  * LCPLL_DFX_DCO Register
  */

typedef union {
  struct {
    uint32_t O_DCOFINEDFTSEL : 2;
    ///< DCO fine frequency and dco dither override:
    ///< 00: DCO fine tuning is set by PLL closed loop .
    ///< 01: DCO fine frequency value is set by o_dcofine and DCO dither value
    ///< is set by o_dither_value.                         10: Internal SAW
    ///< tooth pattern on fine integer code (while frac=0). Code increments
    ///< every fbclk cycle.                         11: Reserved.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t O_DCOCOARSE_OVRD_H : 1;
    ///< DCO coarse frequency override signal:                         0: DCO
    ///< coarse tuning is set by AFC state machine
    ///< 1: DCO coarse frequency value is set by o_dcocoarse
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t O_DCOFINE : 8;
    ///< Fine override value (when o_dcofinedftsel = 01).
    ///< Valid range 0 to 254.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t O_DCOCOARSE : 9;
    ///< AFC override value (when o_dcocoarse_ovrd_h=1).
    ///< Valid range 0 to 319.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_CAPTURE_FILTER : 1;
    ///< SERDES_LANE_ANA_PLL::DFX_DCO::cfg_capture_filter
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_dfx_dco_reg_t;

#define PMA_ANACMNPLL_MSG_DFX_DCO_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_DFX_DCO_RD_MASK (0x001fffffU)
#define PMA_ANACMNPLL_MSG_DFX_DCO_WR_MASK (0x001fffffU)


///< DCO fine frequency and dco dither override:
///< 00: DCO fine tuning is set by PLL closed loop .
///< 01: DCO fine frequency value is set by o_dcofine and DCO dither value
///< is set by o_dither_value.                         10: Internal SAW
///< tooth pattern on fine integer code (while frac=0). Code increments
///< every fbclk cycle.                         11: Reserved.
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINEDFTSEL_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINEDFTSEL_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINEDFTSEL_BF_MSK (0x00000003)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINEDFTSEL_BF_DEF (0x00000000)

///< DCO coarse frequency override signal:                         0: DCO
///< coarse tuning is set by AFC state machine
///< 1: DCO coarse frequency value is set by o_dcocoarse
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_OVRD_H_BF_OFF ( 2)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_OVRD_H_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_OVRD_H_BF_MSK (0x00000004)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_OVRD_H_BF_DEF (0x00000000)

///< Fine override value (when o_dcofinedftsel = 01).
///< Valid range 0 to 254.
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINE_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINE_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINE_BF_MSK (0x000007F8)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOFINE_BF_DEF (0x00000000)

///< AFC override value (when o_dcocoarse_ovrd_h=1).
///< Valid range 0 to 319.
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_BF_MSK (0x000FF800)
#define PMA_ANACMNPLL_MSG_DFX_DCO_O_DCOCOARSE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DFX_DCO::cfg_capture_filter
#define PMA_ANACMNPLL_MSG_DFX_DCO_CFG_CAP_FILTER_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_DFX_DCO_CFG_CAP_FILTER_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX_DCO_CFG_CAP_FILTER_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_DFX_DCO_CFG_CAP_FILTER_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DFX_TDC_CRO register description at address offset 0x30
  *
  * Register default value:        0x0000001C
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_dfx_tdc_cro
  * LCPLL_DFX_TDC_CRO Register
  */

typedef union {
  struct {
    uint32_t CFG_DFT_CNT_RESTART : 1;
    ///< Clears min/max measurements and restarts dft counter
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_DFT_TIMER_LIMIT : 4;
    ///< While cfg_dfx_disable_dft_timer_ovrd_val=0 define the window time
    ///< of the dft measurement. (2^6 +reg [ref_clk cycles])
    ///< AccessType="RW" BitOffset="1" ResetValue="0xE"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_dfx_tdc_cro_reg_t;

#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_DEFAULT (0x0000001cU)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_RD_MASK (0x0000001fU)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_WR_MASK (0x0000001fU)


///< Clears min/max measurements and restarts dft counter
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_CNT_RESTART_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_CNT_RESTART_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_CNT_RESTART_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_CNT_RESTART_BF_DEF (0x00000000)

///< While cfg_dfx_disable_dft_timer_ovrd_val=0 define the window time
///< of the dft measurement. (2^6 +reg [ref_clk cycles])
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_TIMER_LIMIT_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_TIMER_LIMIT_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_TIMER_LIMIT_BF_MSK (0x0000001E)
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_CFG_DFT_TIMER_LIMIT_BF_DEF (0x0000001C)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_VISA_CTRL register description at address offset 0x34
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_visa_ctrl
  * LCPLL_VISA_CTRL Register
  */

typedef union {
  struct {
    uint32_t CFG_VISA_CTRL : 32;
    ///< VISA control register                         [0] visa enable.
    ///< [3:1] prbs mode (pattern gen)
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_visa_ctrl_reg_t;

#define PMA_ANACMNPLL_MSG_VISA_CTRL_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_VISA_CTRL_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_VISA_CTRL_WR_MASK (0xffffffffU)


///< VISA control register                         [0] visa enable.
///< [3:1] prbs mode (pattern gen)
#define PMA_ANACMNPLL_MSG_VISA_CTRL_CFG_VISA_CTRL_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_VISA_CTRL_CFG_VISA_CTRL_BF_WID (32)
#define PMA_ANACMNPLL_MSG_VISA_CTRL_CFG_VISA_CTRL_BF_MSK (0xFFFFFFFF)
#define PMA_ANACMNPLL_MSG_VISA_CTRL_CFG_VISA_CTRL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_VISA_LANE0_SEL register description at address offset 0x38
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_visa_lane0_sel
  * LCPLL_DFX_VISA_LANE0 Register
  */

typedef union {
  struct {
    uint32_t CFG_VISA_LANE0_SEL : 32;
    ///< Parallel VISA control for lane 0                         [7:0] byte
    ///< select                         [15:8] clock select
    ///< [16] clock bypass
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_visa_lane0_sel_reg_t;

#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_WR_MASK (0xffffffffU)


///< Parallel VISA control for lane 0                         [7:0] byte
///< select                         [15:8] clock select
///< [16] clock bypass
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_CFG_VISA_LANE0_SEL_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_CFG_VISA_LANE0_SEL_BF_WID (32)
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_CFG_VISA_LANE0_SEL_BF_MSK (0xFFFFFFFF)
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_CFG_VISA_LANE0_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_VISA_LANE1_SEL register description at address offset 0x3c
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_visa_lane1_sel
  * LCPLL_DFX_VISA_LANE1 Register
  */

typedef union {
  struct {
    uint32_t CFG_VISA_LANE1_SEL : 32;
    ///< Parallel VISA control for lane 1                         [7:0] byte
    ///< select                         [15:8] clock select
    ///< [16] clock bypass
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_visa_lane1_sel_reg_t;

#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_WR_MASK (0xffffffffU)


///< Parallel VISA control for lane 1                         [7:0] byte
///< select                         [15:8] clock select
///< [16] clock bypass
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_CFG_VISA_LANE1_SEL_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_CFG_VISA_LANE1_SEL_BF_WID (32)
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_CFG_VISA_LANE1_SEL_BF_MSK (0xFFFFFFFF)
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_CFG_VISA_LANE1_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_CNTR_BIST_SETTINGS register description at address offset 0x40
  *
  * Register default value:        0x00008B10
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_cntr_bist_settings
  * LCPLL_CNTR_BIST_SETTINGS Register
  */

typedef union {
  struct {
    uint32_t O_PLLLOCK_SEL : 2;
    ///< Selects mode of lock indicator:                         00: Counter
    ///< based lock                         01: Phase lock sticky high
    ///< 10: Boost done                         11: Counter based lock
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_LOCKTIMER_MAXCNT : 14;
    ///< Counter target for counter based lock (o_plllock_sel=1,2) in refclk
    ///< cycles.                         Starts counting after VREG & Kvcc
    ///< calibration completed.                         Used also to check
    ///< if raw phase lock asserted in time.                         Default
    ///< is ~25us for refclk of 156.25MHz.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x22C4"
    uint32_t CFG_PLLLOCK_STATE_SEL : 1;
    ///< Selects when to enter &quot;locked state&quot; (which starts VREG
    ///< tracking loop, DTR temp tracking, feed-forward gain adaptive loop
    ///< and min/max capture):                         0: counter based lock
    ///< 1: Phase lock sticky high
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_cntr_bist_settings_reg_t;

#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_DEFAULT (0x00008b10U)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_RD_MASK (0x0001ffffU)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_WR_MASK (0x0001ffffU)


///< Selects mode of lock indicator:                         00: Counter
///< based lock                         01: Phase lock sticky high
///< 10: Boost done                         11: Counter based lock
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_O_PLLLOCK_SEL_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_O_PLLLOCK_SEL_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_O_PLLLOCK_SEL_BF_MSK (0x00000003)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_O_PLLLOCK_SEL_BF_DEF (0x00000000)

///< Counter target for counter based lock (o_plllock_sel=1,2) in refclk
///< cycles.                         Starts counting after VREG & Kvcc
///< calibration completed.                         Used also to check
///< if raw phase lock asserted in time.                         Default
///< is ~25us for refclk of 156.25MHz.
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_LOCKTIMER_MAXCNT_BF_OFF ( 2)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_LOCKTIMER_MAXCNT_BF_WID (14)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_LOCKTIMER_MAXCNT_BF_MSK (0x0000FFFC)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_LOCKTIMER_MAXCNT_BF_DEF (0x00008B10)

///< Selects when to enter &quot;locked state&quot; (which starts VREG
///< tracking loop, DTR temp tracking, feed-forward gain adaptive loop
///< and min/max capture):                         0: counter based lock
///< 1: Phase lock sticky high
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_PLLLOCK_STATE_SEL_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_PLLLOCK_STATE_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_PLLLOCK_STATE_SEL_BF_MSK (0x00010000)
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_CFG_PLLLOCK_STATE_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_TDC_DCO0 register description at address offset 0x44
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_tdc_dco0
  * LCPLL_RO_TDC_DCO0 Register
  */

typedef union {
  struct {
    uint32_t MIN_TDCEFF : 6;
    ///< TDC min value captured.                         2's complement code,
    ///< integer only, after feed-forward cancelation.
    ///< Capture starts at &quot;&quot;locked state&quot;&quot; and ends when
    ///< min/max counter overflows (reg involved: cfg_dft_cnt_restart, cfg_dft_cnt_alwayson,
    ///< cfg_plllock_state_sel).                         In integer mode, one
    ///< should add 0.5.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t MAX_TDCEFF : 6;
    ///< TDC max value captured. See min_tdceff for more details.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t MIN_PKSEN_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::RO_TDC_DCO0::min_pksen_vref_sel
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t MAX_PKSEN_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::RO_TDC_DCO0::max_pksen_vref_sel
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_tdc_dco0_reg_t;

#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_RD_MASK (0x00ffffffU)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_WR_MASK (0x00000000U)


///< TDC min value captured.                         2's complement code,
///< integer only, after feed-forward cancelation.
///< Capture starts at &quot;&quot;locked state&quot;&quot; and ends when
///< min/max counter overflows (reg involved: cfg_dft_cnt_restart, cfg_dft_cnt_alwayson,
///< cfg_plllock_state_sel).                         In integer mode, one
///< should add 0.5.
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_TDCEFF_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_TDCEFF_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_TDCEFF_BF_MSK (0x0000003F)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_TDCEFF_BF_DEF (0x00000000)

///< TDC max value captured. See min_tdceff for more details.
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_TDCEFF_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_TDCEFF_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_TDCEFF_BF_MSK (0x00000FC0)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_TDCEFF_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_TDC_DCO0::min_pksen_vref_sel
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_PKSEN_VREF_SEL_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_PKSEN_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_PKSEN_VREF_SEL_BF_MSK (0x0003F000)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MIN_PKSEN_VREF_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_TDC_DCO0::max_pksen_vref_sel
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_PKSEN_VREF_SEL_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_PKSEN_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_PKSEN_VREF_SEL_BF_MSK (0x00FC0000)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_MAX_PKSEN_VREF_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_TDC_DCO1 register description at address offset 0x48
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_tdc_dco1
  * LCPLL_RO_TDC_DCO1 Register
  */

typedef union {
  struct {
    uint32_t MIN_CSELFINE : 8;
    ///< min fine code captured.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t MAX_CSELFINE : 8;
    ///< max fine code captured.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t CURR_TDC_TRIM : 2;
    ///< Current TDC ladder trim code
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t KPKI_COMPENSATE : 2;
    ///< SERDES_LANE_ANA_PLL::RO_TDC_DCO1::kpki_compensate
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t VTDC_CALIB_LADDER_MEAS : 8;
    ///< SERDES_LANE_ANA_PLL::RO_TDC_DCO1::vtdc_calib_ladder_meas
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_tdc_dco1_reg_t;

#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_RD_MASK (0x0fffffffU)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_WR_MASK (0x00000000U)


///< min fine code captured.
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MIN_CSELFINE_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MIN_CSELFINE_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MIN_CSELFINE_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MIN_CSELFINE_BF_DEF (0x00000000)

///< max fine code captured.
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MAX_CSELFINE_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MAX_CSELFINE_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MAX_CSELFINE_BF_MSK (0x0000FF00)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_MAX_CSELFINE_BF_DEF (0x00000000)

///< Current TDC ladder trim code
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_CURR_TDC_TRIM_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_CURR_TDC_TRIM_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_CURR_TDC_TRIM_BF_MSK (0x00030000)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_CURR_TDC_TRIM_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_TDC_DCO1::kpki_compensate
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_KPKI_COMPENSATE_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_KPKI_COMPENSATE_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_KPKI_COMPENSATE_BF_MSK (0x000C0000)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_KPKI_COMPENSATE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_TDC_DCO1::vtdc_calib_ladder_meas
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_VTDC_CALIB_LADDER_MEAS_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_VTDC_CALIB_LADDER_MEAS_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_VTDC_CALIB_LADDER_MEAS_BF_MSK (0x0FF00000)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_VTDC_CALIB_LADDER_MEAS_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_TDC_DCO2 register description at address offset 0x4c
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_tdc_dco2
  * SERDES_LANE_ANA_PLL::RO_TDC_DCO2
  */

typedef union {
  struct {
    uint32_t MIN_FEEDFWRDGAIN : 10;
    ///< min feed-forward gain code captured.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t MAX_FEEDFWRDGAIN : 10;
    ///< max feed-forward gain code captured.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t MIN_LDODCO_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::RO_TDC_DCO2::min_ldodco_vref_sel
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t MAX_LDODCO_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::RO_TDC_DCO2::max_ldodco_vref_sel
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_tdc_dco2_reg_t;

#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_WR_MASK (0x00000000U)


///< min feed-forward gain code captured.
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_FEEDFWRDGAIN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_FEEDFWRDGAIN_BF_WID (10)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_FEEDFWRDGAIN_BF_MSK (0x000003FF)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_FEEDFWRDGAIN_BF_DEF (0x00000000)

///< max feed-forward gain code captured.
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_FEEDFWRDGAIN_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_FEEDFWRDGAIN_BF_WID (10)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_FEEDFWRDGAIN_BF_MSK (0x000FFC00)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_FEEDFWRDGAIN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_TDC_DCO2::min_ldodco_vref_sel
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_LDODCO_VREF_SEL_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_LDODCO_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_LDODCO_VREF_SEL_BF_MSK (0x03F00000)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MIN_LDODCO_VREF_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_TDC_DCO2::max_ldodco_vref_sel
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_LDODCO_VREF_SEL_BF_OFF (26)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_LDODCO_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_LDODCO_VREF_SEL_BF_MSK (0xFC000000)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_MAX_LDODCO_VREF_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_TDC_DCO3 register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_tdc_dco3
  * SERDES_LANE_ANA_PLL::RO_TDC_DCO3
  */

typedef union {
  struct {
    uint32_t FINEOUT_LOCK : 8;
    ///< Captures integer fine code when &quot;locked_state&quot; asserted.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FILTER_ACCUM : 16;
    ///< SERDES_LANE_ANA_PLL::RO_TDC_DCO3::filter_accum
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_tdc_dco3_reg_t;

#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_RD_MASK (0x00ffffffU)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_WR_MASK (0x00000000U)


///< Captures integer fine code when &quot;locked_state&quot; asserted.
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FINEOUT_LOCK_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FINEOUT_LOCK_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FINEOUT_LOCK_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FINEOUT_LOCK_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_TDC_DCO3::filter_accum
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FILTER_ACCUM_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FILTER_ACCUM_BF_WID (16)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FILTER_ACCUM_BF_MSK (0x00FFFF00)
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_FILTER_ACCUM_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_CALIB0 register description at address offset 0x54
  *
  * Register default value:        0x801FDFD1
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_calib0
  * LCPLL_CALIB0 Register
  */

typedef union {
  struct {
    uint32_t CFG_COARSE_LOOP_GSCALE_MAX : 4;
    ///< Initial DTR FLL gain value (2's complement, 2^gscale).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t CFG_COARSE_LOOP_GSCALE_MIN : 4;
    ///< Final DTR FLL gain value (2's complement, 2^gscale).
    ///< AccessType="RW" BitOffset="4" ResetValue="0xD"
    uint32_t CFG_COARSE_LOOP_GSCALE_CNT_MAX : 5;
    ///< Duration (in refclk cycles) of each gain in DTR FLL.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x1F"
    uint32_t CFG_DCOCOARSE_OVRDEN : 1;
    ///< DCO DTR FLL override enable. (DTR PLL would still work as usual)
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CFG_DCOCOARSE_OVRD : 8;
    ///< DCO DTR FLL override value when dtr_ovrden=1.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x7F"
    uint32_t CFG_BOOSTGAIN_MAXCNT : 10;
    ///< Duration (in fbclk cycles) of each gain in PLL boost, for both DTR
    ///< and fine loops.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x200"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_calib0_reg_t;

#define PMA_ANACMNPLL_MSG_CALIB0_DEFAULT (0x801fdfd1U)
#define PMA_ANACMNPLL_MSG_CALIB0_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_CALIB0_WR_MASK (0xffffffffU)


///< Initial DTR FLL gain value (2's complement, 2^gscale).
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MAX_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MAX_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MAX_BF_MSK (0x0000000F)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MAX_BF_DEF (0x00000001)

///< Final DTR FLL gain value (2's complement, 2^gscale).
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MIN_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MIN_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MIN_BF_MSK (0x000000F0)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_MIN_BF_DEF (0x000000D0)

///< Duration (in refclk cycles) of each gain in DTR FLL.
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_CNT_MAX_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_CNT_MAX_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_CNT_MAX_BF_MSK (0x00001F00)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_COARSE_LOOP_GSCALE_CNT_MAX_BF_DEF (0x00001F00)

///< DCO DTR FLL override enable. (DTR PLL would still work as usual)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRDEN_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRDEN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRDEN_BF_MSK (0x00002000)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRDEN_BF_DEF (0x00000000)

///< DCO DTR FLL override value when dtr_ovrden=1.
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRD_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRD_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRD_BF_MSK (0x003FC000)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_DCOCOARSE_OVRD_BF_DEF (0x001FC000)

///< Duration (in fbclk cycles) of each gain in PLL boost, for both DTR
///< and fine loops.
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_BOOSTGAIN_MAXCNT_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_BOOSTGAIN_MAXCNT_BF_WID (10)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_BOOSTGAIN_MAXCNT_BF_MSK (0xFFC00000)
#define PMA_ANACMNPLL_MSG_CALIB0_CFG_BOOSTGAIN_MAXCNT_BF_DEF (0x80000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_CALIB1 register description at address offset 0x58
  *
  * Register default value:        0x310420C7
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_calib1
  * SERDES_LANE_ANA_PLL::CALIB1
  */

typedef union {
  struct {
    uint32_t CFG_FILTER_BOOSTFADE_FINE_EN : 1;
    ///< When 1, fine PLL boost will gradually lower to zero in steps of 1.
    ///< When 0, fine PLL boost will change from initial boost to zero at once.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t CFG_FINE_PROP_COEFF_BOOST_VAL : 4;
    ///< Fine PLL Kp boost. Unsigned value
    ///< AccessType="RW" BitOffset="1" ResetValue="0x3"
    uint32_t CFG_FINE_INT_COEFF_BOOST_VAL : 5;
    ///< Fine PLL Ki boost. Unsigned value
    ///< AccessType="RW" BitOffset="5" ResetValue="0x6"
    uint32_t CFG_BOOST_FINE_CONST_ZETA : 1;
    ///< Not needed. not validated                         If set to 1, FINE
    ///< Ki boost value will be twice as big as the FINE Kp boost value.
    ///< This will ensure that the zeta (damping factor) will remain constant
    ///< during the boost phase.                         This mode can only
    ///< be used in case the Kp boost is no larger than 3.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CFG_FULL_RANGE_AFC_SEL : 1;
    ///< Limit AFC code.                         0 - Limit AFC code to max
    ///< value of 319.                         1 - Full range AFC code (0 -
    ///< 511).
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_SEC_AFC_CALIB_BINARY : 1;
    ///< SERDES_LANE_ANA_PLL::CALIB1::cfg_sec_afc_calib_binary
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_FINE_PROP_COEFF_BOOST_STEP : 4;
    ///< FINE PLL loop proportional gain boosting decrement step size during
    ///< gradual boost.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x1"
    uint32_t CFG_FINE_INT_COEFF_BOOST_STEP : 5;
    ///< FINE PLL loop integral gain boosting decrement step size during gradual
    ///< boost.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x2"
    uint32_t CFG_FINE_PROP_COEFF : 4;
    ///< Fine Kp = 2^(-reg)
    ///< AccessType="RW" BitOffset="22" ResetValue="0x4"
    uint32_t CFG_FINE_INT_COEFF : 5;
    ///< Fine Ki = 2^(-reg)
    ///< AccessType="RW" BitOffset="26" ResetValue="0xC"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_calib1_reg_t;

#define PMA_ANACMNPLL_MSG_CALIB1_DEFAULT (0x310420c7U)
#define PMA_ANACMNPLL_MSG_CALIB1_RD_MASK (0x7fffffffU)
#define PMA_ANACMNPLL_MSG_CALIB1_WR_MASK (0x7fffffffU)


///< When 1, fine PLL boost will gradually lower to zero in steps of 1.
///< When 0, fine PLL boost will change from initial boost to zero at once.
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FILTER_BOOSTFADE_FINE_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FILTER_BOOSTFADE_FINE_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FILTER_BOOSTFADE_FINE_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FILTER_BOOSTFADE_FINE_EN_BF_DEF (0x00000001)

///< Fine PLL Kp boost. Unsigned value
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_VAL_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_VAL_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_VAL_BF_MSK (0x0000001E)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_VAL_BF_DEF (0x00000006)

///< Fine PLL Ki boost. Unsigned value
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_VAL_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_VAL_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_VAL_BF_MSK (0x000003E0)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_VAL_BF_DEF (0x000000C0)

///< Not needed. not validated                         If set to 1, FINE
///< Ki boost value will be twice as big as the FINE Kp boost value.
///< This will ensure that the zeta (damping factor) will remain constant
///< during the boost phase.                         This mode can only
///< be used in case the Kp boost is no larger than 3.
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_BOOST_FINE_CONST_ZETA_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_BOOST_FINE_CONST_ZETA_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_BOOST_FINE_CONST_ZETA_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_BOOST_FINE_CONST_ZETA_BF_DEF (0x00000000)

///< Limit AFC code.                         0 - Limit AFC code to max
///< value of 319.                         1 - Full range AFC code (0 -
///< 511).
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FULL_RANGE_AFC_SEL_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FULL_RANGE_AFC_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FULL_RANGE_AFC_SEL_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FULL_RANGE_AFC_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::CALIB1::cfg_sec_afc_calib_binary
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_SEC_AFC_CALIB_BINARY_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_SEC_AFC_CALIB_BINARY_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_SEC_AFC_CALIB_BINARY_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_SEC_AFC_CALIB_BINARY_BF_DEF (0x00000000)

///< FINE PLL loop proportional gain boosting decrement step size during
///< gradual boost.
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_STEP_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_STEP_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_STEP_BF_MSK (0x0001E000)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BOOST_STEP_BF_DEF (0x00002000)

///< FINE PLL loop integral gain boosting decrement step size during gradual
///< boost.
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_STEP_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_STEP_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_STEP_BF_MSK (0x003E0000)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BOOST_STEP_BF_DEF (0x00040000)

///< Fine Kp = 2^(-reg)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BF_MSK (0x03C00000)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_PROP_COEFF_BF_DEF (0x01000000)

///< Fine Ki = 2^(-reg)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BF_OFF (26)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BF_MSK (0x7C000000)
#define PMA_ANACMNPLL_MSG_CALIB1_CFG_FINE_INT_COEFF_BF_DEF (0x30000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_CALIB2 register description at address offset 0x5c
  *
  * Register default value:        0x00013812
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_calib2
  * SERDES_LANE_ANA_PLL::CALIB2
  */

typedef union {
  struct {
    uint32_t CFG_TDCBBPD_EN : 1;
    ///< Switches TDC into bang-bang mode, based on timer (cfg_tdcbbpd_cnt_limit).
    ///< If enabled, cfg_tdc_ladder_min register must be configured to 1 or
    ///< greater.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_TDCBBPD_CNT_LIMIT : 4;
    ///< Determines the number of refclk cycles from lock timer done until
    ///< TDC turns into bang-bang mode: 2 ^ cfg_tdcbbpd_cnt_limit.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x9"
    uint32_t CFG_GAINCAL_UPDATE_RATE : 4;
    ///< This field sets the rate of adaptive feed-forward gain.
    ///< Every time the modulated feedback divider ratio is 0.5 or more away
    ///< from the target                          ratio (with frac code), the
    ///< feed-forward gain loop checks the amount of change in
    ///< TDC effective (after feed-forward cancelation) and based on the sign
    ///< of that change                          it would increment/decrement
    ///< the feed-forward gain.                          Then this register
    ///< determines every how many adaptive-ffgain checks the gain will
    ///< actually be updated. This technique could be useful if ratio is around
    ///< 0.5, to avoid                          too frequent gain updates (which
    ///< could cause stability problems in the loop).
    ///< The adaptive ffgain loop will react every 2 ^ cfg_gaincal_update_rate
    ///< gain checks
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CFG_REFCLK_CYCLES_PER_1US_MAXCNT : 8;
    ///< This signal defines the number of refclk cycles that fit in 1us.
    ///< Used in VREG loop in steady-state, such that whenever DAC code is
    ///< updated, we wait some time based on this counter before start sensing
    ///< the comparator.                         Could be used potentially
    ///< in the future for other timers as well.                         Use
    ///< the following formula:                         Frefclk x 1usec
    ///< AccessType="RW" BitOffset="9" ResetValue="0x9C"
    uint32_t CFG_SCOVRDEN : 1;
    ///< Super coarse overwrite enable.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t CFG_SCOVRD : 4;
    ///< Super coarse overwrite value.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_calib2_reg_t;

#define PMA_ANACMNPLL_MSG_CALIB2_DEFAULT (0x00013812U)
#define PMA_ANACMNPLL_MSG_CALIB2_RD_MASK (0x003fffffU)
#define PMA_ANACMNPLL_MSG_CALIB2_WR_MASK (0x003fffffU)


///< Switches TDC into bang-bang mode, based on timer (cfg_tdcbbpd_cnt_limit).
///< If enabled, cfg_tdc_ladder_min register must be configured to 1 or
///< greater.
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_EN_BF_DEF (0x00000000)

///< Determines the number of refclk cycles from lock timer done until
///< TDC turns into bang-bang mode: 2 ^ cfg_tdcbbpd_cnt_limit.
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_CNT_LIMIT_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_CNT_LIMIT_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_CNT_LIMIT_BF_MSK (0x0000001E)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_TDCBBPD_CNT_LIMIT_BF_DEF (0x00000012)

///< This field sets the rate of adaptive feed-forward gain.
///< Every time the modulated feedback divider ratio is 0.5 or more away
///< from the target                          ratio (with frac code), the
///< feed-forward gain loop checks the amount of change in
///< TDC effective (after feed-forward cancelation) and based on the sign
///< of that change                          it would increment/decrement
///< the feed-forward gain.                          Then this register
///< determines every how many adaptive-ffgain checks the gain will
///< actually be updated. This technique could be useful if ratio is around
///< 0.5, to avoid                          too frequent gain updates (which
///< could cause stability problems in the loop).
///< The adaptive ffgain loop will react every 2 ^ cfg_gaincal_update_rate
///< gain checks
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_GAINCAL_UPDATE_RATE_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_GAINCAL_UPDATE_RATE_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_GAINCAL_UPDATE_RATE_BF_MSK (0x000001E0)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_GAINCAL_UPDATE_RATE_BF_DEF (0x00000000)

///< This signal defines the number of refclk cycles that fit in 1us.
///< Used in VREG loop in steady-state, such that whenever DAC code is
///< updated, we wait some time based on this counter before start sensing
///< the comparator.                         Could be used potentially
///< in the future for other timers as well.                         Use
///< the following formula:                         Frefclk x 1usec
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_REFCLK_CYCLES_PER_1US_MAXCNT_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_REFCLK_CYCLES_PER_1US_MAXCNT_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_REFCLK_CYCLES_PER_1US_MAXCNT_BF_MSK (0x0001FE00)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_REFCLK_CYCLES_PER_1US_MAXCNT_BF_DEF (0x00013800)

///< Super coarse overwrite enable.
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRDEN_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRDEN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRDEN_BF_MSK (0x00020000)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRDEN_BF_DEF (0x00000000)

///< Super coarse overwrite value.
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRD_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRD_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRD_BF_MSK (0x003C0000)
#define PMA_ANACMNPLL_MSG_CALIB2_CFG_SCOVRD_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_PLL_FSM_CONTROL register description at address offset 0x60
  *
  * Register default value:        0x0000020E
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_pll_fsm_control
  * SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL
  */

typedef union {
  struct {
    uint32_t CFG_DCOSETTLE_MODE : 1;
    ///< Settling time exit mode. VREG calibration and all rest of PLL FSM
    ///< would start only after DCO has settle                         '1':
    ///< fbclk detected                         '0': timer
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_DCOSETTLE_TIME : 4;
    ///< DCO settling time timer (cfg_dcosettle_mode=0).
    ///< refclk cycles = 2^reg
    ///< AccessType="RW" BitOffset="1" ResetValue="0x7"
    uint32_t CFG_SKIP_STDC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_stdc_calib
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CFG_STAY_STDC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_stdc_calib
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CFG_SKIP_VTDC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_vtdc_calib
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CFG_STAY_VTDC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_vtdc_calib
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_SKIP_SC_CALIB : 1;
    ///< Skip the sc calib.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x1"
    uint32_t CFG_STAY_SC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_sc_calib
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CFG_SKIP_FIRST_AFC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_first_afc_calib
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_STAY_FIRST_AFC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_first_afc_calib
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_SKIP_DCO_SWING_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_dco_swing_calib
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CFG_STAY_DCO_SWING_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_dco_swing_calib
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CFG_SKIP_KVCC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_kvcc_calib
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t CFG_STAY_KVCC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_kvcc_calib
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_SKIP_SECOND_AFC_CALIB : 1;
    ///< If set to 1, the PLL will only run one afc calibration before kvcc
    ///< calibration                         If set to 0, the PLL will run
    ///< the AFC calibration for the second time after kvcc calibration ends.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t CFG_STAY_SECOND_AFC_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_second_afc_calib
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t CFG_SKIP_FINE_FLL_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_fine_fll_calib
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t CFG_STAY_FINE_FLL_CALIB : 1;
    ///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_fine_fll_calib
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_pll_fsm_ctrl_reg_t;

#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_DEFAULT (0x0000020eU)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_RD_MASK (0x001fffffU)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_WR_MASK (0x001fffffU)


///< Settling time exit mode. VREG calibration and all rest of PLL FSM
///< would start only after DCO has settle                         '1':
///< fbclk detected                         '0': timer
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_MODE_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_MODE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_MODE_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_MODE_BF_DEF (0x00000000)

///< DCO settling time timer (cfg_dcosettle_mode=0).
///< refclk cycles = 2^reg
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_TIME_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_TIME_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_TIME_BF_MSK (0x0000001E)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_DCOSETTLE_TIME_BF_DEF (0x0000000E)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_stdc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_STDC_CALIB_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_STDC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_STDC_CALIB_BF_MSK (0x00000020)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_STDC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_stdc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_STDC_CALIB_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_STDC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_STDC_CALIB_BF_MSK (0x00000040)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_STDC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_vtdc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_VTDC_CALIB_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_VTDC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_VTDC_CALIB_BF_MSK (0x00000080)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_VTDC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_vtdc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_VTDC_CALIB_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_VTDC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_VTDC_CALIB_BF_MSK (0x00000100)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_VTDC_CALIB_BF_DEF (0x00000000)

///< Skip the sc calib.
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SC_CALIB_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SC_CALIB_BF_MSK (0x00000200)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SC_CALIB_BF_DEF (0x00000200)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_sc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SC_CALIB_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SC_CALIB_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_first_afc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FIRST_AFC_CALIB_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FIRST_AFC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FIRST_AFC_CALIB_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FIRST_AFC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_first_afc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FIRST_AFC_CALIB_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FIRST_AFC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FIRST_AFC_CALIB_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FIRST_AFC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_dco_swing_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_DCO_SWING_CALIB_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_DCO_SWING_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_DCO_SWING_CALIB_BF_MSK (0x00002000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_DCO_SWING_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_dco_swing_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_DCO_SWING_CALIB_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_DCO_SWING_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_DCO_SWING_CALIB_BF_MSK (0x00004000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_DCO_SWING_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_kvcc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_KVCC_CALIB_BF_OFF (15)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_KVCC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_KVCC_CALIB_BF_MSK (0x00008000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_KVCC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_kvcc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_KVCC_CALIB_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_KVCC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_KVCC_CALIB_BF_MSK (0x00010000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_KVCC_CALIB_BF_DEF (0x00000000)

///< If set to 1, the PLL will only run one afc calibration before kvcc
///< calibration                         If set to 0, the PLL will run
///< the AFC calibration for the second time after kvcc calibration ends.
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SECOND_AFC_CALIB_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SECOND_AFC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SECOND_AFC_CALIB_BF_MSK (0x00020000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_SECOND_AFC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_second_afc_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SECOND_AFC_CALIB_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SECOND_AFC_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SECOND_AFC_CALIB_BF_MSK (0x00040000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_SECOND_AFC_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_skip_fine_fll_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FINE_FLL_CALIB_BF_OFF (19)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FINE_FLL_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FINE_FLL_CALIB_BF_MSK (0x00080000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_SKIP_FINE_FLL_CALIB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::PLL_FSM_CONTROL::cfg_stay_fine_fll_calib
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FINE_FLL_CALIB_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FINE_FLL_CALIB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FINE_FLL_CALIB_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_CFG_STAY_FINE_FLL_CALIB_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_TEMP_TRACKING register description at address offset 0x64
  *
  * Register default value:        0x00000027
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_temp_tracking
  * SERDES_LANE_ANA_PLL::TEMP_TRACKING
  */

typedef union {
  struct {
    uint32_t CFG_TEMP_TRACK_EN : 1;
    ///< Enable signal for the FINE and DTR temperature tracking feature.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t CFG_FINE2DTR_RATIO : 6;
    ///< Sets the ratio between DTR cap and fine cap. Required for DTR temp
    ///< tracking.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x13"
    uint32_t CFG_SSC_TRACK_EN : 1;
    ///< Set this to '1' for SSC'ed refclk to enable fast cap-swap during boost
    ///< mode.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_temp_tracking_reg_t;

#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_DEFAULT (0x00000027U)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_RD_MASK (0x000000ffU)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_WR_MASK (0x000000ffU)


///< Enable signal for the FINE and DTR temperature tracking feature.
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_TEMP_TRACK_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_TEMP_TRACK_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_TEMP_TRACK_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_TEMP_TRACK_EN_BF_DEF (0x00000001)

///< Sets the ratio between DTR cap and fine cap. Required for DTR temp
///< tracking.
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_FINE2DTR_RATIO_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_FINE2DTR_RATIO_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_FINE2DTR_RATIO_BF_MSK (0x0000007E)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_FINE2DTR_RATIO_BF_DEF (0x00000026)

///< Set this to '1' for SSC'ed refclk to enable fast cap-swap during boost
///< mode.
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_SSC_TRACK_EN_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_SSC_TRACK_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_SSC_TRACK_EN_BF_MSK (0x00000080)
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_CFG_SSC_TRACK_EN_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_ANA_CONTROL1 register description at address offset 0x68
  *
  * Register default value:        0x00000452
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ana_control1
  * LCPLL_ANA_CONTROL Register
  */

typedef union {
  struct {
    uint32_t CFG_PLL_BYPASS : 1;
    ///< When 1, the following output clocks will drive out the input refclk
    ///< (after prediv). Relevant to common PLL only.
    ///< 100MHz refclk                         156.25MHz refclk
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_SDDIV_EN : 1;
    ///< Ungates dco/2 clock that goes into filter's SD post divider.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t CFG_SDDIV_RATIO : 3;
    ///< Sets Fine and DTR SD clock division ratio, from 1 to 5. Input clock
    ///< is dco/2 so possible ratios are 2,4,6,8,10.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x4"
    uint32_t CFG_SD2F0_CLK_SEL : 1;
    ///< Sets DTR SD clock division ratio:                         0 - fine
    ///< SD clock                         1 - fine SD clock further divided
    ///< by 2
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CFG_PREDIV_RATIO : 4;
    ///< Refclk pre-divider ratio, from 1 to 5, relevant only to lane PLL where
    ///< refclksel pin is tied to 0.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint32_t CFG_REFCLK4LANEDIV_EN : 1;
    ///< Ungates dco/2 clock that goes into refclk156div post divider.
    ///< 1 - common PLL                         0 - lane PLL
    ///< AccessType="RW" BitOffset="10" ResetValue="0x1"
    uint32_t CFG_FBDIV_ENB : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL1::cfg_fbdiv_enb
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_DCODIV2_EN : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL1::cfg_dcodiv2_en
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="13" ResetValue="None"
    uint32_t CFG_HSMON0_SEL : 4;
    ///< Select signal for obsmux0:                         0: vss
    ///< 1: iclk_int_refclk                         2: o_fbclk2obs_clk
    ///< 3: iclk_dco_divby2                         4: iclk_dco_divby5
    ///< 5: a2f_lv_0p9_2obs                         6: vss
    ///< 7: cbdiv56_lanediv32_clk                         8: clk_to_pcs40_clk
    ///< 9: clk_to_pcs33_34_clk                         A: o_sd_dtr_clk
    ///< B: o_sd_fine_clk                         C: ock_a2f_lv_ldo
    ///< D: otdc_calib_clk                         E: i_plllock
    ///< F: i_visa8to1_2obs
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_HSMON0_40INV_EN : 1;
    ///< When 0, selected signal on hsmon0 is further delayed by 40 inverters.
    ///< This is to analyze thermal noise and supply noise jitter
    ///< Note that lately we found that this mode is set when this reg is set
    ///< to 0 (rather than 1 as previously thought)
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t CFG_HSMON1_SEL : 4;
    ///< Select signal for obsmux1. Same signals as in obsmux0.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t CFG_HSMON1_40INV_EN : 1;
    ///< When 0, selected signal on hsmon1 is further delayed by 40 inverters.
    ///< This is to analyze thermal noise and supply noise jitter
    ///< Note that lately we found that this mode is set when this reg is set
    ///< to 0 (rather than 1 as previously thought)
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t CFG_CLK2POSTDIV_DIV2_SEL : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL1::cfg_clk2postdiv_div2_sel
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ana_ctrl1_reg_t;

#define PMA_ANACMNPLL_MSG_ANA_CTRL1_DEFAULT (0x00000452U)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_RD_MASK (0x07ff1fffU)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_WR_MASK (0x07ff1fffU)


///< When 1, the following output clocks will drive out the input refclk
///< (after prediv). Relevant to common PLL only.
///< 100MHz refclk                         156.25MHz refclk
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PLL_BYP_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PLL_BYP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PLL_BYP_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PLL_BYP_BF_DEF (0x00000000)

///< Ungates dco/2 clock that goes into filter's SD post divider.
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_EN_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_EN_BF_MSK (0x00000002)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_EN_BF_DEF (0x00000002)

///< Sets Fine and DTR SD clock division ratio, from 1 to 5. Input clock
///< is dco/2 so possible ratios are 2,4,6,8,10.
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_RATIO_BF_OFF ( 2)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_RATIO_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_RATIO_BF_MSK (0x0000001C)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SDDIV_RATIO_BF_DEF (0x00000010)

///< Sets DTR SD clock division ratio:                         0 - fine
///< SD clock                         1 - fine SD clock further divided
///< by 2
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SD2F0_CLK_SEL_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SD2F0_CLK_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SD2F0_CLK_SEL_BF_MSK (0x00000020)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_SD2F0_CLK_SEL_BF_DEF (0x00000000)

///< Refclk pre-divider ratio, from 1 to 5, relevant only to lane PLL where
///< refclksel pin is tied to 0.
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PREDIV_RATIO_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PREDIV_RATIO_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PREDIV_RATIO_BF_MSK (0x000003C0)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_PREDIV_RATIO_BF_DEF (0x00000040)

///< Ungates dco/2 clock that goes into refclk156div post divider.
///< 1 - common PLL                         0 - lane PLL
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_REFCLK4LANEDIV_EN_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_REFCLK4LANEDIV_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_REFCLK4LANEDIV_EN_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_REFCLK4LANEDIV_EN_BF_DEF (0x00000400)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL1::cfg_fbdiv_enb
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_FBDIV_ENB_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_FBDIV_ENB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_FBDIV_ENB_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_FBDIV_ENB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL1::cfg_dcodiv2_en
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_DCODIV2_EN_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_DCODIV2_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_DCODIV2_EN_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_DCODIV2_EN_BF_DEF (0x00000000)

///< Select signal for obsmux0:                         0: vss
///< 1: iclk_int_refclk                         2: o_fbclk2obs_clk
///< 3: iclk_dco_divby2                         4: iclk_dco_divby5
///< 5: a2f_lv_0p9_2obs                         6: vss
///< 7: cbdiv56_lanediv32_clk                         8: clk_to_pcs40_clk
///< 9: clk_to_pcs33_34_clk                         A: o_sd_dtr_clk
///< B: o_sd_fine_clk                         C: ock_a2f_lv_ldo
///< D: otdc_calib_clk                         E: i_plllock
///< F: i_visa8to1_2obs
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_SEL_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_SEL_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_SEL_BF_MSK (0x000F0000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_SEL_BF_DEF (0x00000000)

///< When 0, selected signal on hsmon0 is further delayed by 40 inverters.
///< This is to analyze thermal noise and supply noise jitter
///< Note that lately we found that this mode is set when this reg is set
///< to 0 (rather than 1 as previously thought)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_40INV_EN_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_40INV_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_40INV_EN_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON0_40INV_EN_BF_DEF (0x00000000)

///< Select signal for obsmux1. Same signals as in obsmux0.
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_SEL_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_SEL_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_SEL_BF_MSK (0x01E00000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_SEL_BF_DEF (0x00000000)

///< When 0, selected signal on hsmon1 is further delayed by 40 inverters.
///< This is to analyze thermal noise and supply noise jitter
///< Note that lately we found that this mode is set when this reg is set
///< to 0 (rather than 1 as previously thought)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_40INV_EN_BF_OFF (25)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_40INV_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_40INV_EN_BF_MSK (0x02000000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_HSMON1_40INV_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL1::cfg_clk2postdiv_div2_sel
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_CLK2POSTDIV_DIV2_SEL_BF_OFF (26)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_CLK2POSTDIV_DIV2_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_CLK2POSTDIV_DIV2_SEL_BF_MSK (0x04000000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_CFG_CLK2POSTDIV_DIV2_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_ANA_CONTROL2 register description at address offset 0x6c
  *
  * Register default value:        0x000080A0
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ana_control2
  * SERDES_LANE_ANA_PLL::ANA_CONTROL2
  */

typedef union {
  struct {
    uint32_t CFG_REFCLK_SEL : 1;
    ///< Relevant only if id_pll_refclksel[2:0] (on PLL interface) is set to
    ///< 3'b0.                         Selects the refclk source for the PLL:
    ///< 3'h0 : vss                         3'h1 : ref_clk_1
    ///< 3'h2 : ref_clk_2                         3'h3 : ref_clk_3
    ///< 3'h4 : ref_clk_4                         3'h5 : ref_clk_5
    ///< 3'h6 : vss                         3'h7 : vss
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_REFCLK4LANE_DIVRATIO : 10;
    ///< Division ratio for refclk156 post divider (input clock is dco).
    ///< AccessType="RW" BitOffset="1" ResetValue="0x50"
    uint32_t CFG_A2F_CLKREG_EN : 1;
    ///< Enables A2F.                         A2F are used to measure internal
    ///< supply noise.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_A2F_CLKUNREG_EN : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_a2f_clkunreg_en
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_A2F_LDO_DCO_EN : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_a2f_ldo_dco_en
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CFG_BTI_EN : 1;
    ///< BTI clock gate signal. By default, whenever PLL is off, BTI clock
    ///< drives DCO clock distribution to prevent assymetric Aging. Setting
    ///< this register to '1' will gate BTI clock.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CFG_DCO_ACBUF2TX_EN : 1;
    ///< Used as LDO enable.                         Gated by pll enable.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x1"
    uint32_t CFG_HSCNTR_HSCLK_SEL_OVR : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_hscntr_hsclk_sel_ovr
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_HSCNTR_HSCLK_SEL_OVR_VAL : 3;
    ///< High speed counter (hscnter) input.                         '0' -
    ///< input from DCO/4 (default)                         '1' - A2F_ldo clock
    ///< is routed to high speed counter, allowing measurement of A2F frequency
    ///< in HVM (like in IDV)                         '2' - A2F_lv clock is
    ///< routed to high speed counter, allowing measurement of A2F frequency
    ///< in HVM (like in IDV)                         '3' - vss
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t CFG_PLL_REFCLK_HSMODE_SEL : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_pll_refclk_hsmode_sel
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ana_ctrl2_reg_t;

#define PMA_ANACMNPLL_MSG_ANA_CTRL2_DEFAULT (0x000080a0U)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_RD_MASK (0x001fffffU)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_WR_MASK (0x001fffffU)


///< Relevant only if id_pll_refclksel[2:0] (on PLL interface) is set to
///< 3'b0.                         Selects the refclk source for the PLL:
///< 3'h0 : vss                         3'h1 : ref_clk_1
///< 3'h2 : ref_clk_2                         3'h3 : ref_clk_3
///< 3'h4 : ref_clk_4                         3'h5 : ref_clk_5
///< 3'h6 : vss                         3'h7 : vss
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK_SEL_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK_SEL_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK_SEL_BF_DEF (0x00000000)

///< Division ratio for refclk156 post divider (input clock is dco).
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK4LANE_DIVRATIO_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK4LANE_DIVRATIO_BF_WID (10)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK4LANE_DIVRATIO_BF_MSK (0x000007FE)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_REFCLK4LANE_DIVRATIO_BF_DEF (0x000000A0)

///< Enables A2F.                         A2F are used to measure internal
///< supply noise.
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKREG_EN_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKREG_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKREG_EN_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKREG_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_a2f_clkunreg_en
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKUNREG_EN_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKUNREG_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKUNREG_EN_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_CLKUNREG_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_a2f_ldo_dco_en
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_LDO_DCO_EN_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_LDO_DCO_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_LDO_DCO_EN_BF_MSK (0x00002000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_A2F_LDO_DCO_EN_BF_DEF (0x00000000)

///< BTI clock gate signal. By default, whenever PLL is off, BTI clock
///< drives DCO clock distribution to prevent assymetric Aging. Setting
///< this register to '1' will gate BTI clock.
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_BTI_EN_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_BTI_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_BTI_EN_BF_MSK (0x00004000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_BTI_EN_BF_DEF (0x00000000)

///< Used as LDO enable.                         Gated by pll enable.
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_DCO_ACBUF2TX_EN_BF_OFF (15)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_DCO_ACBUF2TX_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_DCO_ACBUF2TX_EN_BF_MSK (0x00008000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_DCO_ACBUF2TX_EN_BF_DEF (0x00008000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_hscntr_hsclk_sel_ovr
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_BF_MSK (0x00010000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_BF_DEF (0x00000000)

///< High speed counter (hscnter) input.                         '0' -
///< input from DCO/4 (default)                         '1' - A2F_ldo clock
///< is routed to high speed counter, allowing measurement of A2F frequency
///< in HVM (like in IDV)                         '2' - A2F_lv clock is
///< routed to high speed counter, allowing measurement of A2F frequency
///< in HVM (like in IDV)                         '3' - vss
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_VAL_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_VAL_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_VAL_BF_MSK (0x000E0000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_HSCNTR_HSCLK_SEL_OVR_VAL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL2::cfg_pll_refclk_hsmode_sel
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_PLL_REFCLK_HSMODE_SEL_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_PLL_REFCLK_HSMODE_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_PLL_REFCLK_HSMODE_SEL_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_CFG_PLL_REFCLK_HSMODE_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_ANA_CONTROL3 register description at address offset 0x70
  *
  * Register default value:        0x00A00001
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ana_control3
  * SERDES_LANE_ANA_PLL::ANA_CONTROL3
  */

typedef union {
  struct {
    uint32_t CFG_PKSEN_EN : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_en
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t CFG_PKSEN_COMP : 4;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CFG_PKSEN_COMP_EN : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_en
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CFG_PKSEN_COMP_INN_SEL : 2;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_inn_sel
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CFG_PKSEN_COMP_INP_SEL : 2;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_inp_sel
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_PKSEN_COMP_VREF_VAL : 6;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_vref_val
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CFG_PKSEN_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_vref_sel
    ///< AccessType="RW" BitOffset="16" ResetValue="0x20"
    uint32_t CFG_LDO_PKSEN_BYP : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_ldo_pksen_byp
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t CFG_PKSEN_RES_BYPB : 1;
    ///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_res_bypb
    ///< AccessType="RW" BitOffset="23" ResetValue="0x1"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ana_ctrl3_reg_t;

#define PMA_ANACMNPLL_MSG_ANA_CTRL3_DEFAULT (0x00a00001U)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_RD_MASK (0x00ffffffU)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_WR_MASK (0x00ffffffU)


///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_en
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_EN_BF_DEF (0x00000001)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_BF_MSK (0x0000001E)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_en
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_EN_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_EN_BF_MSK (0x00000020)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_inn_sel
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INN_SEL_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INN_SEL_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INN_SEL_BF_MSK (0x000000C0)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INN_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_inp_sel
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INP_SEL_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INP_SEL_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INP_SEL_BF_MSK (0x00000300)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_INP_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_comp_vref_val
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_VREF_VAL_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_VREF_VAL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_VREF_VAL_BF_MSK (0x0000FC00)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_COMP_VREF_VAL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_vref_sel
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_VREF_SEL_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_VREF_SEL_BF_MSK (0x003F0000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_VREF_SEL_BF_DEF (0x00200000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_ldo_pksen_byp
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_LDO_PKSEN_BYP_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_LDO_PKSEN_BYP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_LDO_PKSEN_BYP_BF_MSK (0x00400000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_LDO_PKSEN_BYP_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::ANA_CONTROL3::cfg_pksen_res_bypb
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_RES_BYPB_BF_OFF (23)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_RES_BYPB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_RES_BYPB_BF_MSK (0x00800000)
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_CFG_PKSEN_RES_BYPB_BF_DEF (0x00800000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DFX0 register description at address offset 0x74
  *
  * Register default value:        0x00040000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_dfx0
  * SERDES_LANE_ANA_PLL::DFX0
  */

typedef union {
  struct {
    uint32_t CFG_FINE_MODULATION_EN : 1;
    ///< Modulates fine code by adding an offset that toggles between values
    ///< defined by cfg_fine_modulation_sel.                          cfg_modulation_toggle_delay
    ///< sets modulation frequency.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_FINE_MODULATION_SEL : 1;
    ///< Sets magnitude of fine modulation:                          0 - fine
    ///< offset toggles between 0 and +1.                         1 - fine
    ///< offset toggles between 0 and cfg_fine2dtr_ratio.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CFG_TDCPE_MODULATION_EN : 1;
    ///< Modulates TDC PE by adding an offset that toggles between 0 and 1.
    ///< cfg_modulation_toggle_delay sets modulation frequency.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CFG_LDO_MODULATION_EN : 1;
    ///< Modulates LDO by adding an offset that toggles between 0 and 1.
    ///< cfg_modulation_toggle_delay sets modulation frequency.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CFG_MODULATION_TOGGLE_DELAY : 4;
    ///< Sets modulation frequency.                         Code would toggle
    ///< every 2^reg refclk cycles.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CFG_VISA8TO1_2OBS_SEL : 3;
    ///< Selects which bit in VISA lane0 would be routed to high speed monitor
    ///< mux.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_DFX_FEEDFWRD_OFFSET_OVR_EN : 1;
    ///< Enables overriding feed forward offset. Useful in integer mode to
    ///< shift fbclk phase.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_DFX_FEEDFWRDPHASE_OVR_VAL : 5;
    ///< Sets feed forward offset override value. Useful in integer mode to
    ///< shift fbclk phase.                         The 9 integer bits, 3 fractional
    ///< bits.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_DFX_DISABLE_DFT_TIMER_OVRD_VAL : 1;
    ///< When cfg_dfx_disable_dft_timer_ovrd_en=1, this bit will set DFT timer
    ///< mode.                          When 0, DFT measurements always run.
    ///< When 1, DFT measurements always off.                          No need
    ///< to change this reg. Just keep it at 0. (could have been removed)
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t CFG_DFX_DISABLE_DFT_TIMER_OVRD_EN : 1;
    ///< When 0, DFT measurements would stop when minmax timer overflows.
    ///< When 1, DFT measurements run based on cfg_dfx_disable_dft_timer_ovrd_val.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x1"
    uint32_t CFG_DPSO_BYPASS_MODE : 1;
    ///< When 0, DPSO bus is sampled by fbclk falling edge before sent to TX
    ///< PISO                         When 1, the sample is bypassed. This
    ///< is needed when monitoring VISA signals that are not of fbclk nor on
    ///< refclk domain.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_dfx0_reg_t;

#define PMA_ANACMNPLL_MSG_DFX0_DEFAULT (0x00040000U)
#define PMA_ANACMNPLL_MSG_DFX0_RD_MASK (0x000fffffU)
#define PMA_ANACMNPLL_MSG_DFX0_WR_MASK (0x000fffffU)


///< Modulates fine code by adding an offset that toggles between values
///< defined by cfg_fine_modulation_sel.                          cfg_modulation_toggle_delay
///< sets modulation frequency.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_EN_BF_DEF (0x00000000)

///< Sets magnitude of fine modulation:                          0 - fine
///< offset toggles between 0 and +1.                         1 - fine
///< offset toggles between 0 and cfg_fine2dtr_ratio.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_SEL_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_SEL_BF_MSK (0x00000002)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_FINE_MOD_SEL_BF_DEF (0x00000000)

///< Modulates TDC PE by adding an offset that toggles between 0 and 1.
///< cfg_modulation_toggle_delay sets modulation frequency.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_TDCPE_MOD_EN_BF_OFF ( 2)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_TDCPE_MOD_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_TDCPE_MOD_EN_BF_MSK (0x00000004)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_TDCPE_MOD_EN_BF_DEF (0x00000000)

///< Modulates LDO by adding an offset that toggles between 0 and 1.
///< cfg_modulation_toggle_delay sets modulation frequency.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_LDO_MOD_EN_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_LDO_MOD_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_LDO_MOD_EN_BF_MSK (0x00000008)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_LDO_MOD_EN_BF_DEF (0x00000000)

///< Sets modulation frequency.                         Code would toggle
///< every 2^reg refclk cycles.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_MOD_TOGGLE_DELAY_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_MOD_TOGGLE_DELAY_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_MOD_TOGGLE_DELAY_BF_MSK (0x000000F0)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_MOD_TOGGLE_DELAY_BF_DEF (0x00000000)

///< Selects which bit in VISA lane0 would be routed to high speed monitor
///< mux.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_VISA8TO1_2OBS_SEL_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_VISA8TO1_2OBS_SEL_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_VISA8TO1_2OBS_SEL_BF_MSK (0x00000700)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_VISA8TO1_2OBS_SEL_BF_DEF (0x00000000)

///< Enables overriding feed forward offset. Useful in integer mode to
///< shift fbclk phase.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRD_OFFSET_OVR_EN_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRD_OFFSET_OVR_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRD_OFFSET_OVR_EN_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRD_OFFSET_OVR_EN_BF_DEF (0x00000000)

///< Sets feed forward offset override value. Useful in integer mode to
///< shift fbclk phase.                         The 9 integer bits, 3 fractional
///< bits.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRDPHASE_OVR_VAL_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRDPHASE_OVR_VAL_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRDPHASE_OVR_VAL_BF_MSK (0x0001F000)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_FEEDFWRDPHASE_OVR_VAL_BF_DEF (0x00000000)

///< When cfg_dfx_disable_dft_timer_ovrd_en=1, this bit will set DFT timer
///< mode.                          When 0, DFT measurements always run.
///< When 1, DFT measurements always off.                          No need
///< to change this reg. Just keep it at 0. (could have been removed)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_VAL_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_VAL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_VAL_BF_MSK (0x00020000)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_VAL_BF_DEF (0x00000000)

///< When 0, DFT measurements would stop when minmax timer overflows.
///< When 1, DFT measurements run based on cfg_dfx_disable_dft_timer_ovrd_val.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_EN_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_EN_BF_MSK (0x00040000)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DFX_DIS_DFT_TIMER_OVRD_EN_BF_DEF (0x00040000)

///< When 0, DPSO bus is sampled by fbclk falling edge before sent to TX
///< PISO                         When 1, the sample is bypassed. This
///< is needed when monitoring VISA signals that are not of fbclk nor on
///< refclk domain.
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DPSO_BYP_MODE_BF_OFF (19)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DPSO_BYP_MODE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DPSO_BYP_MODE_BF_MSK (0x00080000)
#define PMA_ANACMNPLL_MSG_DFX0_CFG_DPSO_BYP_MODE_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DFX1 register description at address offset 0x78
  *
  * Register default value:        0x0001AAAA
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_dfx1
  * SERDES_LANE_ANA_PLL::DFX1
  */

typedef union {
  struct {
    uint32_t CFG_DPSO_MARKER : 16;
    ///< When serializing VISA 8b bus to TX, additional 16 (upper bits) are
    ///< set according to this register which could be used as a marker
    ///< AccessType="RW" BitOffset="0" ResetValue="0xAAAA"
    uint32_t CFG_TDCPE_MODULATION_VAL : 5;
    ///< While cfg_tdcpe_modulation_en=1 define the TDC/STDC amplitude offset
    ///< (integer) during the tdc/stdc modulation.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x1"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_dfx1_reg_t;

#define PMA_ANACMNPLL_MSG_DFX1_DEFAULT (0x0001aaaaU)
#define PMA_ANACMNPLL_MSG_DFX1_RD_MASK (0x001fffffU)
#define PMA_ANACMNPLL_MSG_DFX1_WR_MASK (0x001fffffU)


///< When serializing VISA 8b bus to TX, additional 16 (upper bits) are
///< set according to this register which could be used as a marker
#define PMA_ANACMNPLL_MSG_DFX1_CFG_DPSO_MARKER_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DFX1_CFG_DPSO_MARKER_BF_WID (16)
#define PMA_ANACMNPLL_MSG_DFX1_CFG_DPSO_MARKER_BF_MSK (0x0000FFFF)
#define PMA_ANACMNPLL_MSG_DFX1_CFG_DPSO_MARKER_BF_DEF (0x0000AAAA)

///< While cfg_tdcpe_modulation_en=1 define the TDC/STDC amplitude offset
///< (integer) during the tdc/stdc modulation.
#define PMA_ANACMNPLL_MSG_DFX1_CFG_TDCPE_MOD_VAL_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_DFX1_CFG_TDCPE_MOD_VAL_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_DFX1_CFG_TDCPE_MOD_VAL_BF_MSK (0x001F0000)
#define PMA_ANACMNPLL_MSG_DFX1_CFG_TDCPE_MOD_VAL_BF_DEF (0x00010000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_LDO0 register description at address offset 0x7c
  *
  * Register default value:        0x059002E0
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ldo0
  * SERDES_LANE_ANA_PLL::LDO0
  */

typedef union {
  struct {
    uint32_t CFG_LDOCLK_BETA : 3;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldoclk_beta
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_LDOCLK_BYP : 1;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldoclk_byp
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CFG_LDOCLK_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldoclk_vref_sel
    ///< AccessType="RW" BitOffset="4" ResetValue="0x2E"
    uint32_t CFG_LDODCO_BETA : 3;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_beta
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CFG_LDODCO_BYP : 1;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_byp
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CFG_LDODCO_VREF_RC : 2;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_vref_rc
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CFG_LDODCO_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_vref_sel
    ///< AccessType="RW" BitOffset="16" ResetValue="0x10"
    uint32_t CFG_LDODCO_HIGH_VREF_SEL : 6;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_high_vref_sel
    ///< AccessType="RW" BitOffset="22" ResetValue="0x16"
    uint32_t CFG_LDOREFGEN_BETA : 3;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldorefgen_beta
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t CFG_VREFGEN_BYP : 1;
    ///< SERDES_LANE_ANA_PLL::LDO0::cfg_vrefgen_byp
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ldo0_reg_t;

#define PMA_ANACMNPLL_MSG_LDO0_DEFAULT (0x059002e0U)
#define PMA_ANACMNPLL_MSG_LDO0_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_LDO0_WR_MASK (0xffffffffU)


///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldoclk_beta
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BETA_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BETA_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BETA_BF_MSK (0x00000007)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BETA_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldoclk_byp
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BYP_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BYP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BYP_BF_MSK (0x00000008)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_BYP_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldoclk_vref_sel
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_VREF_SEL_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_VREF_SEL_BF_MSK (0x000003F0)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOCLK_VREF_SEL_BF_DEF (0x000002E0)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_beta
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BETA_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BETA_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BETA_BF_MSK (0x00001C00)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BETA_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_byp
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BYP_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BYP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BYP_BF_MSK (0x00002000)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_BYP_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_vref_rc
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_RC_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_RC_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_RC_BF_MSK (0x0000C000)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_RC_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_vref_sel
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_SEL_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_SEL_BF_MSK (0x003F0000)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_VREF_SEL_BF_DEF (0x00100000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldodco_high_vref_sel
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_HIGH_VREF_SEL_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_HIGH_VREF_SEL_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_HIGH_VREF_SEL_BF_MSK (0x0FC00000)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDODCO_HIGH_VREF_SEL_BF_DEF (0x05800000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_ldorefgen_beta
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOREFGEN_BETA_BF_OFF (28)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOREFGEN_BETA_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOREFGEN_BETA_BF_MSK (0x70000000)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_LDOREFGEN_BETA_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO0::cfg_vrefgen_byp
#define PMA_ANACMNPLL_MSG_LDO0_CFG_VREFGEN_BYP_BF_OFF (31)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_VREFGEN_BYP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_VREFGEN_BYP_BF_MSK (0x80000000)
#define PMA_ANACMNPLL_MSG_LDO0_CFG_VREFGEN_BYP_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_LDO1 register description at address offset 0x80
  *
  * Register default value:        0x000000E0
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ldo1
  * SERDES_LANE_ANA_PLL::LDO1
  */

typedef union {
  struct {
    uint32_t CFG_INV_VPEAK_COMB_FB : 1;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_inv_vpeak_comb_fb
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_LDO_BIAS_SEL : 3;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_bias_sel
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CFG_LDO_BIAS_EXT : 1;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_bias_ext
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CFG_LDO_PKSEN_HIGHZ_B : 1;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_pksen_highz_b
    ///< AccessType="RW" BitOffset="5" ResetValue="0x1"
    uint32_t CFG_LDO_CLK_HIGHZ_B : 1;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_clk_highz_b
    ///< AccessType="RW" BitOffset="6" ResetValue="0x1"
    uint32_t CFG_LDO_DCO_HIGHZ_B : 1;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_dco_highz_b
    ///< AccessType="RW" BitOffset="7" ResetValue="0x1"
    uint32_t CFG_DCMON_SEL : 4;
    ///< Selection pins for DFx MUXs
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_DCMON1_EN : 1;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_dcmon1_en
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_DCMON2_EN : 1;
    ///< SERDES_LANE_ANA_PLL::LDO1::cfg_dcmon2_en
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t  : 18;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ldo1_reg_t;

#define PMA_ANACMNPLL_MSG_LDO1_DEFAULT (0x000000e0U)
#define PMA_ANACMNPLL_MSG_LDO1_RD_MASK (0x00003fffU)
#define PMA_ANACMNPLL_MSG_LDO1_WR_MASK (0x00003fffU)


///< SERDES_LANE_ANA_PLL::LDO1::cfg_inv_vpeak_comb_fb
#define PMA_ANACMNPLL_MSG_LDO1_CFG_INV_VPEAK_COMB_FB_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_INV_VPEAK_COMB_FB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_INV_VPEAK_COMB_FB_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_INV_VPEAK_COMB_FB_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_bias_sel
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_SEL_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_SEL_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_SEL_BF_MSK (0x0000000E)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_bias_ext
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_EXT_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_EXT_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_EXT_BF_MSK (0x00000010)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_BIAS_EXT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_pksen_highz_b
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_PKSEN_HIGHZ_B_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_PKSEN_HIGHZ_B_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_PKSEN_HIGHZ_B_BF_MSK (0x00000020)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_PKSEN_HIGHZ_B_BF_DEF (0x00000020)

///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_clk_highz_b
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_CLK_HIGHZ_B_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_CLK_HIGHZ_B_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_CLK_HIGHZ_B_BF_MSK (0x00000040)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_CLK_HIGHZ_B_BF_DEF (0x00000040)

///< SERDES_LANE_ANA_PLL::LDO1::cfg_ldo_dco_highz_b
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_DCO_HIGHZ_B_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_DCO_HIGHZ_B_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_DCO_HIGHZ_B_BF_MSK (0x00000080)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_LDO_DCO_HIGHZ_B_BF_DEF (0x00000080)

///< Selection pins for DFx MUXs
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON_SEL_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON_SEL_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON_SEL_BF_MSK (0x00000F00)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO1::cfg_dcmon1_en
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON1_EN_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON1_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON1_EN_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON1_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::LDO1::cfg_dcmon2_en
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON2_EN_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON2_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON2_EN_BF_MSK (0x00002000)
#define PMA_ANACMNPLL_MSG_LDO1_CFG_DCMON2_EN_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_KVCC0 register description at address offset 0x84
  *
  * Register default value:        0x080013C5
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_kvcc0
  * SERDES_LANE_ANA_PLL::KVCC0
  */

typedef union {
  struct {
    uint32_t CFG_KVCC_SETTLE_MAXCNT : 8;
    ///< Defines number of refclk cycles from DAC change to frequency measurement
    ///< during Kvcc calibration.                         VREG LPF is in bypass
    ///< mode with constant time is ~1nsec (115ohm*8.3pF).
    ///< Use the following formula:                         Frefclk x 1.26usec
    ///< AccessType="RW" BitOffset="0" ResetValue="0xC5"
    uint32_t CFG_KVCC_MEASURE_MAXCNT : 3;
    ///< Defines number of refclk cycles over which the DCO frequency is measured
    ///< and averaged with high accuracy.                         It is used
    ///< for both Kvcc calibration and DFT frequency measurement mode.
    ///< refclk cycles = 2^(reg+6) - 1
    ///< AccessType="RW" BitOffset="8" ResetValue="0x3"
    uint32_t CFG_KVCCCALIB_LDO_OFFSET : 3;
    ///< Amount of offset to inject into LDO for measuring frequency delta
    ///< that is needed for calibrating Kvcc. (Need to be ~30mv)
    ///< Common: use &quot;2&quot; as the default register value.
    ///< Lane: used &quot;1&quot; as a default override.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x2"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t CFG_DFT_FREQ_MEAS_ENABLE : 1;
    ///< DFT frequency measurement is triggered when this signal transitions
    ///< from 0 to 1.                         Make sure to set cfg_dfx_disable_dft_timer_ovrd_en=1
    ///< so that HS counter would remain active and cfg_kvcc_measure_maxcnt
    ///< to define number of refclk cycles.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_NOTCH_OFFSET : 3;
    ///< Sets how many thermo bits to turn off from the notch filter
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t CFG_FULL_RANGE_KVCC_SEL : 1;
    ///< Limit the kvcc full bin code according to thermal control bits in
    ///< the analog. Leaving it unlimited doesn't impact functionality but
    ///< just the read out of the Kvcc calibration. For proper Kvcc debug/characterization,
    ///< set according to the PLL:                         0 - code is limited
    ///< to 191d, 11 thermal bits in analog                         1 - (default)
    ///< Full binary code range
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t CFG_KVCC_INV_POLARITY : 1;
    ///< A chicken bit to invert Kvcc polarity.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t CFG_2F0_FINE_RATIO : 7;
    ///< Fractional ratio. 32 is 1/4 (frac value = reg/2^7).
    ///< AccessType="RW" BitOffset="22" ResetValue="0x20"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="29" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_kvcc0_reg_t;

#define PMA_ANACMNPLL_MSG_KVCC0_DEFAULT (0x080013c5U)
#define PMA_ANACMNPLL_MSG_KVCC0_RD_MASK (0x1fff3fffU)
#define PMA_ANACMNPLL_MSG_KVCC0_WR_MASK (0x1fff3fffU)


///< Defines number of refclk cycles from DAC change to frequency measurement
///< during Kvcc calibration.                         VREG LPF is in bypass
///< mode with constant time is ~1nsec (115ohm*8.3pF).
///< Use the following formula:                         Frefclk x 1.26usec
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_SETTLE_MAXCNT_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_SETTLE_MAXCNT_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_SETTLE_MAXCNT_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_SETTLE_MAXCNT_BF_DEF (0x000000C5)

///< Defines number of refclk cycles over which the DCO frequency is measured
///< and averaged with high accuracy.                         It is used
///< for both Kvcc calibration and DFT frequency measurement mode.
///< refclk cycles = 2^(reg+6) - 1
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_MEAS_MAXCNT_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_MEAS_MAXCNT_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_MEAS_MAXCNT_BF_MSK (0x00000700)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_MEAS_MAXCNT_BF_DEF (0x00000300)

///< Amount of offset to inject into LDO for measuring frequency delta
///< that is needed for calibrating Kvcc. (Need to be ~30mv)
///< Common: use &quot;2&quot; as the default register value.
///< Lane: used &quot;1&quot; as a default override.
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCCCALIB_LDO_OFFSET_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCCCALIB_LDO_OFFSET_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCCCALIB_LDO_OFFSET_BF_MSK (0x00003800)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCCCALIB_LDO_OFFSET_BF_DEF (0x00001000)

///< DFT frequency measurement is triggered when this signal transitions
///< from 0 to 1.                         Make sure to set cfg_dfx_disable_dft_timer_ovrd_en=1
///< so that HS counter would remain active and cfg_kvcc_measure_maxcnt
///< to define number of refclk cycles.
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_DFT_FREQ_MEAS_EN_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_DFT_FREQ_MEAS_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_DFT_FREQ_MEAS_EN_BF_MSK (0x00010000)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_DFT_FREQ_MEAS_EN_BF_DEF (0x00000000)

///< Sets how many thermo bits to turn off from the notch filter
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_NOTCH_OFFSET_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_NOTCH_OFFSET_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_NOTCH_OFFSET_BF_MSK (0x000E0000)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_NOTCH_OFFSET_BF_DEF (0x00000000)

///< Limit the kvcc full bin code according to thermal control bits in
///< the analog. Leaving it unlimited doesn't impact functionality but
///< just the read out of the Kvcc calibration. For proper Kvcc debug/characterization,
///< set according to the PLL:                         0 - code is limited
///< to 191d, 11 thermal bits in analog                         1 - (default)
///< Full binary code range
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_FULL_RANGE_KVCC_SEL_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_FULL_RANGE_KVCC_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_FULL_RANGE_KVCC_SEL_BF_MSK (0x00100000)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_FULL_RANGE_KVCC_SEL_BF_DEF (0x00000000)

///< A chicken bit to invert Kvcc polarity.
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_INV_POLARITY_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_INV_POLARITY_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_INV_POLARITY_BF_MSK (0x00200000)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_KVCC_INV_POLARITY_BF_DEF (0x00000000)

///< Fractional ratio. 32 is 1/4 (frac value = reg/2^7).
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_2F0_FINE_RATIO_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_2F0_FINE_RATIO_BF_WID ( 7)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_2F0_FINE_RATIO_BF_MSK (0x1FC00000)
#define PMA_ANACMNPLL_MSG_KVCC0_CFG_2F0_FINE_RATIO_BF_DEF (0x08000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_KVCC1 register description at address offset 0x88
  *
  * Register default value:        0x000EF200
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_kvcc1
  * SERDES_LANE_ANA_PLL::KVCC1
  */

typedef union {
  struct {
    uint32_t CFG_KVCC_CODE_OVRD : 1;
    ///< DCO notch filter override enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CFG_KVCC_CODE_VAL : 9;
    ///< DCO notch filter override value (binary, before therm decoder).
    ///< AccessType="RW" BitOffset="1" ResetValue="0x100"
    uint32_t CFG_KVCC_LDO_OFFSET_EN_OVRD : 1;
    ///< Takes control over internal Kvcc FSM for manually injecting an offset
    ///< to LDO (for letting FW calibrate Kvcc).
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CFG_KVCC_LDO_OFFSET_EN_VAL : 1;
    ///< When kvcc_ldo_offset_en_ovrd=1                         0 - doesn't
    ///< inject an offset to LDO                         1 - injects an offset
    ///< to LDO in magnitude as configured by kvcccalib_ldo_offset
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_KVCC_MAX_CODE_LIMIT : 9;
    ///< While cfg_full_range_kvcc_sel = 0, define the max value for 2f0 code.
    ///< Common: 0x7F (127)                         Lane: 0x4F (79)
    ///< AccessType="RW" BitOffset="12" ResetValue="0xEF"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_kvcc1_reg_t;

#define PMA_ANACMNPLL_MSG_KVCC1_DEFAULT (0x000ef200U)
#define PMA_ANACMNPLL_MSG_KVCC1_RD_MASK (0x001fffffU)
#define PMA_ANACMNPLL_MSG_KVCC1_WR_MASK (0x001fffffU)


///< DCO notch filter override enable
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_OVRD_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_OVRD_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_OVRD_BF_DEF (0x00000000)

///< DCO notch filter override value (binary, before therm decoder).
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_VAL_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_VAL_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_VAL_BF_MSK (0x000003FE)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_CODE_VAL_BF_DEF (0x00000200)

///< Takes control over internal Kvcc FSM for manually injecting an offset
///< to LDO (for letting FW calibrate Kvcc).
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_OVRD_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_OVRD_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_OVRD_BF_DEF (0x00000000)

///< When kvcc_ldo_offset_en_ovrd=1                         0 - doesn't
///< inject an offset to LDO                         1 - injects an offset
///< to LDO in magnitude as configured by kvcccalib_ldo_offset
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_VAL_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_VAL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_VAL_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_LDO_OFFSET_EN_VAL_BF_DEF (0x00000000)

///< While cfg_full_range_kvcc_sel = 0, define the max value for 2f0 code.
///< Common: 0x7F (127)                         Lane: 0x4F (79)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_MAX_CODE_LIMIT_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_MAX_CODE_LIMIT_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_MAX_CODE_LIMIT_BF_MSK (0x001FF000)
#define PMA_ANACMNPLL_MSG_KVCC1_CFG_KVCC_MAX_CODE_LIMIT_BF_DEF (0x000EF000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_KVCC2 register description at address offset 0x8c
  *
  * Register default value:        0x000000A9
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_kvcc2
  * SERDES_LANE_ANA_PLL::KVCC2
  */

typedef union {
  struct {
    uint32_t CFG_KVCC_ADAPT_EN : 1;
    ///< Kvcc on the fly adaptation enable.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t CFG_KVCC_ADAPT_MODE : 2;
    ///< Defines kvcc adaptation mode.                         0(POR): full
    ///< (dithering on all 2f0 bus between current and next)
    ///< 1: single cap 0 (dithering on dedicated capacitor - 1 lsb)
    ///< 2: single cap 1 (dithering on dedicated capacitor - 2 lsb)
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CFG_KVCC_ADAPT_THR : 2;
    ///< Threshold for update the notch code.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x1"
    uint32_t CFG_KVCC_ADAPT_CTR_DELAY : 3;
    ///< Sets update rate of 2f0 SD modulator (2f0 dithering) ramp code increment.
    ///< fbclk cycles = 2^reg
    ///< AccessType="RW" BitOffset="5" ResetValue="0x5"
    uint32_t CFG_KVCC_ADAPT_STEP : 3;
    ///< Sets step size of 2f0 SD modulator (2f0 dithering) ramp code increment.
    ///< step = 2^(reg-9)                         Cycles to complete ramp =
    ///< 2^(9-adapt_step+adapt_ctr_delay)
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_DFX_KVCC_ADAPT_TOGGLE_EN : 1;
    ///< Enables a BIST to check 2f0 mechanism for temp tracking.
    ///< When enabled, 2f0 dithering SD modulator code is ramped up and down
    ///< continously.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_DFX_KVCC_ADAPT_ENABLE_OVR : 1;
    ///< Enables overriding code to 2f0 dithering SD modulator.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_DFX_KVCC_ADAPT_VAL_OVR : 9;
    ///< 2f0 dithering SD modulator override value (when cfg_dfx_kvcc_adapt_enable_ovr=1)
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CFG_DFX_KVCC_ADAPT_DIR_OVR : 1;
    ///< In 2f0 dithering DFX modes, this bit does the following:
    ///< toggle mode (cfg_dfx_kvcc_adapt_toggle_en=1):
    ///< 0 - 2f0 would ramp down and up repeatedly
    ///< 1 - 2f0 would ramp up and down repeatedly
    ///< override mode (cfg_dfx_kvcc_adapt_enable_ovr=1):
    ///< 0 - 2f0 would dither between current code and current code -1
    ///< 1 - 2f0 would dither between current code and current code +1
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t CFG_KVCC_ADAPT_CHICKEN_BIT : 1;
    ///< Define the polarity of the kvcc adaptation.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t CFG_KVCC_ADAPT_BY_FW : 1;
    ///< SERDES_LANE_ANA_PLL::KVCC2::cfg_kvcc_adapt_by_fw
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t CFG_START_2F0_STEP : 1;
    ///< SERDES_LANE_ANA_PLL::KVCC2::cfg_start_2f0_step
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="26" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_kvcc2_reg_t;

#define PMA_ANACMNPLL_MSG_KVCC2_DEFAULT (0x000000a9U)
#define PMA_ANACMNPLL_MSG_KVCC2_RD_MASK (0x03ffffffU)
#define PMA_ANACMNPLL_MSG_KVCC2_WR_MASK (0x03ffffffU)


///< Kvcc on the fly adaptation enable.
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_EN_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_EN_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_EN_BF_DEF (0x00000001)

///< Defines kvcc adaptation mode.                         0(POR): full
///< (dithering on all 2f0 bus between current and next)
///< 1: single cap 0 (dithering on dedicated capacitor - 1 lsb)
///< 2: single cap 1 (dithering on dedicated capacitor - 2 lsb)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_MODE_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_MODE_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_MODE_BF_MSK (0x00000006)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_MODE_BF_DEF (0x00000000)

///< Threshold for update the notch code.
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_THR_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_THR_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_THR_BF_MSK (0x00000018)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_THR_BF_DEF (0x00000008)

///< Sets update rate of 2f0 SD modulator (2f0 dithering) ramp code increment.
///< fbclk cycles = 2^reg
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CTR_DELAY_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CTR_DELAY_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CTR_DELAY_BF_MSK (0x000000E0)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CTR_DELAY_BF_DEF (0x000000A0)

///< Sets step size of 2f0 SD modulator (2f0 dithering) ramp code increment.
///< step = 2^(reg-9)                         Cycles to complete ramp =
///< 2^(9-adapt_step+adapt_ctr_delay)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_STEP_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_STEP_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_STEP_BF_MSK (0x00000700)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_STEP_BF_DEF (0x00000000)

///< Enables a BIST to check 2f0 mechanism for temp tracking.
///< When enabled, 2f0 dithering SD modulator code is ramped up and down
///< continously.
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_TOGGLE_EN_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_TOGGLE_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_TOGGLE_EN_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_TOGGLE_EN_BF_DEF (0x00000000)

///< Enables overriding code to 2f0 dithering SD modulator.
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_EN_OVR_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_EN_OVR_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_EN_OVR_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_EN_OVR_BF_DEF (0x00000000)

///< 2f0 dithering SD modulator override value (when cfg_dfx_kvcc_adapt_enable_ovr=1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_VAL_OVR_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_VAL_OVR_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_VAL_OVR_BF_MSK (0x003FE000)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_VAL_OVR_BF_DEF (0x00000000)

///< In 2f0 dithering DFX modes, this bit does the following:
///< toggle mode (cfg_dfx_kvcc_adapt_toggle_en=1):
///< 0 - 2f0 would ramp down and up repeatedly
///< 1 - 2f0 would ramp up and down repeatedly
///< override mode (cfg_dfx_kvcc_adapt_enable_ovr=1):
///< 0 - 2f0 would dither between current code and current code -1
///< 1 - 2f0 would dither between current code and current code +1
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_DIR_OVR_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_DIR_OVR_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_DIR_OVR_BF_MSK (0x00400000)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_DFX_KVCC_ADAPT_DIR_OVR_BF_DEF (0x00000000)

///< Define the polarity of the kvcc adaptation.
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CHICKEN_BIT_BF_OFF (23)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CHICKEN_BIT_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CHICKEN_BIT_BF_MSK (0x00800000)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_CHICKEN_BIT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::KVCC2::cfg_kvcc_adapt_by_fw
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_BY_FW_BF_OFF (24)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_BY_FW_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_BY_FW_BF_MSK (0x01000000)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_KVCC_ADAPT_BY_FW_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::KVCC2::cfg_start_2f0_step
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_START_2F0_STEP_BF_OFF (25)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_START_2F0_STEP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_START_2F0_STEP_BF_MSK (0x02000000)
#define PMA_ANACMNPLL_MSG_KVCC2_CFG_START_2F0_STEP_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_SPARE0 register description at address offset 0x90
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_spare0
  * SERDES_LANE_ANA_PLL::SPARE0
  */

typedef union {
  struct {
    uint32_t CFG_SPARE_DIG2ANA : 11;
    ///< Spare controls to analog block.                         [10:0] unused
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_spare0_reg_t;

#define PMA_ANACMNPLL_MSG_SPARE0_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_SPARE0_RD_MASK (0x000007ffU)
#define PMA_ANACMNPLL_MSG_SPARE0_WR_MASK (0x000007ffU)


///< Spare controls to analog block.                         [10:0] unused
#define PMA_ANACMNPLL_MSG_SPARE0_CFG_SPARE_DIG2ANA_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_SPARE0_CFG_SPARE_DIG2ANA_BF_WID (11)
#define PMA_ANACMNPLL_MSG_SPARE0_CFG_SPARE_DIG2ANA_BF_MSK (0x000007FF)
#define PMA_ANACMNPLL_MSG_SPARE0_CFG_SPARE_DIG2ANA_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_VISA_LOCKCNT_RCOMP register description at address offset 0x94
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_visa_lockcnt_rcomp
  * LCPLL_RO_VISA_LOCKCNT_RCOMP Register
  */

typedef union {
  struct {
    uint32_t O_DFX_VISALANE0 : 8;
    ///< VISA Lane0 Data output.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t O_DFX_VISALANE1 : 8;
    ///< VISA Lane1 Data output.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t TIME2LOCK_LAST : 14;
    ///< Number of reference clock cycles that passes from:
    ///< * Beginning of first AFC calibration (if skip_long_calibs is enabled).
    ///< * End of KVCC calibration (if skip_long_calibs is disabled).
    ///< till pll phase lock sticky was achieved.                         In
    ///< case pll phase lock sticky was not achieved, the value will remain
    ///< 0.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t LOCKTIME_ERROR : 1;
    ///< Asserts if raw lock was low when lock timer reached its target.
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint32_t PLLUNLOCK_FLAG : 1;
    ///< Sticky PLL unlock event indicator.                         Asserted
    ///< when raw lock indicator deasserts after locked_state.
    ///< AccessType="RO/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_visa_lockcnt_rcomp_reg_t;

#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_WR_MASK (0x00000000U)


///< VISA Lane0 Data output.
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE0_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE0_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE0_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE0_BF_DEF (0x00000000)

///< VISA Lane1 Data output.
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE1_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE1_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE1_BF_MSK (0x0000FF00)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_O_DFX_VISALANE1_BF_DEF (0x00000000)

///< Number of reference clock cycles that passes from:
///< * Beginning of first AFC calibration (if skip_long_calibs is enabled).
///< * End of KVCC calibration (if skip_long_calibs is disabled).
///< till pll phase lock sticky was achieved.                         In
///< case pll phase lock sticky was not achieved, the value will remain
///< 0.
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_TIME2LOCK_LAST_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_TIME2LOCK_LAST_BF_WID (14)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_TIME2LOCK_LAST_BF_MSK (0x3FFF0000)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_TIME2LOCK_LAST_BF_DEF (0x00000000)

///< Asserts if raw lock was low when lock timer reached its target.
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_LOCKTIME_ERR_BF_OFF (30)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_LOCKTIME_ERR_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_LOCKTIME_ERR_BF_MSK (0x40000000)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_LOCKTIME_ERR_BF_DEF (0x00000000)

///< Sticky PLL unlock event indicator.                         Asserted
///< when raw lock indicator deasserts after locked_state.
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_PLLUNLOCK_FLAG_BF_OFF (31)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_PLLUNLOCK_FLAG_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_PLLUNLOCK_FLAG_BF_MSK (0x80000000)
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_PLLUNLOCK_FLAG_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_DIV_BIAS register description at address offset 0x98
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_div_bias
  * LCPLL_RO_DIV_BIAS Register
  */

typedef union {
  struct {
    uint32_t FRACDIV_SYNC : 32;
    ///< RO; Double buffered fractional divider ratio. Internal fbdivratio
    ///< value to check dynamically updated value.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_div_bias_reg_t;

#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_WR_MASK (0x00000000U)


///< RO; Double buffered fractional divider ratio. Internal fbdivratio
///< value to check dynamically updated value.
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_FRACDIV_SYNC_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_FRACDIV_SYNC_BF_WID (32)
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_FRACDIV_SYNC_BF_MSK (0xFFFFFFFF)
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_FRACDIV_SYNC_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_BWM_LF register description at address offset 0x9c
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_bwm_lf
  * LCPLL_RO_BWM_LF Register
  */

typedef union {
  struct {
    uint32_t FBDIVRATIO_SYNC : 10;
    ///< RO; Double buffered integer divider ratio. Internal fbdivratio value
    ///< to check dynamically updated value.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FBDIV_UPDATE_ALLOWED_H : 1;
    ///< Not important. Can be ignored
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t FEEDFWRDGAIN_CAL : 8;
    ///< Current feed forward gain, including changes from adaptive mode.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t FEEDFWRDGAIN_SHIFT : 2;
    ///< Actual feed forward gain = feedfwrdgain_cal/2^reg.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t TDC_STATUS_CNT1 : 10;
    ///< SERDES_LANE_ANA_PLL::RO_BWM_LF::tdc_status_cnt1
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_bwm_lf_reg_t;

#define PMA_ANACMNPLL_MSG_RO_BWM_LF_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_RD_MASK (0x7fffffffU)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_WR_MASK (0x00000000U)


///< RO; Double buffered integer divider ratio. Internal fbdivratio value
///< to check dynamically updated value.
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIVRATIO_SYNC_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIVRATIO_SYNC_BF_WID (10)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIVRATIO_SYNC_BF_MSK (0x000003FF)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIVRATIO_SYNC_BF_DEF (0x00000000)

///< Not important. Can be ignored
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIV_UPDATE_ALLOWED_H_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIV_UPDATE_ALLOWED_H_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIV_UPDATE_ALLOWED_H_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FBDIV_UPDATE_ALLOWED_H_BF_DEF (0x00000000)

///< Current feed forward gain, including changes from adaptive mode.
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_CAL_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_CAL_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_CAL_BF_MSK (0x0007F800)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_CAL_BF_DEF (0x00000000)

///< Actual feed forward gain = feedfwrdgain_cal/2^reg.
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_SHIFT_BF_OFF (19)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_SHIFT_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_SHIFT_BF_MSK (0x00180000)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_FEEDFWRDGAIN_SHIFT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::RO_BWM_LF::tdc_status_cnt1
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_TDC_STAT_CNT1_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_TDC_STAT_CNT1_BF_WID (10)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_TDC_STAT_CNT1_BF_MSK (0x7FE00000)
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_TDC_STAT_CNT1_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_DCO_CALIB register description at address offset 0xa0
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_dco_calib
  * SERDES_LANE_ANA_PLL::RO_DCO_CALIB
  */

typedef union {
  struct {
    uint32_t AFC_CALIB_DONE : 1;
    ///< AFC calibration done indicator.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FINE_FLL_CALIB_DONE : 1;
    ///< FINE FLL done indicator.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t PLL_PHASE_LOCK : 1;
    ///< raw phase lock.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t PLL_PHASE_LOCK_STICKY : 1;
    ///< sticky high phase lock.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t PLL_MUXED_LOCK : 1;
    ///< PLL lock indicator pin, as sent out of PLL interface.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t AFC_BIN_CODE : 9;
    ///< DCO AFC code (before being chopped to DCO AFC limit).
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t FINE_FLL_BIN_CODE : 8;
    ///< FINE FLL convergence (actual FINE might use FINE PLL code based on
    ///< config).
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_dco_calib_reg_t;

#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_RD_MASK (0x003fffffU)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_WR_MASK (0x00000000U)


///< AFC calibration done indicator.
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_CALIB_DONE_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_CALIB_DONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_CALIB_DONE_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_CALIB_DONE_BF_DEF (0x00000000)

///< FINE FLL done indicator.
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_CALIB_DONE_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_CALIB_DONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_CALIB_DONE_BF_MSK (0x00000002)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_CALIB_DONE_BF_DEF (0x00000000)

///< raw phase lock.
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_BF_OFF ( 2)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_BF_MSK (0x00000004)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_BF_DEF (0x00000000)

///< sticky high phase lock.
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_STICKY_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_STICKY_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_STICKY_BF_MSK (0x00000008)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_PHASE_LOCK_STICKY_BF_DEF (0x00000000)

///< PLL lock indicator pin, as sent out of PLL interface.
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_MUXED_LOCK_BF_OFF ( 4)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_MUXED_LOCK_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_MUXED_LOCK_BF_MSK (0x00000010)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_PLL_MUXED_LOCK_BF_DEF (0x00000000)

///< DCO AFC code (before being chopped to DCO AFC limit).
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_BIN_CODE_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_BIN_CODE_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_BIN_CODE_BF_MSK (0x00003FE0)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_AFC_BIN_CODE_BF_DEF (0x00000000)

///< FINE FLL convergence (actual FINE might use FINE PLL code based on
///< config).
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_BIN_CODE_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_BIN_CODE_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_BIN_CODE_BF_MSK (0x003FC000)
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_FINE_FLL_BIN_CODE_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_RO_TDC register description at address offset 0xa4
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_ro_tdc
  * LCPLL_RO_TDC Register
  */

typedef union {
  struct {
    uint32_t TDCDIR_BB : 1;
    ///< TDC direction bit from TDC BB detector.                         Used
    ///< only when bbinlock is set to 1.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TDCCALDONE : 1;
    ///< TDC calibration done indicator.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t TDCEFF : 6;
    ///< TDC output code 2's comp                         In BB mode, this
    ///< bus will still include the entire TDC information while filter recieves
    ///< only sign bit.                         This bus is sampled for tdc
    ///< min/max reg.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t STDC_CALDONE : 1;
    ///< STDC calibration done flag.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t STDC_STDDEV_SEL : 4;
    ///< STDC stddev bus value.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t  : 19;
    ///< Reserved
    ///< AccessType="RO" BitOffset="13" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_ro_tdc_reg_t;

#define PMA_ANACMNPLL_MSG_RO_TDC_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_RO_TDC_RD_MASK (0x00001fffU)
#define PMA_ANACMNPLL_MSG_RO_TDC_WR_MASK (0x00000000U)


///< TDC direction bit from TDC BB detector.                         Used
///< only when bbinlock is set to 1.
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCDIR_BB_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCDIR_BB_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCDIR_BB_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCDIR_BB_BF_DEF (0x00000000)

///< TDC calibration done indicator.
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCCALDONE_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCCALDONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCCALDONE_BF_MSK (0x00000002)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCCALDONE_BF_DEF (0x00000000)

///< TDC output code 2's comp                         In BB mode, this
///< bus will still include the entire TDC information while filter recieves
///< only sign bit.                         This bus is sampled for tdc
///< min/max reg.
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCEFF_BF_OFF ( 2)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCEFF_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCEFF_BF_MSK (0x000000FC)
#define PMA_ANACMNPLL_MSG_RO_TDC_TDCEFF_BF_DEF (0x00000000)

///< STDC calibration done flag.
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_CALDONE_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_CALDONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_CALDONE_BF_MSK (0x00000100)
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_CALDONE_BF_DEF (0x00000000)

///< STDC stddev bus value.
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_STDDEV_SEL_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_STDDEV_SEL_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_STDDEV_SEL_BF_MSK (0x00001E00)
#define PMA_ANACMNPLL_MSG_RO_TDC_STDC_STDDEV_SEL_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_STATUS register description at address offset 0xa8
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_status
  * LCPLL_STATUS Register
  */

typedef union {
  struct {
    uint32_t FILTER_FRAC : 9;
    ///< PLL filter code, fractional value. These 9 bits are sent to SD modulator
    ///< to generate dithering bit
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t CSELFINE : 8;
    ///< Current fine integer code.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t KVCC_LAST_MEAS : 8;
    ///< Capture freq. delta before end of Kvcc calibration.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t PKSEN_COMP_OUT : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS::pksen_comp_out
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint32_t PKSEN_VREF_SEL_BIN : 6;
    ///< SERDES_LANE_ANA_PLL::STATUS::pksen_vref_sel_bin
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_stat_reg_t;

#define PMA_ANACMNPLL_MSG_STAT_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_STAT_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_STAT_WR_MASK (0x00000000U)


///< PLL filter code, fractional value. These 9 bits are sent to SD modulator
///< to generate dithering bit
#define PMA_ANACMNPLL_MSG_STAT_FILTER_FRAC_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_STAT_FILTER_FRAC_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_STAT_FILTER_FRAC_BF_MSK (0x000001FF)
#define PMA_ANACMNPLL_MSG_STAT_FILTER_FRAC_BF_DEF (0x00000000)

///< Current fine integer code.
#define PMA_ANACMNPLL_MSG_STAT_CSELFINE_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_STAT_CSELFINE_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_STAT_CSELFINE_BF_MSK (0x0001FE00)
#define PMA_ANACMNPLL_MSG_STAT_CSELFINE_BF_DEF (0x00000000)

///< Capture freq. delta before end of Kvcc calibration.
#define PMA_ANACMNPLL_MSG_STAT_KVCC_LAST_MEAS_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_STAT_KVCC_LAST_MEAS_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_STAT_KVCC_LAST_MEAS_BF_MSK (0x01FE0000)
#define PMA_ANACMNPLL_MSG_STAT_KVCC_LAST_MEAS_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS::pksen_comp_out
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_COMP_OUT_BF_OFF (25)
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_COMP_OUT_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_COMP_OUT_BF_MSK (0x02000000)
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_COMP_OUT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS::pksen_vref_sel_bin
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_VREF_SEL_BIN_BF_OFF (26)
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_VREF_SEL_BIN_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_VREF_SEL_BIN_BF_MSK (0xFC000000)
#define PMA_ANACMNPLL_MSG_STAT_PKSEN_VREF_SEL_BIN_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_STATUS1 register description at address offset 0xac
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_status1
  * SERDES_LANE_ANA_PLL::STATUS1
  */

typedef union {
  struct {
    uint32_t FREQ_MEAS_READY_RO : 1;
    ///< Frequency measurement result ready (should assert few cycles after
    ///< cfg_dft_freq_meas_enable).
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FREQ_MEAS : 20;
    ///< Frequency measurement result.                         Valid when freq_meas_ready
    ///< is high.                         Frequency = Frefclk * reg / 2^(6+cfg_kvcc_measure_maxcnt)
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t KVCC_FULL_BIN_RO : 9;
    ///< kvcc (notch filter) code.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_stat1_reg_t;

#define PMA_ANACMNPLL_MSG_STAT1_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_STAT1_RD_MASK (0x3fffffffU)
#define PMA_ANACMNPLL_MSG_STAT1_WR_MASK (0x00000000U)


///< Frequency measurement result ready (should assert few cycles after
///< cfg_dft_freq_meas_enable).
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_READY_RO_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_READY_RO_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_READY_RO_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_READY_RO_BF_DEF (0x00000000)

///< Frequency measurement result.                         Valid when freq_meas_ready
///< is high.                         Frequency = Frefclk * reg / 2^(6+cfg_kvcc_measure_maxcnt)
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_BF_WID (20)
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_BF_MSK (0x001FFFFE)
#define PMA_ANACMNPLL_MSG_STAT1_FREQ_MEAS_BF_DEF (0x00000000)

///< kvcc (notch filter) code.
#define PMA_ANACMNPLL_MSG_STAT1_KVCC_FULL_BIN_RO_BF_OFF (21)
#define PMA_ANACMNPLL_MSG_STAT1_KVCC_FULL_BIN_RO_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_STAT1_KVCC_FULL_BIN_RO_BF_MSK (0x3FE00000)
#define PMA_ANACMNPLL_MSG_STAT1_KVCC_FULL_BIN_RO_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_STATUS2 register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_status2
  * SERDES_LANE_ANA_PLL::STATUS2
  */

typedef union {
  struct {
    uint32_t KVCC_CALIB_CODE : 9;
    ///< kvcc calib final code.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DITH_KVCC_ADAPT_ENABLED_STICKY : 1;
    ///< Indicator to kvcc adaptation activated.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t LDODCO_VREF_SEL_AT_CALIB_DONE : 6;
    ///< SERDES_LANE_ANA_PLL::STATUS2::ldodco_vref_sel_at_calib_done
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t LDODCO_VREF_SEL_BIN : 6;
    ///< SERDES_LANE_ANA_PLL::STATUS2::ldodco_vref_sel_bin
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t PKSEN_VREF_SEL_AT_CALIB_DONE : 6;
    ///< SERDES_LANE_ANA_PLL::STATUS2::pksen_vref_sel_at_calib_done
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint32_t PKSEN_VREF_SEL_REACHED_LIMIT : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS2::pksen_vref_sel_reached_limit
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint32_t DCO_SWING_CALIB_DONE : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS2::dco_swing_calib_done
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint32_t PKSEN_READ_DONE : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS2::pksen_read_done
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint32_t LDODCO_STEP_DONE : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS2::ldodco_step_done
    ///< AccessType="RO/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_stat2_reg_t;

#define PMA_ANACMNPLL_MSG_STAT2_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_STAT2_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_STAT2_WR_MASK (0x00000000U)


///< kvcc calib final code.
#define PMA_ANACMNPLL_MSG_STAT2_KVCC_CALIB_CODE_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_STAT2_KVCC_CALIB_CODE_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_STAT2_KVCC_CALIB_CODE_BF_MSK (0x000001FF)
#define PMA_ANACMNPLL_MSG_STAT2_KVCC_CALIB_CODE_BF_DEF (0x00000000)

///< Indicator to kvcc adaptation activated.
#define PMA_ANACMNPLL_MSG_STAT2_DITH_KVCC_ADAPT_END_STICKY_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_STAT2_DITH_KVCC_ADAPT_END_STICKY_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT2_DITH_KVCC_ADAPT_END_STICKY_BF_MSK (0x00000200)
#define PMA_ANACMNPLL_MSG_STAT2_DITH_KVCC_ADAPT_END_STICKY_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS2::ldodco_vref_sel_at_calib_done
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_AT_CALIB_DONE_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_AT_CALIB_DONE_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_AT_CALIB_DONE_BF_MSK (0x0000FC00)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_AT_CALIB_DONE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS2::ldodco_vref_sel_bin
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_BIN_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_BIN_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_BIN_BF_MSK (0x003F0000)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_VREF_SEL_BIN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS2::pksen_vref_sel_at_calib_done
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_AT_CALIB_DONE_BF_OFF (22)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_AT_CALIB_DONE_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_AT_CALIB_DONE_BF_MSK (0x0FC00000)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_AT_CALIB_DONE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS2::pksen_vref_sel_reached_limit
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_REACHED_LIMIT_BF_OFF (28)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_REACHED_LIMIT_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_REACHED_LIMIT_BF_MSK (0x10000000)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_VREF_SEL_REACHED_LIMIT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS2::dco_swing_calib_done
#define PMA_ANACMNPLL_MSG_STAT2_DCO_SWING_CALIB_DONE_BF_OFF (29)
#define PMA_ANACMNPLL_MSG_STAT2_DCO_SWING_CALIB_DONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT2_DCO_SWING_CALIB_DONE_BF_MSK (0x20000000)
#define PMA_ANACMNPLL_MSG_STAT2_DCO_SWING_CALIB_DONE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS2::pksen_read_done
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_READ_DONE_BF_OFF (30)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_READ_DONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_READ_DONE_BF_MSK (0x40000000)
#define PMA_ANACMNPLL_MSG_STAT2_PKSEN_READ_DONE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS2::ldodco_step_done
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_STEP_DONE_BF_OFF (31)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_STEP_DONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_STEP_DONE_BF_MSK (0x80000000)
#define PMA_ANACMNPLL_MSG_STAT2_LDODCO_STEP_DONE_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_STATUS3 register description at address offset 0xb4
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_status3
  * SERDES_LANE_ANA_PLL::STATUS3
  */

typedef union {
  struct {
    uint32_t TIME2LOCK_FIRST : 14;
    ///< SERDES_LANE_ANA_PLL::STATUS3::time2lock_first
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TDC_STATUS_CNT0 : 10;
    ///< SERDES_LANE_ANA_PLL::STATUS3::tdc_status_cnt0
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t SCCALDONE : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS3::sccaldone
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t SC_CALIB_CODE : 4;
    ///< SERDES_LANE_ANA_PLL::STATUS3::sc_calib_code
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint32_t SC_EN : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS3::sc_en
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_stat3_reg_t;

#define PMA_ANACMNPLL_MSG_STAT3_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_STAT3_RD_MASK (0x3fffffffU)
#define PMA_ANACMNPLL_MSG_STAT3_WR_MASK (0x00000000U)


///< SERDES_LANE_ANA_PLL::STATUS3::time2lock_first
#define PMA_ANACMNPLL_MSG_STAT3_TIME2LOCK_FIRST_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_STAT3_TIME2LOCK_FIRST_BF_WID (14)
#define PMA_ANACMNPLL_MSG_STAT3_TIME2LOCK_FIRST_BF_MSK (0x00003FFF)
#define PMA_ANACMNPLL_MSG_STAT3_TIME2LOCK_FIRST_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS3::tdc_status_cnt0
#define PMA_ANACMNPLL_MSG_STAT3_TDC_STAT_CNT0_BF_OFF (14)
#define PMA_ANACMNPLL_MSG_STAT3_TDC_STAT_CNT0_BF_WID (10)
#define PMA_ANACMNPLL_MSG_STAT3_TDC_STAT_CNT0_BF_MSK (0x00FFC000)
#define PMA_ANACMNPLL_MSG_STAT3_TDC_STAT_CNT0_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS3::sccaldone
#define PMA_ANACMNPLL_MSG_STAT3_SCCALDONE_BF_OFF (24)
#define PMA_ANACMNPLL_MSG_STAT3_SCCALDONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT3_SCCALDONE_BF_MSK (0x01000000)
#define PMA_ANACMNPLL_MSG_STAT3_SCCALDONE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS3::sc_calib_code
#define PMA_ANACMNPLL_MSG_STAT3_SC_CALIB_CODE_BF_OFF (25)
#define PMA_ANACMNPLL_MSG_STAT3_SC_CALIB_CODE_BF_WID ( 4)
#define PMA_ANACMNPLL_MSG_STAT3_SC_CALIB_CODE_BF_MSK (0x1E000000)
#define PMA_ANACMNPLL_MSG_STAT3_SC_CALIB_CODE_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS3::sc_en
#define PMA_ANACMNPLL_MSG_STAT3_SC_EN_BF_OFF (29)
#define PMA_ANACMNPLL_MSG_STAT3_SC_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT3_SC_EN_BF_MSK (0x20000000)
#define PMA_ANACMNPLL_MSG_STAT3_SC_EN_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_SPARE1 register description at address offset 0xb8
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_spare1
  * SERDES_LANE_ANA_PLL::SPARE1
  */

typedef union {
  struct {
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="0" ResetValue="None"
    uint32_t CFG_SPARE_DIG2WRAP : 20;
    ///< SERDES_LANE_ANA_PLL::SPARE1::cfg_spare_dig2wrap
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 11;
    ///< Reserved
    ///< AccessType="RO" BitOffset="21" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_spare1_reg_t;

#define PMA_ANACMNPLL_MSG_SPARE1_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_SPARE1_RD_MASK (0x001ffffeU)
#define PMA_ANACMNPLL_MSG_SPARE1_WR_MASK (0x001ffffeU)


///< SERDES_LANE_ANA_PLL::SPARE1::cfg_spare_dig2wrap
#define PMA_ANACMNPLL_MSG_SPARE1_CFG_SPARE_DIG2WRAP_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_SPARE1_CFG_SPARE_DIG2WRAP_BF_WID (20)
#define PMA_ANACMNPLL_MSG_SPARE1_CFG_SPARE_DIG2WRAP_BF_MSK (0x001FFFFE)
#define PMA_ANACMNPLL_MSG_SPARE1_CFG_SPARE_DIG2WRAP_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_SPARE_STATUS register description at address offset 0xbc
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_spare_status
  * SERDES_LANE_ANA_PLL::SPARE_STATUS
  */

typedef union {
  struct {
    uint32_t SPARE_ANA2DIG : 8;
    ///< Spare RO pins from analog to digital
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t SPARE_WRAP2DIG : 8;
    ///< SERDES_LANE_ANA_PLL::SPARE_STATUS::spare_wrap2dig
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t  : 16;
    ///< Reserved
    ///< AccessType="RO" BitOffset="16" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_spare_stat_reg_t;

#define PMA_ANACMNPLL_MSG_SPARE_STAT_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_RD_MASK (0x0000ffffU)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_WR_MASK (0x00000000U)


///< Spare RO pins from analog to digital
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_ANA2DIG_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_ANA2DIG_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_ANA2DIG_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_ANA2DIG_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::SPARE_STATUS::spare_wrap2dig
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_WRAP2DIG_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_WRAP2DIG_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_WRAP2DIG_BF_MSK (0x0000FF00)
#define PMA_ANACMNPLL_MSG_SPARE_STAT_SPARE_WRAP2DIG_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DCO_SWING0 register description at address offset 0xc0
  *
  * Register default value:        0x0022006D
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_dco_swing0
  * SERDES_LANE_ANA_PLL::DCO_SWING0
  */

typedef union {
  struct {
    uint32_t CFG_DCO_SWING_VPEAK_MODE : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_dco_swing_vpeak_mode
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t CFG_PKSEN_VREF_TARGET : 6;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_vref_target
    ///< AccessType="RW" BitOffset="1" ResetValue="0x36"
    uint32_t CFG_SKIP_DCO_SWING_SLEEP_SEL : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_skip_dco_swing_sleep_sel
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CFG_DCO_SWING_BY_FW : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_dco_swing_by_fw
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_START_PKSEN_READ : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_start_pksen_read
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CFG_START_LDODCO_STEP : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_start_ldodco_step
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CFG_LDODCO_STEP_DIR : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_step_dir
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CFG_LDODCO_STEP_CHICKEN_BIT : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_step_chicken_bit
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CFG_PKSEN_SETTLE_TIMER_LIMIT : 3;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_settle_timer_limit
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CFG_PKSEN_COMP_OUT_CHICKEN_BIT : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_comp_out_chicken_bit
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CFG_LDODCO_ADAPT_EN : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_adapt_en
    ///< AccessType="RW" BitOffset="17" ResetValue="0x1"
    uint32_t CFG_PKSEN_VREF_OVRD : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_vref_ovrd
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t CFG_LDODCO_VREF_OVRD : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_vref_ovrd
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t CFG_LDODCO_STEP_SETTLE_TIMER_LIMIT : 2;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_step_settle_timer_limit
    ///< AccessType="RW" BitOffset="20" ResetValue="0x2"
    uint32_t  : 10;
    ///< Reserved
    ///< AccessType="RO" BitOffset="22" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_dco_swing0_reg_t;

#define PMA_ANACMNPLL_MSG_DCO_SWING0_DEFAULT (0x0022006dU)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_RD_MASK (0x003fffffU)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_WR_MASK (0x003fffffU)


///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_dco_swing_vpeak_mode
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_VPEAK_MODE_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_VPEAK_MODE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_VPEAK_MODE_BF_MSK (0x00000001)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_VPEAK_MODE_BF_DEF (0x00000001)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_vref_target
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_TARGET_BF_OFF ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_TARGET_BF_WID ( 6)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_TARGET_BF_MSK (0x0000007E)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_TARGET_BF_DEF (0x0000006C)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_skip_dco_swing_sleep_sel
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_SKIP_DCO_SWING_SLEEP_SEL_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_SKIP_DCO_SWING_SLEEP_SEL_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_SKIP_DCO_SWING_SLEEP_SEL_BF_MSK (0x00000080)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_SKIP_DCO_SWING_SLEEP_SEL_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_dco_swing_by_fw
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_BY_FW_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_BY_FW_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_BY_FW_BF_MSK (0x00000100)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_DCO_SWING_BY_FW_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_start_pksen_read
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_PKSEN_READ_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_PKSEN_READ_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_PKSEN_READ_BF_MSK (0x00000200)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_PKSEN_READ_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_start_ldodco_step
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_LDODCO_STEP_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_LDODCO_STEP_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_LDODCO_STEP_BF_MSK (0x00000400)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_START_LDODCO_STEP_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_step_dir
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_DIR_BF_OFF (11)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_DIR_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_DIR_BF_MSK (0x00000800)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_DIR_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_step_chicken_bit
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_CHICKEN_BIT_BF_OFF (12)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_CHICKEN_BIT_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_CHICKEN_BIT_BF_MSK (0x00001000)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_CHICKEN_BIT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_settle_timer_limit
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_SETTLE_TIMER_LIMIT_BF_OFF (13)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_SETTLE_TIMER_LIMIT_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_SETTLE_TIMER_LIMIT_BF_MSK (0x0000E000)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_SETTLE_TIMER_LIMIT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_comp_out_chicken_bit
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_COMP_OUT_CHICKEN_BIT_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_COMP_OUT_CHICKEN_BIT_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_COMP_OUT_CHICKEN_BIT_BF_MSK (0x00010000)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_COMP_OUT_CHICKEN_BIT_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_adapt_en
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_ADAPT_EN_BF_OFF (17)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_ADAPT_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_ADAPT_EN_BF_MSK (0x00020000)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_ADAPT_EN_BF_DEF (0x00020000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_pksen_vref_ovrd
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_OVRD_BF_OFF (18)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_OVRD_BF_MSK (0x00040000)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_PKSEN_VREF_OVRD_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_vref_ovrd
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_VREF_OVRD_BF_OFF (19)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_VREF_OVRD_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_VREF_OVRD_BF_MSK (0x00080000)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_VREF_OVRD_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING0::cfg_ldodco_step_settle_timer_limit
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_SETTLE_TIMER_LIMIT_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_SETTLE_TIMER_LIMIT_BF_WID ( 2)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_SETTLE_TIMER_LIMIT_BF_MSK (0x00300000)
#define PMA_ANACMNPLL_MSG_DCO_SWING0_CFG_LDODCO_STEP_SETTLE_TIMER_LIMIT_BF_DEF (0x00200000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_DCO_SWING1 register description at address offset 0xc4
  *
  * Register default value:        0x00000005
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_dco_swing1
  * SERDES_LANE_ANA_PLL::DCO_SWING1
  */

typedef union {
  struct {
    uint32_t CFG_LDODCO_ADAPT_CTR_DELAY : 3;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_ldodco_adapt_ctr_delay
    ///< AccessType="RW" BitOffset="0" ResetValue="0x5"
    uint32_t CFG_LDODCO_ADAPT_STEP : 3;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_ldodco_adapt_step
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CFG_DFX_LDODCO_ADAPT_TOGGLE_EN : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_toggle_en
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CFG_DFX_LDODCO_ADAPT_DIR_OVR : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_dir_ovr
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CFG_DFX_LDODCO_ADAPT_ENABLE_OVR : 1;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_enable_ovr
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CFG_DFX_LDODCO_ADAPT_VAL_OVR : 9;
    ///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_val_ovr
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_dco_swing1_reg_t;

#define PMA_ANACMNPLL_MSG_DCO_SWING1_DEFAULT (0x00000005U)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_RD_MASK (0x0003ffffU)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_WR_MASK (0x0003ffffU)


///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_ldodco_adapt_ctr_delay
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_CTR_DELAY_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_CTR_DELAY_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_CTR_DELAY_BF_MSK (0x00000007)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_CTR_DELAY_BF_DEF (0x00000005)

///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_ldodco_adapt_step
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_STEP_BF_OFF ( 3)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_STEP_BF_WID ( 3)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_STEP_BF_MSK (0x00000038)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_LDODCO_ADAPT_STEP_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_toggle_en
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_TOGGLE_EN_BF_OFF ( 6)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_TOGGLE_EN_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_TOGGLE_EN_BF_MSK (0x00000040)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_TOGGLE_EN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_dir_ovr
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_DIR_OVR_BF_OFF ( 7)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_DIR_OVR_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_DIR_OVR_BF_MSK (0x00000080)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_DIR_OVR_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_enable_ovr
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_EN_OVR_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_EN_OVR_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_EN_OVR_BF_MSK (0x00000100)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_EN_OVR_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::DCO_SWING1::cfg_dfx_ldodco_adapt_val_ovr
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_VAL_OVR_BF_OFF ( 9)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_VAL_OVR_BF_WID ( 9)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_VAL_OVR_BF_MSK (0x0003FE00)
#define PMA_ANACMNPLL_MSG_DCO_SWING1_CFG_DFX_LDODCO_ADAPT_VAL_OVR_BF_DEF (0x00000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_TDC4 register description at address offset 0xc8
  *
  * Register default value:        0xCAB6A27C
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_tdc4
  * SERDES_LANE_ANA_PLL::TDC4
  */

typedef union {
  struct {
    uint32_t CFG_VTDC_MINUS2_THRESH : 8;
    ///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_minus2_thresh
    ///< AccessType="RW" BitOffset="0" ResetValue="0x7C"
    uint32_t CFG_VTDC_MINUS1_THRESH : 8;
    ///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_minus1_thresh
    ///< AccessType="RW" BitOffset="8" ResetValue="0xA2"
    uint32_t CFG_VTDC_PLUS1_THRESH : 8;
    ///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_plus1_thresh
    ///< AccessType="RW" BitOffset="16" ResetValue="0xB6"
    uint32_t CFG_VTDC_PLUS2_THRESH : 8;
    ///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_plus2_thresh
    ///< AccessType="RW" BitOffset="24" ResetValue="0xCA"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_tdc4_reg_t;

#define PMA_ANACMNPLL_MSG_TDC4_DEFAULT (0xcab6a27cU)
#define PMA_ANACMNPLL_MSG_TDC4_RD_MASK (0xffffffffU)
#define PMA_ANACMNPLL_MSG_TDC4_WR_MASK (0xffffffffU)


///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_minus2_thresh
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS2_THRESH_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS2_THRESH_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS2_THRESH_BF_MSK (0x000000FF)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS2_THRESH_BF_DEF (0x0000007C)

///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_minus1_thresh
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS1_THRESH_BF_OFF ( 8)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS1_THRESH_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS1_THRESH_BF_MSK (0x0000FF00)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_MINUS1_THRESH_BF_DEF (0x0000A200)

///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_plus1_thresh
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS1_THRESH_BF_OFF (16)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS1_THRESH_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS1_THRESH_BF_MSK (0x00FF0000)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS1_THRESH_BF_DEF (0x00B60000)

///< SERDES_LANE_ANA_PLL::TDC4::cfg_vtdc_plus2_thresh
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS2_THRESH_BF_OFF (24)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS2_THRESH_BF_WID ( 8)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS2_THRESH_BF_MSK (0xFF000000)
#define PMA_ANACMNPLL_MSG_TDC4_CFG_VTDC_PLUS2_THRESH_BF_DEF (0xCA000000)


/** @brief PMA_ANACMNPLL_REGS_MSG_PMA_ANACMNPLL_REGS_PMA_ANACMNPLL_STATUS4 register description at address offset 0xcc
  *
  * Register default value:        0x00000000
  * Register full path in IP: PMA_ANACMNPLL_regs_MSG/PMA_ANACMNPLL_regs/pma_anacmnpll_status4
  * SERDES_LANE_ANA_PLL::STATUS4
  */

typedef union {
  struct {
    uint32_t VTDC_COARSE_OFFSET : 5;
    ///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_coarse_offset
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t VTDC_FINE_OFFSET : 5;
    ///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_fine_offset
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t VTDC_COARSE_OFFSET_MIN : 5;
    ///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_coarse_offset_min
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t VTDC_COARSE_OFFSET_MAX : 5;
    ///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_coarse_offset_max
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint32_t VTDC_FINE_OFFSET_MIN : 5;
    ///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_fine_offset_min
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t VTDC_FINE_OFFSET_MAX : 5;
    ///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_fine_offset_max
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint32_t VTDC_OFFSET_CALIB_DONE : 1;
    ///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_offset_calib_done
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="31" ResetValue="None"
  } ;
  uint32_t value;
} pma_anacmnpll_msg_stat4_reg_t;

#define PMA_ANACMNPLL_MSG_STAT4_DEFAULT (0x00000000U)
#define PMA_ANACMNPLL_MSG_STAT4_RD_MASK (0x7fffffffU)
#define PMA_ANACMNPLL_MSG_STAT4_WR_MASK (0x00000000U)


///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_coarse_offset
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_BF_OFF ( 0)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_BF_MSK (0x0000001F)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_fine_offset
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_BF_OFF ( 5)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_BF_MSK (0x000003E0)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_coarse_offset_min
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MIN_BF_OFF (10)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MIN_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MIN_BF_MSK (0x00007C00)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MIN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_coarse_offset_max
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MAX_BF_OFF (15)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MAX_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MAX_BF_MSK (0x000F8000)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_COARSE_OFFSET_MAX_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_fine_offset_min
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MIN_BF_OFF (20)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MIN_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MIN_BF_MSK (0x01F00000)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MIN_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_fine_offset_max
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MAX_BF_OFF (25)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MAX_BF_WID ( 5)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MAX_BF_MSK (0x3E000000)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_FINE_OFFSET_MAX_BF_DEF (0x00000000)

///< SERDES_LANE_ANA_PLL::STATUS4::vtdc_offset_calib_done
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_OFFSET_CALIB_DONE_BF_OFF (30)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_OFFSET_CALIB_DONE_BF_WID ( 1)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_OFFSET_CALIB_DONE_BF_MSK (0x40000000)
#define PMA_ANACMNPLL_MSG_STAT4_VTDC_OFFSET_CALIB_DONE_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define PMA_ANACMNPLL_MSG_DIV0_REG(_BASE) ((pma_anacmnpll_msg_div0_reg_t*) PMA_ANACMNPLL_MSG_DIV0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_DIV1_REG(_BASE) ((pma_anacmnpll_msg_div1_reg_t*) PMA_ANACMNPLL_MSG_DIV1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_ADL0_REG(_BASE) ((pma_anacmnpll_msg_adl0_reg_t*) PMA_ANACMNPLL_MSG_ADL0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_ADL1_REG(_BASE) ((pma_anacmnpll_msg_adl1_reg_t*) PMA_ANACMNPLL_MSG_ADL1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_FRAC_LOCK0_REG(_BASE) ((pma_anacmnpll_msg_frac_lock0_reg_t*) PMA_ANACMNPLL_MSG_FRAC_LOCK0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_FRAC_LOCK1_REG(_BASE) ((pma_anacmnpll_msg_frac_lock1_reg_t*) PMA_ANACMNPLL_MSG_FRAC_LOCK1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_TDC0_REG(_BASE) ((pma_anacmnpll_msg_tdc0_reg_t*) PMA_ANACMNPLL_MSG_TDC0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_TDC1_REG(_BASE) ((pma_anacmnpll_msg_tdc1_reg_t*) PMA_ANACMNPLL_MSG_TDC1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_TDC2_REG(_BASE) ((pma_anacmnpll_msg_tdc2_reg_t*) PMA_ANACMNPLL_MSG_TDC2_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_TDC3_REG(_BASE) ((pma_anacmnpll_msg_tdc3_reg_t*) PMA_ANACMNPLL_MSG_TDC3_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_TAP_OVRD_REG(_BASE) ((pma_anacmnpll_msg_tap_ovrd_reg_t*) PMA_ANACMNPLL_MSG_TAP_OVRD_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_DFX_DCO_REG(_BASE) ((pma_anacmnpll_msg_dfx_dco_reg_t*) PMA_ANACMNPLL_MSG_DFX_DCO_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_DFX_TDC_CRO_REG(_BASE) ((pma_anacmnpll_msg_dfx_tdc_cro_reg_t*) PMA_ANACMNPLL_MSG_DFX_TDC_CRO_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_VISA_CTRL_REG(_BASE) ((pma_anacmnpll_msg_visa_ctrl_reg_t*) PMA_ANACMNPLL_MSG_VISA_CTRL_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_REG(_BASE) ((pma_anacmnpll_msg_visa_lane0_sel_reg_t*) PMA_ANACMNPLL_MSG_VISA_LANE0_SEL_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_REG(_BASE) ((pma_anacmnpll_msg_visa_lane1_sel_reg_t*) PMA_ANACMNPLL_MSG_VISA_LANE1_SEL_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_REG(_BASE) ((pma_anacmnpll_msg_cntr_bist_settings_reg_t*) PMA_ANACMNPLL_MSG_CNTR_BIST_SETTINGS_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO0_REG(_BASE) ((pma_anacmnpll_msg_ro_tdc_dco0_reg_t*) PMA_ANACMNPLL_MSG_RO_TDC_DCO0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO1_REG(_BASE) ((pma_anacmnpll_msg_ro_tdc_dco1_reg_t*) PMA_ANACMNPLL_MSG_RO_TDC_DCO1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO2_REG(_BASE) ((pma_anacmnpll_msg_ro_tdc_dco2_reg_t*) PMA_ANACMNPLL_MSG_RO_TDC_DCO2_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_TDC_DCO3_REG(_BASE) ((pma_anacmnpll_msg_ro_tdc_dco3_reg_t*) PMA_ANACMNPLL_MSG_RO_TDC_DCO3_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_CALIB0_REG(_BASE) ((pma_anacmnpll_msg_calib0_reg_t*) PMA_ANACMNPLL_MSG_CALIB0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_CALIB1_REG(_BASE) ((pma_anacmnpll_msg_calib1_reg_t*) PMA_ANACMNPLL_MSG_CALIB1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_CALIB2_REG(_BASE) ((pma_anacmnpll_msg_calib2_reg_t*) PMA_ANACMNPLL_MSG_CALIB2_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_REG(_BASE) ((pma_anacmnpll_msg_pll_fsm_ctrl_reg_t*) PMA_ANACMNPLL_MSG_PLL_FSM_CTRL_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_TEMP_TRACKING_REG(_BASE) ((pma_anacmnpll_msg_temp_tracking_reg_t*) PMA_ANACMNPLL_MSG_TEMP_TRACKING_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_ANA_CTRL1_REG(_BASE) ((pma_anacmnpll_msg_ana_ctrl1_reg_t*) PMA_ANACMNPLL_MSG_ANA_CTRL1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_ANA_CTRL2_REG(_BASE) ((pma_anacmnpll_msg_ana_ctrl2_reg_t*) PMA_ANACMNPLL_MSG_ANA_CTRL2_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_ANA_CTRL3_REG(_BASE) ((pma_anacmnpll_msg_ana_ctrl3_reg_t*) PMA_ANACMNPLL_MSG_ANA_CTRL3_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_DFX0_REG(_BASE) ((pma_anacmnpll_msg_dfx0_reg_t*) PMA_ANACMNPLL_MSG_DFX0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_DFX1_REG(_BASE) ((pma_anacmnpll_msg_dfx1_reg_t*) PMA_ANACMNPLL_MSG_DFX1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_LDO0_REG(_BASE) ((pma_anacmnpll_msg_ldo0_reg_t*) PMA_ANACMNPLL_MSG_LDO0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_LDO1_REG(_BASE) ((pma_anacmnpll_msg_ldo1_reg_t*) PMA_ANACMNPLL_MSG_LDO1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_KVCC0_REG(_BASE) ((pma_anacmnpll_msg_kvcc0_reg_t*) PMA_ANACMNPLL_MSG_KVCC0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_KVCC1_REG(_BASE) ((pma_anacmnpll_msg_kvcc1_reg_t*) PMA_ANACMNPLL_MSG_KVCC1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_KVCC2_REG(_BASE) ((pma_anacmnpll_msg_kvcc2_reg_t*) PMA_ANACMNPLL_MSG_KVCC2_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_SPARE0_REG(_BASE) ((pma_anacmnpll_msg_spare0_reg_t*) PMA_ANACMNPLL_MSG_SPARE0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_REG(_BASE) ((pma_anacmnpll_msg_ro_visa_lockcnt_rcomp_reg_t*) PMA_ANACMNPLL_MSG_RO_VISA_LOCKCNT_RCOMP_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_DIV_BIAS_REG(_BASE) ((pma_anacmnpll_msg_ro_div_bias_reg_t*) PMA_ANACMNPLL_MSG_RO_DIV_BIAS_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_BWM_LF_REG(_BASE) ((pma_anacmnpll_msg_ro_bwm_lf_reg_t*) PMA_ANACMNPLL_MSG_RO_BWM_LF_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_DCO_CALIB_REG(_BASE) ((pma_anacmnpll_msg_ro_dco_calib_reg_t*) PMA_ANACMNPLL_MSG_RO_DCO_CALIB_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_RO_TDC_REG(_BASE) ((pma_anacmnpll_msg_ro_tdc_reg_t*) PMA_ANACMNPLL_MSG_RO_TDC_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_STAT_REG(_BASE) ((pma_anacmnpll_msg_stat_reg_t*) PMA_ANACMNPLL_MSG_STAT_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_STAT1_REG(_BASE) ((pma_anacmnpll_msg_stat1_reg_t*) PMA_ANACMNPLL_MSG_STAT1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_STAT2_REG(_BASE) ((pma_anacmnpll_msg_stat2_reg_t*) PMA_ANACMNPLL_MSG_STAT2_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_STAT3_REG(_BASE) ((pma_anacmnpll_msg_stat3_reg_t*) PMA_ANACMNPLL_MSG_STAT3_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_SPARE1_REG(_BASE) ((pma_anacmnpll_msg_spare1_reg_t*) PMA_ANACMNPLL_MSG_SPARE1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_SPARE_STAT_REG(_BASE) ((pma_anacmnpll_msg_spare_stat_reg_t*) PMA_ANACMNPLL_MSG_SPARE_STAT_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_DCO_SWING0_REG(_BASE) ((pma_anacmnpll_msg_dco_swing0_reg_t*) PMA_ANACMNPLL_MSG_DCO_SWING0_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_DCO_SWING1_REG(_BASE) ((pma_anacmnpll_msg_dco_swing1_reg_t*) PMA_ANACMNPLL_MSG_DCO_SWING1_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_TDC4_REG(_BASE) ((pma_anacmnpll_msg_tdc4_reg_t*) PMA_ANACMNPLL_MSG_TDC4_ADR(_BASE))
#define PMA_ANACMNPLL_MSG_STAT4_REG(_BASE) ((pma_anacmnpll_msg_stat4_reg_t*) PMA_ANACMNPLL_MSG_STAT4_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    pma_anacmnpll_msg_div0_reg_t PMA_ANACMNPLL_DIV0; /*< Address offset = 0x0 */
    pma_anacmnpll_msg_div1_reg_t PMA_ANACMNPLL_DIV1; /*< Address offset = 0x4 */
    pma_anacmnpll_msg_adl0_reg_t PMA_ANACMNPLL_ADL0; /*< Address offset = 0x8 */
    pma_anacmnpll_msg_adl1_reg_t PMA_ANACMNPLL_ADL1; /*< Address offset = 0xc */
    pma_anacmnpll_msg_frac_lock0_reg_t PMA_ANACMNPLL_FRAC_LOCK0; /*< Address offset = 0x10 */
    pma_anacmnpll_msg_frac_lock1_reg_t PMA_ANACMNPLL_FRAC_LOCK1; /*< Address offset = 0x14 */
    pma_anacmnpll_msg_tdc0_reg_t PMA_ANACMNPLL_TDC0; /*< Address offset = 0x18 */
    pma_anacmnpll_msg_tdc1_reg_t PMA_ANACMNPLL_TDC1; /*< Address offset = 0x1c */
    pma_anacmnpll_msg_tdc2_reg_t PMA_ANACMNPLL_TDC2; /*< Address offset = 0x20 */
    pma_anacmnpll_msg_tdc3_reg_t PMA_ANACMNPLL_TDC3; /*< Address offset = 0x24 */
    pma_anacmnpll_msg_tap_ovrd_reg_t PMA_ANACMNPLL_TAP_OVRD; /*< Address offset = 0x28 */
    pma_anacmnpll_msg_dfx_dco_reg_t PMA_ANACMNPLL_DFX_DCO; /*< Address offset = 0x2c */
    pma_anacmnpll_msg_dfx_tdc_cro_reg_t PMA_ANACMNPLL_DFX_TDC_CRO; /*< Address offset = 0x30 */
    pma_anacmnpll_msg_visa_ctrl_reg_t PMA_ANACMNPLL_VISA_CTRL; /*< Address offset = 0x34 */
    pma_anacmnpll_msg_visa_lane0_sel_reg_t PMA_ANACMNPLL_VISA_LANE0_SEL; /*< Address offset = 0x38 */
    pma_anacmnpll_msg_visa_lane1_sel_reg_t PMA_ANACMNPLL_VISA_LANE1_SEL; /*< Address offset = 0x3c */
    pma_anacmnpll_msg_cntr_bist_settings_reg_t PMA_ANACMNPLL_CNTR_BIST_SETTINGS; /*< Address offset = 0x40 */
    pma_anacmnpll_msg_ro_tdc_dco0_reg_t PMA_ANACMNPLL_RO_TDC_DCO0; /*< Address offset = 0x44 */
    pma_anacmnpll_msg_ro_tdc_dco1_reg_t PMA_ANACMNPLL_RO_TDC_DCO1; /*< Address offset = 0x48 */
    pma_anacmnpll_msg_ro_tdc_dco2_reg_t PMA_ANACMNPLL_RO_TDC_DCO2; /*< Address offset = 0x4c */
    pma_anacmnpll_msg_ro_tdc_dco3_reg_t PMA_ANACMNPLL_RO_TDC_DCO3; /*< Address offset = 0x50 */
    pma_anacmnpll_msg_calib0_reg_t PMA_ANACMNPLL_CALIB0; /*< Address offset = 0x54 */
    pma_anacmnpll_msg_calib1_reg_t PMA_ANACMNPLL_CALIB1; /*< Address offset = 0x58 */
    pma_anacmnpll_msg_calib2_reg_t PMA_ANACMNPLL_CALIB2; /*< Address offset = 0x5c */
    pma_anacmnpll_msg_pll_fsm_ctrl_reg_t PMA_ANACMNPLL_PLL_FSM_CTRL; /*< Address offset = 0x60 */
    pma_anacmnpll_msg_temp_tracking_reg_t PMA_ANACMNPLL_TEMP_TRACKING; /*< Address offset = 0x64 */
    pma_anacmnpll_msg_ana_ctrl1_reg_t PMA_ANACMNPLL_ANA_CTRL1; /*< Address offset = 0x68 */
    pma_anacmnpll_msg_ana_ctrl2_reg_t PMA_ANACMNPLL_ANA_CTRL2; /*< Address offset = 0x6c */
    pma_anacmnpll_msg_ana_ctrl3_reg_t PMA_ANACMNPLL_ANA_CTRL3; /*< Address offset = 0x70 */
    pma_anacmnpll_msg_dfx0_reg_t PMA_ANACMNPLL_DFX0; /*< Address offset = 0x74 */
    pma_anacmnpll_msg_dfx1_reg_t PMA_ANACMNPLL_DFX1; /*< Address offset = 0x78 */
    pma_anacmnpll_msg_ldo0_reg_t PMA_ANACMNPLL_LDO0; /*< Address offset = 0x7c */
    pma_anacmnpll_msg_ldo1_reg_t PMA_ANACMNPLL_LDO1; /*< Address offset = 0x80 */
    pma_anacmnpll_msg_kvcc0_reg_t PMA_ANACMNPLL_KVCC0; /*< Address offset = 0x84 */
    pma_anacmnpll_msg_kvcc1_reg_t PMA_ANACMNPLL_KVCC1; /*< Address offset = 0x88 */
    pma_anacmnpll_msg_kvcc2_reg_t PMA_ANACMNPLL_KVCC2; /*< Address offset = 0x8c */
    pma_anacmnpll_msg_spare0_reg_t PMA_ANACMNPLL_SPARE0; /*< Address offset = 0x90 */
    pma_anacmnpll_msg_ro_visa_lockcnt_rcomp_reg_t PMA_ANACMNPLL_RO_VISA_LOCKCNT_RCOMP; /*< Address offset = 0x94 */
    pma_anacmnpll_msg_ro_div_bias_reg_t PMA_ANACMNPLL_RO_DIV_BIAS; /*< Address offset = 0x98 */
    pma_anacmnpll_msg_ro_bwm_lf_reg_t PMA_ANACMNPLL_RO_BWM_LF; /*< Address offset = 0x9c */
    pma_anacmnpll_msg_ro_dco_calib_reg_t PMA_ANACMNPLL_RO_DCO_CALIB; /*< Address offset = 0xa0 */
    pma_anacmnpll_msg_ro_tdc_reg_t PMA_ANACMNPLL_RO_TDC; /*< Address offset = 0xa4 */
    pma_anacmnpll_msg_stat_reg_t PMA_ANACMNPLL_STAT; /*< Address offset = 0xa8 */
    pma_anacmnpll_msg_stat1_reg_t PMA_ANACMNPLL_STAT1; /*< Address offset = 0xac */
    pma_anacmnpll_msg_stat2_reg_t PMA_ANACMNPLL_STAT2; /*< Address offset = 0xb0 */
    pma_anacmnpll_msg_stat3_reg_t PMA_ANACMNPLL_STAT3; /*< Address offset = 0xb4 */
    pma_anacmnpll_msg_spare1_reg_t PMA_ANACMNPLL_SPARE1; /*< Address offset = 0xb8 */
    pma_anacmnpll_msg_spare_stat_reg_t PMA_ANACMNPLL_SPARE_STAT; /*< Address offset = 0xbc */
    pma_anacmnpll_msg_dco_swing0_reg_t PMA_ANACMNPLL_DCO_SWING0; /*< Address offset = 0xc0 */
    pma_anacmnpll_msg_dco_swing1_reg_t PMA_ANACMNPLL_DCO_SWING1; /*< Address offset = 0xc4 */
    pma_anacmnpll_msg_tdc4_reg_t PMA_ANACMNPLL_TDC4; /*< Address offset = 0xc8 */
    pma_anacmnpll_msg_stat4_reg_t PMA_ANACMNPLL_STAT4; /*< Address offset = 0xcc */
} pma_anacmnpll_msg_t;     // size: 0x00d0

// AddressSpace struct pointer
//
#define DLNK_JESD0_PHY_PMA0_ANACMNPLLA  ((pma_anacmnpll_msg_t*) DLNK_JESD0_PHY_PMA0_ANACMNPLLA_BASE)
#define DLNK_JESD0_PHY_PMA0_ANACMNPLLB  ((pma_anacmnpll_msg_t*) DLNK_JESD0_PHY_PMA0_ANACMNPLLB_BASE)
#define DLNK_JESD1_PHY_PMA0_ANACMNPLLA  ((pma_anacmnpll_msg_t*) DLNK_JESD1_PHY_PMA0_ANACMNPLLA_BASE)
#define DLNK_JESD1_PHY_PMA0_ANACMNPLLB  ((pma_anacmnpll_msg_t*) DLNK_JESD1_PHY_PMA0_ANACMNPLLB_BASE)
#define DLNK_JESD2_PHY_PMA0_ANACMNPLLA  ((pma_anacmnpll_msg_t*) DLNK_JESD2_PHY_PMA0_ANACMNPLLA_BASE)
#define DLNK_JESD2_PHY_PMA0_ANACMNPLLB  ((pma_anacmnpll_msg_t*) DLNK_JESD2_PHY_PMA0_ANACMNPLLB_BASE)
#define DLNK_JESD3_PHY_PMA0_ANACMNPLLA  ((pma_anacmnpll_msg_t*) DLNK_JESD3_PHY_PMA0_ANACMNPLLA_BASE)
#define DLNK_JESD3_PHY_PMA0_ANACMNPLLB  ((pma_anacmnpll_msg_t*) DLNK_JESD3_PHY_PMA0_ANACMNPLLB_BASE)

// ******************************************* /Address Space

#endif      // _PMA_ANACMNPLL_MSG_H_

